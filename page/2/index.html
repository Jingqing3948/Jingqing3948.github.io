<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title> 灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">灰海宽松的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['没有一条路无风无浪', '常应常静，常清净矣', 'Love the Life You Live'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-问题解决：微信小程序通过 node 连接 mysql——方法，简要原理，及一些常见问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/02/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87%20node%20%E8%BF%9E%E6%8E%A5%20mysql%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AE%80%E8%A6%81%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"
    >问题解决：微信小程序通过 node 连接 mysql——方法，简要原理，及一些常见问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/02/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87%20node%20%E8%BF%9E%E6%8E%A5%20mysql%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AE%80%E8%A6%81%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2023-03-02T00:00:00.000Z" itemprop="datePublished">2023-03-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A0%B4%E6%B5%AA%EF%BC%88%E9%81%87%E5%88%B0%E7%9A%84bug%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/">破浪（遇到的bug及解决方案）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>博主自己在22年夏天根据课程要求做了一个小程序连接阿里云服务器的案例，在最近又碰到了相应的需求。</p>
<p>原参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_56598099/article/details/119105587?app_version=5.14.2&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22119105587%22,%22source%22:%22jtwqwq%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">微信小程序 Node连接本地MYSQL_微信小程序nodejs连接数据库_JJJenny0607的博客-CSDN博客</a> ,还请多多支持原作者！</p>
<p>第二次尝试的时候已经熟练许多了，但是还是遇到了很多挺烦人的问题，也浪费了很多时间排查 bug。因此博主打算趁着刚做过记忆还深刻的时候，把全过程、博主自己的理解和遇到的一些问题的解决方法整理出来。当然我也不可能能解决所有问题，遇到的部分问题也只是针对我自己的情况可以解决。因此如果 solutions 不起效或遇到其他问题，可以在评论区留言，我会与大家沟通（不保证能否解决~）。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212343956.png" alt="55ff06e4153087c9216fd7b56763ea7"></p>
<p>nodejs 作为中介服务器，可以让小程序连接 mysql 数据库。</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>如果不出错误的话， 基本流程就是跟着上面的文章来的。</p>
<ol>
<li><p>下载 node。可以在 cmd 中输入 <code>node -v</code> 查看有无成功下载。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212344379.png" alt="image-20230302134251274"></p>
</li>
<li><p>新建一个数据库，这一部分很简单，有 mysql 相关基础的读者应该没问题，也可以看博主的 mysql 专栏学习。</p>
</li>
<li><p>新建一个小程序，在结构中新建 server 文件夹用于存储 node 本地服务器相关代码。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212344368.png" alt="image-20230302135701456"></p>
</li>
<li><p>右键 server 文件夹，点击“在内建终端中打开”，安装一些所需的包。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm i mysql --save-dev</span><br><span class="line">npm install body-parser --save-dev</span><br><span class="line">npm install express --save-dev</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在文件夹下新建 server.js 文件，编写代码。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express=<span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser =<span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">IPAddress</span>=<span class="string">&#x27;[你的数据库地址]&#x27;</span><span class="comment">//因为这里是要链接远程数据库，ip 地址是 mysql 的地址！！本地就是 127.0.0.1，服务器上就自己找找看</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserName</span>=<span class="string">&#x27;[mysql 用户名]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PWD</span>=<span class="string">&#x27;[mysql 密码]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">DBName</span>=<span class="string">&#x27;[要操作的数据库名]&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">json</span>())</span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line"><span class="comment">//这上面一段固定的，[] 的部分需要根据自己数据库的信息修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理get请求。这里是一个 get 请求的方法演示，作用是查询 table1 表中的所有数据并返回。</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/getUser&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123; <span class="comment">//这里的是 get 方法 getUser，对应了刚才的页面发来的请求。就会执行这个方法。</span></span><br><span class="line">  <span class="comment">//参数传入是在 req.body 对象里面。比如上面的语句是获取传入的 openid 变量，并且我们新定义一个叫 openid 的变量存储传入的 openid 变量</span></span><br><span class="line">  <span class="keyword">var</span> connection=mysql.<span class="title function_">createConnection</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="title class_">IPAddress</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3306</span>,		<span class="comment">//端口号，mysql 固定3306</span></span><br><span class="line">    <span class="attr">user</span>:<span class="title class_">UserName</span>,</span><br><span class="line">    <span class="attr">password</span>:<span class="variable constant_">PWD</span>,</span><br><span class="line">    <span class="attr">database</span>:<span class="title class_">DBName</span></span><br><span class="line">  &#125;)<span class="comment">//配置连接的属性</span></span><br><span class="line">  connection.<span class="title function_">connect</span>();<span class="comment">//尝试连接</span></span><br><span class="line">  connection.<span class="title function_">query</span>(<span class="string">&quot;select * from table1&quot;</span>,<span class="keyword">function</span>(<span class="params">error,results,fields</span>)&#123;<span class="comment">//执行查找语句</span></span><br><span class="line">    <span class="keyword">if</span>(error) <span class="variable language_">console</span>.<span class="title function_">log</span>(error);<span class="comment">//执行失败的话</span></span><br><span class="line">    res.<span class="title function_">json</span>(results)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">    </span><br><span class="line">  &#125;)</span><br><span class="line">  connection.<span class="title function_">end</span>();<span class="comment">//断开连接</span></span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;<span class="comment">//这是一个监听端口，会输出监听到的信息。上面的 console.log 就会在这里输出</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://&#x27;</span>+<span class="title class_">IPAddress</span>+<span class="string">&#x27;:3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们的 nodejs 是部署在本地的，就在 server 文件夹里。node_modules 是下载的 nodejs 包，server.js 是我们的操作 nodejs 的代码。</p>
<p>我们在需要调用数据库的页面里先调用本地服务器，比如在 mysqlTest.js 中，onLoad 里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//我们写一个调用数据库函数，使得本页面加载时调用此函数，查找 youqi.data 里的所有条目。</span></span><br><span class="line">        wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">            <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,<span class="comment">//这里要和 server.js 定义的 post or get 一致！！！</span></span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;http://[本地 IPV4 地址]:3000/getUser&#x27;</span>,<span class="comment">//这里的 ip 地址不是数据库的地址，而是你的电脑本地的地址，因为这一步的操作是要找到本地 nodejs 服务器。getUser 要和 server.js 中定义的方法名一致。</span></span><br><span class="line">            <span class="attr">data</span>: &#123;</span><br><span class="line">              <span class="comment">//这里面是传入参数。比如我们要 select * from data where openid= 给定的 openid，就可以从这里传入</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;<span class="comment">//成功获取到值，返回一个 res 对象。如果不知道 res 对象里面包含什么，可以先输出 res 对象看一下其中都包含什么</span></span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">fail</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//没有获取到值，说明这中间出问题了。</span></span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>本地 IPV4 地址是怎么查出来的？打开 cmd，输入 ipconfig。无线局域网适配器 WLAN 里的 IPV4 即是。</p>
<p>nodejs 接收到了请求，就会执行 server.js 里对应的方法。</p>
<h1 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h1><p>首先 <strong>nodejs 服务器需要手动开启</strong>，我还不会自动开启。</p>
<p>右键 server 文件夹，在内建终端中打开，然后在终端中输入：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212344060.png" alt="image-20230227001627448"></p>
<p>下面那句话说明正常启动服务器并且开始监听。</p>
<p>我们输出一下 res，看看成功会返回什么信息。调试器里的 console 输出：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212343123.png" alt="image-20230227000549916"></p>
<p>data 里是我们数据库的查询结果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212343704.png" alt="image-20230227000639178"></p>
<p>res.data 获取这个15长度的 Array。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212343282.png" alt="image-20230227000715899"></p>
<p>然后比如我们要获取其中的 time 值，就是 res.data[0].time, res.data[1].time… res.dat[14].time。</p>
<p>{} 表示其中是一个对象变量，通过句号+索引名称获取特定的值。</p>
<p>而刚才的一直在监听的内建终端里输出：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212344070.png" alt="image-20230302140540514"></p>
<p>这个的输出对应 function(error,results,fields) 里的 console.log(results)。如果查询失败，error 也是在这个内建终端里输出。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="数据库无法连接？"><a href="#数据库无法连接？" class="headerlink" title="数据库无法连接？"></a>数据库无法连接？</h2><p>建好数据库后，最好就先用 cmd 或 workbench 连接一下试试。如果能成功连接并查询，之后出问题也可以排除 mysql 的一部分问题。</p>
<p>如果采用云服务器（如阿里云）连接不上，可能的问题有：</p>
<ul>
<li><p>服务器端口 80 和 3306 没开。（不建议一键全部放行，有被hacker get 的风险）</p>
</li>
<li><p>mysql 需要有一个用户能在所有 ip 地址里对该数据库进行读写操作，这里可以参考 DCL 的内容来新建符合要求的 user。<a target="_blank" rel="noopener" href="https://jingqing3948.blog.csdn.net/article/details/124430926">Mysql_9 SQL 语句——DCL_sql语言dcl_灰海宽松的博客-CSDN博客</a></p>
</li>
<li><p>服务器防火墙的问题，要开启3306端口。</p>
<p>  <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212343761.png" alt="image-20230302141204512"></p>
</li>
</ul>
<h2 id="小程序报错-ERR-TIMEOUT"><a href="#小程序报错-ERR-TIMEOUT" class="headerlink" title="小程序报错 ERR TIMEOUT"></a>小程序报错 ERR TIMEOUT</h2><p>打开网站可以看到 404 显示。</p>
<ul>
<li><p>首先先确保前面那个问题确实解决了，该数据库确实可以从本地连接，，不是数据库的问题。</p>
</li>
<li><p>再确认 get post 方法是否对应，方法名是否写错。很多时候输入了错误的链接也会显示 404.</p>
</li>
<li><p>小程序不校验合法域名是否打开。</p>
</li>
<li><p>启用或关闭 windows 功能——Internet Information Services，及其可承载 web 核心，<strong>子项</strong>全部打开。点击确定。如果成功启动，在浏览器中输入 127.0.0.1，应该可以看到：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212343506.png" alt="image-20230302141638928"></p>
</li>
<li><p>检查方法名，get post 类别是否写错。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WXMiniProgram/" rel="tag">WXMiniProgram</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：王道操作系统"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/27/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
    >技术学习：王道操作系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/27/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2022-11-27T00:00:00.000Z" itemprop="datePublished">2022-11-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h2><p>计算机结构大概分为四层：</p>
<ul>
<li>用户</li>
<li>应用程序</li>
<li>操作系统</li>
<li>硬件</li>
</ul>
<p>操作系统是一类系统软件，调度硬件资源，合理分配管理软件（因此操作系统又被称作资源管理器（resource manager））。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211121137338.png" alt="image-20221026211255236" style="zoom:67%;" />

<p>程序要运行首先要被放到内存中，然后才能被 CPU 处理；运行中的程序叫进程。</p>
<p>双击打开 QQ.exe，对应进程就会被放到内存中；</p>
<p>QQ 正常运行过程中，对应进程被 CPU 处理。</p>
<p>QQ 若想调用摄像头等，操作系统会把相应硬件分配给他。</p>
<p>计算机还会提供用户和硬件之间的接口。主要分为三种：GUI 接口，命令接口，程序接口。</p>
<p>联机&#x2F;交互式命令接口：用户说一句，系统做一句。（cmd）</p>
<p>脱机&#x2F;批处理命令接口：用户说一堆，系统做一堆。（.bat）</p>
<p>程序接口：通过程序才能调用。（.dll）</p>
<p>只有硬件的计算机叫裸机；操作系统将硬件资源转换为通用的、强大的虚拟形式，有时操作系统也被称为虚拟机。操作系统提供几百个系统调用（system call）供其他应用程序使用，实现运行程序、访问内存和设备等操作，也可以说操作系统为其他应用程序提供了一个标准库（standard library）。</p>
<h2 id="操作系统几大特征"><a href="#操作系统几大特征" class="headerlink" title="操作系统几大特征"></a>操作系统几大特征</h2><p>操作系统围绕以下几大主题展开：</p>
<ul>
<li>虚拟化（virtualize）：尽管一般只有一个 CPU，但是能同时进行多个进程，造成多个 CPU 的假象。多个程序实例同时用到一片内存地址时，却能各运行各的，值互不干扰。实际上每个进程是在访问自己的私有虚拟内存空间（virtual address space)，虚拟内存通过一定的规则映射到物理内存上，运行中的程序的物理内存是完全独立的。</li>
<li>并发（concurrency）<strong>不是并行！并行是同时发生，并发是交替发生。</strong>单核计算机就会采用并发的程序运行方式。现在尽管都有四核计算机，可以进行4个程序的并行操作，但是并发仍然很重要。</li>
<li>共享：系统中的某些资源供多个进程使用。</li>
</ul>
<p>​		互斥型共享就是一次只能一个程序用，如摄像头；</p>
<p>​		同时型共享就是两个进程交替使用，如 QQ 微信 同时发送文件。</p>
<ul>
<li>异步性：并发执行的程序有时候会卡住。比如 AB 程序都要用同一个地址，A先用了，B用的时候就要等A用完释放才能用。</li>
</ul>
<h2 id="操作系统历史"><a href="#操作系统历史" class="headerlink" title="操作系统历史"></a>操作系统历史</h2><p>手工操作阶段：用户手工打点，给机器。人机协调不均衡，资源分配不均匀。</p>
<p>批处理阶段——单道批处理系统：用户打好的点交给磁带，磁带读入计算机速度快得多（监督程序，早期的操作系统）。但是利用率仍然很低。</p>
<p>批处理阶段——多道批处理系统：每次内存中同时读入多个程序。多个程序并发执行，有了”中断“的概念。但是用户在程序执行的时候没法干涉，人机交互很差。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212021804594.png" alt="image-20221202180444486"></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位轮流给所有用户提供服务。用户的请求可以被及时响应，解决了人机交互问题；各个用户之间也感受不到其他用户的存在。但是众生平等，没有优先级。</p>
<p>实时操作系统：优先度高的任务可以先被处理，并且必须在给定的时限内完成任务。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212021811216.png" alt="image-20221202181100161"></p>
<h1 id="OS-运行机制和体系结构"><a href="#OS-运行机制和体系结构" class="headerlink" title="OS 运行机制和体系结构"></a>OS 运行机制和体系结构</h1><p>计算机中的指令有的安全（加减乘除运算），有的危险一点（清空内存）。因此需要通过权限控制限制用户能执行的指令。</p>
<p>具体实现方法为：CPU 处于核心态（管态）时可以执行所有指令；处于用户态（目态）时只能执行非特权指令。</p>
<p>内核程序是系统的管理者，可以执行所有指令，运行在核心态；</p>
<p>应用程序只能执行非特权指令，运行在用户态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212022149616.png" alt="image-20221202214904545"></p>
<p>操作系统的内核包含橙黄两部分：大内核。</p>
<p>只包含黄色部分：微内核。</p>
<p>各自的缺点：大内核组织结构混乱，难以维护；微内核频发切换，性能低。</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>一开始的计算机只是简单的串行执行程序。</p>
<p>现在的操作系统不仅可以并发执行程序，而且收到中断指令时，CPU 会切换到内核模式，中断当前程序的执行，按中断指令调整程序执行顺序，然后恢复到用户态继续执行。</p>
<p>中断分内中断、外中断。区别在于中断指令来自于 CPU 内部还是外部。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212022249948.png" alt="image-20221202224925813"></p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>我们知道计算机硬件为了供用户使用，向上层提供了一些接口。用户直接使用的接口叫命令接口；用户通过应用程序间接使用的接口叫程序接口。系统调用是操作系统提供给应用程序的接口。</p>
<p>系统调用可以增加安全性，不让用户可以直接随意访问所有功能。如两个人去打印店用打印机，第一个人打到一半第二个人发送了他的打印任务请求，可打印机最终还是有序地把两个人的任务分别打印好了。如果用户能直接让打印机打印自己的任务，不加协调，无法实现这样的结果。</p>
<p>哪些操作要通过系统调用的方式进行？凡是和资源相关的。这样可以保证系统的安全性和稳定性。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212030058354.png" alt="image-20221203005839292"></p>
<p>编程语言提供的一些库函数也是从下往上提供的一些封装的功能。但库函数不一定是系统调用。如求绝对值的库函数，这个库函数就不是系统调用，用户直接就能访问。</p>
<p>现在大多数系统调用都是高级语言中封装的部分库函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212030122447.png" alt="image-20221203012249371"></p>
<p>陷入指令核心态不能执行，可以理解为：核心态只能执行系统调用，不能发起系统调用给自己。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程（process）是操作系统中最基本的抽象。</p>
<p>进程就是运行中的程序，程序本身只是存放在磁盘上的一些静态指令，是操作系统让其运行起来。</p>
<p>现在我们的计算机可以同时运行上百个进程，是通过虚拟化 CPU 而实现。每个进程只运行一个时间片段，然后跳转到其他进程，造成多个进程同时运行的假象。</p>
<p>内存中存放每个进程的程序段和数据段，但内存怎么知道哪个是哪个进程的？通过一种数据结构叫进程控制块（PCB）找到对应进程的额程序段和数据段。程序段、数据段、PCB 组成了进程实体。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031509614.png" alt="image-20221203150903451"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031512628.png" alt="image-20221203151228535"></p>
<p>操作系统需要一些低级机制（mechanism）切换程序运行，如上下文切换（context switch，停止当前程序，并运行另一个程序）；还需要一些智能决定要切换到哪个程序，如策略（poliicy，根据一些算法判断要运行哪个程序，如“哪个程序在上一分钟运行的时间更长？”）</p>
<h2 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031514568.png" alt="image-20221203151433504"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031605299.png" alt="image-20221203160553246"></p>
<p>就绪态就是除了处理机其他资源都准备就绪了。阻塞态还需要准备资源才能进入就绪态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031608044.png" alt="image-20221203160853843"></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>就是这几种进程状态之间的切换。</p>
<p>通过两个指针实现：就绪队列指针和阻塞队列指针，用于存放就绪和阻塞的进程（阻塞队列可能还有好几个，按阻塞原因分组）。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031747844.png" alt="image-20221203174739750"></p>
<p>状态切换使用原语，因为原语执行过程中不会受到中断的干扰。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031748654.png" alt="image-20221203174850603"></p>
<p>原语做的操作无非是：1. 修改 PCB；2. 把 PCB 放到对应队列中；3. 分配&#x2F;释放资源。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212032207002.png" alt="image-20221203220754958"></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程之间互相通信，安全起见不能直接进行。</p>
<ol>
<li><p>共享存储，共用一块存储空间。有基于数据结构的分享（给定数据结构存储方式）和基于存储区的分享（内存中划定一块存储区，进程自己决定怎么存储）。</p>
<p>共享的缓冲区叫做管道，如果只采用一个管道只能使用半双工型，全双工型需要两根管道。两个进程访问该管道要互斥的访问。</p>
<p>管道写满才能读，读空了才能写。</p>
<p>读出来的数据就直接被丢弃了。所以安全起见只能有一个读的进程。</p>
</li>
<li><p>消息传递。类似计网的数据报，消息封装好之后发给另一个进程的消息队列。</p>
</li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>让一个进程可以并发执行多个任务。比如 qq 聊天的同时可以发文件收消息发消息。</p>
<p>一个进程包含多个线程。线程是调度， CPU 的程序执行单元，进程是资源分配的单元，比如把显示器资源分配给 QQ。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041613632.png" alt="image-20221204161307495"></p>
<p>线程有两种实现方式：</p>
<ol>
<li>用户级线程 （ULT），进程的切换由应用程序实现，而不需要操作系统管理，因此用户态下就能实现线程的切换，且线程的存在对用户透明，对操作系统不透明。</li>
<li>内核级线程（KLT），线程管理靠操作系统在核心态下实现、</li>
<li>两者组合的形式，n 个用户级线程映射到 m 个内核级线程上。</li>
</ol>
<p>操作系统分配 CPU 处理机只能分配给内核级线程（因为用户级线程对操作系统来说不透明）。所以如果有三个用户级线程，但这个应用程序只有两个内核级线程，最多也只能被分配到两个处理机，最多也只能有两个用户线程并发执行（哪怕这个操作系统是三核的，四核的，有很多核空闲出来）。</p>
<p>几个用户级进程映射到几个内核级进程上？这就是多线程模型问题。</p>
<ol>
<li><p>多个用户级进程映射到一个内核级进程上。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041620426.png" alt="image-20221204162042367"></p>
<p>线程切换不用在核心态下进行，切换效率高，但是并发度不高。</p>
</li>
<li><p>一对一。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041621304.png" alt="image-20221204162149252"></p>
<p>优缺点正好和1相反。</p>
</li>
<li><p>n 对 m，用户级线程多于内核级线程，较为折中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041622150.png" alt="image-20221204162233095"></p>
</li>
</ol>
<h1 id="进程调度和切换"><a href="#进程调度和切换" class="headerlink" title="进程调度和切换"></a>进程调度和切换</h1><p>线程数往往多于处理机数，因此要考虑按怎样的算法分配处理机。</p>
<p>进程调度和切换的区别是什么？</p>
<p>进程调度先选再切换。</p>
<p>进程切换包括：</p>
<ol>
<li>保存原来运行的数据</li>
<li>恢复新进程的数据。</li>
</ol>
<p>切换会影响效率。</p>
<p><strong>调度层次1：高级调度（→就绪态）</strong></p>
<p>首先先不说处理机够不够处理内存中的线程，有时候线程多到内存中放不下。高级调度需要按一定的原则从外存中挑选一些作业放到内存中并建立进程（PCB），让他们有进一步竞争处理机的机会。主要解决的是调入问题。</p>
<p><strong>调度层次2：中级调度（挂起态→就绪态）</strong></p>
<p>引入虚拟存储技术之后，暂时不能运行的进程可以先调至外存等待（挂起）。等可以运行再拿回来，这样能提高内存利用率和系统吞吐量。</p>
<p>其对应的 PCB 并不会一起移出内存，而是存储了被挂起的进程的信息，被放到内存中的挂起队列里。</p>
<p>中级调度就是挑选挂起的进程调入内存。</p>
<p>引入挂起的进程实际上可以说是有七种状态。不能运行的进程都会先放到就绪挂起态或阻塞挂起态，能运行再回到内存（有的操作系统阻塞挂起态直接回到就绪挂起态）。注意挂起和阻塞的区别！</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041640940.png" alt="image-20221204164038790"></p>
<p><strong>调度层次3：初级调度（就绪态→运行态）</strong></p>
<p>就是从就绪队列中按一定算法挑一个进程来执行。</p>
<h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><p>当前运行的进程主动（运行完了，或者异常终止）或被动放弃处理机，就会发生调度。</p>
<p>有以下几种情况不能调度：</p>
<ol>
<li>进程在处理中断时。</li>
<li>进程在操作系统内核程序临界区中。（<a target="_blank" rel="noopener" href="https://blog.csdn.net/gary101818/article/details/124198452?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-124198452-blog-111413758.pc_relevant_vip_default&spm=1001.2101.3001.4242.1&utm_relevant_index=4">临界资源及临界区（内核&#x2F;普通）以及三种进程不能切换的情况_Unstoppable~~~的博客-CSDN博客_内核临界区</a> 在此感谢这位博主！调度区和调度资源是两回事，调度区又分普通调度区和内核调度区。）</li>
<li>原语执行时.</li>
</ol>
<h2 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h2><p>非剥夺&#x2F;非抢占调度方式：只允许进程主动放弃处理机。哪怕有更紧急的进程到达，也不会把当前正在使用处理机的进程挤开。开销小，但没法处理紧急情况。</p>
<p>剥夺&#x2F;抢占调度方式：允许进程主动或被动放弃处理机。</p>
<h2 id="调度算法评价指标"><a href="#调度算法评价指标" class="headerlink" title="调度算法评价指标"></a>调度算法评价指标</h2><p>CPU 利用率：CPU 有活干的时间&#x2F;总时间。</p>
<p>系统吞吐量：完成了的作业道数&#x2F;总用时。</p>
<p>周转时间：提交作业到作业完成用时。包括在外存等待高级调度→在内存就绪队列等待低级调度→在 CPU 上执行→等待 I&#x2F;O 操作完成的时间。</p>
<p><em>注意概念问题，进程是运行中的程序，所以作业在外存的时候不可以被称为进程。进入内存才创建了进程。</em></p>
<p>带权周转时间：周转时间&#x2F;实际运行时间。越小越好（排队用时少吧）。</p>
<p>等待时间：作业等待处理机状态的时间之和。（不包括 IO）</p>
<p>响应时间：用户提交请求到首次产生响应的时间。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>早期批处理调度算法：只根据等待时间和预估处理时间调度，不考虑是否紧急。</p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>思想</th>
<th>规则</th>
<th>用于何种调度</th>
<th>是否可抢占</th>
<th>优缺点</th>
<th>是否会导致饥饿（某个作业长期得不到服务）</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务 FCFS</td>
<td>公平</td>
<td>先来后到</td>
<td>都用</td>
<td>非抢占式</td>
<td>公平；但排在后面的短作业体验差</td>
<td>不会</td>
</tr>
<tr>
<td>短作业优先 SJF</td>
<td>让平均等待、周转、带权周转时间最短</td>
<td>最短的作业优先服务</td>
<td>都用</td>
<td>非抢占式（最短剩余优先算法是抢占式的，当有进程入队的时候立刻调度。平均时间抢占式的更少）</td>
<td>平均时间少，但对长作业不公平，可能“饥饿</td>
<td>会</td>
</tr>
<tr>
<td>高响应比优先 HRRN</td>
<td>综合考虑等待时间和处理时间</td>
<td>$\frac{等待时间+服务时间}{服务时间}$，优先执行响应比大的</td>
<td>都用</td>
<td>非抢占式（当前进程主动结束时才进行调度）</td>
<td>综合考虑了等待时间和服务时间，长作业等久了也会执行</td>
<td>不会</td>
</tr>
</tbody></table>
<p>后期交互式系统算法：</p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>思想</th>
<th>规则</th>
<th>用于何种调度</th>
<th>是否可抢占</th>
<th>优缺点</th>
<th>是否会导致饥饿</th>
</tr>
</thead>
<tbody><tr>
<td>时间片轮转 RR</td>
<td>公平轮流地为所有进程服务</td>
<td>按先来后到，轮流给各个进程一个时间片执行。如果没执行完就交给下一个进程，然后重新到队尾排队（时间片大小要合适。太大就是 FCFS 算法了，太小效率低）</td>
<td>进程调度</td>
<td>是</td>
<td>公平；响应快；但是频繁切换效率低，不区分紧急程度</td>
<td>不会</td>
</tr>
<tr>
<td>优先级调度</td>
<td>按紧急程度处理</td>
<td>优先度高的先执行</td>
<td>都用</td>
<td>是</td>
<td>可以优先处理紧急任务；但总是高优先级任务到来可能饥饿</td>
<td>会</td>
</tr>
<tr>
<td>多级反馈队列调度算法</td>
<td>根据时间片计算优先级</td>
<td>进程刚到达放入1队列，一个时间片内没完成放入2队列，还没完成一直往后放，如果已经在最后一个队列了就重新放到该队列结尾。1队列优先级最高</td>
<td>进程调度</td>
<td>是</td>
<td>综合了各个调度算法优点</td>
<td>会</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071304330.png" alt="image-20221207130426052"></p>
<h1 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h1><p>虽然之前提过进程是异步的，各个进程相互独立，但是有的工作是有顺序的，比如先读入再写。</p>
<p>同步，即相互制约，指部分工作的次序需要协调。</p>
<p>互斥：一些共享资源不允许多个进程同时访问。比如一次只允许一个进程访问的资源叫临界资源。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071354552.png" alt="image-20221207135453437"></p>
<p><strong>进程互斥遵循以下原则</strong>：</p>
<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待，防止饥饿，不让进程等太久</li>
<li>让权等待，如果该进程进不去，那就不给他了，赶紧给别人。</li>
</ol>
<h2 id="进程互斥软件实现方法"><a href="#进程互斥软件实现方法" class="headerlink" title="进程互斥软件实现方法"></a>进程互斥软件实现方法</h2><ol>
<li><strong>单标志法</strong>	<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071403844.png" alt="image-20221207140305743"></li>
</ol>
<p>​	一开始只允许 P1 访问。一直到P1把 turn 变为0，然后切时间片的时候才能交给 P0. 两者交替访问。</p>
<p>​	但是违背了空闲让进。如果只有 P0 想访问临界区，就一直进不去。</p>
<ol start="2">
<li><p><strong>双标志先检查法</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071408231.png" alt="image-20221207140814172"></p>
<p>判断对方有没有在访问。</p>
<p>但是如果按照①⑤③②⑥⑦的顺序，两者会同时访问临界资源，违反了忙则等待。</p>
</li>
<li><p><strong>双标志后检查法</strong></p>
<p>先上锁再检查。但是两个进程要是都先锁住了，就都执行不了了，可能出现死锁问题。</p>
</li>
<li><p><strong>Peterson 算法</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071417229.png" alt="image-20221207141722082"></p>
<p>可惜没有遵守让权等待。</p>
</li>
</ol>
<h2 id="进程互斥硬件实现方法"><a href="#进程互斥硬件实现方法" class="headerlink" title="进程互斥硬件实现方法"></a>进程互斥硬件实现方法</h2><ol>
<li><p><strong>中断屏蔽方法</strong></p>
<p>访问临界资源的时候把中断关上；访问完了打开，再允许调度。但是用户态不适用（用户态不应该搞中断的问题），而且对多处理机不适用。</p>
</li>
<li><p><strong>TestAndSet 指令</strong></p>
<p>是硬件实现方法，下图为软件实现方式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071812977.png" alt="TS 软件实现方式"></p>
<p>如果 lock 原来是 true，那么其他进程访问的时候一直卡在 while 处。知道访问临界区的进程退出并解锁，其他进程访问的时候 lock 才是 false，才能跳出循环。</p>
<p>但是无法解决让权等待问题，如果有一个进程把 lock 变成 true 之后又进不去临界区，其他进程就永远无法访问，一直忙等。</p>
</li>
<li><p><strong>Swap 指令</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071819188.png" alt="image-20221207181932099"></p>
<p>逻辑上等同于 TS，也无法解决让权等待问题。</p>
</li>
<li><p><strong>信号量</strong></p>
<p>信号量用于表示系统中某种资源的数量。我们用一对原语（等待 P，信号 V）对信号量做操作.信号量涉及到的三个操作就是初始化、P、V。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071834097.png" alt="image-20221207183421978" style="zoom:67%;" />

<p>然而这样的信号量也没能解决让权等待问题。不过一个记录型信号量可以解决。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071941190.png" alt="image-20221207194128022"></p>
<p>释放完资源，S.value≤0 说明还有进程在阻塞队列中，直接把当前刚释放的处理机给阻塞队列的进程执行。</p>
<p>这样如果该进程进不去自己的处理机，就会把自己调整到堵塞态，把处理机让出来给别人，解决了让权等待问题。</p>
</li>
</ol>
<h2 id="信号量实现进程同步和互斥"><a href="#信号量实现进程同步和互斥" class="headerlink" title="信号量实现进程同步和互斥"></a>信号量实现进程同步和互斥</h2><p><strong>互斥</strong>：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072021901.png" alt="image-20221207202126671"></p>
<p><strong>同步</strong>：如怎样保证2一定在4之前执行</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072032942.png" alt="image-20221207203235758"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072035570.png" alt="image-20221207203533381"></p>
<h1 id="进程种类"><a href="#进程种类" class="headerlink" title="进程种类"></a>进程种类</h1><p><strong>生产者和消费者</strong></p>
<p>生产者把产品放入未满的缓冲区，消费者从未空的缓冲区取出。两者要互斥地对缓冲区访问；同时如果生产者要放入满缓冲区要先等消费者取出，消费者要从空缓冲区取要先等生产者放，这两件事是同步关系。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072051458.png" alt="image-20221207205103231"></p>
<p>注意 决定互斥的 mutex 顺序不能和决定同步的 empty full 颠倒！！！</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080032409.png" alt="image-20221208003209311"></p>
<p>如上图，如果先进行①②，则互斥锁打开，生产者因为仓库已满无法放入，阻塞。消费者又因为互斥锁打开无法取东西，阻塞，就死锁了。</p>
<p><strong>多生产者 多消费者</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080034113.png" alt="image-20221208003430037"></p>
<p>缓冲区大小（盘子）如果为1，那么不用互斥变量也能解决。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080038949.png" alt="image-20221208003840866"></p>
<p>因为苹果、橘子、盘子变量同时只能有一个&#x3D;1，每次最多也只能有一个变量访问。如果缓冲区变为2就需要 mutex 了，父母同时放入水果可能覆盖对方的值。</p>
<p><strong>吸烟者问题</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080042576.png" alt="image-20221208004256422"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080207995.png" alt="image-20221208020707796"></p>
<p>因为只有一个缓冲区，所以不需要 mutex 就能实现互斥。</p>
<p>吸烟者问题其实是实现了一个生产者生产多种产品的问题。此例中生产者生产的产品顺序固定，还可以修改生产顺序逻辑。</p>
<p><strong>读者-写者问题</strong></p>
<p>允许多人同时读，但是有人在写的时候其他人不能读写。</p>
<p>读进程有限的解决办法：mutex 用于所有读进程互斥访问 count 变量，当 count 变量&#x3D;0时才可写入。但是写进程有饿死的风险。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212081327613.png" alt="image-20221208132742538"></p>
<p>如果再加一个写的互斥信号量，就能让写操作优先于读操作了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212081327794.png" alt="image-20221208132713723"></p>
<p><strong>哲学家进餐问题</strong></p>
<p>一个进程同时持有多个临界资源的情况。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212081937374.png" alt="image-20221208193715205"></p>
<p>如果只是简单地用两个信号量判断左右两根筷子是否空闲，可能所有进程并发拿起了左手的筷子，并发地卡住了右手的筷子，造成死锁。</p>
<p>有几种解决方案：①拿两只筷子的行为添加一个互斥信号量。这样一个哲学家拿不起来被阻塞的时候，其他哲学家也不会尝试拿。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212090131892.png" alt="image-20221209013159819"></p>
<p>②奇数先拿左手，偶数先拿右手，这样相邻的人拿筷子就会互斥。</p>
<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>信号量挺琐碎的，而且容易出错，顺序错了都会影响结果。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212091244806.png" alt="管程是什么" style="zoom:67%;" />

<p>管程内的数据只有在管程内的过程（函数）才能访问；一次只允许一个进程进入管程。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212091302459.png" alt="image-20221209130200400"></p>
<p>monitor 是 java 语法的管程，每次只允许一个进程访问（互斥），进程只能通过管程提供的特定入口进入。我们可以自己定义逻辑判断，让进程等待或释放（同步）。</p>
<p>关键字 synchronized 修饰的函数同一时间段内只能被一个进程访问。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>A等B，B等C，C等A，都在等对方手里的资源。</p>
<p>和饥饿不一样，饥饿是如果一直来新进程自己可能一直无法继续。</p>
<p>死锁的四个条件：</p>
<ol>
<li>互斥，对某一资源互斥使用。</li>
<li>不剥夺，不能抢资源。</li>
<li>请求和保持，在新资源还在请求时可以保持自己手里已有的资源。</li>
<li>循环等待，存在资源的循环等待链。比如有12两个资源，进程一申请顺序：12，进程二申请顺序：21，两者正好互相锁住。</li>
</ol>
<p>可能发生死锁的情况：</p>
<ul>
<li>竞争不能共用的系统资源时；</li>
<li>进程推进顺序不当；（哲学家拿筷子，都先拿左手的）</li>
<li>信号量使用不当（如生产者消费者一例，先互斥锁再信号量锁。生产者先进入满仓库，因为当前只有自己进程进入仓库所以互斥锁不干扰；但是仓库已满，无法放入导致阻塞；消费者又因为生产者正在访问，互斥锁限制导致阻塞）。</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>破坏四个条件之一。</p>
<ol>
<li><p>把资源改为可以共享使用的；不过不是所有设备都能强行改的。</p>
</li>
<li><p>剥夺：要么如果当前进程资源不足时立刻全部释放资源，等一会再重新运行；要么根据优先级，高优先级抢低优先级的资源使用。但是比较复杂而且会影响前一个进程，常用于易于保存和恢复状态的进程（如 CPU）；效率低；方案一还可能导致饥饿。</p>
</li>
<li><p>请求保持：采用静态分配方法，进程开始运行时就把所有需要的资源都给他，全程让他运行。但是可能有的资源这个进程就用一两下，一直占着会比较浪费；可能导致饥饿。</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212092228135.png" alt="image-20221209222856008"></p>
<p>比如上例，两个进程申请资源顺序都从小到大，先1后2，就不会死锁了。但是实际资源使用顺序可能并不是从小到大，效率低；而且增添设备要修改编号，不方便；而且用户编程要注意顺序，比较费事。</p>
</li>
</ol>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212092245236.png" alt="image-20221209224517132"></p>
<p>安全序列就是按某种顺序分配资源，所有进程都能顺利得到，不会死锁。存在一种安全序列的情况，那么当前系统就是处于安全状态。</p>
<p>银行家算法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212092328566.png" alt="image-20221209232829502"></p>
<p>如图，剩余资源 (3, 3, 2)，视作一个一维数组。P0 全分配也不够，不行；P1可以，全分配给P1后P1归还资源，剩余资源数变成 (5, 3, 2)；然后P2不够，P3可以，变成 (7, 4, 3)；p4 变成 (7, 4, 5); P1 变成 (7, 5, 5)，最后 P2 P4，五轮循环全部分配。</p>
<p>最大需求：Max</p>
<p>已分配：Allocation</p>
<p>最多还需要：Need</p>
<p>当次发起申请的请求量：Request</p>
<p>Request≥Need：出错了</p>
<p>Request≤Available：说明有多余空闲。系统先尝试分配一下，成功后证明安全，正式分配。</p>
<h2 id="检测、消除死锁"><a href="#检测、消除死锁" class="headerlink" title="检测、消除死锁"></a>检测、消除死锁</h2><p>点表示进程，方框表示资源，箭头表示分配。如果所有箭头都能被顺利消除，证明不会发生死锁。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212100101090.png" alt="image-20221210010155006"></p>
<p>P1向R2要一个。R2给了P2一个自己还剩下一个，所以可以要到。（P1释放后，就能把P1的所有边去掉了）</p>
<p>P2向R1要一个。但是R1三个都给出去了，所以P2要不到，阻塞了。</p>
<p>P1运行完释放，R1里就有两个空闲的了，P2就能要到了。</p>
<p>下例就没法全部消除，死锁了。只有P3能正常运行并释放。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212100117430.png" alt="image-20221210011729366" style="zoom:67%;" />

<p>解决办法：可以挂起或终止死锁的部分节点，或者回退到没有发生死锁的断点。</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>存放数据的硬件，程序要先被放到内存中才能被处理.</p>
<p>代码被编译成指令，通常还会涉及到几个地址。比如一个加法指令涉及的三部分（A，B，C）A代表：这是一个加法指令；B C代表：把B中的数据加到C中。</p>
<p>指令中采取的是相对的逻辑地址，因为还不能确定物理存到了哪里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212101408696.png" alt="image-20221210140802510"></p>
<p>装入有三种：</p>
<ol>
<li>绝对装入，编译时就知道要放到哪个物理地址里，编译时直接采用物理地址；适用于单道程序环境。</li>
<li>静态重定位装入，编译时采用相对地址，装入时根据相对地址存入到物理地址。但是如果内存中容量不够，就不能装入。用于早期操作系统。</li>
<li>动态重定位装入，刚进内存不会装入，等到程序运行时再装入。允许程序运行中在内存里移动。现代操作系统。</li>
</ol>
<p>链接也有三种，装入前链接成一块，边装入边链接，运行时再链接。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存中存了多少？空闲多少？进程分配到哪里？怎么释放？内存扩充（游戏60G，内存4G，采用虚拟内存的方式扩充）、地址转换（就是装入。逻辑地址和物理地址之间的链接 是操作系统解决，程序员不用管）、内存保护。</p>
<p><strong>覆盖与交换技术</strong></p>
<p>覆盖技术：解决内存太小的问题。内存中分固定区和覆盖区。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212101818476.png" alt="image-20221210181822311"></p>
<p>缺点在于固定区覆盖区要程序员自己规定，不透明。</p>
<p>交换技术：把内存中某些进程拿出来，再把某些进程换进去。磁盘中专门有一块交换区，追求交换的速度，采用连续存储方式，IO 比文件区要快得多。缺页率高时换出得多。优先换出阻塞和优先级低的进程。</p>
<p><em>覆盖是同一个进程中的</em>，交换是多个进程中的。</p>
<p><strong>内存保护</strong>限制每个进程只能访问自己范围内的数据。可以设置上下限寄存器；或者重定向寄存器决定上限，界地址寄存器代表最大长度。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a><strong>内存分配</strong></h2><p><strong>连续分配</strong>：内存分为系统区和用户区。系统区存放操作系统相关数据；用户区存进程，只能存一个。实现简单，没有外部碎片（内存空闲区域太小，没法分配给进程的情况），可以通过覆盖技术扩大内存，不一定要保护；但是利用率低，而且有内部碎片（分配给某个进程的内存区域，有些部分没有用到）。</p>
<p><strong>固定分区分配</strong>：内存分成很多个分区，每个分区只装一道作业。</p>
<p>（分区大小相等，缺乏灵活性，但是适用于一台计算机控制多个相同对象的场合；</p>
<p>也可以设置不同大小的分区，适用于各种作业）</p>
<p>操作系统需要叫分区说明表的数据结构，让内核程序知道哪些分区可用不可用，起始位置，大小等。没有外部碎片，但是有内部碎片；而且可能有过大的用户程序，所有分区都满足不了，就只能覆盖，降低效率。</p>
<p><strong>动态分区分配</strong>：根据进程大小动态建立分区。系统区大小都是不固定的。可以采取空闲表或空闲链的数据结构存储信息。</p>
<p>动态分配的算法：</p>
<ol>
<li>要插入的进程比空闲区小：更新空闲区起始位置和大小。</li>
<li>要插入的进程和空闲区一样大：直接在空闲分区表中删掉这一条空闲区的记录。</li>
</ol>
<p><strong>动态分区回收算法</strong></p>
<ol>
<li>要回收的分区前面或后面有一块空闲：更新那块空闲的起始位置和大小。</li>
<li>前后没有空闲：新增一条空闲记录。</li>
<li>前后都有空闲：空闲表中两条记录 更新成一整条。</li>
</ol>
<p>动态分配算法 没有内部碎片，但有外部碎片。可以通过“拼凑”来解决。</p>
<p>具体怎么选择空闲分区分配？</p>
<p><strong>动态分区分配算法</strong></p>
<p>首次适应算法：从小地址到大逐渐找。空闲区按地址从小到大存储在空闲链中。</p>
<p>最佳适应算法：优先找能容得下的最小的空闲区，大的留着给大的进程预备着。空闲分区从小到大存储在空闲链中。小碎片会越来越多，导致外部碎片。</p>
<p>最坏适应算法：优先使用最大的空闲分区，避免外部碎片。但是大进程到来的时候可能插入不进来了。</p>
<p>临近适应算法：因为首次适应算法每次都从头找，头部可能有很多小碎片，每次又要遍历。临近适应算法每次从上次结束的地方开始查找。也是优先使用最大分区，类似最坏适应算法。</p>
<p><strong>基本分页存储算法</strong></p>
<p>是一种非连续分配。</p>
<p>每个分区10MB，A进程23MB，可以拆成10+10+3MB存储。</p>
<p>但是这样导致第三个分区内部碎片达到7MB。如果分区大小为2MB，那么只有最后一个分区有1MB内部碎片。</p>
<p>每个分区是一个页框，有页框号，从0开始。把进程分配成页框的大小，叫做一个个页，有页号。</p>
<p>分的页并不是连续存储在分区中的，可以不连续存储，根据逻辑地址找页与页之间的关系。</p>
<p>页号：逻辑地址&#x2F;页面长度。</p>
<p>偏移量：逻辑地址%页面长度。</p>
<p>如第80个内存单元，页面长度50，那么页号&#x3D;1，偏移量&#x3D;30.</p>
<p>如果页面大小是2的整数次幂，那么页面范围就是00000……0001000……0000到00000……00010111……11111，末尾的部分就是页面偏移量。</p>
<p>页表存储页面信息，页表项包含页号和块号信息，每个页表项应该能表示出所有块数的信息。比如有2^20个块，则每个页表项要有20种状态，20位即至少三个字节。(但是通常采用4个字节 这样让总内存数可以等于证书个页表项)</p>
<p><strong>基本地址变换机构</strong></p>
<p>用于实现分页管理逻辑地址转变为物理地址的操作。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212111322421.png" alt="image-20221211132202245"></p>
<p>基本地址变换结构 每次要访问两次内存。</p>
<p>查页表，知道要访问的数据的位置：一次；</p>
<p>去访问数据：二次。</p>
<p><strong>具有快表的地址变换机构</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212111948810.png" alt="image-20221211191228059"></p>
<p>让最近访问过的页表项存到快表中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212111948830.png" alt="image-20221211194853670"></p>
<p>如果快表中有该页表项，直接取出该项计算出物理地址，就不用到慢表中查表了。</p>
<p>访问快表命中了，就只需要一次访存。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212112026971.png" alt="image-20221211202653892"></p>
<p><strong>两级页表</strong></p>
<ol>
<li>单极页表必须连续存储；</li>
<li>并不是整张页表都会被频繁访问到。</li>
</ol>
<p>可以把长长的页表再分成离散的几块，即第二级页表。又叫顶级页表。这样就解决了问题1.</p>
<p>然后对于没有进内存的目标页，访问的时候产生缺页中断，然后调入页。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121211186.png" alt="image-20221212121134020"></p>
<p>但是没有快表的话，两级页表要访存3次。</p>
<p><strong>基本分段存储管理方式</strong></p>
<p>按逻辑把程序分为一个个段（如 主函数，sum 函数……）分段离散的存储到内存中。可读性更高。</p>
<p>段号规定了可以有多少个段，段内地址规定了段的大小。</p>
<p>当然啦，为了查找到哪个段放在哪里，也需要段表。段表每一条包含段号、基址（起始位置）、段长。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121532859.png" alt="image-20221212153212634"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121541529.png" alt="image-20221212154131290"></p>
<p>段表寄存器存储在系统区的 PCB 中，即段表的位置。</p>
<p>相比分页，分段是有意义的，是二维的，用户既要给出段名（如 main 函数的段），又要给出地址。</p>
<p>分段也更容易实现信息共享和保护。首先什么代码可以共享？不能修改的代码可以共享，如常量，防止多个进程并发访问会出问题。</p>
<p>然后分段是按逻辑分的。比如每个函数分一个段。分页是按大小直接截断的。所以分段可能提取出可以共享的代码片段，分页会更难一些。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121545141.png" alt="image-20221212154510085"></p>
<p>分段也是两次访存，也可以尝试快表。</p>
<p><strong>段页式管理方式</strong></p>
<p>分段和分页的缺点是什么？</p>
<p>分页划分固定分区，但不便于信息共享和保护。</p>
<p>分段根据程序分配大小不确定的分区，可能有外部碎片（紧凑还是付出代价很大的）。而且进程太大的话也难以找到一大块连续区域。</p>
<p>那，把大的段分页就好了。</p>
<p>分页的页表包含：页号 页内偏移量信息。分段的段表包含：段号 段长 基址信息（段号可以隐含）。</p>
<p>段页式系统的逻辑地址结构 段包含：段号 页表长 页存放块号（起始地址）。页包含：页号 页面存放的内存块号。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121726546.png" alt="image-20221212172648263"></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>归根结底，以上的内存分配方法需要把整个程序都装入内存运行。而且由于内存的<strong>驻留性</strong>，程序运行完之前整个都一直留在内存中。</p>
<p>第一，没必要，程序的某些部分不常使用，不用一直占在内存里，内存利用率低。第二，太大的程序装不进来。第三，很多程序排队时，这样一次只能运行很少的几个，并发性差。</p>
<p>根据之前快存学到的局部性原理，可以把常用的部分留到内存中，不常用的拿出去。要用到的不在内存里，就拿进来；内存太满，就把不常用的再拿出去。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121801081.png" alt="image-20221212180126990" style="zoom:50%;" />

<p>虚拟内存有多次性（分多次装入）、对换性（可以换出来）、虚拟性。</p>
<p>存储方式：采用连续型并不合适，因为要分多次装入。改用请求式管理。</p>
<p><strong>请求分页管理</strong></p>
<p>和基本分页管理的区别在于：1. 要访问的信息可能在内存中，也可能不在。不在的话要调入进来。要存储该页是否在内存中的信息。</p>
<ol start="2">
<li>暂时不用的可以换出去。如果在内存中做过修改，那么不用拿回到外存；如果做过修改了就要了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121843299.png" alt="image-20221212184343182"></p>
<p>先根据状态位<strong>判断要访问的页在不在内存中</strong>，不在里面，就先产生缺页中断，<strong>调入内存</strong>。如果有空闲块就插到空闲块里，没有就根据<strong>页面置换</strong>算法换出来一个不常用的。调出内存的页面如果发生改变就要写入外存，没有就直接丢掉。最后还要<strong>修改请求页表中的状态信息</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121916450.png" alt="image-20221212191632934"></p>
<p>缺页中断是自行产生的内中断。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121858690.png" alt="image-20221212185821630"></p>
<p>几个值得注意的点：</p>
<ol>
<li>我们知道，如果内存中的内容被修改（发生了”写“操作），状态位中的修改位变为1，移出内存时要再写入外存。实际上修改位的改变不一定用在内存中修改，可能只修改快表中的修改位即可，这样少访存。</li>
<li>换入换出页面太频繁，开销会很大。</li>
<li>页面调入内存后，直接就放到快表里，之后访问就访问快表就行。</li>
</ol>
<p><strong>页面置换算法</strong></p>
<p>追求更小的缺页率，这样换入换出更少。</p>
<p>最佳置换算法 OPT：选择不再使用，或者最长时间内不再被访问的页面淘汰。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121943217.png" alt="image-20221212194302144"></p>
<p>插入701之后满了，再想插入2就要顶掉一个。看看后面要访问的页面，7是最不着急的，先把7顶掉。后面以此类推。</p>
<p><em>注意缺页不一定就会发生页面置换。如果还有块空闲就不用。</em></p>
<p>但最大问题就是操作系统无法提前预判后面的页面访问序列。</p>
<p>先进先出置换算法 FIFO：最早进来的页面最早被淘汰。就是队列的数据结构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121946779.png" alt="image-20221212194655703"></p>
<p>但是这就是再猜啊。怎么能因为用的早就觉得下一秒他不会用了呢？买彩票呢。可能会引发 Belady 异常（为进程分配的物理块变大时，缺页次数反而变多）。</p>
<p>最近最久未使用置换算法 LRU：</p>
<p>哪个最久没用过，就先替换掉哪个。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121953012.png" alt="image-20221212195347896"></p>
<p>性能确实好，但是开销大，实现困难。</p>
<p>时钟置换算法 CLOCK：每个页面添加一个访问位，初值都是0，访问过了改为1.每次优先替换掉0的页面。如果全为1，则全置0后再次扫描。</p>
<p>改进的时钟置换算法：同时考虑访问位和修改位。</p>
<p>替换：第一轮扫描找0，0的替换。这种不仅最近没用过，而且不用写入外存。</p>
<p>第二轮找0，1的替换。这种最近没用过，但是之前修改过，要写入外存。</p>
<p>如果这两轮都没找到，说明所有的第一位都是1.全部置0，再进行扫描。</p>
<p>第三轮找0，0，类似第一轮。</p>
<p>第四轮找0，1，类似第二轮。</p>
<p><strong>页面分配策略</strong></p>
<p>驻留集：请求分页存储管理中分给内存的物理块的集合。虚拟存储中，驻留集大小一般小于进程总大小。太小，频繁缺页出入内存效率低；太大，并发性降低。</p>
<p>固定分配：一开始给定每个进程固定大小的驻留集。</p>
<p>动态分配：根据运行过程中的情况动态分配大小。</p>
<p>局部置换：缺页时只能当前进程自己的物理块置换需要的页进来。</p>
<p>全局置换：可以用空闲的物理块，或其他进程的物理块置换。全局置换大小肯定不固定，肯定是动态分配。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212130102033.png" alt="image-20221213010232817"></p>
<p>调入哪些页？</p>
<p>首次调入时，根据局部性原理，某个页相邻的页也会容易用到。因此一调调一小片。</p>
<p>运行中缺页调入时，只调缺少的页。</p>
<p>从何处调入页面？</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212130114188.png" alt="image-20221213011456020"></p>
<p>抖动&#x2F;颠簸现象：刚换出去的页面又换进来。主要原因是驻留集太少了，少于要频繁使用的块。</p>
<p>工作集：运行时进程实际访问的页面集合。驻留集不应小于工作集。</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>有信息的数据集合。</p>
<p>文件包含的信息：文件名、标识符（操作系统要看）、类型、大小、创建修改时间、所有者、安全信息。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件分为无结构的流式文件和有结构的记录式文件。记录式文件由一条条记录组成。</p>
<p>文件存放在根目录里的目录里。</p>
<p>操作系统应该向上提供给用户的功能：CRUD，打开和关闭文件。</p>
<p>文件存放在外存类似进程在内存中，是分块存放的（救命啊，我刚把那块学过去）。</p>
<p>初次子海外，操作系统还应该提供文件共享和保护功能。</p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>无结构文件（如txt）很简单。</p>
<p>有结构文件一般有关键字区分各个记录；记录存储长度不同又分为定长和可变长。</p>
<p>有结构文件逻辑结构：</p>
<ol>
<li><p>顺序&#x2F;链式存储。顺序定长存储可以实现随机存取，想找第i位直接起始位置+i*单位长度即可。顺序可变长无法计算，链式存储不连续也无法实现随机存取。<em>顺序定长存储如果物理上也采用顺序存储，则可实现快速检索。</em></p>
</li>
<li><p>索引文件。对于可变长记录文件，可以建立一个定长的索引表，包含索引号、长度、起始位置指针的信息。检索速度很高。但是索引表和记录数一样，占的空间不小。</p>
</li>
<li><p>索引顺序文件，一条索引代表一组记录。可能查找速度还是很慢，那就建立多级索引。</p>
<p>类似数据结构中学到的中间表，如果索引中只存储必要的少部分信息（文件名，指针），索引占的小，能放更多的索引，用更少的磁盘块存储，就平均需要访问更少的磁盘块就能找到文件。</p>
</li>
</ol>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20221213034225243.png" alt="image-20221213034225243" style="zoom:50%;" />

<p>​	外存中的索引节点叫磁盘索引节点，内存中的叫索引节点，可能包含更多信息，如文件是否被修改、同时有几个进程在访问等。</p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>文件控制块 FCB 中存储文件名、类型（是否是目录）、权限、地址等信息。</p>
<p>目录支持的功能有：搜索、创建、删除、显示、修改文件。</p>
<p>早期操作系统只支持<strong>单文件目录</strong>，那就不能重名了。</p>
<p>早期多用户操作系统支持<strong>双文件目录</strong>，一个主文件目录，其中包含多个用户目录。不同用户目录各自文件可以重名。但是用户自己没办法创建多级目录。</p>
<p>后来的多级目录结构支持<strong>多级目录</strong>了。</p>
<p>引入当前目录概念：如果没有此概念，我们要找根目录下 &#x2F;目录1&#x2F;目录2&#x2F;照片.jpg，需要三次访存。根目录找目录1，目录1找目录2，目录2找jpg。要是有当前目录的相对路径就会方便得多。</p>
<p>树形目录结构缺点在于不能共享文件。</p>
<p><strong>无环图目录结构</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212130400399.png" alt="image-20221213040035339"></p>
<p>不同用户不同目录下可以访问到相同的共享文件。</p>
<p>共享文件要设置共享计数器。当有用户取消共享后，要删除共享信息，共享计数器–。减为0时删除共享节点。</p>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p>很多操作系统中，磁盘块和内存块、页大小相同，成块成块拿进来。</p>
<p>类似内存，文件存储的逻辑地址分为逻辑块号和块内地址两部分。</p>
<p><strong>连续分配</strong></p>
<p>自不必多说<del>物理块号&#x3D;起始块号+逻辑块号。支持顺序访问和随机访问。但是不方便拓展，比如1</del>3块的A文件想扩展，但是4~6是B文件，不是空闲文件，A文件想拓展只能整体挪到空闲区域；而且还可能产生大量磁盘碎片。</p>
<p><strong>链接分配</strong></p>
<p>隐式链接：FCB存储起始块号和结束块号。像链表一样从第一个找到结尾（每个磁盘块中包含指向下一个盘块的指针，但是这对用户来说是透明的），没法随机存取，但是拓展方便。</p>
<p>显示链接：FCB 中包含起始块号，此外还有一张文件分配表 FAT，其中包含所有块号的下一块指针。隐式链接想找一个块，要先在 FCB 中找到起始位置，再读磁盘，找磁盘里的下一块。显示连接可以先不用读磁盘，根据分配表推测出要找的逻辑块的物理地址再去读磁盘，访问速度更快。</p>
<p>链接分配都不会有外部碎片。</p>
<p><strong>索引分配</strong></p>
<p>每个文件建立一个索引表。索引表存放的磁盘块叫索引块，文件数据存放的磁盘块叫数据块。FAT是一个磁盘对应一张，索引表是一个文件对应一张。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131026788.png" alt="image-20221213102643626"></p>
<p>也支持随机存取，也方便拓展，但是索引表占空间。</p>
<p>要是文件太大，索引表一个索引块存不下，需要多个。</p>
<p>可以让索引块之间链接起来。但是不支持顺序存储，要找最后一块就要从头便历。</p>
<p>可以建立多级索引。每级大小不超过一个数据块。k级表访问数据，要访问k+1次磁盘块（k次查找位置，1次查找数据）。</p>
<p>混合索引：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131040897.png" alt="image-20221213104019760"></p>
<p>小文件层级小一点。因小文件访问可能频繁一些，就少访问几次。</p>
<h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>操作系统的盘有什么用？又叫文件卷，每个文件卷都包含目录区和文件区。</p>
<p><strong>空闲表法</strong></p>
<p>分配磁盘块给用户：类似动态分区分配，可采用首次适应、最佳适应、最坏适应等。</p>
<p>回收磁盘块：也类似动态分区分配，考虑前后有无空闲块。</p>
<p><strong>空闲链表法</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131057529.png" alt="image-20221213105751349"></p>
<p>空闲盘块链分配：空闲链从链头摘下来k个空闲块，并修改链头位置。</p>
<p>空闲盘块链回收：回收的空闲块挂到空闲链结尾，并修改链尾位置。</p>
<p>空闲盘区链分配：先按算法找到合适的空闲盘区。如果没有合适的，也可以把不同盘区的盘块同时给一个文件。</p>
<p>空闲盘区链回收：如果和空闲盘区挨着，直接合并。否则变成一个单独的空闲盘区挂到队尾。</p>
<p><strong>位示图法</strong></p>
<p>一定注意从0还是1开始！</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131113265.png" alt="image-20221213111306083"></p>
<p>分配：扫描位图，找到连续的k个0，修改为1.</p>
<p>回收：算出回收盘块的位图字号、位号，置为0.</p>
<p><strong>成组链接法</strong></p>
<p>大文件不适用空闲块法。</p>
<p>超级块存放在内存中，其中包含下一组空闲块块数和块号。</p>
<p>如果没有下一级了，下一组空闲盘块数可以用特殊标识符如-1表示。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131251971.png" alt="image-20221213125105862"></p>
<p>空闲分配：如果&lt;100个，从超级块分配就够。</p>
<p>如果&#x3D;100个，不能直接分配超级块因为这样超级块对后面的链接就消失了。要先把300的内容提到超级块作为新的超级块，再分配。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131309663.png" alt="image-20221213130944587"></p>
<p>回收：直接加到超级块上。如果超级块最大大小为100，已经满了，还要回收，就要让新回收的块作为新的超级块，并指向原来的超级块。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131313202.png" alt="image-20221213131331129"></p>
<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><p><strong>文件创建</strong></p>
<p>需要关注：文件名；文件路径；需要的外存空间。</p>
<ol>
<li>在外存中找到合适大小的内存空间；</li>
<li>在目录表中更新新文件的信息。</li>
</ol>
<p><strong>文件删除</strong></p>
<ol>
<li>根据目录表找到该目录项；</li>
<li>外存中回收内存；</li>
<li>目录表中删除该文件信息。</li>
</ol>
<p><strong>打开文件</strong></p>
<p>需要用户提供的信息：文件名；文件目录；打开方式（读；写；……）</p>
<p>操作系统先去目录表找到对应的文件，复制到内存中。并且把目录项复制到内存系统的“打开文件表”中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131338588.png" alt="image-20221213133814373"></p>
<p><strong>关闭文件</strong></p>
<p>删除用户打开文件表的对应项；回收空间；系统打开文件表的打开计数器-1，减到0则删除打开文件表的对应项。</p>
<p><strong>读文件</strong></p>
<p>指明要读的文件，要读入多少数据，读入的数据在内存中的位置。读入指定大小放入内存中。</p>
<p><strong>写文件</strong></p>
<p>和read很像。最后再通过write系统调用写回外存。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>基于索引节点的共享方式（硬链接）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131621187.png" alt="image-20221213162136121"></p>
<p>count说明还有几个进程在共享该文件。</p>
<p>要删除时，count–，若&gt;0则不能删除，&#x3D;0才能删除。</p>
<p>基于符号链的共享方式（软链接）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131626995.png" alt="image-20221213162634924"></p>
<p>删掉文件1，软链接仍然存在，只是无法通过软链接去访问文件1了。</p>
<p>因为访问共享文件要查询多级目录，进行多次 IO，因此采用软链接。</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p>口令保护：规定一个口令，用户要说对应口令才能访问。但是口令保存在系统内部，不安全。</p>
<p>加密保护：用密码对文件加密。如异或加密。有点费时。</p>
<p>访问控制：文件的 FCB 中增加一个访问控制列表 ACL，记录用户可以有哪些权限（读写运行ls）。以组为单位，如：管理员，文件主，文件主的伙伴，陌生人。</p>
<h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131650838.png" alt="image-20221213165015538"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131653423.png" alt="image-20221213165347348"></p>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131724309.png" alt="image-20221213172411000"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131726317.png" alt="image-20221213172609205"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131726041.png" alt="image-20221213172629925"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131726557.png" alt="image-20221213172637487"></p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131813172.png" alt="image-20221213181331914"></p>
<p>先来先服务算法 FCFS：就是单纯的先处理先来的进程。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131821625.png" alt="image-20221213182105548"></p>
<p>最短寻找时间优先 SSTF：先找离当前磁道近的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131824597.png" alt="image-20221213182454524"></p>
<p>扫描算法 SCAN：只有磁道移到最外侧之后才允许往回移动，避免 SSTF 的左右横跳。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131830038.png" alt="image-20221213183053980"></p>
<p>LOOK 调度算法：改进 SCAN 算法，观察到当前磁道已经是访问请求最右边的磁道后，就可以立即改变磁道移动方向往回。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131833520.png" alt="image-20221213183329408"></p>
<p>循环扫描算法 C-SCAN：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131844015.png" alt="image-20221213184440873"></p>
<p>C-LOOK 算法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131845424.png" alt="image-20221213184532367"></p>
<h2 id="减少延迟时间"><a href="#减少延迟时间" class="headerlink" title="减少延迟时间"></a>减少延迟时间</h2><p>磁盘一直旋转的。如果要读几个相邻的扇区，读了第一个处理的过程中磁盘还在转，处理好了的时候可能又转到不知道哪里去了。可能就会产生很长的延迟时间。</p>
<p>解决办法：交替编号。逻辑上相邻的扇区物理上分开。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131921182.png" alt="image-20221213192126906"></p>
<p>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？因为更改柱面号需要移动磁头臂，更改盘面号不用移动臂，只需要激活相邻盘面的磁头即可。可以减少磁头移动消耗的时间。</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>初始化：</p>
<p>​	物理格式化：把磁盘划分为扇区。扇区包含头、尾、中间数据部分。头尾会存放一些扇区校验码之类的信息。</p>
<p>​	磁盘分区：分为几个文件卷。</p>
<p>​	逻辑格式化：创建文件系统（根目录、管理空间的数据结构如位示图、空闲分区表等）。</p>
<p>​	磁盘的初始化程序：放在哪里？</p>
<p>​	ROM 只读存储器中的数据出厂时就写好了且不能更改，集成在主板上。但是磁盘的初始化程序说不定以后会更新换代，ROM 中的内容又不能更新，因此初始化程序不放在 ROM 中，而是放在磁盘（C）里。初始化程序的装入程序写在 ROM 中。</p>
<p>坏块的管理：坏掉的扇区。简单的磁盘直接在 FAT 中标记出来防止被使用到（对操作系统不透明）。复杂的磁盘交给磁盘控制器维护坏块链表，而且保留一些备用分区（对操作系统透明）。</p>
<h1 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h1><h2 id="I-O-设备分类"><a href="#I-O-设备分类" class="headerlink" title="I&#x2F;O 设备分类"></a>I&#x2F;O 设备分类</h2><p><strong>按使用特性分类</strong></p>
<p>人机交互类外设：如鼠标打印机键盘等。数据传输慢。</p>
<p>存储设备：移动硬盘、光盘等，数据传输速率快。</p>
<p>网络通信设备：调制解调器等用于网络通信，速度中等。</p>
<p><strong>按速率分类</strong></p>
<p>低速设备：鼠标键盘。</p>
<p>中速：激光打印机。</p>
<p>高速：移动硬盘等。</p>
<p><strong>按信息交换的单位分类</strong></p>
<p>块为单位：磁盘。</p>
<p>字符为单位：鼠标键盘等。</p>
<h2 id="I-O-控制器"><a href="#I-O-控制器" class="headerlink" title="I&#x2F;O 控制器"></a>I&#x2F;O 控制器</h2><p>IO设备包括：</p>
<ul>
<li><p>机械部件：用于执行具体 IO 操作的，如鼠标按钮、显示器屏、磁盘盘面。</p>
</li>
<li><p>电子部件：插入主板扩充槽的印刷电路板。</p>
</li>
</ul>
<p>CPU 要通过 IO 控制器作为中介才能控制机械部件。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132007717.png" alt="image-20221213200720497"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132008149.png" alt="image-20221213200846891"></p>
<p>一个 IO 控制器可能控制多个设备；而且可能有多个寄存器。有的操作系统让这些寄存器存到内存里，叫做内存映像 IO；有的采用专门的地址，即寄存器独立编址。独立编址不在内存里，因此还要设置专门的指令来实现对其的操作，还要指明具体对哪个控制器操作。</p>
<h2 id="IO-控制方式"><a href="#IO-控制方式" class="headerlink" title="IO 控制方式"></a>IO 控制方式</h2><p>关注：一次读写操作的流程；CPU 干预的频率；数据传送单位；数据流向；优缺点。</p>
<p><strong>程序直接控制</strong></p>
<p>读：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132014482.png" alt="image-20221213201440173"></p>
<p>重点在轮询。CPU要不断轮询。</p>
<p>数据传送单位：每次一个字。</p>
<p>数据流向：内存和 IO 设备经由 CPU 读写。每个字读写都需要 CPU 帮助。</p>
<p>简单，但是 CPU 和 IO 只能串行工作，CPU 一直轮询检查效率也很低。</p>
<p><strong>中断驱动方式</strong></p>
<p>CPU 发出读写命令后，等待 IO 的进程暂时阻塞，先运行其他程序。IO 完成后控制器会向 CPU 发一个中断信号，CPU 收到后继续执行。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132032231.png" alt="image-20221213203221153"></p>
<p>CPU 执行完每个指令的周期末尾检查中断。中断处理过程需要保存、恢复进程的运行环境，也需要一定时间开销。</p>
<p>CPU 只有 IO 开始时干预一下，等待 IO 过程中就运行其他进程了。</p>
<p>数据传送单位：每次一个字。</p>
<p>数据流向：内存和 IO 设备经由 CPU 读写。每个字读写都需要 CPU 帮助。</p>
<p>相比程序直接控制，CPU 利用率高一点了。但是一个字一个字的传，速度还是慢。</p>
<p><strong>DMA 方式</strong></p>
<p>数据传输单位是块；设备和内存之间数据传输不用每次都经过 CPU ，只有开始传输或结束时才需要干预。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132141644.png" alt="image-20221213214114491"></p>
<p>缺点：CPU 每发一条 IO 指令，只能读写几次连续的数据块。离散的数据块就要多次中断。</p>
<p><strong>通道控制方式</strong></p>
<p>通道相当于简化版的 CPU。CPU向通道发出指令，指明通道程序在内存中的位置，并指明要操作的是哪个 IO 设备，然后 CPU 就去运行其他程序了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132150157.png" alt="image-20221213215048076"></p>
<p>通道能执行的指令很单一，而且放在内存中。</p>
<p>CPU 干预次数极少，效率也高，就是需要专门的通道程序支持。</p>
<h2 id="I-O-软件层次"><a href="#I-O-软件层次" class="headerlink" title="I&#x2F;O 软件层次"></a>I&#x2F;O 软件层次</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132153000.png" alt="image-20221213215341827"></p>
<p>设备独立性软件：向上提供接口（入库函数）。校验用户是否有权限使用当前设备。差错处理。分配和回收设备。管理数据缓冲区。建立逻辑设备名到物理设备名的映射，并根据实际的物理设备选择合适的驱动程序。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132205495.png" alt="image-20221213220547401"></p>
<p>可以只设立一个系统 LUT，但是所有用户的逻辑设备名不能重复；也可以给每个用户设计一个。</p>
<p>为什么不同设备驱动程序也不同？因为不同设备内部结构也不一样。比如不同打印机内部寄存器数量可能不一样。驱动程序一般作为单独的进程。</p>
<p>设备驱动程序：主要负责具体控制硬件设备。</p>
<p>中断处理程序：IO 顺利完成后，进行中断处理。并从设备读入一个字长的数据。</p>
<h2 id="I-O-核心子系统"><a href="#I-O-核心子系统" class="headerlink" title="I&#x2F;O 核心子系统"></a>I&#x2F;O 核心子系统</h2><p><strong>假脱机技术</strong></p>
<p>脱机技术是什么？我们记得最早期的计算机是人手动打孔纸带放入计算机中的，因为人打孔太慢，CPU 运行再快也得等着。</p>
<p>批处理几段引入了脱机输入，先通过外围控制机把数据输入到更快速的磁带上再让主机读入。脱机指的是脱离主机控制的 IO 操作。</p>
<p>不仅 IO 快了，而且 CPU 忙的时候用户也可以先处理数据到磁带上。</p>
<p>假脱机技术 SPOOLing 用软件模拟脱机技术。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132359303.png" alt="image-20221213222958979"></p>
<p>输入输出进程模拟外围控制机。</p>
<p>借助 SPOOLing 技术，可以让打印机实现共享。收到用户的打印请求时，在输出井里申请空闲缓冲区（在磁盘上），并放入要打印的数据；且给用户进程申请一张空白的打印请求表，里面存储打印的相关信息，并把该表挂到假脱机文件队列上。打印机空闲时从队列中取出打印请求表，根据表取出打印的数据到输出缓冲区，再到打印机打印。</p>
<h2 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h2><p>分配设备要考虑：<strong>设备属性</strong>（独占？共享？虚拟？虚拟就是假脱机技术等独占改成共享）。<strong>设备分配算法</strong>（FCFS 优先级高的优先 短任务优先）。<strong>安全性</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132238185.png"></p>
<p>分配分为静态分配和动态分配。</p>
<p><strong>设备分配管理中的数据结构</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132240499.png" alt="image-20221213224041439"></p>
<p><strong>设备控制表 DCT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132242703.png" alt="image-20221213224208534"></p>
<p><strong>控制器控制表 COCT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132243321.png" alt="image-20221213224340187"></p>
<p><strong>通道控制表 CHCT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132244138.png"></p>
<p><strong>系统设备表 SDT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132245062.png" alt="image-20221213224501959"></p>
<p><strong>设备分配步骤</strong></p>
<ol>
<li>根据进程的物理设备名，去 SDT 找设备。</li>
<li>根据 SDT 找 DCT，空闲就直接把设备分给这个进程，忙碌就把这个进程的 PCB 挂到设备等待队列中。</li>
<li>根据 DCT 找到 COCT，空闲就分配，不空闲就等待。</li>
<li>根据 COCT 找到 CHCT，空闲就分配，不空闲就等待。</li>
</ol>
<p>以上方法缺点在于用户要知道物理设备名，不透明；而且只指定这一个设备，如果该设备坏了或者堵塞哪怕其他设备能用也无法切换。</p>
<p>可以建立逻辑设备，用逻辑设备找物理设备。</p>
<p>SDT 中设备类型就是逻辑设备名。</p>
<p>通过逻辑设备表 LUT 建立逻辑设备名和物理设备名之间的映射关系。</p>
<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><p>缓冲区是一个存储区域，可以用专门的硬件寄存器，也可以用内存做。速度快，成本高，容量小，比如快表。本节中介绍的主要是内存缓冲区。</p>
<p>可以缓冲 CPU 和 IO 之间速度不匹配的矛盾，进而 CPU 中断次数也会减少；解决数据颗粒度不匹配的问题；提高 CPU 与 IO 的并行性。</p>
<p><strong>单缓冲区</strong></p>
<p>某用户进程请求设备读入若干个块的数据。。如果采用单缓冲策略，主存中会被分配一个缓冲区（一般是一个块大小）。缓冲区中只有空的时候才能冲入数据，只有非空的时候才能传出数据。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132311260.png" alt="image-20221213231116133"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132315136.png" alt="image-20221213231551012"></p>
<p><strong>双缓冲区</strong></p>
<p>一满一空，可以空的边读，满的边往工作区写。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132321677.png" alt="image-20221213232144595"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132321658.png" alt="image-20221213232106544"></p>
<p>用时&#x3D;Max(C+M, T)</p>
<p>如果两台机器各配置2个缓冲区，就能同时收发了。</p>
<p><strong>循环缓冲区</strong></p>
<p>多个大小相同的缓冲区链接成一个循环队列。 </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132329586.png" alt="image-20221213232951510"></p>
<p><strong>缓冲池</strong></p>
<p>放满了各种各样缓冲区的池子。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132331181.png" alt="image-20221213233107985"></p>
<p>输入：取出一个空缓冲区挂到收容输入队列中，输入放到收容输入队列中，装好了挂到输入队列中。</p>
<p>提取输入：从输入队列取下来，放到提取输入队列中提取到用户进程，再挂回空缓冲区。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：骆昊 + 黑马程序员 MySQL"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/03/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%AA%86%E6%98%8A%20+%20%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20MySQL/"
    >技术学习：骆昊 + 黑马程序员 MySQL 基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/03/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%AA%86%E6%98%8A%20+%20%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20MySQL/" class="article-date">
  <time datetime="2022-08-02T23:00:00.000Z" itemprop="datePublished">2022-08-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习于：b站 骆昊 jackfrued 老师的网课+黑马网课.</p>
<p>涵盖内容包括基本增删改查，约束，事务。</p>
<p>MYSQL 的安装配置网上一搜一大把，博主就不在此发表拙见了，安装太久了自己也记不是很清具体方法了。这里指跟随课程学习了 Command Line Client 的安装（说实话，这玩意我自认为没啥用）。</p>
<p>Mysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。</p>
<p>如果选择的是 zip 下载，应该只会安装一个 mysql 文件包，在程序终端可以使用。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果是选择 msi 文件安装，MYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。</p>
<p>开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\h, ?, ?</td>
<td>获取帮助</td>
</tr>
<tr>
<td>\c</td>
<td>清除前面输入的内容（内容输入有误时使用）</td>
</tr>
<tr>
<td>\R</td>
<td>修改 每次输入命令前左侧的提示样式（默认：’mysql&gt;’）</td>
</tr>
<tr>
<td>? 需要查看帮助的命令;</td>
<td>显示该命令的帮助（如：? show）</td>
</tr>
<tr>
<td>show databases; show databases();</td>
<td>查看所有数据库，查看当前所在数据库</td>
</tr>
<tr>
<td>use ‘数据库名’;</td>
<td>选中某个数据库</td>
</tr>
<tr>
<td>（选中某个数据库后）show tables;</td>
<td>查看当前数据库中所有表</td>
</tr>
<tr>
<td>exit &#x2F; quit</td>
<td>退出</td>
</tr>
</tbody></table>
<h1 id="关系型数据库-SQL"><a href="#关系型数据库-SQL" class="headerlink" title="关系型数据库 SQL"></a>关系型数据库 SQL</h1><p>数据库有很多种结构，mysql 学习的是关系型数据库，说白了就是二维表的结构。</p>
<pre class="mermaid">graph LR
R[关系型数据库]-->T[理论基础]
R-->S[具体表象]
R-->L[编程语言 SQL]
T-->A[关系代数]
T-->C[关系运算]
T-->P[一阶谓词逻辑]
S-->Ta[二维表]
L-->D[DDL]
L-->M[DML]
L-->Q[DQL]
L-->DCL[DCL]</pre>

<p>DDL: create &#x2F; drop &#x2F; alter （database 或 schema 数据库名 &#x2F; table 表名）</p>
<p>DML: insert &#x2F; update &#x2F; delete</p>
<p>DQL: select …… from</p>
<p>DCL: grant（授权） &#x2F; revoke（召回权限）</p>
<table>
<thead>
<tr>
<th>正式的关系模型术语</th>
<th>非正式的日常用语</th>
</tr>
</thead>
<tbody><tr>
<td>关系（relation）</td>
<td>表（table）</td>
</tr>
<tr>
<td>元组（tuple）记录</td>
<td>行（row）或记录（record）</td>
</tr>
<tr>
<td>势（cardinality）</td>
<td>行数（number of rows）</td>
</tr>
<tr>
<td>属性（attribute）</td>
<td>列（column）或字段（field）</td>
</tr>
<tr>
<td>度（degree）</td>
<td>列数（number of columns）</td>
</tr>
<tr>
<td>定义域（domain）</td>
<td>列的取值集合（pool of legal values）</td>
</tr>
</tbody></table>
<h1 id="ER-和-EER-模型"><a href="#ER-和-EER-模型" class="headerlink" title="ER 和 EER 模型"></a>ER 和 EER 模型</h1><p>为什么要有 ER 图和 EER 图的存在？</p>
<p><strong>真正做项目、设计数据库时，</strong>实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR &#x2F; json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）<strong>是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。</strong></p>
<h2 id="ER-模型"><a href="#ER-模型" class="headerlink" title="ER 模型"></a>ER 模型</h2><p>ER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212337130.png" alt="百度百科图片"></p>
<p>相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。</p>
<h2 id="EER-模型"><a href="#EER-模型" class="headerlink" title="EER 模型"></a>EER 模型</h2><p>以下部分内容有参考自文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356216273">为了彻底搞清楚数据库 E-R 模型设计，我肝了这篇万字长文 - 知乎 (zhihu.com)</a></p>
<p>关于两者的具体区分我还有去问b站up主 骆昊jackfrued 老师，老师表示：不用太纠结这个问题，ER图更抽象，可以理解为概念模型图（PowerDesigner）。</p>
<p>相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。</p>
<h3 id="泛化层次"><a href="#泛化层次" class="headerlink" title="泛化层次"></a>泛化层次</h3><p>包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。</p>
<p><strong>子类父类</strong>就是类似 Java 的继承，如动物是父类，猫、狗是其子类。<strong>子类父类是一对一的关系！</strong></p>
<p><strong>泛化</strong>又叫归纳，就是将几个类的共同属性提取出来作为父类；</p>
<p><strong>特化</strong>又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。</p>
<p>其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。</p>
<p><strong>mandatory &#x2F; optional</strong>：父类中的所有属性都必须包含在每一个子类中 &#x2F; 不用全部继承，选择部分继承即可（完全性限制）</p>
<p><strong>disjoint &#x2F; overlapping</strong>：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212336682.png" alt="img"></p>
<p>图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D &#x2F; O，表示 disjoint &#x2F; overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。</p>
<h3 id="汇集层次"><a href="#汇集层次" class="headerlink" title="汇集层次"></a>汇集层次</h3><p>Aggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212337609.png" alt="img"></p>
<p>如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。</p>
<h3 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h3><p>一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212337534.png" alt="img"></p>
<p>Workbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212337092.png" alt="EER 图示例"></p>
<p>在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。</p>
<p><em>自动生成的 SQL 语句中，外键下方有两句话<code>ON DELETE NO ACTION</code> <code>ON UPDATE NO ACTION</code>，意为：当外键参考的主键修改&#x2F;删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改&#x2F;删除外键在使用的主键。</em></p>
<p>同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。</p>
<p><em>Power Designer 建模工具，也支持正 &#x2F; 反向工程，可以生成 SQL 方言。完整版付费。</em></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型可以通过 <code>? data types</code> 查看说明，每种数据类型也可以通过 <code>? 数据类型</code> 查看。</p>
<p><em>除了data types 其他可以用?查看的内容可以输入 <code>? contents</code> 查看。</em></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>整数 (tinyint, smallint, mediumint, int, bigint)</td>
<td>都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）</td>
</tr>
<tr>
<td>字符串 (char(位数), varchar(位数), text)</td>
<td>char 长度固定，varchar 长度可变</td>
</tr>
<tr>
<td>小数 (float, double, decimal(总位数, 小数点后位数))</td>
<td>不要用 float, double！</td>
</tr>
<tr>
<td>时间日期 (year, date, time, datetime, timestamp)</td>
<td>date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数</td>
</tr>
<tr>
<td>Mysql 中的枚举类型 (enum, boolean)</td>
<td></td>
</tr>
</tbody></table>
<p>PS: </p>
<ol>
<li><p>虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。</p>
</li>
<li><p>金额等小数一般不会用小数的数据类型存储，而是整数类型&#x2F;100使用。因为小数形式有误差，比如0.1+0.2&#x3D;0.30000000004.</p>
</li>
<li><p>decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。</p>
</li>
<li><p>时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。</p>
</li>
</ol>
<p>这里了解到了一个很有趣的“千年虫”问题 (<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/305603895">漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)</a>)。</p>
<blockquote>
<p>Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。</p>
<p>早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022&#x2F;04&#x2F;19，就是22&#x2F;04&#x2F;19）</p>
<p>尽管节约了内存空间，但是40年后1999-&gt;2000年时，问题就出现了……对计算机来说，相当于99-&gt;00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。</p>
<p>如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：</p>
<p>1.只修改核心关键的医疗、航空、金融、军事领域的程序；<br>2.对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。</p>
</blockquote>
<p>回到刚才的话题，因此时间戳也并不推荐使用。</p>
<p>5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符。</p>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><table>
<thead>
<tr>
<th>SQL 语句</th>
<th>作用</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建数据库 &#x2F; 表</td>
<td>create database `数据库名`; &#x2F; create table `表名` ( 字段描述 );</td>
</tr>
<tr>
<td>drop</td>
<td>删除数据库 &#x2F; 表</td>
<td>drop database `数据库名`; &#x2F; drop table `表名`;</td>
</tr>
<tr>
<td>use</td>
<td>选中数据库</td>
<td>use `数据库名`;</td>
</tr>
<tr>
<td>alter</td>
<td>更改数据库 &#x2F; 表信息</td>
<td>alter table `表名` add constraint `约束名` unique (`字段名`);</td>
</tr>
</tbody></table>
<p>PS： </p>
<p>修改表的引擎 &#x2F; 更改自增约束初始值是在 create table `表名` () 后面添加的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table `表名`(</span><br><span class="line"></span><br><span class="line">)engine = innodb auto_increment=2 comment &#x27;表示例&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary key (`列名`),</span><br></pre></td></tr></table></figure>

<p><em>复合主键语法上没错，但是开发使用时非常不好用，因为需要至少两条字段才能唯一确定一条记录。一般不会用。</em></p>
<p><em>如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。</em></p>
<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p><code>default val;</code> 设置默认值。</p>
<h3 id="自增约束、非空约束"><a href="#自增约束、非空约束" class="headerlink" title="自增约束、非空约束"></a>自增约束、非空约束</h3><p>都在字段描述后面写即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`col_name` int auto_increment not null comment &#x27;列名&#x27;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建表时：</span><br><span class="line">create table(</span><br><span class="line">    id int primary key comment &#x27;id&#x27;;</span><br><span class="line">	age int check (age&gt;=0 &amp;&amp; age&lt;=100) comment &#x27;年龄&#x27;,</span><br><span class="line">	gender char(1) default &#x27;m&#x27; comment &#x27;性别&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改表时，主键，unique，check，外键用 add，其他用 modify</span><br><span class="line">alter table add primary key(列名);</span><br><span class="line">alter  table table_name modify 列名 数据类型  not null;# 如果是 null，就是取消非空约束</span><br></pre></td></tr></table></figure>

<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint `uk_col_name` unique (`col_name`),</span><br></pre></td></tr></table></figure>

<p>类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint `ck_col_sex` check (`col_sex`=&#x27;M&#x27; or `col_sex`=&#x27;F&#x27;),</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。</p>
<p>外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 外键需要先创建一个字段，然后给这个字段添加外键。原外键的字段和新的要添加外键的字段数据类型要一样。</span><br><span class="line">alter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段);</span><br><span class="line"></span><br><span class="line">alter table 表名 drop foreign key 外键名;</span><br></pre></td></tr></table></figure>

<p><em>一对多时，多的一方需要加外键约束。</em></p>
<p>之后子表引用了父表，父表被引用的记录就不能随便删除了。子表也不能随便写外键的值，必须要在父表中存在才可以引用。</p>
<table>
<thead>
<tr>
<th>外键删除更新行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no action&#x2F;restrict</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则不删除&#x2F;更新</td>
</tr>
<tr>
<td>cascade</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录也删除&#x2F;更新</td>
</tr>
<tr>
<td>set null</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录对应字段设为空值（前提：该字段可以为 null）</td>
</tr>
<tr>
<td>set default</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录也删除&#x2F;更新对应字段设为默认值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段) on update cascade on delete cascade;</span><br></pre></td></tr></table></figure>

<h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行</span><br><span class="line">insert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的</span><br></pre></td></tr></table></figure>

<p>注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 <code>default</code> ，不然系统也难以分辨哪一项使用默认值。</p>
<p><em>日期可以写字符串 2002-01-01，会自动转换</em></p>
<p>插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。</p>
<p><strong>如果主键、unique 的记录重复会报错。</strong>报错显示： <code>duplicate key for key &#39;定义的约束键名称&#39;</code></p>
<p><strong>填写了规定的 check 以外的内容会报错。</strong>报错显示：<code>check constraint &#39;定义的约束键名称&#39; is violated.</code> 不过字符串不区分大小写，规定性别只能填 ‘F’ ‘M’ 的话，填 ‘f’ ‘m’ 也行。</p>
<p><strong>如果对应的外键在原表中没有对应的记录会报错。</strong> 报错显示：<code>cannot add or update a child row: a foreign constraint fails</code> 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。</p>
<p><strong>如果没有给 NOT NULL且没有默认值的字段赋值时会报错。</strong> 报错显示：<code>Field &#39;字段名&#39; doesn&#39;t have a default value.</code> 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete from `表名`;//这可不兴用啊！</span><br><span class="line">delete from `表名` where `字段名`=&#x27;要删除的记录的对应字段值&#x27;;//不等于可以用&lt;&gt;，有的 DBMS 支持!=</span><br><span class="line">delete from `表名` where `字段名` = &#x27;字段值&#x27; or `字段名` = &#x27;字段值&#x27;;//删除多条语句</span><br><span class="line">delete from `表名` where `字段名` in (&#x27;字段值&#x27;,&#x27;字段值&#x27;);//删除多条语句</span><br></pre></td></tr></table></figure>

<p>但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： <code>Cannot delete or update a parent row</code> 。</p>
<p>删除了外键约束之后就可以随意修改两个表对应的值而不报错了。</p>
<p>另一种删除表的方式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table `表名`;</span><br></pre></td></tr></table></figure>

<p>截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update `表名` set `列名` = &#x27;值&#x27;;//把这一列的数据全都改成这个值，不常用</span><br><span class="line">update `表名` set `列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27; where `字段`=&#x27;值&#x27;;//限制条件，只修改某几个记录</span><br></pre></td></tr></table></figure>

<h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><p>查询语句。</p>
<p><em>本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）</em></p>
<p><em>tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）</em></p>
<h2 id="编写顺序、执行顺序"><a href="#编写顺序、执行顺序" class="headerlink" title="编写顺序、执行顺序"></a>编写顺序、执行顺序</h2><p>编写顺序如下：<code>select from where group by having order by limit;</code></p>
<p>执行顺序：</p>
<ol>
<li><p>from 表名</p>
</li>
<li><p>where 条件（where 可以用表别名，但是不能用 select 中的字段别名）</p>
</li>
<li><p>group by 分组</p>
</li>
<li><p>having 分组条件</p>
</li>
<li><p>select 投影</p>
</li>
<li><p>order by 排序</p>
</li>
<li><p>limit 分页</p>
</li>
</ol>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>查询所有学生的所有信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `表名`;-- * 号表示所有字段</span><br></pre></td></tr></table></figure>

<p>但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。</p>
<p>实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;</span><br></pre></td></tr></table></figure>

<p>如果只查询部分列，就只写那几列就行。</p>
<h2 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合 Union"></a>联合 Union</h2><p>Union 会把查询结果联合起来。</p>
<p>union all：结果可能重复。</p>
<p>union：重复的结果合并。</p>
<p><strong>想做union操作，两个要联合的表必须字段数相同，字段类型匹配。</strong></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>给字段或表起别名—— alias，简写为 as。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id` as `学号` from `tb_student`;</span><br></pre></td></tr></table></figure>

<p>as 可以省略，不过还是写上可读性高一些。<em><strong>一般字段不省略，表省略</strong>。具体还得看公司编程规范的要求，没有就看个人喜好了。</em></p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>限制查询记录的条件——where（选择 Selection，只查询某几行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_sex`=&#x27;M&#x27; or `stu_name`=&#x27;Jingqing&#x27;;</span><br></pre></td></tr></table></figure>

<p>多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。</p>
<p><em>性能问题，一般不用 or 而使用 union，结果取并集。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_sex`=&#x27;M&#x27; </span><br><span class="line">union</span><br><span class="line">select * from table where `stu_name`=&#x27;Jingqing&#x27;;</span><br></pre></td></tr></table></figure>

<p><em><strong>如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。</strong></em></p>
<p>类似 10&lt;x&lt;30 的形式不可以直接写两个等式，要拆成 x&gt;10 and x&lt;30 。</p>
<p>这里的字段如果是数字类型的，也可以进行 + - * &#x2F; % mod（也是取余）以及 &lt; &gt;  &#x3D; &gt;&#x3D; &lt;&#x3D; &lt;&gt; 等形式的运算。</p>
<p>还有一种条件写法是 <code>between …… and ……</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_age` between 10 and 30;-- 相当于 &lt;=30 and &gt;=10</span><br></pre></td></tr></table></figure>

<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select if(`stu_sex`,&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;性别&#x27; from `tb_student`;-- 有点类似三目运算符 ?:</span><br></pre></td></tr></table></figure>

<p>if 中第一项可以是表达式，如 age &gt; 10.</p>
<p><strong>这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。</strong>比如 Oracle 数据库中对应的函数是 decode，不能通用。</p>
<p>通用的分支结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select case `sex` </span><br><span class="line">when 1 then &#x27;男&#x27; </span><br><span class="line">elseif 0 then &#x27;女&#x27; </span><br><span class="line">else &#x27;未知&#x27;</span><br><span class="line">end as &#x27;性别&#x27; from `tb_student`;-- end 表示条件判断结束</span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>如：查询所有姓王的学生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_name` like &#x27;王%&#x27;;-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生</span><br><span class="line">select * from `student` where `stu_name` like &#x27;王_&#x27;;-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生</span><br></pre></td></tr></table></figure>

<p>这里和正则表达式有一定联系，之后会单独学习。</p>
<p>2023-01-23 补档：我后来确实学习了正则表达式~学习笔记在这里：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq/category_11807727.html?spm=1001.2014.3001.5482">Regex_灰海宽松的博客-CSDN博客</a></p>
<p>事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `字段名` regexp &#x27;正则表达式&#x27;;</span><br></pre></td></tr></table></figure>

<p>模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。</p>
<h2 id="空值处理，以及三值逻辑"><a href="#空值处理，以及三值逻辑" class="headerlink" title="空值处理，以及三值逻辑"></a>空值处理，以及三值逻辑</h2><p><strong>下面两种写法是错误的！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_address` = null;</span><br><span class="line">select * from `student` where `stu_address` &lt;&gt; null;</span><br></pre></td></tr></table></figure>

<p>因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。</p>
<p>正确做法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_address` is null;</span><br><span class="line">select * from `student` where `stu_address` is not null;</span><br></pre></td></tr></table></figure>

<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct `字段名` from `表名`;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序</span><br></pre></td></tr></table></figure>

<p>order by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。</p>
<h2 id="当前日期"><a href="#当前日期" class="headerlink" title="当前日期"></a>当前日期</h2><p>curdate()获取当前日期，使用 datediff(datepart, date1, date2) 函数可以和出生日期做差获取年龄。</p>
<p>now()获取当前年月日时分秒（datetime）。</p>
<h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p>floor() 函数是下取整。floor(3.99) &#x3D; 3.</p>
<p>ceil() 函数是向上取整，ceil(3.1) &#x3D; 4.</p>
<p>round() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)&#x3D;4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(datediff(curdate(),`date`)/365) from `staff`;</span><br></pre></td></tr></table></figure>

<p><em>可以通过? functions 查看函数一览。还会有相应的例子提示~</em></p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>描述性统计信息：包括集中趋势和离散趋势。</p>
<p>集中趋势：平均值，中位数等。</p>
<p>离散趋势：方差，标准差等。</p>
<p>聚合函数属于 SQL 语句，所有 DBMS 都能用。</p>
<ul>
<li><p>min(字段名)</p>
</li>
<li><p>max(字段名)</p>
</li>
<li><p>avg(字段名) <em>做计算的时候会忽略 null 值</em></p>
</li>
<li><p>sum(字段名)</p>
</li>
<li><p>count(字段名) <em>做计算的时候会忽略 null 值</em></p>
<p><em><strong>如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。</strong></em></p>
<p><em>比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) &#x2F; count(stu_id) 就是错误的，因为是9个人的成绩 &#x2F; 10.</em> </p>
<p><em>如果成绩为空的学生视为 &#x3D; 0，就要用 sum(score) &#x2F; count(stu_id)，或者对 avg() 函数做如下处理：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(ifnull(`score`,0)) from student;-- 如果第一个表达式!=null，则返回第一个表达式</span><br></pre></td></tr></table></figure>

<p><em>ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。</em></p>
<p>coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。</p>
</li>
<li><p>std(字段名)，计算标准差，越小说明越稳定。</p>
<ul>
<li>std(), stddev() 和 stddev_pop()：所有数据总体的标准差</li>
<li>stddev_samp()：样本标准差，抽样计算。</li>
</ul>
</li>
<li><p>variance(字段名)，计算方差，标准差的平方。</p>
<ul>
<li>variance(), var_pop()</li>
<li>var_samp()</li>
</ul>
</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>聚合函数通常和分组一起使用。分组是非常重要的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(`score`) from `student` group by `sex`;</span><br></pre></td></tr></table></figure>

<p>PS： Excel 的数据透视表有同样功能：</p>
<p>插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认</p>
<p>行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和</span><br></pre></td></tr></table></figure>

<p>group by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。</p>
<p><strong>如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `Score` where avg(score)&gt;90 group by `stu_id`; -- 错误</span><br><span class="line">select `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)&gt;90; -- 正确</span><br></pre></td></tr></table></figure>

<p>分组以前的筛选： where, 写在分组后</p>
<p>分组以后的筛选： having, 写在分组后。</p>
<p><em>其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id` from `tb_record` group by `stu_id` having avg(score)&gt;90;</span><br></pre></td></tr></table></figure>

<p><em>也是没有问题的。</em></p>
<p>查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)&gt;90;</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询 (subquery) 的用途：</p>
<ul>
<li>集合成员资格，判断某一元素是否是某一个集合的成员</li>
<li>集合之间的比较，某一个集合是否包含另一个集合等</li>
<li>集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。</li>
</ul>
<p>查询年龄最大的学生的姓名。</p>
<p>可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。</p>
<p>一种方法是嵌套子查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name` from `tb_student` </span><br><span class="line">where `stu_birth` = (</span><br><span class="line">    select min(`stu_birth`) from `tb_student`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @a =(select min(`stu_birth`) from `tb_student`);</span><br><span class="line">select @a; -- 可以查看一下 @a 的值。</span><br></pre></td></tr></table></figure>

<p>如果子查询有很多结果，满足其中一个即可：不能用等号，要用 <strong>in</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `name` from `tb_student` </span><br><span class="line">where `stu_id` in (</span><br><span class="line">    select `stu_id` from `tb_record` group by `stu_id` where count(*)&gt;=2</span><br><span class="line">); -- 查询出所有至少选了2门课的学生姓名</span><br></pre></td></tr></table></figure>

<p>如果用了等号，报错： subquery returns more than 1 row.</p>
<p>标量子查询：结果为一个。可以做&gt; &lt; &#x3D;操作。</p>
<p>列子查询：结果为一列。可以做 IN NOT IN SOME ALL ANY 操作。（ANY SOME 等价）</p>
<p>行子查询：结果为一行。可以做 &#x3D; &lt;&gt; IN NOT IN 操作。</p>
<p>表子查询：结果为多行多列。最常用 IN NOT IN 操作。</p>
<h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><p>一对一，一对多，多对多（两个一对多）</p>
<p>一对一：其中一方设置unique的外键。</p>
<p>一对多：多的一方设置外键。</p>
<p>多对多：建立中间表，设置两个外键。</p>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;</span><br></pre></td></tr></table></figure>

<p>如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。</p>
<p>本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。</p>
<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ol>
<li>有外键约束：利用外键连接，不用加条件，自动连接。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` </span><br><span class="line">from `tb_student` natural join `tb_college`;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。<em>注意：不管有几个同名的列，所有列都会作为连接的条件！</em></li>
<li>如果没有外键也没有同名列，就只会得到笛卡尔积的结果。</li>
</ol>
<h3 id="内-外连接"><a href="#内-外连接" class="headerlink" title="内 &#x2F; 外连接"></a>内 &#x2F; 外连接</h3><p>另一种连接方式是 inner join &#x2F; outer join </p>
<p>或者用 <code>where A.id=B.id</code> ，这种内连接方式叫做隐式内连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` </span><br><span class="line">from `tb_student` inner join `tb_college` </span><br><span class="line">on `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号</span><br></pre></td></tr></table></figure>

<p>inner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。</p>
<p>left outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。</p>
<p>right outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。</p>
<p>full outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。</p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A AS1 inner join A AS2 where 条件;-- 自连接可以是内或外连接。必须起别名！！！</span><br></pre></td></tr></table></figure>

<h3 id="θ-连接"><a href="#θ-连接" class="headerlink" title="θ 连接"></a>θ 连接</h3><p>添加条件使得两个表中的数据相互对应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` </span><br><span class="line">where `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号</span><br></pre></td></tr></table></figure>

<h3 id="三表连接"><a href="#三表连接" class="headerlink" title="三表连接"></a>三表连接</h3><p>链接条件用多个条件筛选。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`</span><br><span class="line">where `tb_course`.`cou_id`=`tb_record`.`cou_id` </span><br><span class="line">and `tb_student`.`stu_id`=`tb_record`.`stu_id`;</span><br><span class="line"></span><br><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`</span><br><span class="line">inner join `tb_record`</span><br><span class="line">on `tb_student`.`stu_id`=`tb_record`.`stu_id`</span><br><span class="line">inner join `tb_course`</span><br><span class="line">on `tb_course`.`cou_id`=`tb_record`.`cou_id`</span><br><span class="line">where `tb_course`.`cou_name` is not null; -- where 写在最后</span><br><span class="line"></span><br><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`</span><br><span class="line">natural join `tb_record`</span><br><span class="line">natural join `tb_course`;</span><br></pre></td></tr></table></figure>

<h2 id="查询小技巧"><a href="#查询小技巧" class="headerlink" title="查询小技巧"></a>查询小技巧</h2><p>百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件</p>
<p>python -推广链接 不想看到广告推送</p>
<p>site:zhihu.com python 只搜索知乎里的 python 内容</p>
<p>2023-01-23 补充：关于信息检索，博主也有开一个新坑：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq/category_12158048.html?spm=1001.2014.3001.5482">信息检索_灰海宽松的博客-CSDN博客</a>。目前更新还不完全，不过对于搜索引擎部分应该足够用了。</p>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>limit 是 mysql 的<strong>方言</strong>。</p>
<p>limit 查询最值有个缺陷，就是只能查出一条。如果有两个最大值就只能显示一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。</span><br><span class="line">select * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)</span><br><span class="line">select * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)</span><br></pre></td></tr></table></figure>

<h2 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h2><p>select 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）</p>
<p>查询学生姓名和平均成绩。</p>
<p>查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？</p>
<p>先通过一个查询，得到一个派生表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `tb_record` group by `stu_id`;</span><br></pre></td></tr></table></figure>

<p>然后把其结果作为一个新表，和学生表做关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`avg(score)`from `tb_student`</span><br><span class="line">natural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思</span><br></pre></td></tr></table></figure>

<p><strong>临时表必须要起别名！！！</strong>不然报错。</p>
<p><strong>注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！</strong>因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，<strong>没选课的学生就不会查出来。</strong></p>
<p>如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。</p>
<h1 id="DQL-例题及注意事项"><a href="#DQL-例题及注意事项" class="headerlink" title="DQL 例题及注意事项"></a>DQL 例题及注意事项</h1><h2 id="简单排序——查询最大值、次大只"><a href="#简单排序——查询最大值、次大只" class="headerlink" title="简单排序——查询最大值、次大只"></a>简单排序——查询最大值、次大只</h2><ol>
<li><p>员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。</p>
<p>做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。</p>
<p>做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。</p>
<p>做法③：查询一名没有人薪水比他大的员工（即：薪水大于这名员工的员工数&#x3D;0）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` t1 where(</span><br><span class="line">    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`</span><br><span class="line">)=0;-- 结尾改成1，就是工资第二高的人</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询除了 boss 外工资最高的人。</p>
<p>在题1的基础上，用 where 排除掉 boss。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` </span><br><span class="line">where `salary`=(</span><br><span class="line">    select max(salary) from `tb_employee` where `position`&lt;&gt;&#x27;boss&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询月薪 top 3的人。</p>
<p>这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` t1 where(</span><br><span class="line">    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`</span><br><span class="line">)&lt;3 order by `salary` desc;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。</p>
<p>题目很简单，但是<strong>遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。</strong>要用 ifnull() 或 coalesce() 函数限制一下。</p>
</li>
<li><p>查询所有部门名称及员工人数。</p>
<p>部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。<strong>重点注意几种连接的不同，思考一下题中哪个信息要全部展示出来。</strong>比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dname,total from `tb_department` t1</span><br><span class="line">left join (</span><br><span class="line">    select dname, count(*) as total from `tb_department` t2 group by `dno`</span><br><span class="line">) on t1.`stu_id`=t2.`stu_id`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious</p>
<p>先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sname,salary from `tb_employee` t1</span><br><span class="line">inner join (</span><br><span class="line">	select avg(salary),dno from `tb_employee` group by dno;</span><br><span class="line">)t2 on t1.dno=t2.dno and t1.salary &gt; t2.avg(salary);-- 两个连表条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。</p>
<p>派生表通过薪水值、部门号和员工表、部门表相连接。</p>
</li>
<li><p>查询薪水排名4-6员工的薪水、姓名、<strong>排名</strong>。</p>
<p>问题1：怎么查出排名？</p>
<p>问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5</p>
<p>解决：mysql 8的窗口函数可以解决排名 &#x2F; top N 问题。</p>
<p>①不用窗口函数：</p>
<p>系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：<code>set @a=0;</code>或<code>select@a:=0;</code>而且变量也可以通过 as 起别名。</p>
<p>我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set @a=0;</span><br><span class="line">select row_num,ename,salary from (</span><br><span class="line">	select @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0</span><br><span class="line">    from `tb_employee` order by salary desc</span><br><span class="line">) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次</span><br></pre></td></tr></table></figure>

<p>注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.</p>
<p>另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。</p>
</li>
<li><p>查询每个部门薪水排名前两名的员工。</p>
<p>Top N 问题通过题1的做法③解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select eno,ename,salary,dno from `tb_employee` t1</span><br><span class="line">where (</span><br><span class="line">	select count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary&gt;t1.salary</span><br><span class="line">)&lt;2 order by t1.dno asc, t1.salary desc;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>内容来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92654574">通俗易懂的学会：SQL 窗口函数 - 知乎</a></p>
<p>应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by</p>
<p>窗口函数不光是函数，有一套完整的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;</span><br><span class="line">                order by &lt;用于排序的列名&gt;)</span><br></pre></td></tr></table></figure>

<p>&lt;窗口函数&gt; 处放聚合函数或专用窗口函数。</p>
<p>窗口函数是以一个列的形式使用的。</p>
<h3 id="专用窗口函数"><a href="#专用窗口函数" class="headerlink" title="专用窗口函数"></a>专用窗口函数</h3><p>rank、dese rank、row_number</p>
<p>看图即知区别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212341896.png" alt="img"></p>
<h3 id="partition-by-和-group-by-的区别"><a href="#partition-by-和-group-by-的区别" class="headerlink" title="partition by 和 group by 的区别"></a>partition by 和 group by 的区别</h3><p>partition by 是把所有数据分成绩一个窗口，而并不汇总。比如上图中，如果按班级号分窗口再进行排序，就会在每个班级内部从1到无穷排序。不写的话就默认整个表是一个大窗口。</p>
<p>group by 是分组后汇总。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212341737.png" alt="img"></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`sal`,</span><br><span class="line">rank() over (order by `sal` desc)as `r1`,</span><br><span class="line">dense_rank() over (order by `sal` desc)as `r2`,</span><br><span class="line">row_number() over (order by `sal` desc)as `r3`</span><br><span class="line">from `tb_emp`;</span><br></pre></td></tr></table></figure>

<p>第八题窗口函数做法：加一个 where r between 4 and 6 的条件。</p>
<p>第九题窗口函数做法：因为产生了分组，因此不能直接用 where r &lt;&#x3D;2。但是<strong>窗口函数的分窗口后的列做筛选，既不能直接用 where 也不能用 having</strong>。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`sal`,`dno`</span><br><span class="line">from(</span><br><span class="line">    select `ename`,`sal`,`dno`,</span><br><span class="line">    rank() over (partition by `dno` order by `sal` desc)as `r`</span><br><span class="line">    from `tb_emp`</span><br><span class="line">) `temp` where `r`&lt;=2;-- 不能在派生表里直接筛选</span><br></pre></td></tr></table></figure>

<p><em>窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。</em></p>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p>Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。主要是 DBA 使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问。域名如 localhost，%代表任意路径</span><br><span class="line">alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified with mysql_native_password by &#x27;新密码&#x27;;-- with mysql_native_password 是 mysql 的修改方式</span><br><span class="line">drop user &#x27;人名&#x27;@&#x27;域名&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。</p>
<p>查看权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>授权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 权限 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>数据库名和表名可以用通配符 * 代替。</p>
<p>权限包括： all (privileges), select, insert, update, delete, alter, drop, create</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改</span><br><span class="line">grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;</span><br><span class="line">grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限</span><br><span class="line">grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人</span><br></pre></td></tr></table></figure>

<p>召回权限：revoke</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限 数据库名.表名 from &#x27;人名&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p>添加权限之后最好 Reconnect 刷新一下。或者执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>Workbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。</p>
<p>至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>很多内容其实在 DQL 早就介绍过。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(s1, s2, sn)</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>转小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>转大写</td>
</tr>
<tr>
<td>LPAD(str, n, pad)</td>
<td>用 pad 对 str 左边n个字符长度进行填充</td>
</tr>
<tr>
<td>RPAD(str, n, pad)</td>
<td>用 pad 对 str 右边n个字符长度进行填充</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉头尾的空格</td>
</tr>
<tr>
<td>SUBSTRING(str, start, len)</td>
<td>返回 str 从指定位置 start 开始 len 长度的子字符串（从0开始）</td>
</tr>
</tbody></table>
<p>如：所有员工的工号都必须是五位数，不足的话在左端补0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名 = lpad(字段名,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>rand()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>round(x,y)</td>
<td>返回x四舍五入值，保留y位小数</td>
</tr>
</tbody></table>
<p>例：生成6位验证码。</p>
<p>首先靠随机数生成，然后*1000000并四舍五入，然后还要考虑开头为0的情况，因此不足六位补0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select lpad(round(rand()*1000000,0),6,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>curdate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>curtime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>year(date)</td>
<td></td>
</tr>
<tr>
<td>month(date)</td>
<td></td>
</tr>
<tr>
<td>day(date)</td>
<td></td>
</tr>
<tr>
<td>date_add(date, interval expr type)</td>
<td>date 加时间间隔 expr，可以是年月日时间，如<code>interval 70 day</code></td>
</tr>
<tr>
<td>datediff(date1, date2)</td>
<td>求两个日期相差天数</td>
</tr>
</tbody></table>
<h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>if(value, t, f)</td>
<td>true 返回t， false 返回f</td>
</tr>
<tr>
<td>ifnull(value1, value2)</td>
<td>value1 为 null 返回 value1，空返回 value2</td>
</tr>
<tr>
<td>case when val1 then res1 else default end</td>
<td>switch case</td>
</tr>
<tr>
<td>case expr when val1 then res1 else default end</td>
<td>表达式形式的 switch case</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(case workaddress </span><br><span class="line"> when &#x27;北京&#x27; then &#x27;一线城市&#x27; </span><br><span class="line"> when &#x27;上海&#x27; then &#x27;一线城市&#x27; </span><br><span class="line"> else &#x27;二线城市&#x27; </span><br><span class="line"> end) as &#x27;工作地&#x27;;</span><br><span class="line"> </span><br><span class="line">(case score </span><br><span class="line"> when score=100 then &#x27;满分&#x27; </span><br><span class="line"> when score&gt;=90 then &#x27;优秀&#x27; </span><br><span class="line"> else &#x27;懒得写了&#x27; </span><br><span class="line"> end) as &#x27;成绩所在段&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组不可分割的操作集合，要么都成功执行，要么都失败。如银行账户数据库操作，一个人给另一个人转账1000元，那么这两个人的update操作就是不可分割的，不然如果有一个操作成功执行另一个没有，就可能银行平白无故少了1000或者收款人没收到钱。</p>
<p>事务的步骤：</p>
<ol>
<li>开启事务</li>
<li>执行一条条操作。这期间如果有失败则事务回滚。或者手动进行事务回滚。</li>
<li>全部执行完后提交事务。默认mysql是自动提交事务的，每执行一条语句就会提交一条。</li>
</ol>
<h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@autocommit;-- 1：自动提交；0：手动提交</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set @@autocommit=0;-- 开启手动提交</span><br><span class="line"></span><br><span class="line">rollback;-- 回滚</span><br><span class="line"></span><br><span class="line">commit;-- 提交</span><br></pre></td></tr></table></figure>

<p>或者在<code>@@autocommit=1</code>时临时开启事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction;-- 开启事务</span><br></pre></td></tr></table></figure>

<h2 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性 ACID"></a>事务四大特性 ACID</h2><p>atomicity 原子性：事务是不可分割的最小操作单元。</p>
<p>consistency 一致性：所有数据保持一致状态。</p>
<p>isolation 隔离性：事务不受外部干扰，独立进行。</p>
<p>durability 持久性：提交或回滚后，事务对数据库的操作就是永久的。</p>
<h2 id="并发事务问题及解决办法"><a href="#并发事务问题及解决办法" class="headerlink" title="并发事务问题及解决办法"></a>并发事务问题及解决办法</h2><p>多个事务同时进行时会出现的问题。</p>
<p>以下是数据库事务可以设置的几种隔离级别，分别是应对不同问题用的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212342656.png" alt="image-20220801231316895"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@TRANSACTION_ISOLATION;-- 查看数据库隔离级别</span><br><span class="line">set session/global TRANSACTION ISOLATION LEVEL SERIALIZABLE;-- 设置当前会话/全局事务隔离级别为serializable</span><br></pre></td></tr></table></figure>

<p>read uncommitted 是数据库最低隔离级别，即：一个事务中的数据还未提交别的事务就可以读得到。</p>
<p><strong>问题1</strong>：脏读：一个事务读到另一个事务未提交的数据（Read uncommitted会发生）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212342398.png" alt="image-20220802212804661"></p>
<p><strong>解决办法</strong>：read committed 限制一个事务修改的数据要等到提交后别的数据才能读得到。解决了脏读问题，但是没有解决不可重复读问题，事务2第一次读和第二次读数据可能值不一样。</p>
<p>解决后：（给要读取的左边的窗口设置 read-committed 隔离级别）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212342155.png" alt="image-20220802212544087"></p>
<p><strong>问题2</strong>：不可重复读：一个事务前后读了同一个数据两次，两次值不一样。因为其他事务在这中间提交过一次。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212342998.png" alt="image-20220802213646432"></p>
<p><strong>解决办法</strong>：repeatable 使得事务2开启后事务1才提交的数据事务2读取不到，避免了不可重复读的问题。但是没有解决串行化问题，即事务2再对数据的修改会覆盖事务1的修改。</p>
<p><strong>问题3</strong>：幻读：每个事务开启时把数据读入缓存内，这样重复读取的时候直接从缓存中读取，避免了重复读取数据不一样。但是数据不及时更新，比如事务1删库了，事务2还能读；或者事务1新增了一条主键为i的数据提交了，事务2随后也想新增一条主键为i的数据，提交的时候发现1已经写过了，交不进去了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212342557.png" alt="image-20220802221507795"></p>
<p><strong>解决办法</strong>：serializable 让事务1在操作当前数据库时，别的事务直接操作不了。</p>
<p><strong>问题4</strong>：开启序列化后，其他事务插入会卡住，等待当前事务插入完成后再执行插入操作。会导致用户体验差，需要等待。所以序列化等级还是很少使用的。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：Java Wordle"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AJava%20Wordle/"
    >北邮国院项目：Java Wordle</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AJava%20Wordle/" class="article-date">
  <time datetime="2022-07-19T23:00:00.000Z" itemprop="datePublished">2022-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Wordle-游戏介绍"><a href="#Wordle-游戏介绍" class="headerlink" title="Wordle 游戏介绍"></a>Wordle 游戏介绍</h1><blockquote>
<p>Wordle的游戏规则很简单，玩家需要猜出程序每天指定的一个5位英语单词谜底。</p>
<p>玩家可以随意提交一个英语单词，但必须是字典里有的，不能胡乱拼写。</p>
<p>如果字母在谜底中出现且位置对了就显示绿色，字母出现了但位置不对就显示黄色，字母在答案的单词中没出现就显示灰色。</p>
<p>根据反馈信息再进行下一轮猜测，在6次尝试之内猜出就算赢。<br>来源：<a target="_blank" rel="noopener" href="https://news.mydrivers.com/1/813/813695.htm#:~:text=Wordle%E7%9A%84%E6%B8%B8,%E4%BD%8D%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%B0%9C%E5%BA%95%E3%80%82">https://news.mydrivers.com/1/813/813695.htm#:~:text=Wordle%E7%9A%84%E6%B8%B8,%E4%BD%8D%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%B0%9C%E5%BA%95%E3%80%82</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/494e131e4b2641d48becd4aef3f90c7d.png" alt="在这里插入图片描述"></p>
<h1 id="成果图示"><a href="#成果图示" class="headerlink" title="成果图示"></a>成果图示</h1><p>博主大二期间学习的java课程大作业，就是写一款 wordle 游戏，主要考察 GUI 界面的开发。<br>最终成果图示：<br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/008abdff020b4e05bc56265450bc7442.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1840388526344189a27121987da22d47.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/74f2dd38063349298b84d23cafb28db2.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e9aacefcb2984adf913ea8c80fee24ff.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/07e7dd5c4a4348afb35cfc7cc009ca88.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/f163f8a63ff14878b74691ba432fd882.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/de75c6c50c9b45a3bbd2c58f95104217.png" alt="在这里插入图片描述"></p>
<h1 id="玩法介绍"><a href="#玩法介绍" class="headerlink" title="玩法介绍"></a>玩法介绍</h1><p>点击HELP 查看帮助，点击 START 开始游戏。<br>本游戏中没有虚拟键盘，输入框也不能获取鼠标焦点，只能通过键盘键入字母，回车检查答案。<br>敲下回车后，字母就会呈现灰色、黄色、绿色三种状态，并换到下一行开始下一次猜单词机会。当猜中答案或六轮游戏结束时，弹出小窗，提示用户游戏胜利&#x2F;失败。<br>注意：</p>
<ol>
<li>检查用户输入。本游戏中用户只能输入字母，当用户试图键入数字或符号时会提示只能输入字母。当用户输入不足5位就尝试检查，或尝试输入超出5位时会提示输入必须为5位字母。当用户输入非单词尝试检查会提示输入必须为词库中存在的单词（词库：words.txt，可以自己更新）</li>
<li>一些小的注意点。当用户输入中有两个e，都不在正确的位置上，那这两个e只有一个会显示黄色就够了，另一个显示灰色，否则会影响用户的判断。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Java_Wordle_Game">Java_Wordle_Game github下载地址</a><br>README：帮助信息<br>javadoc：生成的 javadoc<br>Test：测试图片及说明<br>words.txt：词库</p>
<p>运行方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>
<p>在此感谢老师同学对此项目的帮助指导！<br>欢迎大家star支持[Doge]有问题也可以与博主交流~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：MySQL 数据库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93/"
    >北邮国院笔记：MySQL 数据库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2022-07-19T23:00:00.000Z" itemprop="datePublished">2022-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本博客学习自：黑马程序员 mysql 入门网课，b站 骆昊jackfrued 老师 mysql 网课，以及博主自己课内学习的数据库课程，侵删！</p>
<p>课内学习的课程内容因为是英方课，包括一些不常用的概念和英文，更注重整体框架的理解，大致了解即可。</p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>MYSQL 的安装配置网上一搜一大把，博主就不在此发表拙见了，安装太久了自己也记不是很清具体方法了。这里指跟随课程学习了 Command Line Client 的安装（说实话，这玩意我自认为没啥用）。</p>
<p>Mysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。</p>
<p>如果选择的是 zip 下载，应该只会安装一个 mysql 文件包，在程序终端可以使用。</p>
<p>如果是选择 msi 文件安装，MYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。</p>
<p>由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。</p>
<p>开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，区别只是其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\h, ?, ?</td>
<td>获取帮助</td>
</tr>
<tr>
<td>\c</td>
<td>清除前面输入的内容（内容输入有误时使用）</td>
</tr>
<tr>
<td>\R</td>
<td>修改 每次输入命令前左侧的提示样式（默认：’mysql&gt;’）</td>
</tr>
<tr>
<td>? 需要查看帮助的命令;</td>
<td>显示该命令的帮助（如：? show）</td>
</tr>
<tr>
<td>show databases; show databases();</td>
<td>查看所有数据库，查看当前所在数据库</td>
</tr>
<tr>
<td>use ‘数据库名’;</td>
<td>选中某个数据库</td>
</tr>
<tr>
<td>（选中某个数据库后）show tables;</td>
<td>查看当前数据库中所有表</td>
</tr>
<tr>
<td>exit &#x2F; quit</td>
<td>退出</td>
</tr>
</tbody></table>
<h1 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h1><p>数据库有很多种结构，mysql 学习的是关系型数据库，说白了就是二维表的结构。</p>
<pre class="mermaid">graph LR
R[关系型数据库]-->T[理论基础]
R-->S[具体表象]
R-->L[编程语言 SQL]
T-->A[关系代数]
T-->C[关系运算]
T-->P[一阶谓词逻辑]
S-->Ta[二维表]
L-->D[DDL]
L-->M[DML]
L-->Q[DQL]
L-->DCL[DCL]</pre>

<p>DDL: create &#x2F; drop &#x2F; alter （database 或 schema 数据库名 &#x2F; table 表名）</p>
<p>DML: insert &#x2F; update &#x2F; delete</p>
<p>DQL: select …… from</p>
<p>DCL: grant（授权） &#x2F; revoke（召回权限）</p>
<table>
<thead>
<tr>
<th>正式的关系模型术语</th>
<th>非正式的日常用语</th>
</tr>
</thead>
<tbody><tr>
<td>关系（relation）</td>
<td>表（table）</td>
</tr>
<tr>
<td>元组（tuple）记录</td>
<td>行（row）或记录（record）</td>
</tr>
<tr>
<td>势（cardinality）</td>
<td>行数（number of rows）</td>
</tr>
<tr>
<td>属性（attribute）</td>
<td>列（column）或字段（field）</td>
</tr>
<tr>
<td>度（degree）</td>
<td>列数（number of columns）</td>
</tr>
<tr>
<td>定义域（domain）</td>
<td>列的取值集合（pool of legal values）</td>
</tr>
</tbody></table>
<h1 id="ER-和-EER-模型"><a href="#ER-和-EER-模型" class="headerlink" title="ER 和 EER 模型"></a>ER 和 EER 模型</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为什么要有 ER 图和 EER 图的存在？</p>
<p><strong>真正做项目、设计数据库时，</strong>实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR &#x2F; json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）<strong>是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。</strong></p>
<h3 id="ER-模型"><a href="#ER-模型" class="headerlink" title="ER 模型"></a>ER 模型</h3><p>ER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336311.png" alt="百度百科图片"></p>
<p>相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。</p>
<h3 id="EER-模型"><a href="#EER-模型" class="headerlink" title="EER 模型"></a>EER 模型</h3><p>以下部分内容有参考自文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356216273">为了彻底搞清楚数据库 E-R 模型设计，我肝了这篇万字长文 - 知乎 (zhihu.com)</a></p>
<p>关于两者的具体区分我还有去问b站up主 骆昊jackfrued 老师，老师表示：不用太纠结这个问题，ER图更抽象，可以理解为概念模型图（PowerDesigner）。</p>
<p>相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。</p>
<h4 id="泛化层次"><a href="#泛化层次" class="headerlink" title="泛化层次"></a>泛化层次</h4><p>包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。</p>
<p><strong>子类父类</strong>就是类似 Java 的继承，如动物是父类，猫、狗是其子类。<strong>子类父类是一对一的关系！</strong></p>
<p><strong>泛化</strong>又叫归纳，就是将几个类的共同属性提取出来作为父类；</p>
<p><strong>特化</strong>又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。</p>
<p>其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。</p>
<p><strong>mandatory &#x2F; optional</strong>：父类中的所有属性都必须包含在每一个子类中 &#x2F; 不用全部继承，选择部分继承即可（完全性限制）</p>
<p><strong>disjoint &#x2F; overlapping</strong>：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336748.png" alt="img"></p>
<p>图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D &#x2F; O，表示 disjoint &#x2F; overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。</p>
<h4 id="汇集层次"><a href="#汇集层次" class="headerlink" title="汇集层次"></a>汇集层次</h4><p>Aggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336896.png" alt="img"></p>
<p>如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。</p>
<h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336013.png" alt="img"></p>
<p>Workbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336256.png" alt="EER 图示例"></p>
<p>在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。</p>
<p><em>自动生成的 SQL 语句中，外键下方有两句话<code>ON DELETE NO ACTION</code> <code>ON UPDATE NO ACTION</code>，意为：当外键参考的主键修改&#x2F;删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改&#x2F;删除外键在使用的主键。</em></p>
<p>同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。</p>
<p><em>Power Designer 建模工具，也支持正 &#x2F; 反向工程，可以生成 SQL 方言。完整版付费。</em></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型可以通过 <code>? data types</code> 查看说明，每种数据类型也可以通过 <code>? 数据类型</code> 查看。</p>
<p><em>除了data types 其他可以用?查看的内容可以输入 <code>? contents</code> 查看。</em></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>整数 (tinyint, smallint, mediumint, int, bigint)</td>
<td>都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）</td>
</tr>
<tr>
<td>字符串 (char(位数), varchar(位数), text)</td>
<td>char 长度固定，varchar 长度可变</td>
</tr>
<tr>
<td>小数 (float, double, decimal(总位数, 小数点后位数))</td>
<td>不要用 float, double！</td>
</tr>
<tr>
<td>时间日期 (year, date, time, datetime, timestamp)</td>
<td>date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数</td>
</tr>
<tr>
<td>Mysql 中的枚举类型 (enum, boolean)</td>
<td></td>
</tr>
</tbody></table>
<p>PS: </p>
<ol>
<li><p>虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。</p>
</li>
<li><p>金额等小数一般不会用小数的数据类型存储，而是整数类型&#x2F;100使用。因为小数形式有误差，比如0.1+0.2&#x3D;0.30000000004.</p>
</li>
<li><p>decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。</p>
</li>
<li><p>时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。</p>
</li>
</ol>
<p>这里了解到了一个很有趣的“千年虫”问题 (<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/305603895">漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)</a>)。</p>
<blockquote>
<p>Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。</p>
<p>早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022&#x2F;04&#x2F;19，就是22&#x2F;04&#x2F;19）</p>
<p>尽管节约了内存空间，但是40年后1999-&gt;2000年时，问题就出现了……对计算机来说，相当于99-&gt;00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。</p>
<p>如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：</p>
<p>1.只修改核心关键的医疗、航空、金融、军事领域的程序；<br>2.对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。</p>
</blockquote>
<p>回到刚才的话题，因此时间戳也并不推荐使用。</p>
<p>5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符</p>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><table>
<thead>
<tr>
<th>SQL 语句</th>
<th>作用</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建数据库 &#x2F; 表</td>
<td>create database `数据库名`; &#x2F; create table `表名` ( 字段描述 );</td>
</tr>
<tr>
<td>drop</td>
<td>删除数据库 &#x2F; 表</td>
<td>drop database `数据库名`; &#x2F; drop table `表名`;</td>
</tr>
<tr>
<td>use</td>
<td>选中数据库</td>
<td>use `数据库名`;</td>
</tr>
<tr>
<td>alter</td>
<td>更改数据库 &#x2F; 表信息</td>
<td>alter table `表名` add constraint `约束名` unique (`字段名`);</td>
</tr>
</tbody></table>
<p>PS： </p>
<p>修改表的引擎 &#x2F; 更改自增约束初始值是在 create table `表名` () 后面添加的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table `表名`(</span><br><span class="line"></span><br><span class="line">)engine = innodb auto_increment=2 comment &#x27;表示例&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary key (`列名`),</span><br></pre></td></tr></table></figure>

<p><em>复合主键语法上没错，但是开发使用时非常不好用，因为需要至少两条字段才能唯一确定一条记录。一般不会用。</em></p>
<p><em>如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。</em></p>
<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p><code>default val;</code> 设置默认值。</p>
<h3 id="自增约束、非空约束"><a href="#自增约束、非空约束" class="headerlink" title="自增约束、非空约束"></a>自增约束、非空约束</h3><p>都在字段描述后面写即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`col_name` int auto_increment not null comment &#x27;列名&#x27;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建表时：</span><br><span class="line">create table(</span><br><span class="line">    id int primary key comment &#x27;id&#x27;;</span><br><span class="line">	age int check (age&gt;=0 &amp;&amp; age&lt;=100) comment &#x27;年龄&#x27;,</span><br><span class="line">	gender char(1) default &#x27;m&#x27; comment &#x27;性别&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改表时，主键，unique，check，外键用 add，其他用 modify</span><br><span class="line">alter table add primary key(列名);</span><br><span class="line">alter  table table_name modify 列名 数据类型  not null;# 如果是 null，就是取消非空约束</span><br></pre></td></tr></table></figure>

<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint `uk_col_name` unique (`col_name`),</span><br></pre></td></tr></table></figure>

<p>类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint `ck_col_sex` check (`col_sex`=&#x27;M&#x27; or `col_sex`=&#x27;F&#x27;),</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。</p>
<p>外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 外键需要先创建一个字段，然后给这个字段添加外键。原外键的字段和新的要添加外键的字段数据类型要一样。</span><br><span class="line">alter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段);</span><br><span class="line"></span><br><span class="line">alter table 表名 drop foreign key 外键名;</span><br></pre></td></tr></table></figure>

<p><em>一对多时，多的一方需要加外键约束。</em></p>
<p>之后子表引用了父表，父表被引用的记录就不能随便删除了。子表也不能随便写外键的值，必须要在父表中存在才可以引用。</p>
<table>
<thead>
<tr>
<th>外键删除更新行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no action&#x2F;restrict</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则不删除&#x2F;更新</td>
</tr>
<tr>
<td>cascade</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录也删除&#x2F;更新</td>
</tr>
<tr>
<td>set null</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录对应字段设为空值（前提：该字段可以为 null）</td>
</tr>
<tr>
<td>set default</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录也删除&#x2F;更新对应字段设为默认值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段) on update cascade on delete cascade;</span><br></pre></td></tr></table></figure>

<h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行</span><br><span class="line">insert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的</span><br></pre></td></tr></table></figure>

<p>注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 <code>default</code> ，不然系统也难以分辨哪一项使用默认值。</p>
<p><em>日期可以写字符串 2002-01-01，会自动转换</em></p>
<p>插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。</p>
<p><strong>如果主键、unique 的记录重复会报错。</strong>报错显示： <code>duplicate key for key &#39;定义的约束键名称&#39;</code></p>
<p><strong>填写了规定的 check 以外的内容会报错。</strong>报错显示：<code>check constraint &#39;定义的约束键名称&#39; is violated.</code> 不过字符串不区分大小写，规定性别只能填 ‘F’ ‘M’ 的话，填 ‘f’ ‘m’ 也行。</p>
<p><strong>如果对应的外键在原表中没有对应的记录会报错。</strong> 报错显示：<code>cannot add or update a child row: a foreign constraint fails</code> 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。</p>
<p><strong>如果没有给 NOT NULL且没有默认值的字段赋值时会报错。</strong> 报错显示：<code>Field &#39;字段名&#39; doesn&#39;t have a default value.</code> 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete from `表名`;//这可不兴用啊！</span><br><span class="line">delete from `表名` where `字段名`=&#x27;要删除的记录的对应字段值&#x27;;//不等于可以用&lt;&gt;，有的 DBMS 支持!=</span><br><span class="line">delete from `表名` where `字段名` = &#x27;字段值&#x27; or `字段名` = &#x27;字段值&#x27;;//根据多个条件删除语句</span><br><span class="line">delete from `表名` where `字段名` in (&#x27;字段值&#x27;,&#x27;字段值&#x27;);//删除多条语句</span><br></pre></td></tr></table></figure>

<p>但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： <code>Cannot delete or update a parent row</code> 。</p>
<p>删除了外键约束之后就可以随意修改两个表对应的值而不报错了。</p>
<p>另一种删除表的方式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table `表名`;</span><br></pre></td></tr></table></figure>

<p>截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update `表名` set `列名` = &#x27;值&#x27;;//把这一列的数据全都改成这个值，不常用</span><br><span class="line">update `表名` set `列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27; where `字段`=&#x27;值&#x27;;//限制条件，只修改某几个记录</span><br></pre></td></tr></table></figure>

<h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><p>学习自b站骆昊jackfrued 老师的网课以及黑马网课。</p>
<p>查询语句。</p>
<p><em>本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）</em></p>
<p><em>tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）</em></p>
<h2 id="编写顺序、执行顺序"><a href="#编写顺序、执行顺序" class="headerlink" title="编写顺序、执行顺序"></a>编写顺序、执行顺序</h2><p>编写顺序如下：<code>select from where group by having order by limit;</code></p>
<p>执行顺序：</p>
<ol>
<li><p>from 表名</p>
</li>
<li><p>where 条件（where 可以用表别名，但是不能用 select 中的字段别名）</p>
</li>
<li><p>group by 分组</p>
</li>
<li><p>having 分组条件</p>
</li>
<li><p>select 投影</p>
</li>
<li><p>order by 排序</p>
</li>
<li><p>limit 分页</p>
</li>
</ol>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>查询所有学生的所有信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `表名`;-- * 号表示所有字段</span><br></pre></td></tr></table></figure>

<p>但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。</p>
<p>实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;</span><br></pre></td></tr></table></figure>

<p>如果只查询部分列，就只写那几列就行。</p>
<h2 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合 Union"></a>联合 Union</h2><p>Union 会把查询结果联合起来。</p>
<p>union all：结果可能重复。</p>
<p>union：重复的结果合并。</p>
<p><strong>想做union操作，两个要联合的表必须字段数相同，字段类型匹配。</strong></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>给字段或表起别名—— alias，简写为 as。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id` as `学号` from `tb_student`;</span><br></pre></td></tr></table></figure>

<p>as 可以省略，不过还是写上可读性高一些。<em><strong>一般字段不省略，表省略</strong>。具体还得看公司编程规范的要求，没有就看个人喜好了。</em></p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>限制查询记录的条件——where（选择 Selection，只查询某几行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_sex`=&#x27;M&#x27; or `stu_name`=&#x27;Jingqing&#x27;;</span><br></pre></td></tr></table></figure>

<p>多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。</p>
<p><em>性能问题，一般不用 or 而使用 union，结果取并集。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_sex`=&#x27;M&#x27; </span><br><span class="line">union</span><br><span class="line">select * from table where `stu_name`=&#x27;Jingqing&#x27;;</span><br></pre></td></tr></table></figure>

<p><em><strong>如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。</strong></em></p>
<p>类似 10&lt;x&lt;30 的形式不可以直接写两个等式，要拆成 x&gt;10 and x&lt;30 。</p>
<p>这里的字段如果是数字类型的，也可以进行 + - * &#x2F; % mod（也是取余）以及 &lt; &gt;  &#x3D; &gt;&#x3D; &lt;&#x3D; &lt;&gt; 等形式的运算。</p>
<p>还有一种条件写法是 <code>between …… and ……</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_age` between 10 and 30;-- 相当于 &lt;=30 and &gt;=10</span><br></pre></td></tr></table></figure>

<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select if(`stu_sex`,&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;性别&#x27; from `tb_student`;-- 有点类似三目运算符 ?:</span><br></pre></td></tr></table></figure>

<p>if 中第一项可以是表达式，如 age &gt; 10.</p>
<p><strong>这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。</strong>比如 Oracle 数据库中对应的函数是 decode，不能通用。</p>
<p>通用的分支结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select case `sex` </span><br><span class="line">when 1 then &#x27;男&#x27; </span><br><span class="line">elseif 0 then &#x27;女&#x27; </span><br><span class="line">else &#x27;未知&#x27;</span><br><span class="line">end as &#x27;性别&#x27; from `tb_student`;-- end 表示条件判断结束</span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>如：查询所有姓王的学生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_name` like &#x27;王%&#x27;;-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生</span><br><span class="line">select * from `student` where `stu_name` like &#x27;王_&#x27;;-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生</span><br></pre></td></tr></table></figure>

<p>这里和正则表达式有一定联系，之后会单独学习。</p>
<p>2023-01-23 补档：我后来确实学习了正则表达式~学习笔记在这里：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq/category_11807727.html?spm=1001.2014.3001.5482">Regex_灰海宽松的博客-CSDN博客</a></p>
<p>事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `字段名` regexp &#x27;正则表达式&#x27;;</span><br></pre></td></tr></table></figure>

<p>模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。</p>
<h2 id="空值处理，以及三值逻辑"><a href="#空值处理，以及三值逻辑" class="headerlink" title="空值处理，以及三值逻辑"></a>空值处理，以及三值逻辑</h2><p><strong>下面两种写法是错误的！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_address` = null;</span><br><span class="line">select * from `student` where `stu_address` &lt;&gt; null;</span><br></pre></td></tr></table></figure>

<p>因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。</p>
<p>正确做法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_address` is null;</span><br><span class="line">select * from `student` where `stu_address` is not null;</span><br></pre></td></tr></table></figure>

<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct `字段名` from `表名`;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序</span><br></pre></td></tr></table></figure>

<p>order by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。</p>
<h2 id="当前日期"><a href="#当前日期" class="headerlink" title="当前日期"></a>当前日期</h2><p>curdate()获取当前日期，使用 datediff(datepart, date1, date2) 函数可以和出生日期做差获取年龄。</p>
<p>now()获取当前年月日时分秒（datetime）。</p>
<h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p>floor() 函数是下取整。floor(3.99) &#x3D; 3.</p>
<p>ceil() 函数是向上取整，ceil(3.1) &#x3D; 4.</p>
<p>round() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)&#x3D;4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(datediff(curdate(),`date`)/365) from `staff`;</span><br></pre></td></tr></table></figure>

<p><em>可以通过? functions 查看函数一览。还会有相应的例子提示~</em></p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>描述性统计信息：包括集中趋势和离散趋势。</p>
<p>集中趋势：平均值，中位数等。</p>
<p>离散趋势：方差，标准差等。</p>
<p>聚合函数属于 SQL 语句，所有 DBMS 都能用。</p>
<ul>
<li><p>min(字段名)</p>
</li>
<li><p>max(字段名)</p>
</li>
<li><p>avg(字段名) <em>做计算的时候会忽略 null 值</em></p>
</li>
<li><p>sum(字段名)</p>
</li>
<li><p>count(字段名) <em>做计算的时候会忽略 null 值</em></p>
<p><em><strong>如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。</strong></em></p>
<p><em>比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) &#x2F; count(stu_id) 就是错误的，因为是9个人的成绩 &#x2F; 10.</em> </p>
<p><em>如果成绩为空的学生视为 &#x3D; 0，就要用 sum(score) &#x2F; count(stu_id)，或者对 avg() 函数做如下处理：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(ifnull(`score`,0)) from student;-- 如果第一个表达式!=null，则返回第一个表达式</span><br></pre></td></tr></table></figure>

<p><em>ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。</em></p>
<p>coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。</p>
</li>
<li><p>std(字段名)，计算标准差，越小说明越稳定。</p>
<ul>
<li>std(), stddev() 和 stddev_pop()：所有数据总体的标准差</li>
<li>stddev_samp()：样本标准差，抽样计算。</li>
</ul>
</li>
<li><p>variance(字段名)，计算方差，标准差的平方。</p>
<ul>
<li>variance(), var_pop()</li>
<li>var_samp()</li>
</ul>
</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>聚合函数通常和分组一起使用。分组是非常重要的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(`score`) from `student` group by `sex`;</span><br></pre></td></tr></table></figure>

<p>PS： Excel 的数据透视表有同样功能：</p>
<p>插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认</p>
<p>行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和</span><br></pre></td></tr></table></figure>

<p>group by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。</p>
<p><strong>如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `Score` where avg(score)&gt;90 group by `stu_id`; -- 错误</span><br><span class="line">select `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)&gt;90; -- 正确</span><br></pre></td></tr></table></figure>

<p>分组以前的筛选： where, 写在分组后</p>
<p>分组以后的筛选： having, 写在分组后。</p>
<p><em>其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id` from `tb_record` group by `stu_id` having avg(score)&gt;90;</span><br></pre></td></tr></table></figure>

<p><em>也是没有问题的。</em></p>
<p>查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)&gt;90;</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询 (subquery) 的用途：</p>
<ul>
<li>集合成员资格，判断某一元素是否是某一个集合的成员</li>
<li>集合之间的比较，某一个集合是否包含另一个集合等</li>
<li>集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。</li>
</ul>
<p>查询年龄最大的学生的姓名。</p>
<p>可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。</p>
<p>一种方法是嵌套子查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name` from `tb_student` </span><br><span class="line">where `stu_birth` = (</span><br><span class="line">    select min(`stu_birth`) from `tb_student`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @a =(select min(`stu_birth`) from `tb_student`);</span><br><span class="line">select @a; -- 可以查看一下 @a 的值。</span><br></pre></td></tr></table></figure>

<p>如果子查询有很多结果，满足其中一个即可：不能用等号，要用 <strong>in</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `name` from `tb_student` </span><br><span class="line">where `stu_id` in (</span><br><span class="line">    select `stu_id` from `tb_record` group by `stu_id` where count(*)&gt;=2</span><br><span class="line">); -- 查询出所有至少选了2门课的学生姓名</span><br></pre></td></tr></table></figure>

<p>如果用了等号，报错： subquery returns more than 1 row.</p>
<p>标量子查询：结果为一个。可以做&gt; &lt; &#x3D;操作。</p>
<p>列子查询：结果为一列。可以做 IN NOT IN SOME ALL ANY 操作。（ANY SOME 等价）</p>
<p>行子查询：结果为一行。可以做 &#x3D; &lt;&gt; IN NOT IN 操作。</p>
<p>表子查询：结果为多行多列。最常用 IN NOT IN 操作。</p>
<h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><p>一对一，一对多，多对多（两个一对多）</p>
<p>一对一：其中一方设置unique的外键。</p>
<p>一对多：多的一方设置外键。</p>
<p>多对多：建立中间表，设置两个外键。</p>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;</span><br></pre></td></tr></table></figure>

<p>如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。</p>
<p>本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。</p>
<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ol>
<li>有外键约束：利用外键连接，不用加条件，自动连接。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` </span><br><span class="line">from `tb_student` natural join `tb_college`;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。<em>注意：不管有几个同名的列，所有列都会作为连接的条件！</em></li>
<li>如果没有外键也没有同名列，就只会得到笛卡尔积的结果。</li>
</ol>
<h3 id="内-外连接"><a href="#内-外连接" class="headerlink" title="内 &#x2F; 外连接"></a>内 &#x2F; 外连接</h3><p>另一种连接方式是 inner join &#x2F; outer join </p>
<p>或者用 <code>where A.id=B.id</code> ，这种内连接方式叫做隐式内连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` </span><br><span class="line">from `tb_student` inner join `tb_college` </span><br><span class="line">on `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号</span><br></pre></td></tr></table></figure>

<p>inner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。</p>
<p>left outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。</p>
<p>right outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。</p>
<p>full outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。</p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A AS1 inner join A AS2 where 条件;-- 自连接可以是内或外连接。必须起别名！！！</span><br></pre></td></tr></table></figure>

<h3 id="θ-连接"><a href="#θ-连接" class="headerlink" title="θ 连接"></a>θ 连接</h3><p>添加条件使得两个表中的数据相互对应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` </span><br><span class="line">where `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号</span><br></pre></td></tr></table></figure>

<h3 id="三表连接"><a href="#三表连接" class="headerlink" title="三表连接"></a>三表连接</h3><p>链接条件用多个条件筛选。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`</span><br><span class="line">where `tb_course`.`cou_id`=`tb_record`.`cou_id` </span><br><span class="line">and `tb_student`.`stu_id`=`tb_record`.`stu_id`;</span><br><span class="line"></span><br><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`</span><br><span class="line">inner join `tb_record`</span><br><span class="line">on `tb_student`.`stu_id`=`tb_record`.`stu_id`</span><br><span class="line">inner join `tb_course`</span><br><span class="line">on `tb_course`.`cou_id`=`tb_record`.`cou_id`</span><br><span class="line">where `tb_course`.`cou_name` is not null; -- where 写在最后</span><br><span class="line"></span><br><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`</span><br><span class="line">natural join `tb_record`</span><br><span class="line">natural join `tb_course`;</span><br></pre></td></tr></table></figure>

<h2 id="查询小技巧"><a href="#查询小技巧" class="headerlink" title="查询小技巧"></a>查询小技巧</h2><p>百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件</p>
<p>python -推广链接 不想看到广告推送</p>
<p>site:zhihu.com python 只搜索知乎里的 python 内容</p>
<p>2023-01-23 补充：关于信息检索，博主也有开一个新坑：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq/category_12158048.html?spm=1001.2014.3001.5482">信息检索_灰海宽松的博客-CSDN博客</a>。目前更新还不完全，不过对于搜索引擎部分应该足够用了。</p>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>limit 是 mysql 的<strong>方言</strong>。</p>
<p>limit 查询最值有个缺陷，就是只能查出一条。如果有两个最大值就只能显示一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。</span><br><span class="line">select * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)</span><br><span class="line">select * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)</span><br></pre></td></tr></table></figure>

<h2 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h2><p>select 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）</p>
<p>查询学生姓名和平均成绩。</p>
<p>查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？</p>
<p>先通过一个查询，得到一个派生表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `tb_record` group by `stu_id`;</span><br></pre></td></tr></table></figure>

<p>然后把其结果作为一个新表，和学生表做关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`avg(score)`from `tb_student`</span><br><span class="line">natural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思</span><br></pre></td></tr></table></figure>

<p><strong>临时表必须要起别名！！！</strong>不然报错。</p>
<p><strong>注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！</strong>因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，<strong>没选课的学生就不会查出来。</strong></p>
<p>如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。</p>
<h1 id="DQL-例题及注意事项"><a href="#DQL-例题及注意事项" class="headerlink" title="DQL 例题及注意事项"></a>DQL 例题及注意事项</h1><h2 id="简单排序——查询最大值、次大只"><a href="#简单排序——查询最大值、次大只" class="headerlink" title="简单排序——查询最大值、次大只"></a>简单排序——查询最大值、次大只</h2><ol>
<li><p>员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。</p>
<p>做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。</p>
<p>做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。</p>
<p>做法③：查询一名没有人薪水比他大的员工（即：薪水大于这名员工的员工数&#x3D;0）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` t1 where(</span><br><span class="line">    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`</span><br><span class="line">)=0;-- 结尾改成1，就是工资第二高的人</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询除了 boss 外工资最高的人。</p>
<p>在题1的基础上，用 where 排除掉 boss。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` </span><br><span class="line">where `salary`=(</span><br><span class="line">    select max(salary) from `tb_employee` where `position`&lt;&gt;&#x27;boss&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询月薪 top 3的人。</p>
<p>这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` t1 where(</span><br><span class="line">    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`</span><br><span class="line">)&lt;3 order by `salary` desc;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。</p>
<p>题目很简单，但是<strong>遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。</strong>要用 ifnull() 或 coalesce() 函数限制一下。</p>
</li>
<li><p>查询所有部门名称及员工人数。</p>
<p>部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。<strong>重点注意几种连接的不同，思考一下题中哪个信息要全部展示出来。</strong>比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dname,total from `tb_department` t1</span><br><span class="line">left join (</span><br><span class="line">    select dname, count(*) as total from `tb_department` t2 group by `dno`</span><br><span class="line">) on t1.`stu_id`=t2.`stu_id`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious</p>
<p>先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sname,salary from `tb_employee` t1</span><br><span class="line">inner join (</span><br><span class="line">	select avg(salary),dno from `tb_employee` group by dno;</span><br><span class="line">)t2 on t1.dno=t2.dno and t1.salary &gt; t2.avg(salary);-- 两个连表条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。</p>
<p>派生表通过薪水值、部门号和员工表、部门表相连接。</p>
</li>
<li><p>查询薪水排名4-6员工的薪水、姓名、<strong>排名</strong>。</p>
<p>问题1：怎么查出排名？</p>
<p>问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5</p>
<p>解决：mysql 8的窗口函数可以解决排名 &#x2F; top N 问题。</p>
<p>①不用窗口函数：</p>
<p>系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：<code>set @a=0;</code>或<code>select@a:=0;</code>而且变量也可以通过 as 起别名。</p>
<p>我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set @a=0;</span><br><span class="line">select row_num,ename,salary from (</span><br><span class="line">	select @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0</span><br><span class="line">    from `tb_employee` order by salary desc</span><br><span class="line">) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次</span><br></pre></td></tr></table></figure>

<p>注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.</p>
<p>另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。</p>
</li>
<li><p>查询每个部门薪水排名前两名的员工。</p>
<p>Top N 问题通过题1的做法③解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select eno,ename,salary,dno from `tb_employee` t1</span><br><span class="line">where (</span><br><span class="line">	select count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary&gt;t1.salary</span><br><span class="line">)&lt;2 order by t1.dno asc, t1.salary desc;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>内容来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92654574">通俗易懂的学会：SQL 窗口函数 - 知乎</a></p>
<p>应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by</p>
<p>窗口函数不光是函数，有一套完整的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;</span><br><span class="line">                order by &lt;用于排序的列名&gt;)</span><br></pre></td></tr></table></figure>

<p>&lt;窗口函数&gt; 处放聚合函数或专用窗口函数。</p>
<p>窗口函数是以一个列的形式使用的。</p>
<h3 id="专用窗口函数"><a href="#专用窗口函数" class="headerlink" title="专用窗口函数"></a>专用窗口函数</h3><p>rank、dese rank、row_number</p>
<p>看图即知区别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152337617.png" alt="img"></p>
<h3 id="partition-by-和-group-by-的区别"><a href="#partition-by-和-group-by-的区别" class="headerlink" title="partition by 和 group by 的区别"></a>partition by 和 group by 的区别</h3><p>partition by 是把所有数据分成绩一个窗口，而并不汇总。比如上图中，如果按班级号分窗口再进行排序，就会在每个班级内部从1到无穷排序。不写的话就默认整个表是一个大窗口。</p>
<p>group by 是分组后汇总。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152337023.png" alt="img"></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`sal`,</span><br><span class="line">rank() over (order by `sal` desc)as `r1`,</span><br><span class="line">dense_rank() over (order by `sal` desc)as `r2`,</span><br><span class="line">row_number() over (order by `sal` desc)as `r3`</span><br><span class="line">from `tb_emp`;</span><br></pre></td></tr></table></figure>

<p>第八题窗口函数做法：加一个 where r between 4 and 6 的条件。</p>
<p>第九题窗口函数做法：因为产生了分组，因此不能直接用 where r &lt;&#x3D;2。但是<strong>窗口函数的分窗口后的列做筛选，既不能直接用 where 也不能用 having</strong>。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`sal`,`dno`</span><br><span class="line">from(</span><br><span class="line">    select `ename`,`sal`,`dno`,</span><br><span class="line">    rank() over (partition by `dno` order by `sal` desc)as `r`</span><br><span class="line">    from `tb_emp`</span><br><span class="line">) `temp` where `r`&lt;=2;-- 不能在派生表里直接筛选</span><br></pre></td></tr></table></figure>

<p><em>窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。</em></p>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p>Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。主要是 DBA 使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问。域名如 localhost，%代表任意路径</span><br><span class="line">alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified with mysql_native_password by &#x27;新密码&#x27;;-- with mysql_native_password 是 mysql 的修改方式</span><br><span class="line">drop user &#x27;人名&#x27;@&#x27;域名&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。</p>
<p>查看权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>授权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 权限 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>数据库名和表名可以用通配符 * 代替。</p>
<p>权限包括： all (privileges), select, insert, update, delete, alter, drop, create</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改</span><br><span class="line">grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;</span><br><span class="line">grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限</span><br><span class="line">grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人</span><br></pre></td></tr></table></figure>

<p>召回权限：revoke</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限 数据库名.表名 from &#x27;人名&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p>添加权限之后最好 Reconnect 刷新一下。或者执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>Workbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。</p>
<p>至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>很多内容其实在 DQL 早就介绍过。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(s1, s2, sn)</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>转小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>转大写</td>
</tr>
<tr>
<td>LPAD(str, n, pad)</td>
<td>用 pad 对 str 左边n个字符长度进行填充</td>
</tr>
<tr>
<td>RPAD(str, n, pad)</td>
<td>用 pad 对 str 右边n个字符长度进行填充</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉头尾的空格</td>
</tr>
<tr>
<td>SUBSTRING(str, start, len)</td>
<td>返回 str 从指定位置 start 开始 len 长度的子字符串（从0开始）</td>
</tr>
</tbody></table>
<p>如：所有员工的工号都必须是五位数，不足的话在左端补0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名 = lpad(字段名,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>rand()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>round(x,y)</td>
<td>返回x四舍五入值，保留y位小数</td>
</tr>
</tbody></table>
<p>例：生成6位验证码。</p>
<p>首先靠随机数生成，然后*1000000并四舍五入，然后还要考虑开头为0的情况，因此不足六位补0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select lpad(round(rand()*1000000,0),6,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>curdate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>curtime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>year(date)</td>
<td></td>
</tr>
<tr>
<td>month(date)</td>
<td></td>
</tr>
<tr>
<td>day(date)</td>
<td></td>
</tr>
<tr>
<td>date_add(date, interval expr type)</td>
<td>date 加时间间隔 expr，可以是年月日时间，如<code>interval 70 day</code></td>
</tr>
<tr>
<td>datediff(date1, date2)</td>
<td>求两个日期相差天数</td>
</tr>
</tbody></table>
<h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>if(value, t, f)</td>
<td>true 返回t， false 返回f</td>
</tr>
<tr>
<td>ifnull(value1, value2)</td>
<td>value1 为 null 返回 value1，空返回 value2</td>
</tr>
<tr>
<td>case when val1 then res1 else default end</td>
<td>switch case</td>
</tr>
<tr>
<td>case expr when val1 then res1 else default end</td>
<td>表达式形式的 switch case</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(case workaddress </span><br><span class="line"> when &#x27;北京&#x27; then &#x27;一线城市&#x27; </span><br><span class="line"> when &#x27;上海&#x27; then &#x27;一线城市&#x27; </span><br><span class="line"> else &#x27;二线城市&#x27; </span><br><span class="line"> end) as &#x27;工作地&#x27;;</span><br><span class="line"> </span><br><span class="line">(case score </span><br><span class="line"> when score=100 then &#x27;满分&#x27; </span><br><span class="line"> when score&gt;=90 then &#x27;优秀&#x27; </span><br><span class="line"> else &#x27;懒得写了&#x27; </span><br><span class="line"> end) as &#x27;成绩所在段&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组不可分割的操作集合，要么都成功执行，要么都失败。如银行账户数据库操作，一个人给另一个人转账1000元，那么这两个人的update操作就是不可分割的，不然如果有一个操作成功执行另一个没有，就可能银行平白无故少了1000或者收款人没收到钱。</p>
<p>事务的步骤：</p>
<ol>
<li>开启事务</li>
<li>执行一条条操作。这期间如果有失败则事务回滚。或者手动进行事务回滚。</li>
<li>全部执行完后提交事务。默认mysql是自动提交事务的，每执行一条语句就会提交一条。</li>
</ol>
<h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@autocommit;-- 1：自动提交；0：手动提交</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set @@autocommit=0;-- 开启手动提交</span><br><span class="line"></span><br><span class="line">rollback;-- 回滚</span><br><span class="line"></span><br><span class="line">commit;-- 提交</span><br></pre></td></tr></table></figure>

<p>或者在<code>@@autocommit=1</code>时临时开启事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction;-- 开启事务</span><br></pre></td></tr></table></figure>

<h2 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性 ACID"></a>事务四大特性 ACID</h2><p>atomicity 原子性：事务是不可分割的最小操作单元。</p>
<p>consistency 一致性：所有数据保持一致状态。</p>
<p>isolation 隔离性：事务不受外部干扰，独立进行。</p>
<p>durability 持久性：提交或回滚后，事务对数据库的操作就是永久的。</p>
<h2 id="并发事务问题及解决办法"><a href="#并发事务问题及解决办法" class="headerlink" title="并发事务问题及解决办法"></a>并发事务问题及解决办法</h2><p>多个事务同时进行时会出现的问题。</p>
<p>以下是数据库事务可以设置的几种隔离级别，分别是应对不同问题用的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336578.png" alt="image-20220801231316895"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@TRANSACTION_ISOLATION;-- 查看数据库隔离级别</span><br><span class="line">set session/global TRANSACTION ISOLATION LEVEL SERIALIZABLE;-- 设置当前会话/全局事务隔离级别为serializable</span><br></pre></td></tr></table></figure>

<p>read uncommitted 是数据库最低隔离级别，即：一个事务中的数据还未提交别的事务就可以读得到。</p>
<p><strong>问题1</strong>：脏读：一个事务读到另一个事务未提交的数据（Read uncommitted会发生）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544202.png" alt="image-20220802212804661"></p>
<p><strong>解决办法</strong>：read committed 限制一个事务修改的数据要等到提交后别的数据才能读得到。解决了脏读问题，但是没有解决不可重复读问题，事务2第一次读和第二次读数据可能值不一样。</p>
<p>解决后：（给要读取的左边的窗口设置 read-committed 隔离级别）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544203.png" alt="image-20220802212544087"></p>
<p><strong>问题2</strong>：不可重复读：一个事务前后读了同一个数据两次，两次值不一样。因为其他事务在这中间提交过一次。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544204.png" alt="image-20220802213646432"></p>
<p><strong>解决办法</strong>：repeatable 使得事务2开启后事务1才提交的数据事务2读取不到，避免了不可重复读的问题。但是没有解决串行化问题，即事务2再对数据的修改会覆盖事务1的修改。</p>
<p><strong>问题3</strong>：幻读：每个事务开启时把数据读入缓存内，这样重复读取的时候直接从缓存中读取，避免了重复读取数据不一样。但是数据不及时更新，比如事务1删库了，事务2还能读；或者事务1新增了一条主键为i的数据提交了，事务2随后也想新增一条主键为i的数据，提交的时候发现1已经写过了，交不进去了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336806.png" alt="image-20220802221507795"></p>
<p><strong>解决办法</strong>：serializable 让事务1在操作当前数据库时，别的事务直接操作不了。</p>
<p><strong>问题4</strong>：开启序列化后，其他事务插入会卡住，等待当前事务插入完成后再执行插入操作。会导致用户体验差，需要等待。所以序列化等级还是很少使用的。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="Mysql-体系结构"><a href="#Mysql-体系结构" class="headerlink" title="Mysql 体系结构"></a>Mysql 体系结构</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336306.png" alt="image-20220803115255247"></p>
<p>连接层：连接池部分，与客户端连接，并检查授权认证、权限、最大连接数等。</p>
<p>服务层：SQL接口一行，绝大部分核心功能如SQL解析优化、所有跨存储引擎的实现都在这一层。</p>
<p>引擎层：可插拔存储引擎一行，<strong>索引</strong>在这一层实现，决定数据库数据如何存、取、组织。如果当前引擎不满足需求还可以拓展，因此被称作可插拔。</p>
<p>存储层：最下面一行，存取数据库的相关数据。</p>
<h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p>存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的。</p>
<p>查询建表语句：<code>show create table 表名;</code>时在结尾就可以看到该表的存储引擎。</p>
<p><code>show engines;</code>查询当前数据库支持的所有引擎。</p>
<p>创建指定引擎的表：<code>create table (...) engine=指定引擎;</code></p>
<p>修改表引擎：<code>alter table 表名 engine=指定引擎;</code></p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>高性能存储引擎，Mysql 5.5后的默认引擎。</p>
<p>支持事务、行级锁、外键。</p>
<p>文件后缀.ibd是InnoDB存储引擎的表空间文件，每个表有一个，存储表结构数据和索引。<em>表结构早期是frm，后来变成sdi，sdi又融入了ibd格式中。</em></p>
<p>有一个系统变量<code>innodb_file_per_table</code>，可以通过<code>show variables like &#39;innodb_file_per_table&#39;</code>查看，ON则表示每张表都对应一个表空间文件ibd。</p>
<p>ibd文件在mysql文件夹-data文件夹-对应数据库文件夹里。</p>
<p>ibd文件直接打开是看不了的，都是二进制。可以进入目标文件夹后，通过命令行<code>ibd2sdi 指定表名.ibd</code>，就可以查看该表的json文件信息了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544208.png" alt="image-20220803210405717"></p>
<p>表空间文件逻辑存储结构如图所示，段-区-页-行，每一行就是表中的一行数据。</p>
<p>一个区大小固定为1M，一页大小固定为16K。（大概了解，SQL优化部分还要涉及）</p>
<h2 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h2><p>数据库早期的默认存储引擎。（现在功能几乎可以被NoSQL的Mongodb取代）</p>
<p>不支持事务和外键，支持表锁，不支持行锁，访问速度快。</p>
<p>存储文件包括：</p>
<p>.MYD：数据</p>
<p>.MYI：索引</p>
<p>.sdi：表结构，可以直接打开，里面装的是json格式内容（可以通过json.cn格式化）。</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>存放在内存中，数据是临时的。（现在功能几乎可以被NoSQL的Redis取代）</p>
<p>访问速度快，支持hash索引。</p>
<p>存储文件只包括：.sdi，因为数据索引都存在内存里了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544209.png" alt="image-20220803211018558"></p>
<h2 id="三种存储引擎的选择"><a href="#三种存储引擎的选择" class="headerlink" title="三种存储引擎的选择"></a>三种存储引擎的选择</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544210.png" alt="image-20220803211235879"></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是高效获取数据的数据结构。</p>
<h2 id="Linux中安装Mysql"><a href="#Linux中安装Mysql" class="headerlink" title="Linux中安装Mysql"></a>Linux中安装Mysql</h2><p>首先在Linux中安装Mysql。还好前两天接触了一点虚拟机。</p>
<p><a target="_blank" rel="noopener" href="https://downloads.mysql.com/archives/community/">Mysql 下载地址</a></p>
<p>FinalShell可以直接点击上传标志上传下载的压缩包：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544211.png" alt="image-20220803220722619"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf 压缩包名 -C mysql //解压到该文件夹内</span><br><span class="line"></span><br><span class="line">//安装其中的所有rpm文件</span><br><span class="line">rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install openssl-devel</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>启动：安装好mysql后，linux会自动提供mysqld服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld //启动mysql</span><br><span class="line"></span><br><span class="line">mysql -uroot -p //然后去日志文件里找密码~</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure>

<p>查找密码可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>也可以直接打开该文件看。登录后就是用熟悉的SQL改密码.</p>
<p>linux密码默认校验规则等级为Medium，要求&gt;8位，包括数字，大小写字母和符号。可以设置强度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password.policy = 0;</span><br><span class="line">set global validate_password.length = 4;</span><br></pre></td></tr></table></figure>

<p>然后可以设置个简单点的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;1234&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后为了DataGrip可以访问，创建一个可以远程访问新用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;Windows&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;1234&#x27;;</span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to &#x27;Windows&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p>可以通过ifconfig查看ip地址。查看后就可以在DataGrip中链接啦。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336010.png" alt="image-20220803223712197"></p>
<h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><p>是帮助Mysql高效<strong>获取数据</strong>的有序数据结构。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544213.png" alt="image-20220803224534102" style="zoom:80%;" />

<p>比如查找age&#x3D;45的记录，如果age采用二叉树的存储方式，很明显右边比左边更高效。</p>
<p>索引使得查询和排序成本降低，但是增删改成本增加，而且索引也要占用空间（MYI文件）。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336564.png" alt="image-20220803224920983" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544216.png" alt="image-20220803225009939" style="zoom:67%;" />

<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>二叉树比较简单，小数插在左子树，大数插在右子树。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544217.png" alt="image-20220803225242447" style="zoom:67%;" />

<p>但是如果一直往左或右插，树就变成一边倒的形状了，查询效率大大降低。</p>
<p>红黑树可以解决平衡问题。但是大数据情况下还是层级较深，检索速度较慢。</p>
<p>B树：又名多路平衡查找树。</p>
<p>首先每个节点的子节点个数叫度数。</p>
<p>以最大度数为5的5阶B树为例：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544218.png" alt="image-20220803230306405" style="zoom:67%;" />

<p>一开始插入4个数以内，都在一个节点里</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336423.png" alt="image-20220804001653602"></p>
<p>然后插入第五个数，就开始分裂，中间的数作为父节点，左右两组数作为子节点</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544220.png" alt="image-20220804001734711"></p>
<p>然后插入数还是往子节点里插入</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544221.png" alt="image-20220804001859705"></p>
<p>如果子节点够5个，中间的提到父节点处。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336894.png" alt="image-20220804002347547"></p>
<p>一直插入到父节点达到5个，父节点再次分裂。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544223.png" alt="image-20220804002649191"></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>就是B树的所有叶子节点会形成一个单向链表</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544224.png" alt="image-20220804003347742" style="zoom:67%;" />

<p>Mysql里的B+树就是叶子结点变成了双向循环链表，提高区间访问性能。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544225.png" alt="image-20220804003507672"></p>
<h2 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h2><p>通过一定的Hash算法，把值都归到对应hash值的槽位上。如果出现槽位冲突，采用链表的方式解决。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544226.png" alt="image-20220804003919738"></p>
<p>只能用于&#x3D;等值查询，不能查询范围(&gt;&lt; between)，不能排序。</p>
<p>效率很高，通常一次查询就找得到。</p>
<p>只有Memory存储引擎支持。但是InnoDB具有自适应hash功能，可以在给定的条件下将B+树构建为hash索引。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336338.png" alt="image-20220804004326046" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544228.png" alt="image-20220804004404121" style="zoom:80%;" />

<p>有主键，主键就是聚集索引；</p>
<p>没有主键，第一个unique是聚集索引；</p>
<p>没有主键和unique唯一索引，则表会自动生成一个rowid作为隐藏的聚集索引。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336849.png" alt="image-20220804131209280"></p>
<p><code>select ... where name=&#39;Arm&#39;;</code>会先在二级索引中找到对应节点，然后根据id去聚集索引B+树中找主键，进而找到对应的row行数据。</p>
<p>因此直接<code>select ... where id=10;</code>效率会更高，哪怕name有索引也需要回表查询（回id表）。</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (col_name,...);</span><br><span class="line">-- 查看表中索引：</span><br><span class="line">SHOW INDEX FROM table_name;</span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><code>show global status like &#39;Com_______&#39;;</code>查看当前数据库增删改查等操作的频次。如 Com_commit Com_select。</p>
<p>慢查询日志：记录了所有查询时间超过10s（long_query_time）sql语句的日志。查询变量：slow_query_log 可以看是否开启。</p>
<p>默认没有开启，需要到&#x2F;etc&#x2F;my.cnf中开启 slow_query_log。</p>
<p>开启后&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;主机吗名-slow.log中就会生成慢查询日志。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">// 编辑，添加：</span><br><span class="line"></span><br><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=10</span><br><span class="line"></span><br><span class="line">:x//保存退出</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld//重启</span><br><span class="line"></span><br><span class="line">show variables like &#x27;slow_query_log&#x27;;//查询是否开启</span><br></pre></td></tr></table></figure>

<p>但是慢查询查询不到少于它规定秒数的语句。</p>
<p>show profiles 可以帮助我们了解每条sql语句耗时。首先通过：have_profiling参数 查看当前数据库是否支持profile操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select @@have_profiling;</span><br><span class="line"></span><br><span class="line">select @@profiling;-- 默认关闭</span><br><span class="line"></span><br><span class="line">set profiling=1;</span><br><span class="line"></span><br><span class="line">show profiles;-- 查看刚才执行的所有sql耗时</span><br><span class="line"></span><br><span class="line">show profile for query 数字序号;-- 查看某一条特定的sql具体查询耗时，从start到cleaning up</span><br><span class="line"></span><br><span class="line">show profile cpu for query 数字序号;-- 还可以查看cpu占用情况</span><br></pre></td></tr></table></figure>

<p>然而时间并不是准确的判定性能方法。explain才是更好的方法。explain可以查看select的详细执行状况。在任意select语句前加上explain或 desc 就可以了。</p>
<p>属性含义：</p>
<p>id：select查询的序列号，表示select或操作表的顺序，从大到小，相同id值从上到下。</p>
<p>比如查询学生表、成绩表、学生成绩表 id 都是1，但从上到下顺序是s, sc, c。子查询 id 会更大。</p>
<p>select_type：查询类型。</p>
<p>​	simple：简单类型</p>
<p>​	subquery：子查询</p>
<p>​	primary：主查询，外层查询</p>
<p>​	union：联合的后半部分</p>
<p><strong>type</strong>：连接类型，性能由好到坏分别为：null（不查询表，查询常量时）, system（系统表）, const（主键约束查询，唯一性约束查询）, eq_ref（子查询的 const）, ref（非唯一性约束查询）, range, index（用到了索引，但也是全表索引扫描）, all（全表扫描）</p>
<p>尽量往前靠。</p>
<p><strong>possible_key</strong>：这张表中可能用到的索引。</p>
<p><strong>key</strong>：实际用到的索引。</p>
<p><strong>key_len</strong>：使用到的索引中的最大可能字节数。越短越好。</p>
<p>rows：Mysql认为必须要执行查询的行数（估计值）。</p>
<p>filtered：返回的行数&#x2F;读取的行数百分比，越大越好。比如查主键就不用遍历，查一条就查得出来。</p>
<h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p>通过 create index 给某个属性添加索引。</p>
<p><em>查询结果结尾加 &#x2F;G ，可以把列转换为行显示。</em></p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol>
<li>联合索引的<strong>最左前缀法则</strong>。比如一个索引要关联多列，那么查询从最左列开始，且不跳过索引中的列。比如我们给 profession age status 三列添加了一个索引，那么查询时就该写：<code>select * from table where profession=&quot;&quot; and age=&quot;&quot; and status=&quot;&quot;; </code> 不写 profession 查询或者只写 profession 和 status 查询会出错，会出现有 null 的列。（好像8.0可以不写最左列）原理大概是复合属性的索引是先按第一个排序，再按第二个，再第三个……所以只按后面的排序查找就出错。当然这三个查询顺序无所谓，关键是左边的一定得有。（这里的左指的是创建索引的时候的顺序，比如 <code>create index index_name on table_name(left_column, right column);</code>）</li>
<li>联合索引中如果出现范围查询（&lt; &gt;），范围查询右侧的属性失效。比如 <code>select * from table where profession=&quot;&quot; and age&gt;30 and status=&quot;&quot;; </code>  status 查询就会失效。解决办法是尽量用 &gt;&#x3D; &lt;&#x3D;。</li>
<li>索引列上不要做运算，否则会失效。 比如查询姓名三个字以“松”结尾的学生，姓名有索引，但是 <code>select * from students where substring(name,3,1)=&quot;松&quot;;</code> 不走索引。</li>
<li>查询字符串没加单引号也失效。</li>
<li>尾部模糊匹配（”abc%”）不会失效，头部模糊匹配（”%abc”）失效。</li>
<li>or 的失效情况：<code>有索引列条件 or 无索引列条件</code> ，结果是所有索引都不会被用到。处理办法就是右边的属性也建立索引。</li>
</ol>
<p>总结就是，mysql 评估说全表扫描比索引查找快，那么就决定用全表。比如当前列 null 值比较多，<code>is null</code> 查询就会全表查询，<code>is not null</code> 是索引查询。</p>
<h3 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h3><p>有的列可能用了多个索引。可以人为提示指明用哪一个。</p>
<p><code>explain select * from table use index(index_name) where 条件;</code></p>
<p><code>explain select * from table ignore index(index_name) where 条件;</code></p>
<p><code>explain select * from table force index(index_name) where 条件;</code> use 可能不接受。force 是强制使用这个索引。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>查询使用了索引，且查询返回的列都在该索引当中。</p>
<p>覆盖索引效率高于 select *。</p>
<p>如果查询多列，包括有索引列和没索引列，explain 中 extra 显示 using index condition，意为使用了索引查找，但是最后又回表查询非索引列。</p>
<p>如果查询的多列只包含索引列，explain 中 extra 显示 using where; using index 意为只使用了索引查找，因为要查询的列只在索引列中就找得到。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304041241125.png" alt="image-20230404124124952"></p>
<p>比如上例，如果 <code>select * from table where id=2;</code> 先去聚集索引表中找 id&#x3D;2 的行，然后回表找到这一行，找到这一行的所有数据。</p>
<p>如果 <code>select id, name from table where name=&#39;Arm&#39;;</code> 先去辅助索引表中找到 Arm，辅助索引表中也会存储其 id 信息。这样就已经能查到所有字段了，就不用回表了。</p>
<p>但是如果查询的字段是 <code>id, name, gender</code> ，gender 不在辅助索引表中，因此还是用回表的。先根据 arm 对应的 id 值，去聚集索引表中找到相关的行信息，再回表查询 gender。这就超出了覆盖索引的范围。</p>
<p>例：<code>select id, username, pwd from user where username=&#39;jingqing&#39;;</code> 怎样设置索引使得查询最优？</p>
<p>答：id 是主键索引，为了达成覆盖索引，我们要给 username pwd 建立复合索引。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>varchar int 等类型可能是很长的字符串，导致索引变得很大，查询时浪费大量磁盘 IO。</p>
<p>创建索引时可以只选择一定长度的前缀建立索引。如：</p>
<p><code>create index index_name on table_name(column(n));</code> 表示前n个字符建立前缀。</p>
<p>至于n取多少合适，可以根据索引的选择性决定，选择性&#x3D;不重复的索引值&#x2F;记录总数，越大越好，1是最好的唯一索引。（count(distinct column)&#x2F;count(column)）</p>
<p>我们可以用 substring(column, 1, n) &#x2F; count(*) 来计算前n个前缀的选择性。</p>
<h3 id="单列索引和联合索引"><a href="#单列索引和联合索引" class="headerlink" title="单列索引和联合索引"></a>单列索引和联合索引</h3><p>包含多列的是联合索引。</p>
<p>多个查询条件时推荐使用建立联合索引。因为比如 column a 和 column b 建立了两个单列索引，同时查询两者时 mysql 也只会选择其中一个索引查询，另一个字段回表查询（如果 mysql 自动选择了单列索引，可以用 use index() 限制）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336398.png" alt="image-20230404131344451"></p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li>什么时候用索引？数据量比较大，且查询比较频繁的表要建立。</li>
<li>哪几列建立索引？常作为查询条件的列（where, order by, group by)。</li>
<li>建议区分度高的列建立唯一索引。</li>
<li>太长的列可以建立前缀索引。</li>
<li>尽量用联合索引而不是单列索引，避免回表。</li>
<li>索引也会影响维护，因此并不是多多益善。</li>
<li>如果索引列不能存储 null，建表的时候请用 not null 约束该列。当优化器知道每列是否有 null 值时，可以更好的决定用哪个索引查询。</li>
</ol>
<h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="插入优化"><a href="#插入优化" class="headerlink" title="插入优化"></a>插入优化</h2><p><code>insert into table values(1,1...);</code></p>
<ol>
<li><p><code>insert into table values(1,1...),(1,1...),(1,1...);</code> 使用批量插入，和数据库之间建立连接也不用每条数据插入一次，效率会高。建议500~1000条数据使用批量插入。</p>
</li>
<li><p>插入的时候是自动开启和关闭事务的，插入前开启，插入后关闭。太频繁了性能也不高，我们可以手动开启和关闭事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into table values(1,1,1);</span><br><span class="line">insert into table values(2,2,2);</span><br><span class="line">insert into table values(3,3,3);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键顺序插入，这个和 mysql 的数据组织结构有关系。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：Web 开发实践 小程序标点地图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/12/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%87%E7%82%B9%E5%9C%B0%E5%9B%BE/"
    >北邮国院项目：Web 开发实践 小程序标点地图</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/12/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%87%E7%82%B9%E5%9C%B0%E5%9B%BE/" class="article-date">
  <time datetime="2022-05-11T23:00:00.000Z" itemprop="datePublished">2022-05-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>web 开发实践课的大作业。本次小程序设计主要围绕 map 组件展开。</p>
<p>我们组设计了一款能够记录地图上的标点信息，并将自己的标点信息发布到帖子上的旅游类app。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/DianJi_Demo">github 代码地址</a>，希望对你有所帮助~</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/34ffd9596cbecd6cf2c5083c61472e18.png" alt="HN6nM.png"></p>
<p>小程序的主要功能就是记录地图上的标点信息，并上传到云数据库中；</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/035976c6063c4d019ea3a2e62d35bca0.gif" alt="在这里插入图片描述"></p>
<p>以及编辑文章，把文章信息上传到云数据库中；</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/00c96f64cec54457a23359ff540dcc67.gif" alt="在这里插入图片描述"></p>
<p>获取云数据库中的文章（最新发布的3篇）。</p>
<p>xxxxxxxxxx int zong(int i)&#x2F;&#x2F;纵坐标y1{    double x&#x3D;(i-51);    double y&#x3D;12.0*sin(x&#x2F;7);    int y1&#x3D;(int)(15-y);    return y1;}​int heng(int i)&#x2F;&#x2F;横坐标j{    int j&#x3D;i;    if(i&gt;101&amp;&amp;i&lt;&#x3D;202)j&#x3D;203-i;    else if(i&gt;202&amp;&amp;i&lt;&#x3D;303)j&#x3D;i-202;    else if(i&gt;303&amp;&amp;i&lt;&#x3D;404)j&#x3D;405-i;    return j;}​void dayin(char ch,int j,int y1)&#x2F;&#x2F;在(y1,j)处输出给定字符{        gotoxy(y1,j);        if(ch&#x3D;&#x3D;’ ‘)        {            if(y1&#x3D;&#x3D;15)printf(“-“);            else if(j&#x3D;&#x3D;51)printf(“|”);            else printf(“ “);        }        else printf(“#”);        gotoxy(29-y1,102-j);        if(ch&#x3D;&#x3D;’ ‘)&#x2F;&#x2F;防止坐标点和坐标轴被空格覆盖        {            if(29-y1&#x3D;&#x3D;15)printf(“-“);            else if(102-j&#x3D;&#x3D;51)printf(“|”);            else if(29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;49)printf(“-“);            else if((29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;50)||(29-y1&#x3D;&#x3D;3&amp;&amp;102-j&#x3D;&#x3D;50))printf(“1”);            else if(29-y1&#x3D;&#x3D;16&amp;&amp;102-j&#x3D;&#x3D;100)printf(“X”);            else printf(“ “);        }        else printf(“#”);        gotoxy(1,1);}​​​​int main(){    float x,y;    int tim&#x3D;20;    system(“color F0”);    system(“mode con cols&#x3D;101 lines&#x3D;30”);    clear();        for(int i&#x3D;0;i&lt;&#x3D;100;i++)&#x2F;&#x2F;打印x轴     {        gotoxy(15,i+1);        if(i!&#x3D;50)printf(“-“);        else printf(“+”);        gotoxy(1,1);        rest(1);    }        for(int i&#x3D;29;i&gt;&#x3D;0;i–)&#x2F;&#x2F;打印y轴     {        gotoxy(i+1,51);        if(i!&#x3D;14)printf(“|”);        gotoxy(1,1);         rest(1);    }    &#x2F;&#x2F;打印轴上的点    gotoxy(16,52); printf(“O”);        gotoxy(16,100);printf(“X”);        gotoxy(1,49);printf(“Y”);        gotoxy(3,50);printf(“1”);        gotoxy(26,49);printf(“-1”);                    int i&#x3D;0,j,y1;​    for(i&#x3D;52;i&lt;&#x3D;404;i++)&#x2F;&#x2F;打印函数     {        j&#x3D;heng(i),y1&#x3D;zong(i);        dayin(‘#’,j,y1);        rest(4);                if(i-51-tim&gt;0)        {            y1&#x3D;zong(i-tim);            j&#x3D;heng(i-tim);            dayin(‘ ‘,j,y1);        }    }       for(int r&#x3D;i-tim;r&lt;&#x3D;i;r++)    {        j&#x3D;heng(r);        y1&#x3D;zong(r);        dayin(‘ ‘,j,y1);        rest(4);    }     gotoxy(1,1);    rest(1000);    return 0;}c</p>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/77e31ce1557342dd8a883fe55c21c05d.png" alt="在这里插入图片描述"></p>
<p>目前有两个数据库表。databasemarkers 存储本次记录中所有标点信息；databasearticles 存储该文章发布时间、文章标题、备注、内容以及对应的标点记录id（外键）。</p>
<h1 id="1-地图标点"><a href="#1-地图标点" class="headerlink" title="1. 地图标点"></a>1. 地图标点</h1><p>小程序自带的 map 组件中有一个属性 markers，是一个对象数组。只要把相应格式的对象数组传给 map 组件，就会自动在地图上标记出点的信息。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/4e581029e11d4f26ae9ba03e9effae44.png" alt="在这里插入图片描述"></p>
<p>wxml 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- subkey 用于调整地图样式</span></span><br><span class="line"><span class="comment">经纬度 latitude longitude 信息是地图初始的中心点。</span></span><br><span class="line"><span class="comment">本例中，要传递给 map 组件的对象数组也命名为 markers，在 js 文件中获取数据后传递给 map--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">id</span>=<span class="string">&quot;map&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">subkey</span>=<span class="string">&quot;DKEBZ-LKBW4-B3KUP-DYSCI-IG7OS-SQBJH&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">longitude</span>=<span class="string">&#x27;&#123;&#123;weidu&#125;&#125;&#x27;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">latitude</span>=<span class="string">&#x27;&#123;&#123;jingdu&#125;&#125;&#x27;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">scale</span>=<span class="string">&quot;10&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">layer-style</span>=<span class="string">&quot;1&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">show-location</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">markers</span>=<span class="string">&quot;&#123;&#123;markers&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--每次点击添加标点按钮，就会获取当前位置信息，存入 markers 数组--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&quot;default&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;recstart&quot;</span>&gt;</span></span><br><span class="line">    添加标点</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--点击结束记录，将标点信息上传到数据库 databasemarkers 中，并跳转到文章编辑页面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&quot;default&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;recstop&quot;</span>&gt;</span></span><br><span class="line">    添加标点</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cnt=cnt+<span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> db=wx.<span class="property">cloud</span>.<span class="property">database</span></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">jingdu</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">weidu</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">markers</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">	<span class="attr">recstart</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line">        cnt = cnt + <span class="number">1</span></span><br><span class="line">        wx.<span class="title function_">getLocation</span>(&#123;</span><br><span class="line">            <span class="attr">altitude</span>: <span class="string">&#x27;altitude&#x27;</span>,</span><br><span class="line">            <span class="attr">highAccuracyExpireTime</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">isHighAccuracy</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;gcj02&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">                <span class="keyword">let</span> marker = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">markers</span></span><br><span class="line">                marker.<span class="title function_">push</span>(&#123;</span><br><span class="line">                    <span class="attr">id</span>: cnt-<span class="number">1</span>,</span><br><span class="line">                    <span class="attr">latitude</span>: result.<span class="property">latitude</span>,</span><br><span class="line">                    <span class="attr">longitude</span>: result.<span class="property">longitude</span>,</span><br><span class="line">                    <span class="attr">width</span>: <span class="number">20</span>,</span><br><span class="line">                    <span class="attr">height</span>: <span class="number">30</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// let pointobj = this.data.polyline[0].points</span></span><br><span class="line">                <span class="comment">// console.log(pointobj)</span></span><br><span class="line">                <span class="comment">// pointobj.push(</span></span><br><span class="line">                <span class="comment">//   &#123;</span></span><br><span class="line">                <span class="comment">// 	  latitude: result.latitude,</span></span><br><span class="line">                <span class="comment">//     longitude: result.longitude,</span></span><br><span class="line">                <span class="comment">//   &#125;</span></span><br><span class="line">                <span class="comment">// )</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">data</span>.<span class="property">markers</span>)</span><br><span class="line">                that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                    <span class="attr">jingdu</span>: result.<span class="property">latitude</span>,</span><br><span class="line">                    <span class="attr">weidu</span>: result.<span class="property">longitude</span>,</span><br><span class="line">                    <span class="attr">recmode</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">markers</span>: marker,</span><br><span class="line">                    <span class="comment">// polyline:[&#123;</span></span><br><span class="line">                    <span class="comment">//   points:pointobj</span></span><br><span class="line">                    <span class="comment">// &#125;]</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// fail: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">            <span class="comment">// complete: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">recstop</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line">      db.<span class="title function_">collection</span>(<span class="string">&quot;databasemarkers&quot;</span>).<span class="title function_">add</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">          <span class="attr">markers</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">markers</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据添加成功！&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        <span class="keyword">var</span> docstring=res.<span class="property">_id</span></span><br><span class="line">        wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/pages/addarticle/addarticle?docstring=&#x27;</span>+docstring</span><br><span class="line">      &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">onLoad</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line">        wx.<span class="title function_">getLocation</span>(&#123;</span><br><span class="line">            <span class="attr">altitude</span>: <span class="string">&#x27;altitude&#x27;</span>,</span><br><span class="line">            <span class="attr">highAccuracyExpireTime</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">isHighAccuracy</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;type&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                    <span class="attr">jingdu</span>: result.<span class="property">latitude</span>,</span><br><span class="line">                    <span class="attr">weidu</span>: result.<span class="property">longitude</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fail: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">            <span class="comment">// complete: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="2-发布文章"><a href="#2-发布文章" class="headerlink" title="2. 发布文章"></a>2. 发布文章</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/28e718d09b274fb89bbed42d385fab02.png" alt="在这里插入图片描述"></p>
<p>添加完标点信息后，提示输入文章标题、备注、正文信息，点击提交，文章就会发布到 databasearticles 数据库中。</p>
<p>wxml：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;inputbox&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-top: 1px solid #e4e4e4;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>题目<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入题目&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputtitle&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入备注信息&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputcomment&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;line-content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>正文<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入正文&quot;</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputcontent&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">const db=wx<span class="selector-class">.cloud</span><span class="selector-class">.database</span>()</span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    dataobj:&#123;</span><br><span class="line">      comment:<span class="string">&quot;&quot;</span>,</span><br><span class="line">      content:<span class="string">&quot;&quot;</span>,</span><br><span class="line">      title:<span class="string">&quot;&quot;</span>,</span><br><span class="line">      markersid:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  inputtitle:<span class="built_in">function</span>(options)&#123;</span><br><span class="line">    <span class="selector-tag">var</span> value=options<span class="selector-class">.detail</span><span class="selector-class">.value</span></span><br><span class="line">    console<span class="selector-class">.log</span>(value)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      title:value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  inputcomment:<span class="built_in">function</span>(options)&#123;</span><br><span class="line">    <span class="selector-tag">var</span> value=options<span class="selector-class">.detail</span><span class="selector-class">.value</span></span><br><span class="line">    console<span class="selector-class">.log</span>(value)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      comment:value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  inputcontent:<span class="built_in">function</span>(options)&#123;</span><br><span class="line">    <span class="selector-tag">var</span> value=options<span class="selector-class">.detail</span><span class="selector-class">.value</span></span><br><span class="line">    console<span class="selector-class">.log</span>(value)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      <span class="attribute">content</span>:value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  submit()&#123;</span><br><span class="line">    <span class="selector-tag">var</span> mydate=new Date()</span><br><span class="line">    db<span class="selector-class">.collection</span>(&quot;databasearticles&quot;)<span class="selector-class">.add</span>(&#123;</span><br><span class="line">      data:&#123;</span><br><span class="line">        <span class="attribute">content</span>:this.data.content,</span><br><span class="line">        markersid:this.data.markersid,</span><br><span class="line">        comment:this.data.comment,</span><br><span class="line">        title:this.data.title,</span><br><span class="line">        createdate:mydate</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)<span class="selector-class">.then</span>(res=&gt;&#123;</span><br><span class="line">      console<span class="selector-class">.log</span>(&quot;数据添加成功！&quot;)</span><br><span class="line">        console<span class="selector-class">.log</span>(res)</span><br><span class="line">        wx<span class="selector-class">.navigateTo</span>(&#123;</span><br><span class="line">          url: <span class="string">&#x27;/pages/success/success&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="selector-tag">var</span> docstring=options<span class="selector-class">.docstring</span></span><br><span class="line">    console<span class="selector-class">.log</span>(docstring)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      markersid:docstring</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>wxss：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inputbox</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>:<span class="number">60</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">450</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#e4e4e4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line-content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">300</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">160</span>rpx;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#e4e4e4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line-content</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">40</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line-content</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">40</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.submit</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">180</span>rpx auto <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">98</span>rpx;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3</span>rpx solid <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">167</span>);</span><br><span class="line">  <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">167</span>);</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-direction</span>: row;</span><br><span class="line">	<span class="attribute">align-items</span>: center;</span><br><span class="line">	<span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-获取最新发布的三篇文章"><a href="#3-获取最新发布的三篇文章" class="headerlink" title="3. 获取最新发布的三篇文章"></a>3. 获取最新发布的三篇文章</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/f2b099a392ac4f8aae5218d74c035409.png" alt="在这里插入图片描述"></p>
<p>最新发布模块可以获取云数据库中最新发布的三篇文章，原理是根据时间戳倒叙排序后取前三条记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">collection</span>(<span class="string">&quot;databasearticles&quot;</span>)</span><br><span class="line">      .<span class="title function_">orderBy</span>(<span class="string">&#x27;createdate&#x27;</span>,<span class="string">&#x27;desc&#x27;</span>)</span><br><span class="line">      .<span class="title function_">limit</span>(<span class="number">3</span>)</span><br><span class="line">      .<span class="title function_">get</span>(&#123;</span><br><span class="line">        <span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">new3obj</span>:res.<span class="property">data</span><span class="comment">//new3obj 是在 data 中定义的，用来接收最新发布的三篇文章对象集合的变量</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<p>以上就是本小程序核心功能啦！希望对你有帮助！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wechat-Miniprogram/" rel="tag">Wechat Miniprogram</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：黑马程序员 Java"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/02/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Java/"
    >技术学习：黑马程序员 Java</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/02/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Java/" class="article-date">
  <time datetime="2022-05-01T23:00:00.000Z" itemprop="datePublished">2022-05-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18J411W7cE?p=1">黑马程序员全套Java教程</a>网课为主。</p>
<h1 id="Java-介绍"><a href="#Java-介绍" class="headerlink" title="Java 介绍"></a>Java 介绍</h1><p>Java是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。</p>
<p>JVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。</p>
<p>JRE: Java Runtime Environment，运行只需要 JRE 就够了。</p>
<p>JDK: Java Development Kit，Java 程序开发工具包。</p>
<pre class="mermaid"> graph LR
 A[JDK] -->B[开发人员使用的工具, JDK 的 bin 目录下]
   A --> C[JRE]
   C -->D[JVM, JRE 的 bin 目录下]
   C -->E[运行所需要的核心类库, JRE 的 lib 目录下]</pre>

<p>尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~</p>
<p>JDK 的安装目录如下：</p>
<table>
<thead>
<tr>
<th>JDK目录名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>存放工具命令，如：javac, java, etc.</td>
</tr>
<tr>
<td>conf</td>
<td>配置文件</td>
</tr>
<tr>
<td>include</td>
<td>某些平台特定的头文件</td>
</tr>
<tr>
<td>jmods</td>
<td>模块</td>
</tr>
<tr>
<td>legal</td>
<td>授权文档</td>
</tr>
<tr>
<td>lib</td>
<td>补充 JAR 包</td>
</tr>
<tr>
<td>其他</td>
<td>说明型文档</td>
</tr>
</tbody></table>
<p>环境配置等就不多赘述了，网上好的教程太多太多。总之就是终端 javac 和 java 可以执行，最好使用 IDEA 作为 IDE。</p>
<h2 id="IDEA-环境介绍"><a href="#IDEA-环境介绍" class="headerlink" title="IDEA 环境介绍"></a>IDEA 环境介绍</h2><p>集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。</p>
<p>创建项目-项目内创建模块（实现不同的功能）-模块 src 下创建包（类似文件夹，用于归纳区分不同的类）-包下创建类-类中编写代码。</p>
<p>其中，.class 文件都会放在模块同级的 out 文件夹中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201224741.png" alt="AJdw2.png"></p>
<h1 id="基础语法（重点比较与C的区别）"><a href="#基础语法（重点比较与C的区别）" class="headerlink" title="基础语法（重点比较与C的区别）"></a>基础语法（重点比较与C的区别）</h1><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p><em>使用 Notepad++ 前需要设置：<code>设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI</code>。</em></p>
<p>新建一个 <code>HelloWorld.java</code> 文件，编辑内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123; <span class="comment">// class 类名必须和文件名一致</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">//main 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">// 单独输出一行的意思。注意大小写不可以出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在DOS窗口中进入当前文件所在目录，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java //编译，得到 .class 字节码文件，可以在任何支持 java 的平台上运行</span><br><span class="line">java HelloWorld // .class 文件被解释执行，转化为可以直接在本地对应平台上运行的机器码文件</span><br></pre></td></tr></table></figure>

<p>java 和 C、C++ 一样，属于<strong>编译型语言</strong>（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释 <code>//</code> 、多行注释 <code>/* */</code> 都和C一样。还有一个文件注释 <code>/** */</code>暂时用不到，之后了解。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>字母全部小写。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>整数型：byte, short, int, long</p>
<p>浮点型：float, double</p>
<p>字符型：char</p>
<p>布尔型：boolean</p>
<p>变量的定义和 c 相似，<code>int a=10;</code> 不能重复定义和未初始化就使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> l=<span class="number">1000000L</span>;</span><br><span class="line"><span class="type">float</span> f=<span class="number">1.235F</span>; <span class="comment">//防止 long 类型和 float 类型不兼容</span></span><br></pre></td></tr></table></figure>

<p>标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。</p>
<p><em>命名规范：</em></p>
<p><em>方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法</em></p>
<p><em>类名：大驼峰命名法</em></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>+，-，*，&#x2F;，%，</p>
<p>+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;（隐含了强制类型转换）</p>
<p>++，–</p>
<p>&#x3D;&#x3D;，&gt;&#x3D;，&lt;&#x3D;，&gt;，&lt;，!&#x3D;</p>
<p>? : </p>
<p>&amp;，|，^，!（逻辑运算符）</p>
<p>&amp;&amp;，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）</p>
<p>与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">99</span>+<span class="string">&quot;string&quot;</span> <span class="comment">//&quot;100string&quot;</span></span><br><span class="line"><span class="string">&quot;string&quot;</span>+<span class="number">1</span>+<span class="number">99</span> <span class="comment">//&quot;string199&quot;，从左往右计算</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动类型转换：把小范围的变量赋值给大范围的变量</p>
<p>数据范围从小到大：</p>
<pre class="mermaid">graph LR
A[byte]-->B[short]
B-->C[int]
D[char]-->C
C-->E[long]
E-->F[float]
F-->G[double]</pre>



<p>算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。</p>
<p>强制类型转换：赋值运算符中隐含。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s=<span class="number">10</span>;		</span><br><span class="line">s+=<span class="number">10</span>;			<span class="comment">// 正常</span></span><br><span class="line">s=s+<span class="number">10</span>;			<span class="comment">// 错，因为右边发生了自动类型转换，变成了int型</span></span><br><span class="line">s=(<span class="type">short</span>)(s+<span class="number">10</span>);<span class="comment">// 也可以</span></span><br></pre></td></tr></table></figure>

<h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><p>输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//导包</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。</span></span><br><span class="line"><span class="type">int</span> i=sc.nextInt();<span class="comment">//接收数据</span></span><br><span class="line">String s=sc.nextLine();</span><br></pre></td></tr></table></figure>

<h2 id="分支、循环语句"><a href="#分支、循环语句" class="headerlink" title="分支、循环语句"></a>分支、循环语句</h2><p>if - else 语句：和 C 语言一样。</p>
<p>switch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。</p>
<p>for, while, do - while 语句，及 break continue 和 C 一样。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>Random 类，在 java.util 包下，需要导包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line">Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> n=r.nextInt(<span class="number">10</span>);<span class="comment">//[0,10)的范围内取随机数</span></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一次性声明大量<strong>同类型</strong>变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr;<span class="comment">//推荐。定义了一个 int 型的数组，数组名是 arr</span></span><br><span class="line"><span class="type">int</span> arr[];<span class="comment">//定义了一个 int 型变量，变量名是 arr 数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//静态初始化简化版</span></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//动态初始化，只申请了空间，系统赋予初始值</span></span><br><span class="line"><span class="comment">//数字类型：初始值为0.0</span></span><br><span class="line"><span class="comment">//布尔类型：初始值为 false</span></span><br><span class="line"><span class="comment">//字符串类型：初始值为&quot;&quot;</span></span><br><span class="line"><span class="comment">//引用类型：初始值为 null</span></span><br></pre></td></tr></table></figure>

<p>java 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。</p>
<h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>定义的方法中的变量放在栈内存中，使用完直接消失。</p>
<p>如<code>int a</code>，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。</p>
<p>如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]&#x3D;1, arr[1]&#x3D;2……）</p>
<p>访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。</p>
<p>因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2=arr1;</span><br><span class="line">arr2[<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">arr2[<span class="number">1</span>]=<span class="number">22</span>;</span><br><span class="line">arr2[<span class="number">2</span>]=<span class="number">33</span>;<span class="comment">//这时访问 arr1[]，发现其中的数据也变成了11,22,33</span></span><br></pre></td></tr></table></figure>

<h3 id="数组常见异常"><a href="#数组常见异常" class="headerlink" title="数组常见异常"></a>数组常见异常</h3><ol>
<li>数组越界问题，ArrayIndexOutOfException。</li>
<li>空指针异常问题，NullPointerException。（<code>arr=null</code>，表示数组不指向任何有效对象）</li>
</ol>
<h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>数组自带属性 length，通过<code>arr.length</code>就能获得数组长度。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h2><p>查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">String line=sc.nextLine();</span><br><span class="line"><span class="comment">//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。</span></span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 类型代表字符串。其内容都是被双引号引住的。</p>
<p>在 java.lang 包下，不用导包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;abc&quot;</span>;<span class="comment">//直接赋值</span></span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] c=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(c);<span class="comment">//根据字符数组创建字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;<span class="comment">//a, b, c 对应的 ascii 码</span></span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br></pre></td></tr></table></figure>

<p>字符串一旦创建不能再修改。不过多个字符串的值可以共享<code>s1=s2;</code></p>
<p><em>字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。</em></p>
<h3 id="字符串比较：-和-equals"><a href="#字符串比较：-和-equals" class="headerlink" title="字符串比较：&#x3D;&#x3D; 和 equals()"></a>字符串比较：&#x3D;&#x3D; 和 equals()</h3><p>用&#x3D;&#x3D;判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。</p>
<p>基本类型 &#x3D;&#x3D; 比较的是数据值是否相同，引用类型 <strong>&#x3D;&#x3D;</strong> 比较的是<strong>地址</strong>是否相同。</p>
<p>用字符串的成员方法 <strong>equals()</strong> 判断，是比较字符串<strong>内容</strong>是否相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] c=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//输出 false，因为 s1 s2 地址不同，只有内容是一样的</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line">String s3=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s4=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s3==s4);<span class="comment">//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。</span></span><br><span class="line">System.out.println(s3.equals(s4));<span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1==s3);<span class="comment">//输出 false</span></span><br><span class="line">System.out.println(s1.equals(s3));<span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历字符串：成员方法-length-和-charAt"><a href="#遍历字符串：成员方法-length-和-charAt" class="headerlink" title="遍历字符串：成员方法 length() 和 charAt()"></a>遍历字符串：成员方法 length() 和 charAt()</h3><p><code>s.length()</code>可以获取字符串长度。<strong>这里注意是有括号的，和数组长度 length 区分开！</strong> </p>
<p>s.charAt(i) 可以获取索引为 i 处的字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    System.out.println(s.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串可以直接用 + 号拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;World&quot;</span>;</span><br><span class="line">s1=s1+s2;<span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure>

<p>在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有”Hello “，”World”，”Hello World”三个字符串，而不是直接在”Hello “的位置上拼接”World”）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。</p>
<h3 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h3><p>查看字符串是否以指定子串结尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">s1.endsWith(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h3><p>与 String 类相比，最主要的特点在于内容可变。</p>
<p>在 java.lang 包下，不用导包。</p>
<p>构造方法：</p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder()</td>
<td>无参构造方法</td>
</tr>
<tr>
<td>StringBuilder(String s)</td>
<td>把给定的 String 字符串转换成 StringBuilder 类型的</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>append(String s)</td>
<td>在结尾拼接上字符串 s</td>
</tr>
<tr>
<td>StringBuilder reverse()</td>
<td>反转字符串</td>
</tr>
<tr>
<td>String toString()</td>
<td>把 StringBuilder 类型转换为 String 类型并返回</td>
</tr>
</tbody></table>
<p>用 StringBuilder 完成字符串拼接操作：</p>
<ol>
<li>String 类型转换为 StringBuilder 类型</li>
<li>StringBuilder 类型通过 append() 成员方法拼接字符串</li>
<li>StringBuilder 类型通过 toString() 成员方法转换为 String 类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);<span class="comment">//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举</span></span><br><span class="line">sb.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">String s1=sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用</span></span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).append(<span class="string">&quot;World&quot;</span>).toString();</span><br></pre></td></tr></table></figure>

<p>用 StringBuilder 完成字符串反转操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">String sr=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString();</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>java 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。</p>
<p>像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(形参)&#123;<span class="comment">//和 main 方法同级</span></span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;<span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line">方法名(实参);<span class="comment">//在 main 方法中调用。有返回值类型的方法建议用变量接收调用</span></span><br></pre></td></tr></table></figure>

<p>方法不能嵌套定义。</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>多个方法在一个类中，有相同的方法名，但参数不完全相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：返回值不能作为判断方法是否重载的标准！</strong>只有方法名和参数可以。</p>
<p>调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。</p>
<p><strong>形参值修改不会对实参造成影响。</strong>main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201224438.png" alt="A8wxg.png"></p>
<p>但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201223885.png" alt="A8Kh1.png"></p>
<p>如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠</p>
<p>类是对象的数据类型，是一个抽象的概念。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">    数据类型 变量;</span><br><span class="line">    数据类型 变量;</span><br><span class="line">    数据类型 变量;</span><br><span class="line">    </span><br><span class="line">    方法<span class="number">1</span>;</span><br><span class="line">    方法<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    String name;<span class="comment">//初始值为null或0或false或&quot;&quot;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">boolean</span> tail;</span><br><span class="line">    String color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Eat &quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>类的实体化。比如罗小黑，是猫类的一个实体化。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）</p>
<h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p>对象能执行的动作，如猫可以叫，可以跑。</p>
<h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 main 方法中</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">c.name=<span class="string">&quot;小黑&quot;</span>;<span class="comment">//c 的名字</span></span><br><span class="line">c.age=<span class="number">2</span>;<span class="comment">//2岁了</span></span><br><span class="line">c.tail=<span class="literal">false</span>;<span class="comment">//有尾巴</span></span><br><span class="line">System.out.println(c.age);</span><br><span class="line">c.meow();<span class="comment">//行为：猫叫</span></span><br><span class="line">c.eat(<span class="string">&quot;猫粮&quot;</span>)<span class="comment">//行为：吃饭</span></span><br></pre></td></tr></table></figure>

<p>在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。</p>
<p>对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的<strong>属性</strong>等具体内容存储在<strong>堆内存</strong>中。对象中的<strong>方法</strong>调用时则加载到<strong>栈内存</strong>中，执行完毕后出栈。</p>
<h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><p>成员变量：类中在方法外的变量（如上例中的属性变量）</p>
<p>局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类中方法外</td>
<td>方法中，或方法声明上</td>
</tr>
<tr>
<td>堆内存中</td>
<td>栈内存中</td>
</tr>
<tr>
<td>对象消失时随之消失</td>
<td>方法调用完毕而消失</td>
</tr>
<tr>
<td>有默认的初始值</td>
<td>没有默认的初始值，必须先定义、赋值才能使用</td>
</tr>
</tbody></table>
<h1 id="封装-packaging"><a href="#封装-packaging" class="headerlink" title="封装 packaging"></a>封装 packaging</h1><p>Java 的三大特性：封装、继承、多态。</p>
<p>之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age&#x3D;-30）</p>
<p>因此我们要添加一些限制。</p>
<h2 id="private-修饰符"><a href="#private-修饰符" class="headerlink" title="private 修饰符"></a>private 修饰符</h2><p>可以修饰成员变量、成员方法不<strong>直接</strong>被其他类使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br></pre></td></tr></table></figure>

<p>被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get &#x2F; set 方法。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>写在类中，作为类的方法。主要用于对象初始化。声明变量时<code>Cat c=new Cat();</code>Cat() 就是一种无参构造方法。</p>
<p>每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。<strong>建议无论是否用到构造方法，都写一个无参构造方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;&#125;<span class="comment">//我们自己加的无参构造方法，会覆盖系统默认的</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;<span class="comment">//写一部分参数的构造方法也可以</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;<span class="comment">//通过 this 赋给成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;<span class="comment">//写全参数的构造方法也可以</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main 中构造对象：</span></span><br><span class="line">Cat c1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">Cat c2=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">Cat c3=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小白&quot;</span>,<span class="number">2</span>);<span class="comment">//这些都可以，与自己写的构造方法的参数相对应。</span></span><br></pre></td></tr></table></figure>

<p>this被哪个对象调用，就代表哪个对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201256813.png" alt="AlrRQ.png"></p>
<p>然后把”林青霞” 字符串类型传入堆内存中。</p>
<h2 id="get-set"><a href="#get-set" class="headerlink" title="get &#x2F; set"></a>get &#x2F; set</h2><p>无参构造方法后用 setXxx() 方法创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;<span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age&gt;=<span class="number">0</span>&amp;&amp;age&lt;=<span class="number">20</span>)<span class="comment">//在 set 中可以添加一些限制处理</span></span><br><span class="line">	<span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span>&#123;<span class="comment">//获取值</span></span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 main 方法中赋值并获取值示例：</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">c.setName(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">System.out.print(c.getName);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。</p>
<pre class="mermaid">graph TB
C[Collection]-->L[List]-->A[ArrayList]
C-->S[Set]-->H[HashSet]
C-->Q[Queue]</pre>



<p>ArrayList 就是集合的一种。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList&lt;E&gt;"></a>ArrayList&lt;E&gt;</h2><p>在 java.util 包下，需要导包。</p>
<p>&lt;E&gt; 表示泛型，随便加一种数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; array=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList&lt;E&gt;()</td>
<td>无参构造方法</td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td>结尾添加一个元素，成功返回true</td>
</tr>
<tr>
<td>void add(index i, E e)</td>
<td>在指定索引处添加一个元素（不能越界！）</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>删除指定对象，成功返回 true</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引处的值，返回该值</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>修改指定索引处值，返回修改后的值</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回指定索引处元素</td>
</tr>
<tr>
<td>int size()</td>
<td>返回集合元素个数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">4</span>);</span><br><span class="line">array.add(<span class="number">1</span>,<span class="number">2</span>);	 <span class="comment">// 1下标位置插入2这个元素</span></span><br><span class="line">System.out.println(array);<span class="comment">//输出 array：1，2，3，4</span></span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123; <span class="comment">// 父类，基类，超类</span></span><br><span class="line">    String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">boolean</span> tail;</span><br><span class="line">	String color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123; <span class="comment">// 子类，派生类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。</p>
<p>当子类属于父类的一种时，可以使用继承。</p>
<h2 id="变量访问特点"><a href="#变量访问特点" class="headerlink" title="变量访问特点"></a>变量访问特点</h2><p>范围越小，权限越高。</p>
<p>访问优先级：子类中局部变量&gt;子类中成员变量&gt;父类中成员变量&gt;找不到就报错</p>
<p>如果想优先访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201821077.png" alt="AmPt7.png"></p>
<h2 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h2><p>构造方法的访问优先级和变量相反。即使访问子类的构造方法，也会优先访问<strong>父类的无参构造方法</strong>，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。</p>
<p>而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。</p>
<p>因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）</p>
<p>解决方法：1. 父类中补上无参构造方法</p>
<ol start="2">
<li>在子类构造方法中手动访问父类的带参构造方法来代替</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">super</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(age);<span class="comment">// 子类的带参构造方法就这样传递给父类即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不支持一个子类继承多个父类，但是允许多层基层（爷-&gt;父-&gt;子）</span></span><br></pre></td></tr></table></figure>

<h2 id="成员方法的访问特点"><a href="#成员方法的访问特点" class="headerlink" title="成员方法的访问特点"></a>成员方法的访问特点</h2><p>先在子类中寻找，找不到再去父类中寻找。</p>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>public &gt; protected &gt; 默认 &gt; private</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201821429.png" alt="Awiam.png"></p>
<h2 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h2><p>有 final 和 static。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>成员变量和成员方法被 final 修饰后，不可以被重新赋值 &#x2F; 重写。</p>
<p>类被 final 修饰后，也不可以作为父类。</p>
<p><em>引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容也不可以改变）</em></p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>被 static 修饰的成员变量在所有对象里值都是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String university;<span class="comment">//在学生类中的静态成员变量</span></span><br><span class="line"></span><br><span class="line">Student.unievrsity=<span class="string">&quot;北大&quot;</span>;<span class="comment">//统一赋值</span></span><br><span class="line">Strudent s1=<span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//university 变量的值是 &quot;北大&quot;</span></span><br><span class="line">Strudent s2=<span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//university 变量的值是 &quot;北大&quot;</span></span><br></pre></td></tr></table></figure>

<p>静态成员方法则是与类本身相关（非静态的方法是和类的具体实例对象有关，静态方法是和整个类有关），调用方式也是 <code>类名.静态方法名</code>。静态方法中不能使用 this 关键字（因为没有具体的实例对象）。此外，<strong>静态成员方法只能访问静态成员变量 &#x2F; 方法！</strong></p>
<h2 id="包-Package"><a href="#包-Package" class="headerlink" title="包 Package"></a>包 Package</h2><p>文件夹，用于存放编译后生成的 class 文件，方便管理。</p>
<p>在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ithema;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行根据路径建包</span></span><br><span class="line">javac -d . HelloWorld.java</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line">javac HelloWorld.java</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line">java com.ithema.HelloWorld</span><br></pre></td></tr></table></figure>

<h2 id="导包-import"><a href="#导包-import" class="headerlink" title="导包 import"></a>导包 import</h2><p>如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用</p>
<p><code>import B文件夹.要调用的类名;</code></p>
<p>之前对于权限的学习，我们知道：只有 public 的类可以被其他跨包无关类访问；被 protected 修饰的父类对跨包的子类可见。</p>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>之前学过方法重载，是函数名相同但是参数设置不同的函数。</p>
<p>方法重写是子类中重新定义了父类中的方法。</p>
<p>子类如果想访问父类中的方法，可以通过 super 来指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//注解，可以检查方法重写的正确性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;子类中重写方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。</li>
<li>子类的重写方法权限必须高于父类方法。（public &gt; protected &gt; 默认 &gt; private）</li>
</ol>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>同一个对象在不同时刻表现出的形态也不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//父类引用指向子类对象</span></span><br></pre></td></tr></table></figure>

<p>a 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。</p>
<h2 id="多态中成员的访问特点"><a href="#多态中成员的访问特点" class="headerlink" title="多态中成员的访问特点"></a>多态中成员的访问特点</h2><p>访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。<em>因为成员变量不会被重写</em></p>
<p>访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。</p>
<p>例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalOperator</span>(Animal a)</span><br><span class="line">&#123;</span><br><span class="line">    a.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">Dog d=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">Pig p=<span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">AnimalOperator(c);<span class="comment">// 多态</span></span><br><span class="line">AnimalOperator(d);<span class="comment">// 多态</span></span><br><span class="line">AnimalOperator(p);<span class="comment">// 多态</span></span><br></pre></td></tr></table></figure>

<p>调用的都是子类中重写的方法。</p>
<p>多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类接口就能访问（无论子类具体是哪一种）。</p>
<p>但是多态无法访问子类中特有的方法。</p>
<p>解决这一弊端的方法就是转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//向上转型，a 不能访问 Cat 类中特有的方法</span></span><br><span class="line">Cat c=(Cat)a;<span class="comment">//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。</span></span><br></pre></td></tr></table></figure>

<p>使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。<em>ClassCastException</em></p>
<h1 id="Abstract-接口"><a href="#Abstract-接口" class="headerlink" title="Abstract, 接口"></a>Abstract, 接口</h1><p>抽象方法：没有方法体的方法，待补全，请输入文本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>抽象类：含有抽象方法的类。</p>
<p>（没有抽象方法的类也可以是抽象类，但是意义何在）</p>
<p>抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象类。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Jumpping</span>&#123; <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Jump</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Jumpping</span>&#123; <span class="comment">// 实现</span></span><br><span class="line">    <span class="comment">// 重写 Jump() 方法。如果不重写， Cat 就是一个抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。</p>
<p>接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。</p>
<p>（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）</p>
<p>接口是抽象的，不能直接实例化，可以借助多态的方法实例化。</p>
<p>相较类与类之间不能多继承，只能层层继承：接口可以多实现 <code>implements interface1, interface2</code></p>
<p>接口和接口之间也可以多继承 <code>interface1 extends interface2, interface3</code></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201836142.png" alt="在这里插入图片描述"></p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。</p>
<p>但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。</p>
<p>例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。但并不是“是人就该会说英语，是运动员和教练就该会说英语”。所以说英语应当作为接口而不是人里面的抽象方法。</p>
<pre class="mermaid">graph TB
A[人]-->B[运动员]
A-->C[教练]
B-->D[篮球运动员]
B-->E[乒乓球运动员]
H[说英语]-->E
H-->G
C-->G[乒乓球教练]
C-->F[篮球教练]</pre>

<p>其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。</p>
<h2 id="抽象类-接口作为形参-返回值"><a href="#抽象类-接口作为形参-返回值" class="headerlink" title="抽象类 &#x2F; 接口作为形参 &#x2F; 返回值"></a>抽象类 &#x2F; 接口作为形参 &#x2F; 返回值</h2><p>类也可以作为形式参数或函数的返回值。</p>
<p>抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要传递的是实现了该抽象类的子类的实例对象。</p>
<p>如函数形参是Animal，实际需要通过多态的方法Animal a&#x3D;new Cat();然后把a传给函数。</p>
<p>接口作为形参&#x2F;函数返回值，和抽象类一样，实际需要的是实现了该接口的类的实例对象。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在类中定义一个类。</p>
<h2 id="内部类和外部类的互相使用"><a href="#内部类和外部类的互相使用" class="headerlink" title="内部类和外部类的互相使用"></a>内部类和外部类的互相使用</h2><p>无论外部类的成员变量的权限修饰符是什么（private, public……）因为都在同一个类中，所以即使权限修饰符是 private 也可以相互访问。</p>
<p>内部类都可以<strong>直接</strong>访问外部类的全部成员变量。</p>
<p>而外部类如果想访问内部类的成员，需要<strong>先创建一个内部类对象再访问</strong>。</p>
<h2 id="外界使用内部类"><a href="#外界使用内部类" class="headerlink" title="外界使用内部类"></a>外界使用内部类</h2><p>外界使用内部类：<code>Outer.Inner oi=new Outer().new Inner();</code></p>
<p>如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。<strong>封装</strong></p>
<h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><p>在类的成员位置定义：成员内部类</p>
<p>在类的局部定义：局部内部类。</p>
<p>局部内部类不能从外界直接创建对象，只能通过调用方法来创建类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(num);<span class="comment">//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner i=<span class="keyword">new</span> <span class="title class_">Inner</span>();<span class="comment">//在方法中创建内部对象</span></span><br><span class="line">        i.show();<span class="comment">//创建对象之后，记得调用内部方法的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>继承了另一个类，或实现了接口的子类匿名对象。</p>
<p>首先有一个父类&#x2F;接口，其中有具体的&#x2F;抽象的方法，然后匿名内部类对其进行重写&#x2F;实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口文件 inter.java 中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类文件 Outer.java 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">inter</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show();<span class="comment">// 创建匿名对象之后，记得调用成员变量</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//另一种方法：</span></span><br><span class="line">        inter i=<span class="keyword">new</span> <span class="title class_">inter</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行 j 的 jump 。</p>
<p>我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；</p>
<p>然后用多态的方式<code>jump c=new cat(); jump d=new dog();</code> 新建对象并传给 method 方法。</p>
<p>但是可以通过匿名内部类的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jo.method(<span class="keyword">new</span> <span class="title class_">jump</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫跳高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">jo.method(<span class="keyword">new</span> <span class="title class_">jump</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗跳高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>直接传一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。</p>
<h1 id="一些常用类"><a href="#一些常用类" class="headerlink" title="一些常用类"></a>一些常用类</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int abs(int a)</td>
<td>绝对值，支持 double  float int long 类型</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>向上取整，返回一个 double 值</td>
</tr>
<tr>
<td>public static double floor(double a)</td>
<td>向下取整，返回一个 double 值</td>
</tr>
<tr>
<td>public static int round(float a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td></td>
</tr>
<tr>
<td>public static int min(int a,int b)</td>
<td></td>
</tr>
<tr>
<td>public static double pow(double a,double b)</td>
<td>a 的 b 次幂</td>
</tr>
<tr>
<td>public static double random()</td>
<td>随机数，范围 [0.0,1.0)</td>
</tr>
</tbody></table>
<p>随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用<code>random()*100</code>。</p>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>不用导包，不能实例化，static</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static void exit(int status)</td>
<td>终止运行 JVM，非零表示非正常终止</td>
</tr>
<tr>
<td>public static long currentTimeMillis()</td>
<td>返回当前时间到1970年1月1日的时间间隔，以毫秒为单位</td>
</tr>
</tbody></table>
<p>currentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object 类是所有类的根类。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式。建议子类全部重写该方法</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>比较对象是否相等（默认比较地址）。重写可以比较对象内容</td>
</tr>
</tbody></table>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><p>Object 中包含 toString 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出类名@+一串哈希值。</p>
<p>一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter &#x2F; setter 一样自动生成。类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动实现</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&#123; Person:name=&quot;</span> + name +<span class="string">&quot; age=&quot;</span> + age+<span class="string">&quot;&#125;&quot;</span>;<span class="comment">// name 和 age 都是本类中的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p><code>s1.equals(s2)</code>本质上是比较两个对象的地址，肯定是 false。</p>
<p>一般也会重写&#x2F;自动生成可以比较两个对象内容是否一致的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>==o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//同一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(o==<span class="literal">null</span>||getClass()!=o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//o是空对象，或这两个对象不属于一个类</span></span><br><span class="line">    Student student=(Student) o;<span class="comment">//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来</span></span><br><span class="line">    <span class="keyword">if</span> (age!=student.age)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> name!=<span class="literal">null</span>?name.equals(student.name):student.name==<span class="literal">null</span>;<span class="comment">//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>需要导包 <code>java.util.Arrays</code>，不能创建对象，成员是 static的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static String toString(int[] a)</td>
<td>返回形如 “[a, b, c]” 的字符串形式</td>
</tr>
<tr>
<td>public static void sort(int[] a)</td>
<td>按数字顺序排列指定的数组</td>
</tr>
</tbody></table>
<h2 id="补充：工具类"><a href="#补充：工具类" class="headerlink" title="补充：工具类"></a>补充：工具类</h2><p>以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。比如 <code>Arrays.sort(arr);</code></p>
<p>以下这些方法不能创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Math</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Arrays</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">System</span><span class="params">()</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>因为这些类自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。</p>
<h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>其中有一些方法能更好地处理基本数据类型。</p>
<p>包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p>
<h3 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Integer valueOf(int i)</td>
<td>把 int 转换为 Integer 类型</td>
</tr>
<tr>
<td>public static Integer valueOf(String s)</td>
<td>把 String 转换为 Integer 类型</td>
</tr>
</tbody></table>
<p>public String[] split(String regex) 把给定字符串用 regex 分隔开。</p>
<p>如给定字符串 s 是”1 2 3 4”，<code>s.split(&quot; &quot;)</code>就会得到4个字符串：”1””2””3””4”。</p>
<h3 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h3><p>int -&gt; String：</p>
<p>① 空字符串+int 类型 <code>&quot;&quot;+123</code></p>
<p>② <code>String s=String.valueOf(i);</code></p>
<p>String -&gt; int：</p>
<p>① <code>Integer in=Integer.valueOf(s);</code></p>
<p><code>int i=intValue(in);</code></p>
<p>② <code>int i=Integer.parseInt(s);</code></p>
<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>装箱：基本类型-&gt;对应的包装类型</p>
<p>拆箱：包装类型-&gt;基本类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i=Integer.valueOf(<span class="number">100</span>);<span class="comment">//装箱</span></span><br><span class="line">Integer ii=<span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line">ii=ii.intValue()+<span class="number">200</span>;<span class="comment">//拆箱</span></span><br><span class="line">ii+=<span class="number">200</span>;<span class="comment">//自动拆箱</span></span><br><span class="line"></span><br><span class="line">Integer i3=<span class="literal">null</span>;</span><br><span class="line">i3+=<span class="number">300</span>;<span class="comment">//NullPointerException。因此对象使用之前最好先判断是否为 null</span></span><br></pre></td></tr></table></figure>

<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>Date 类，需要导包。<strong>注意是 java.util 下的，而不是 java.sql 下的！</strong>java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒</td>
</tr>
<tr>
<td>public Date(long Date)</td>
<td>分配一个 Date 对象，值为从标准时间起指定的毫秒数</td>
</tr>
<tr>
<td>public long getTime()</td>
<td>获取日期对象从标准时间到现在的毫秒数</td>
</tr>
<tr>
<td>public void setTime(long time)</td>
<td>设置时间，单位为毫秒</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> d=<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">Date da=<span class="keyword">new</span> <span class="title class_">Date</span>(d);<span class="comment">//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> time=System.currentTimeMillis();<span class="comment">//可以这样获取当前时间，然后传给 Date() 或 setTime()</span></span><br></pre></td></tr></table></figure>

<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>可以自己设置日期格式。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SimpleDateFormat()</td>
<td>构造方法，并使用系统默认的 Date 格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造方法，并使用自己规定的格式</td>
</tr>
<tr>
<td>public final String format(Date d)</td>
<td>将日期对象转换为相应格式的字符串</td>
</tr>
<tr>
<td>public final Date parse(String s)</td>
<td>将字符串转换为日期</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Parse Exception&#123;<span class="comment">//结尾要加一些东西，在 IDEA 中可以自动补全</span></span><br><span class="line">    Date d=<span class="keyword">new</span> <span class="title class_">Date</span>;<span class="comment">//被分配时的时间</span></span><br><span class="line">    SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年-MM月-dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">    String s=sdf.format(d);</span><br><span class="line">    System.out.println(s);<span class="comment">//输出格式就形如 2022年-05月-05日 10:24:00</span></span><br><span class="line">    </span><br><span class="line">    String ss=<span class="string">&quot;2022-05-05 10:24:00&quot;</span>;</span><br><span class="line">    SimpleDateFormat sdf1=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    Date d1=sdf1.parse(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>y 年 M 月 d 日</p>
<p>H 时 m 分 s 秒</p>
<p>（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把 Date 转换为 String 和把String转换为Date；这两个方法可以设置两个传入参数：</p>
<p><code>public static String dateToString(Date d, String format)</code></p>
<p><code>public static String StringTodate(String s, String format)</code></p>
<p>在方法内根据传入的字符串格式，利用 SimpleDateFormat 的方法进行转换。）</p>
<h3 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h3><p>需要导包<code>java.util.Calendar</code>，是一个抽象类。</p>
<p>为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。</p>
<p>Calendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar rightnow=Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<p>其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int get(int field)</td>
<td>获取给定日历字段的值</td>
</tr>
<tr>
<td>public abstract void add(int field, int amount)</td>
<td>添加&#x2F;减去给定的日历字段</td>
</tr>
<tr>
<td>public final void set(int year, int month, int date)</td>
<td>设置日历的年月日</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">y=c.get(Calendar.YEAR);</span><br><span class="line">m=c.get(Calendar.MONTH)+<span class="number">1</span>;<span class="comment">//month 是从0开始的，所以要+1</span></span><br><span class="line">d=c.get(Calendar.DATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例：求2020年2月有多少天?</span></span><br><span class="line">Calendar c=Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//设置为3月1日</span></span><br><span class="line">c.add(Calendar.DATE,-<span class="number">1</span>);<span class="comment">//倒退1天，就是2月的最后一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;2020年2月有&quot;</span>+c.get(Calendar.DATE)+<span class="string">&quot;天&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。</p>
<h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>Throwable 是所有错误、异常的父类。</p>
<pre class="mermaid">graph LR
A[Throwable]-->B[Error]
A-->C[异常]
C-->R[RuntimeException <br> 运行型异常]
C-->O[其他 <br> 编译型异常]</pre>

<p>Error 程序无法处理，而异常程序可以处理。</p>
<p>RuntimeException：运行时异常，非受检异常， 可以先不处理，等到真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。比如数组越界。</p>
<p>编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。</p>
<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>JVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。</p>
<p>程序员还可以有自己的处理异常方法，如 try…catch 和 throw。</p>
<h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能出现异常的代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">    出现异常后的处理代码;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s=<span class="string">&quot;2022-05-07&quot;</span>;</span><br><span class="line">SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line">sdf.parse(s);<span class="comment">// 这个方法不能直接用，必须要加异常处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    sdf.parse(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ParseException e)&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;parseException!&quot;</span>);<span class="comment">//不管会不会发生异常，都要写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，<strong>处理完成后可以继续执行。</strong></p>
<p>如果异常变量命名为 e ,调用 e 的成员方法 <code>e.printStackTrace()</code> 就会输出平时出现异常时系统默认提示的信息：<code>java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... </code></p>
<p>但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。</p>
<h3 id="Throwable-的成员方法"><a href="#Throwable-的成员方法" class="headerlink" title="Throwable 的成员方法"></a>Throwable 的成员方法</h3><p>Throwable 作为超类，其所有子类都可以使用他的成员方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String getMessage()</td>
<td>返回此 Throwable 的详细消息字符串</td>
</tr>
<tr>
<td>public String toString()</td>
<td>返回此可抛出的简短描述</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>把异常的错误信息输出到控制台</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.getMessage():  Index 3 out of bounds for length 3</span><br><span class="line">e.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span><br><span class="line">e.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....</span><br></pre></td></tr></table></figure>

<p>利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Throwable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String detailMessage;<span class="comment">//Throwable 类中的一个成员方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        detailMessage=message;<span class="comment">//构造方法。出现异常时，会通过这种方法构造一个异常对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> detailMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a>Throws</h2><p>可以抛出异常给 try catch 处理，但是自身不能解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throws</span> 异常类名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">    method1();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        method2();<span class="comment">//抛出给了 try catch 处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ParseException e)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfException&#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);<span class="comment">//会报错并停止运行，throws 并没有解决数组越界这个异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">    String s=<span class="string">&quot;2022-05-07&quot;</span>;</span><br><span class="line">	SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line">	sdf.parse(s);<span class="comment">//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    无参构造</span><br><span class="line">    带参构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">(message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);<span class="comment">//把 message 传给父类处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异常类的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">throws</span> ScoreException&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">0</span>||score&gt;<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScoreException</span>(<span class="string">&quot;输入分数有误！请重新输入&quot;</span>);<span class="comment">//throw 不是 throws!</span></span><br><span class="line">            <span class="comment">/*throw 写在方法体内，throws 写在类定义里。</span></span><br><span class="line"><span class="comment">            throws 不一定有异常，而 throw 一定是抛出了异常。*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;分数正常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> score=sc.nextInt();</span><br><span class="line">    Teacher t=<span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//调用方法时，要处理抛过来的异常</span></span><br><span class="line">        t.checkScore(score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ScoreException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常时就会输出：异常类型 ScoreException，异常原因&quot;输入分数有误！请重新输入&quot;，异常位置。</span></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：Data Structure 数据结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
    >北邮国院笔记：Data Structure 数据结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2021-09-30T23:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为考试要求，博主学习的是双语的数据结构，因此自己总结一些英文的概念、知识点。希望也可以对读者学习这门课程有所帮助~<br>特别感谢许可老师的教导！</p>
<p>理解时间复杂度的定义<br>（本课程涉及到的所有算法，都需要记住时间复杂度O）</p>
<h1 id="Data-structure-notes"><a href="#Data-structure-notes" class="headerlink" title="Data structure notes"></a>Data structure notes</h1><p>Program &#x3D; Algorithm + Data Structure<br>An algorithm is a finite set of instructions that, fi followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:</p>
<ul>
<li>   Input</li>
<li>   Output</li>
<li>   Definiteness</li>
<li>   Finiteness</li>
<li>   Effectiveness</li>
</ul>
<p><em>Note:<br>A program is written in some programming language, and does not have to be finite.<br>An algorithm can be described by human languages, flow charts, some programming languages, or pseudocode.</em></p>
<p>引入 time complexities 和 space complexities 的概念。</p>
<p>$2^n^&gt;n^2^&gt;nlogn&gt;n&gt;logn&gt;1$</p>
<h1 id="单词："><a href="#单词：" class="headerlink" title="单词："></a>单词：</h1><p>Algorithm 算法<br>Definiteness 确定性<br>Finiteness 有限性<br>Effectiveness 有效性<br>Finite 有限的<br>Pseudocode 伪代码<br>Assumptions 假设<br>Asymptotic 渐近线的，渐近的<br>Notation 记号，标记法<br>For loops for循环<br>Nested 嵌套<br>Consecutive statements 顺序语句<br>Fibonacci 斐波那契<br>Euclid 欧几里得<br>Exponentiation 幂<br>Pow 指数</p>
<p>【表】<br>理解链表、数组的特点（优缺点）<br>会代码实现：单链表 循环链表 双向链表……</p>
<p><em>【栈和队列】</em><br><em>理解原理，会算法：两种实现方法</em><br><em>会应用算法，如：中序后序互转；前中后缀表达式互换；栈（队列）操作后的状态</em></p>
<h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p><strong>ADT(Abstract Data Type)</strong> is a data type that is organized in such a way that the <strong>specification</strong>  on the objects and <strong>specification</strong> of the operations on the objects are <strong>separated from</strong> the <strong>representation</strong> of the objects and the <strong>implementation</strong> on the operations.</p>
<h1 id="The-List-ADT"><a href="#The-List-ADT" class="headerlink" title="The List ADT"></a>The List ADT</h1><ol>
<li>   Array implementation<ul>
<li><pre><code>**MaxSize** has to be estimated. （大小必须事先给出。给小了数组越界；(可以再申请)给大了太浪费空间）
</code></pre>
</li>
<li><pre><code>**Find_Kth** takes O(1) time. （随机存取）
</code></pre>
</li>
<li><pre><code>**Insertion and Deletion** not only take O(N) time, but also involve a lot of data movements which takes time.（插入删除不方便，需要移动大量元素；存储密度高）
</code></pre>
</li>
</ul>
</li>
<li>   Linked Lists（是否带有头结点）<ul>
<li>   三种操作：Find_Kth、Find_Value、Find_Length take O(N) time. 注意循环逻辑，以及有无头结点时对边界情况的处理</li>
<li>   找前一个结点不方便，只能重新从头遍历、</li>
</ul>
</li>
</ol>
<h2 id="Doubly-Linked-Lists"><a href="#Doubly-Linked-Lists" class="headerlink" title="Doubly Linked Lists"></a>Doubly Linked Lists</h2><p>找前一个结点更方便。注意初始化、插入、删除、双向遍历的区别。</p>
<h2 id="Circular-Lists"><a href="#Circular-Lists" class="headerlink" title="Circular Lists"></a>Circular Lists</h2><p>头尾相接的单链表。注意判空条件（<code>L-&gt;Next==L</code>）、判断表尾结点条件(<code>p-&gt;Next==L</code>)以及插入删除时修改的操作。<br>双向循环链表不再赘述。</p>
<h2 id="Application-The-polynomial-ADT"><a href="#Application-The-polynomial-ADT" class="headerlink" title="Application: The polynomial ADT"></a>Application: The polynomial ADT</h2><p>多项式求和、求积函数，使用链表更好，因为如果出现形如x^100000^+x^5^+x^1^这种，数组会浪费大量空间，而单链表只需要将系数非0的部分申请空间创造结点。<br>（也可以建立十字链表，两个维度分别存储系数和指数）</p>
<h2 id="Cursor-Implementation-of-Linked-Lists-no-pointer"><a href="#Cursor-Implementation-of-Linked-Lists-no-pointer" class="headerlink" title="Cursor Implementation of Linked Lists (no pointer)"></a>Cursor Implementation of Linked Lists (no pointer)</h2><p>可以使用一个游标int Cursor来作为指针，游标移动访问数组，从而实现类似于指针移动的操作。<br>The cursor implementation is usually significantly <strong>faster</strong> because of the lack of memory management routines.</p>
<h1 id="The-Stack-ADT"><a href="#The-Stack-ADT" class="headerlink" title="The Stack ADT"></a>The Stack ADT</h1><p>A Stack is a <strong>Last-in-First-Out (LIFO)</strong> list. An ordered list in which insertions and deletion are made at the top only.<br>类似于一堆书，放书和拿书都只能从最顶上进行。最后放上的书最早被拿出来。<br>Push: 入栈<br>Top: 读取并返回栈顶元素<br>Pop: 栈顶元素出栈</p>
<h2 id="Application-1-Balancing-symbols-括号匹配"><a href="#Application-1-Balancing-symbols-括号匹配" class="headerlink" title="Application 1: Balancing symbols 括号匹配"></a>Application 1: Balancing symbols 括号匹配</h2><p>输入一串表达式，判断其中的括号()[]{}是否匹配。<br>检验方法：每个右括号都和离他最近的，也就是最晚输入的左括号匹配，正符合栈的后进先出原则。<br>读到左括号的时候入栈，读到右括号的时候与栈顶的左括号比较，比较后出栈。<br>最后结束输入，还要检查一下栈是否为空，若非空，栈内剩下的括号全都不匹配。<br><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/1%20STACK/7-1%20Balancing%20Symbols.cpp">7-1 Balancing symbols 代码实现</a></p>
<h2 id="Application-2-Postfix-Evaluation-后缀表达式的计算"><a href="#Application-2-Postfix-Evaluation-后缀表达式的计算" class="headerlink" title="Application 2: Postfix Evaluation 后缀表达式的计算"></a>Application 2: Postfix Evaluation 后缀表达式的计算</h2><p>Infix expression中缀表达式： a + b * c - d &#x2F; e<br>Prefix expression 前缀表达式：- + a * b c &#x2F; d e<br>Postfix expression 后缀表达式： a b c * + d e &#x2F; -<br>中缀表达式更符合人脑的计算方法，而后缀表达式更符合计算机的计算方法。<br>实际上在计算机中计算表达式，是先转化为postfix expression，再进行计算的。<br>转换方法：<br>建立堆栈。</p>
<ol>
<li>   读入的字符是操作数：直接输出</li>
<li>   读入的字符是操作符：<br> a)	堆栈是空的，则直接存入堆栈中（push）<br> b)	该操作符的优先级&gt;栈顶元素操作符，则直接入栈（push）<br> c)	该操作符的优先级&lt;&#x3D;栈顶元素操作符，则栈顶元素出栈（pop），直到该操作符的优先级大于栈顶元素（这个栈顶元素也要出栈），然后该操作符入栈（push）<br> d)	操作符是左括号，则直接入栈（pop），遇到右括号之前永不输出<br> e)	操作符是右括号，则一直出栈（pop）直到左括号出栈<br> f)	最终输入结束，栈若非空，栈中元素全部出栈。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/1%20STACK/7-2%20Infix%20to%20Postfix%20Conversion.cpp">7-2 Infix to postfix Conversion 代码实现</a></p>
<h1 id="The-Queue-ADT"><a href="#The-Queue-ADT" class="headerlink" title="The Queue ADT"></a>The Queue ADT</h1><p>A Queue is a <strong>First-In-First-Out (FIFO)</strong> list. An ordered list in which insertions take place at one end and deletions take place at the opposite end.<br>就像日常生活中的排队，先来后到，先排的有机会先出。<br>EnQueue: 入队<br>DeQueue: 出队</p>
<h2 id="Circular-Queue：循环链表"><a href="#Circular-Queue：循环链表" class="headerlink" title="Circular Queue：循环链表"></a>Circular Queue：循环链表</h2><h2 id="Application-who-is-the-last"><a href="#Application-who-is-the-last" class="headerlink" title="Application: who is the last"></a>Application: who is the last</h2><p>输入n、m；n个人坐成一个圈，从第一个人开始报数，每m个人淘汰掉第m个人，然后下一个人继续重新报数。问：谁能留到最后？<br><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/2%20QUEUE/7-4%20who%20is%20the%20last.cpp">7-4 who is the last 代码实现</a></p>
<p>树<br>【基本概念】各类树的度、高、深、节点数与叶子节点的关系；孩子兄弟节点树；<br>【二分检索树】：概念 平衡二叉树 完全二叉树 满二叉树 AVL树…… 会插入 删除；<br>【遍历树】：先序 后序 中序 层序；会代码创建树和检索、会执行画图<br>【B-树】：会画图 构建B-树，增加节点，删除节点 B-树<br>【霍夫曼树】：理解原理 给出数据 会画霍夫曼树的图；节点关系<br>理清各种树之间的关系</p>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="Conception"><a href="#Conception" class="headerlink" title="Conception"></a>Conception</h2><ul>
<li>degree of a node: number of its subtrees</li>
<li>degree of a tree: max{degree(node)}</li>
<li>parent;children;siblings</li>
<li>leaf:a node with degree 0</li>
<li>path from n_1 to n_k: a <strong>unique</strong> sequence of n_1, n_2 …… n_k (n_i is the parent of n_{i+1})</li>
<li>length of path: number of <strong>edges</strong> on the path</li>
<li>depth of n_i: path to root (depth(root)&#x3D;0)</li>
<li>height of n_i：length of the longest path from n_i to a leaf.(Height(leaf)&#x3D;0)</li>
<li>ancestors of anode: all the nodes along the path from the node up to the root</li>
<li>descendants of a node: all the nodes in its subtrees</li>
</ul>
<h2 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h2><h3 id="FirstChild-NextSibling-Representation"><a href="#FirstChild-NextSibling-Representation" class="headerlink" title="FirstChild-NextSibling Representation"></a>FirstChild-NextSibling Representation</h3><p>Each Node carries its element and 2 pointers. The first points its FirstChild; The second points its NextSibling.<br><em>This representation is <strong>not unique</strong> since the children in a tree can be of any order.</em></p>
<h3 id="Binary-Trees"><a href="#Binary-Trees" class="headerlink" title="Binary Trees"></a>Binary Trees</h3><p>a tree in wh ich no node can have more than 2 children.<br><em>Rotate the FirstChild-NextSibling tree clockwise by 45°</em></p>
<h2 id="Tree-Traversals-significant"><a href="#Tree-Traversals-significant" class="headerlink" title="Tree Traversals (significant!)"></a>Tree Traversals (significant!)</h2><h3 id="Preorder-Traversal"><a href="#Preorder-Traversal" class="headerlink" title="Preorder Traversal"></a>Preorder Traversal</h3><p>visit This Node first;<br>visit its child recursively.</p>
<h3 id="Postorder-Traversal"><a href="#Postorder-Traversal" class="headerlink" title="Postorder Traversal"></a>Postorder Traversal</h3><p>visit its child recursively;<br>At last, visit this node itself.</p>
<h3 id="Levelorder-Traversal"><a href="#Levelorder-Traversal" class="headerlink" title="Levelorder Traversal"></a>Levelorder Traversal</h3><p>visit Tree via a queue.</p>
<ul>
<li>Enqueue root node;</li>
<li>while(queue is not empty){</li>
<li>visit first node in queue and Dequeue;</li>
<li>for its each child, enqueue.}</li>
</ul>
<h3 id="Inorder-Traversal-for-binary-trees"><a href="#Inorder-Traversal-for-binary-trees" class="headerlink" title="Inorder Traversal(for binary trees)"></a>Inorder Traversal(for binary trees)</h3><p>Recursive:</p>
<ul>
<li>visit left tree recursively.</li>
<li>visit root node.</li>
<li>visit left tree recursively.<br>Iterative:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iter_inorder</span><span class="params">(Tree)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack S;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;tree;tree=tree-&gt;Left)Push(tree,S);</span><br><span class="line">		tree=Top(S);Pop(S);</span><br><span class="line">		<span class="keyword">if</span>(!tree)<span class="keyword">break</span>;</span><br><span class="line">		visit(tree-&gt;Element);</span><br><span class="line">		tree=tree-&gt;Right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inorder traversal: infix expression<br>preorder traversal: prefix expression<br>postorder traversal: postfix expression<br><em>Depth is a evry important conception. we can use a function to calculate it:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ListDir</span><span class="params">(DirOrFile D,<span class="type">int</span> Depth)</span><span class="comment">//at first, Depth is 0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(D is a legitimate entry)&#123;</span><br><span class="line">		PrintName(D,Depth);</span><br><span class="line">		<span class="keyword">if</span>(D is a directory)</span><br><span class="line">			<span class="keyword">for</span>(each child C of D)</span><br><span class="line">				ListDir(C,Depth+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Threaded-Binary-Trees"><a href="#Threaded-Binary-Trees" class="headerlink" title="Threaded Binary Trees"></a>Threaded Binary Trees</h2><ul>
<li>If tree-&gt;Left is null, 指向中序遍历的前一个结点  a pointer to the inorder predecessor of Tree.</li>
<li>If tree-&gt;Right is null, 指向中序遍历的前一个结点  a pointer to the inorder successor of Tree.</li>
<li>最开头、最结尾结点的左、右指针指向head node. There must not be any loose threads. Therefore a threaded binary tree must have a <strong>head node</strong> of which the left child points to the first node.</li>
</ul>
<h2 id="The-Search-Tree-ADT-–-Binary-Search-Trees"><a href="#The-Search-Tree-ADT-–-Binary-Search-Trees" class="headerlink" title="The Search Tree ADT – Binary Search Trees"></a>The Search Tree ADT – Binary Search Trees</h2><ul>
<li>Every node has a key which is an integer, and it’s distinct.</li>
<li>The keys in a nonempty <strong>left</strong> subtree must be <strong>smaller</strong> than the key in the root of the subtree.</li>
<li>The keys in a nonempty <strong>right</strong> subtree must be <strong>larger</strong> than the key in the root of the subtree.</li>
<li>The left and right subtrees are also binary search trees.</li>
</ul>
<p>insert is quite easy while delete not.<br>Delete:</p>
<ul>
<li>if it’s leaf node:just delete it.</li>
<li>if it’s degree is 1: use its child to replace it.</li>
<li>if it’s degree is 2: use the <strong>largest</strong> node in its <strong>left</strong> subtree or the <strong>smallest</strong> node in its <strong>right</strong> subtree to replace it.<br><em>will the lazy deletion be in the scope of final exam?</em><br><strong>Internal path length: O(Nlog N);depth of any node is O(log N)</strong><br>要会计算Average Search Time (AST)<br><em>If you print Binary Search Tree inorder, then it is an increasing order.</em></li>
</ul>
<p>Get Depth: preorder traversal</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Height</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ekse <span class="keyword">return</span> <span class="number">1</span>+Max(Height(T-&gt;Left),Height(T-&gt;Right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AVL-Trees"><a href="#AVL-Trees" class="headerlink" title="AVL Trees"></a>AVL Trees</h2><p>If the tree is too high, AST can be very large and time complexities is O(N). So we need to balance the height by rotating.<br><strong>If |h_L-h_R|&gt;1,rotate.</strong></p>
<ul>
<li>Single Rotation: Trouble is left subtree’s left subtree or right subtree’s right subtree.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tree <span class="title function_">SingleRotatewithLeft</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	TreeNode LeftTree = T-&gt;LeftChild;</span><br><span class="line">	T-&gt;LeftChild = LeftTree-&gt;RightChild;</span><br><span class="line">	LeftTree-&gt;RightChild = T;</span><br><span class="line">	<span class="keyword">return</span> LeftTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">SingleRotatewithRight</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	TreeNode RightTree = T-&gt;RightChild;</span><br><span class="line">	T-&gt;RightChild = RightTree-&gt;LeftChild;</span><br><span class="line">	RightTree-&gt;LeftChild = T;</span><br><span class="line">	<span class="keyword">return</span> RightTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double Rotation: Trouble is left subtree’s right subtree or right subtree’s left subtree.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tree <span class="title function_">DoubleRotatewithLeft</span><span class="params">(Tree T)</span> 			</span><br><span class="line">&#123;</span><br><span class="line">	T-&gt;LeftChild = SingleRotatewithRight(T-&gt;LeftChild);</span><br><span class="line">	<span class="keyword">return</span> SingleRotatewithLeft(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">DoubleRotatewithRight</span><span class="params">(Tree T)</span> 			</span><br><span class="line">&#123;</span><br><span class="line">	T-&gt;RightChild = SingleRotatewithLeft(T-&gt;RightChild);</span><br><span class="line">	<span class="keyword">return</span> SingleRotatewithRight(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Trees-要会插入、建立"><a href="#B-Trees-要会插入、建立" class="headerlink" title="B Trees 要会插入、建立"></a>B Trees 要会插入、建立</h2><h3 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h3><p>考完试补全<br>$$<br>Depth(M,N)&#x3D;O(log_{[M&#x2F;2]}N)<br>$$</p>
<p>$$<br>T_{Find}(M,N)&#x3D;O(log N)<br>$$</p>
<h2 id="Forest-Empty"><a href="#Forest-Empty" class="headerlink" title="Forest Empty"></a>Forest Empty</h2><h2 id="Huffman-Tree"><a href="#Huffman-Tree" class="headerlink" title="Huffman Tree"></a>Huffman Tree</h2><p>Weighted Path Length, WPL<br>$$<br>WPL&#x3D;\sum^k_{i&#x3D;1}w_i*l_i<br>$$<br>Huffman Tree: the binary tree with the minimum weighted path length.<br>0 is appended to left branch,<br>1 is appended to right branch.</p>
<p>哈希<br>要求：<br>会算法 给出散列函数 会画图 会计算比较成功的次数 比较失败的次数 平均查找时间<br>【分离链接法】<br>【开放定址法】线性探测法 平方探测法 双散列<br>【再散列】</p>
<h1 id="HASHING"><a href="#HASHING" class="headerlink" title="HASHING"></a>HASHING</h1><p>散列表（hashing table）的实现叫散列（hashing）散列是一种用于以常数时间执行插入、删除和查找的技术，但不能排序。<br>散列函数（hashing function）是关键字被映射到0～TableSize-1范围内的函数。</p>
<ul>
<li>must be easy to compute and minimizes the number of collisions.</li>
<li>Should be unbiased. For any x and any i, we have that probability(f(x)&#x3D;i)&#x3D;1&#x2F;b. (Uniform hash function)<br>** f(x)&#x3D;x%TableSize**<br>TableSize&#x3D;prime number is good for random integer keys.</li>
</ul>
<h2 id="处理冲突的办法"><a href="#处理冲突的办法" class="headerlink" title="处理冲突的办法"></a>处理冲突的办法</h2><h3 id="open-addressing-开放定址法"><a href="#open-addressing-开放定址法" class="headerlink" title="open addressing 开放定址法"></a>open addressing 开放定址法</h3><p>find another empty cell to solve collision </p>
<h4 id="Linear-Probing-线性探测法"><a href="#Linear-Probing-线性探测法" class="headerlink" title="Linear Probing 线性探测法"></a>Linear Probing 线性探测法</h4><p>f(i)&#x3D;i (a linear function)<br>如果对应位被占了，则往下继续寻找空位。<br>下一位是否为空？若为空放入，若不为空检查下一位；<br>再下一位是否为空？……<br>查找：先去对应位找，如果没找到再继续往下遍历。</p>
<h4 id="Quadratic-Probing-平方探测法"><a href="#Quadratic-Probing-平方探测法" class="headerlink" title="Quadratic Probing 平方探测法"></a>Quadratic Probing 平方探测法</h4><p>f(i)&#x3D;i^2^<br>如果对应位被占了，则+1^1；<br>若这一位也被占了，则原位置+2^2；<br>……<br>（也有的算法是+-i^2）<br>最大加到（n&#x2F;2）的平方<br>查找：先去对应位找，如果没找到再去加1、加4等等位找。</p>
<h4 id="Double-Hashing-双散列法"><a href="#Double-Hashing-双散列法" class="headerlink" title="Double Hashing 双散列法"></a>Double Hashing 双散列法</h4><p>第一个散列函数冲突时，使用第二个散列函数。<br><strong>hash2(x)必须不恒等于0！</strong><br><em>Tips: hash2(x)&#x3D;R-(x%R) with R a prime smaller than TableSize, will work well.</em></p>
<h3 id="Rehashing-再散列"><a href="#Rehashing-再散列" class="headerlink" title="Rehashing 再散列"></a>Rehashing 再散列</h3><p>当插入数据达到N&#x2F;2时，再散列。</p>
<ul>
<li>建立一个原表的二倍大的表（接近原表二倍大的素数）</li>
<li>从原表中读取数据，用新hash function 存到新表中。</li>
</ul>
<p>堆<br>【二叉堆】<br>要求：会构建堆 插入 删除； 画图，手动执行中间数据；</p>
<h1 id="Piority-Queue-Heap"><a href="#Piority-Queue-Heap" class="headerlink" title="Piority Queue(Heap)"></a>Piority Queue(Heap)</h1><p>Can find the element with the highest \ lowest priority.</p>
<table>
<thead>
<tr>
<th></th>
<th>Insertion</th>
<th>Deletion</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>O(1)</td>
<td>find:O(n) delete:O(n)</td>
</tr>
<tr>
<td>Linked List</td>
<td>O(1)</td>
<td>find:O(n) delete:O(n)</td>
</tr>
<tr>
<td>Ordered Array</td>
<td>find:O(1) insert:O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Ordered Linked List</td>
<td>find:O(1) insert:O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>## complete binary tree</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Its nodes correspond to the nodes numbered from 1 to n in the perfect binary tree of height h.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A complete binary tree of height h has between 2^h and 2^{h+1}-1 nodes.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Array representation: BT[n+1](BT[0]is not used)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>For node i:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- parent: i&#x2F;2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- left child: 2*i</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- right child: 2*i+1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>A min tree</strong> is a tree in which the key value in each node is no larger than the key values in its children.<br><strong>A min heap</strong> :a complete binary tree + a min tree. And the max heap is visa versa.</p>
<h2 id="Insertion-Min-Heap"><a href="#Insertion-Min-Heap" class="headerlink" title="Insertion(Min Heap)"></a>Insertion(Min Heap)</h2><p>Because a heap is a complete binary tree, the nth node only has one possible position to insert. Then, if nth node is smaller than its parent:exchange upward will its location is proper.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = ++H-&gt;Size; H-&gt;Elements[ i / <span class="number">2</span> ] &gt; X; i /= <span class="number">2</span> ) </span><br><span class="line">	H-&gt;Elements[ i ] = H-&gt;Elements[ i / <span class="number">2</span> ]; </span><br><span class="line"></span><br><span class="line">     H-&gt;Elements[ i ] = X; </span><br></pre></td></tr></table></figure>

<p><em>Another kind of Insertion is: insert all nodes first, then adjust their location. We need to check from n&#x2F;2 node. If its children node is smaller than it, choose the smallest node and exchange them. n&#x2F;2 node go downward until reach the proper location. Then do the same thing to the n&#x2F;2-1 node until the first node.</em></p>
<h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>We only need to delete the root node——the smallest node.</p>
<ul>
<li>Exchange the root node with the last node——the nth node.</li>
<li>do the same thing mentioned above in the Italic text: re-arrange the new node.</li>
<li>Iteratively delete root node until delete the whole heap.<br>*<em>Those 2 operations’ time complexity are O(log N). Insertion all node is O(nlogn).</em></li>
</ul>
<p><em>For the perfect binary tree of height h containing 2h+1 - 1 nodes, the sum of the heights of the nodes is 2h+1 - 1 - (h + 1).</em></p>
<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><p>G:graph</p>
<p>V:finite nonempty set of vertices</p>
<p>E:finite set of edges</p>
<p>Undirected graph: $(v_i,v_j)$ <em>v_i and v_j are adjacent</em></p>
<p>Directed graph: $&lt;v_i,v_j&gt;$ <em>v_i is adjacent to v_j;v_j is adjacent from v_i</em></p>
<p><strong>Complete Graph</strong>: a graph that has the maximum number of edges</p>
<p><strong>Subgraph</strong></p>
<p><strong>Path from v_p to v_q</strong></p>
<p><strong>Length of a path</strong></p>
<p><strong>Simple path</strong>: v_i1, v_i2 …… v_in are distinct (on the path)  路径上的顶点不重复出现</p>
<p><strong>Cycle</strong> Simple path with v_p &#x3D; v_q</p>
<p><strong>A graph is connected</strong>: every pair of distinct v_i and v_j are connected  图中任意两点都连通</p>
<p><strong>Connected Component of an undirected G</strong>: the maximal connected subgraph</p>
<p><strong>A tree</strong>: a graph that is connected and  acyclic</p>
<p><strong>A DAG</strong>: a directed acyclic graph  有向无环图</p>
<p><strong>Strongly connected directed graph G</strong>: for every pair of v_i and v_j in V(G), there exist directed paths from v_i to v_j and from v_j to v_i.<br>(Graph without direction: <strong>weakly connected</strong>)</p>
<p><strong>Stronhly connected component</strong>: the maximal subgraph that is strongly connected</p>
<p><strong>Degree(v)</strong>: in-degree and out-degree  进入某个顶点的边数和传出该顶点的边数</p>
<h2 id="Representation-of-Graphs"><a href="#Representation-of-Graphs" class="headerlink" title="Representation of Graphs"></a>Representation of Graphs</h2><h3 id="Adjacency-Matrix-邻接矩阵法"><a href="#Adjacency-Matrix-邻接矩阵法" class="headerlink" title="Adjacency Matrix 邻接矩阵法"></a>Adjacency Matrix 邻接矩阵法</h3><p>二维矩阵存储边信息。如果v_i to v_j 有边，adj_mat[i][j]&#x3D;1，否则&#x3D;0.（undirected graph还要考虑双向，同时也要让adj_mat[j][i]&#x3D;1）</p>
<h3 id="Adjacency-Lists-邻接表法"><a href="#Adjacency-Lists-邻接表法" class="headerlink" title="Adjacency Lists 邻接表法"></a>Adjacency Lists 邻接表法</h3><p>每个顶点结点都是一个单链表的头结点，后面挂着他连接的顶点的节点。</p>
<p>如：</p>
<p>0-&gt;1-&gt;2</p>
<p>1-&gt;0</p>
<p>2-&gt;0</p>
<p>这就是一个三个顶点的无向图，01、02相连。</p>
<p>S(n+2e) Space complexities</p>
<h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><p><strong>AOV Network</strong>: digraph in which V(G) represents activities and E(G) represents precedence relations 顶点表示事件，边表示事件之间的进程关系。比如A-&gt;B，就是要先做完A才能做B</p>
<p><strong>i is a predecessor of j</strong>: there is a path from i to j  前驱</p>
<p><strong>i is an immediate predecessor</strong>: &lt;i,j&gt;&#x3D;1.  直接前驱 Then j is called a <strong>successor (immediate successor)</strong> of i 直接后继</p>
<p><strong>Partial order</strong>: transitive (i-&gt;k,k-&gt;j: i-&gt;j) &amp;&amp; irreflexive (i-&gt;j is impossible)</p>
<p>AOV network must be a dag (directed acyclic graph)</p>
<p><strong>Topological order</strong>: a linear ordering of the vertices of a graph such that, for any 2 vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.  所有时间都是按完成顺序排序的.<br>算法：</p>
<ol>
<li>找出入度为0的节点</li>
<li>visit 该节点，并删除该节点的所有出度边</li>
<li>再重新寻找入度为0，没有 visit 过的节点，循环往复</li>
</ol>
<p>If we use a special box (queue or stack) to sort, T&#x3D;O(|V|+|E|)</p>
<h2 id="Shortest-Path-Algorithms-最短路径算法"><a href="#Shortest-Path-Algorithms-最短路径算法" class="headerlink" title="Shortest Path Algorithms 最短路径算法"></a>Shortest Path Algorithms 最短路径算法</h2><p>两类问题：</p>
<ol>
<li>从物流中心（一个顶点）往其他所有顶点运输物品，怎样路径最短？</li>
<li>怎样让所有顶点之间路径总和最短？</li>
</ol>
<h3 id="1-Single-Source-Shortest-Path-Problem"><a href="#1-Single-Source-Shortest-Path-Problem" class="headerlink" title="1. Single-Source Shortest-Path Problem"></a>1. Single-Source Shortest-Path Problem</h3><p>Given as input a weighted graph, G &#x3D; ( V, E ), and a distinguished vertex, s, find the shortest weighted path from s to every other vertex in G.</p>
<p><strong>Breadth-first search 广度优先搜索</strong></p>
<p>Similar to the topological order. We will visit every node connect to the fist node (if they haven’t been visit) and Enquque; and Dequeue this node, do the same thing to every node in the Queue.</p>
<p>Just simply scan the whole table</p>
<p>T+(|V|^2+|E|)</p>
<p><strong>Dijkstra’s Algorithm 迪杰斯特拉算法</strong></p>
<p>建立三个数组，final[]标记哥哥顶点是否已经找到最短路径；dist[]最短路径长度；path[]路径上的前驱<br>第一次循环：遍历所有结点，找到还没有确定最短路径且dist最小的顶点，final[i]&#x3D;true<br>检查i结点的所有final&#x3D;false邻接节点，如果把i作为路径上的前驱，最短路径会不会缩短？如果会，更新最短路径长度dist和路径上的前驱path信息。<br>进入下一轮循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">( Table T )</span></span><br><span class="line">&#123;   <span class="comment">/* T is initialized by Figure 9.30 on p.303 */</span></span><br><span class="line">    Vertex  V, W;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        V = smallest unknown distance vertex;</span><br><span class="line">        <span class="keyword">if</span> ( V == NotAVertex )</span><br><span class="line">	<span class="keyword">break</span>; </span><br><span class="line">        T[ V ].Known = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( each W adjacent to V )</span><br><span class="line">	<span class="keyword">if</span> ( !T[ W ].Known ) </span><br><span class="line">	    <span class="keyword">if</span> ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) &#123;</span><br><span class="line">	    	Decrease( T[ W ].Dist  to</span><br><span class="line">			 T[ V ].Dist + Cvw );</span><br><span class="line">		T[ W ].Path = V;</span><br><span class="line">	    &#125; <span class="comment">/* end-if update W */</span></span><br><span class="line">    &#125; <span class="comment">/* end-for( ; ; ) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>not work for edge with negative cost!</strong></p>
<p>T&#x3D;O(|E|log|V|)</p>
<h2 id="Acylic-Graphs"><a href="#Acylic-Graphs" class="headerlink" title="Acylic Graphs"></a>Acylic Graphs</h2><p>If the graph is acyclic, vertices amy be selected in topological order since when a vertex is selected, its distance can no longer be lowered without any incoming edges from unknown nodes.</p>
<p>T&#x3D;O(|E|+|V|)</p>
<p>Application: AOE(Activity On Edge)Networks</p>
<p>EC[ j ] \ LC[ j ] :: the earliest \ latest completion time for node v_j</p>
<p><strong>CPM (Critical Path Method)</strong></p>
<p>Calculation of EC: start from v_0, for any a_i&#x3D;&lt;v,w&gt;, we have $EC[w]&#x3D;max_{(v,w)\in E(EC[v]+C_{v,w})}$</p>
<p>Calculation of LC: Start from the last vertex v_e, for any a_i &#x3D; &lt;v,w&gt;, $LC[v]&#x3D;min_{(v,w)\in E}(LC[w]-C_{v,w})$</p>
<p>Slack Time of &lt;v,w&gt;: $LC[w]-EC[v]-C_{v,w}$</p>
<p>Critical Path: path consisting entirely of zero-slack edges.</p>
<p><strong>All-Pairs Shortest Path Problem</strong></p>
<p>Method 1: Use single-source algorithm  for |V| times.<br>T &#x3D; O(|V|^3) – works fast on sparse graph. 稀疏图</p>
<p>Method 2  O( |V|^3 ) algorithm given in Ch.10, works faster on dense graphs.</p>
<h2 id="Network-Flow-Problems"><a href="#Network-Flow-Problems" class="headerlink" title="Network Flow Problems"></a>Network Flow Problems</h2><p>Find Maximum Path from s to t.</p>
<p>Step 1:  Find any path s -&gt; t in Gr ;</p>
<p>Step 2:  Take the minimum edge on this path as the amount of flow and add to G_f ;</p>
<p>Step 3:  Update G_r and remove the 0 flow edges;</p>
<p>Step 4:  If (there is a path s -&gt; t in G_r )<br>                    Goto Step 1;<br>               Else<br>                     End.</p>
<h2 id="Minimum-Spanning-Tree"><a href="#Minimum-Spanning-Tree" class="headerlink" title="Minimum Spanning Tree"></a>Minimum Spanning Tree</h2><p>is a tree which consists of V(G) and a subset of E(G). </p>
<ul>
<li>It is acyclic – the number of edges is |V|-1.</li>
<li>It is minimum for the total cost of edges is minimized.</li>
<li>A minimum spanning tree exists if G is connected.</li>
</ul>
<h2 id="2-Method-of-calculating-the-minimum-spanning-tree"><a href="#2-Method-of-calculating-the-minimum-spanning-tree" class="headerlink" title="2 Method of calculating the minimum spanning tree:"></a>2 Method of calculating the minimum spanning tree:</h2><ol>
<li><p>Prim’s Algorithm<br>very samiliar to Dijkstra’s algorithm. We choose a vertex to start, and every time add a a least cost vertex until all vertex is connected.</p>
</li>
<li><p>Kruskal’s Algorithm – maintain a forest<br>every time add a a least cost edge &lt;v,w&gt; from E until all vertex is connected.</p>
</li>
</ol>
<h2 id="DFS-–-Depth-First-Search"><a href="#DFS-–-Depth-First-Search" class="headerlink" title="DFS – Depth-First Search"></a>DFS – Depth-First Search</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListComponents</span> <span class="params">( Graph G )</span> </span><br><span class="line">&#123;   <span class="keyword">for</span> ( each V in G ) </span><br><span class="line">        <span class="keyword">if</span> ( !visited[ V ] ) &#123;</span><br><span class="line">	DFS( V );</span><br><span class="line">               <span class="built_in">printf</span>(“\n“);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span> <span class="params">( Vertex V )</span>  <span class="comment">/* this is only a template */</span></span><br><span class="line">&#123;   visited[ V ] = <span class="literal">true</span>;  <span class="comment">/* mark this vertex to avoid cycles */</span></span><br><span class="line">    <span class="keyword">for</span> ( each W adjacent to V )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[ W ] )</span><br><span class="line">	DFS( W );</span><br><span class="line">&#125; <span class="comment">/* T = O( |E| + |V| ) as long as adjacency lists are used */</span></span><br></pre></td></tr></table></figure>

<p>Applications:</p>
<ol>
<li>Undirected Graphs</li>
<li>Biconnectivity</li>
<li>Euler Circuits</li>
</ol>
<h2 id="NP-Completeness"><a href="#NP-Completeness" class="headerlink" title="NP-Completeness"></a>NP-Completeness</h2><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="Basic-String-Operations"><a href="#Basic-String-Operations" class="headerlink" title="Basic String Operations"></a>Basic String Operations</h2><p>The StrAssign、Strcopy、StrCompare、StrLength、Concat and SubString</p>
<h2 id="String-Operations-Library-in-C"><a href="#String-Operations-Library-in-C" class="headerlink" title="String Operations Library (in C)"></a>String Operations Library (in C)</h2><p>gets(str)  &#x2F;&#x2F;Input a string;</p>
<p>puts(str) &#x2F;&#x2F;Output a string；</p>
<p>strcat(str1, str2)  &#x2F;&#x2F; string Concatenation；</p>
<p>strcpy(str1, str2, k)  &#x2F;&#x2F;String copy；</p>
<p>strcmp(str1, str2) &#x2F;&#x2F;String comparision；</p>
<p>strlen(str)  &#x2F;&#x2F;Get the length of string </p>
<h2 id="Pattern-Matching-algorithm"><a href="#Pattern-Matching-algorithm" class="headerlink" title="Pattern Matching algorithm"></a>Pattern Matching algorithm</h2><p>旧模式匹配算法：每次不匹配时，子串都从头重新匹配。效率很低</p>
<p>Basic match algorithm is inefficient</p>
<h3 id="Knuth-Morris-Pratt-KMP-Algorithms"><a href="#Knuth-Morris-Pratt-KMP-Algorithms" class="headerlink" title="Knuth-Morris-Pratt (KMP Algorithms)"></a>Knuth-Morris-Pratt (KMP Algorithms)</h3><p>When dismatch happens, we don’t need to go back to first. We can use a next array to decide where to go back.</p>
<p>next[]: compare s[i] and t[j]，if equals then continue comparing following items, else compare s[i] and t [ next[j] ], till end.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">Get_next</span><span class="params">( SString T, <span class="type">int</span>  &amp;next[] )</span></span><br><span class="line">&#123;    j = <span class="number">1</span> ;  <span class="comment">// postfix pointer</span></span><br><span class="line">     k = <span class="number">0</span>;   <span class="comment">//prefix pointer</span></span><br><span class="line">     next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= T[<span class="number">0</span>] )</span><br><span class="line">     &#123;  <span class="keyword">if</span> ( k == <span class="number">0</span> || T[j] == T[k] ) </span><br><span class="line">             &#123; ++j ;  ++k ;  next[j]=k; &#125;</span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">             k = next[k];  <span class="comment">// k go back, then compare T[j] with T[ next[k] ]</span></span><br><span class="line">     &#125;<span class="comment">// end while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For example:<br>a  a  b  c  a  a  a  b  c  a  d<br>0  1  2  1  1  2  3  3  4  5  6</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：程序设计课程设计 C语言订餐系统"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/11/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F/"
    >北邮国院项目：程序设计课程设计 C语言订餐系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/11/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2021-09-10T23:00:00.000Z" itemprop="datePublished">2021-09-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>尽管快半年没有学c了，好在回顾起来还是蛮快的。而且也发现比去年的自己熟练了许多。<br>小学期要求5人合作，用C语言做一个订餐系统，能够实现用户的登录、选择餐馆、订餐、按各种规则查询与排序、修改个人信息，管理员的登录、添加菜品、按各种规则查询与排序、修改个人信息。<br>首先，我们调研了几个流行的订餐系统，<del>并解决了午饭</del>分析其页面逻辑顺序，借此设定了我们自己的订餐系统的逻辑顺序。<br>感谢blue、peppa、214、Mar鼎力相助！<br><img src="https://img-blog.csdnimg.cn/d8feaa5c8fab43efb78c7dd073d37419.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>至于写法，主要尝试了两个新知识点：<strong>文件操作与链表</strong>。<br>想要实现这样的订餐系统，必须有地方可以存储其数据。不能说放在程序里吧，每次一关一开又恢复原状了。我们使用FILE文件操作，对存放在指定位置的txt进行读写操作，读取其中的数据。<br>至于数据结构采用结构体数组还是链表，在之前学习翁恺老师的网课时我们认识到了结构体数组的一些弊端。数组大小固定，一旦初始化无法修改，少了可能越界，多了浪费内存空间，链表就可以想用一个结点开辟一个结点。而且对于插入、删除等操作还是链表香啊，数组中间插入或删除一个，后面的都要跟着动。<br>至于如何实现多人合作，可参考翁恺老师网课12.3.1多个源代码文件用devc++创建项目的方法。我们每人负责了几个函数，最后对好接口和返回值合并。其实就像同学说的，在合并之前是最没底的，也没法测试知道自己写的什么样。好在最终完成的还算顺利。</p>
<p>链表中嵌套链表，是这回我们做的一个非常有意思的尝试。我们发现每次订单中所点的菜品及其数量，和每次订单结束后推荐的菜品数量都是不固定的。对于数据结构还没开始学的我们来说有些困难。后来去问了老师，老师给出了“那你们只能在链表里套一个链表了吧”的解决方案。没想到这个方案真的能做，虽然这铁不是最佳方案。但是也非常有趣。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_dish</span> //订单中的菜品链表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> dish_id; <span class="comment">//菜品号</span></span><br><span class="line">	<span class="type">int</span> number;	 <span class="comment">//该菜品数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_dish</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LISTDISH;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">recommend_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> dish_name[len]; <span class="comment">//推荐的菜品名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">recommend_d</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RECOMMEND;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> //订单链表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> number;				<span class="comment">//订单号</span></span><br><span class="line">	<span class="type">char</span> user_id[len];		<span class="comment">//用户id，据此可以找到用户地址</span></span><br><span class="line">	<span class="type">int</span> restaurant_id;		<span class="comment">//餐馆id</span></span><br><span class="line">	<span class="type">int</span> score;				<span class="comment">//本次订单对餐馆的打分</span></span><br><span class="line">	<span class="type">int</span> price;				<span class="comment">//本次订单的总价格</span></span><br><span class="line">	TIME delivery_time_s;	<span class="comment">//起始配送时间。TIME是一个包含月、日、时、分成员的结构体</span></span><br><span class="line">	TIME delivery_time_e;	<span class="comment">//结束配送时间</span></span><br><span class="line">	RECOMMEND *recommend_d; <span class="comment">//本次用户推荐菜品头结点指针 </span></span><br><span class="line">	LISTDISH *head_ld;		<span class="comment">//本次订单的菜品链表头结点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LIST;</span><br></pre></td></tr></table></figure>
<p>如上，在订单链表的每个结点中，都包含着一个listdish（存储本次订单所选菜品及其数量）链表的头结点和一个recommend（存储本次订单推荐的菜品）链表的头结点。访问的时候可以通过list-&gt;recommend-&gt;dish_name这样的方法直接得到本次订单中推荐菜品的菜品名称。<br>这样的结构，如何从文件中读取？<br>其他的链表都还好办。至于这三个链表，我们建立了3个txt文件（虽然listdish和recommend有许多链表，但是最好还是都存在一个txt里，不然每次新点订单还要新建txt文件。）其中listdish和recommend文本文档是这样的：<img src="https://img-blog.csdnimg.cn/bcd7964a59194715921f1261517f5d50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>每一行代表第几个订单。每两个数字为一组，第一个数字为菜品号，第二个数字为该菜品所点数量。由于不固定长度，我们采用两个-1作为结尾，当读到-1时本订单结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LIST *<span class="title function_">read_inf_l</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LIST *head = (LIST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LIST))</span><br><span class="line">	, *last = head, *p, *temp = (LIST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LIST));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	FILE *fp_l = fopen(<span class="string">&quot;D:\\小学期\\list.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp_l, <span class="string">&quot;%d %s %d %d %d %d %d %d %d %d %d %d %d &quot;</span></span><br><span class="line">	, &amp;temp-&gt;number, temp-&gt;user_id, &amp;temp-&gt;restaurant_id</span><br><span class="line">	, &amp;temp-&gt;score, &amp;temp-&gt;price</span><br><span class="line">	, &amp;temp-&gt;delivery_time_s.month, &amp;temp-&gt;delivery_time_s.day</span><br><span class="line">	, &amp;temp-&gt;delivery_time_s.hour, &amp;temp-&gt;delivery_time_s.minute</span><br><span class="line">	, &amp;temp-&gt;delivery_time_e.month, &amp;temp-&gt;delivery_time_e.day</span><br><span class="line">	, &amp;temp-&gt;delivery_time_e.hour, &amp;temp-&gt;delivery_time_e.minute) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		p = (LIST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LIST));</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;head_ld = read_inf_ld(temp-&gt;number);<span class="comment">//跳转到read_inf_ld(int number)函数中获得本次订单listdish链表的头结点，number是订单号</span></span><br><span class="line">		p-&gt;recommend_d = read_inf_recommend(temp-&gt;number);<span class="comment">//跳转到read_inf_recommend(int number)函数中获得本次订单recommend链表的头结点，number是订单号</span></span><br><span class="line">		p-&gt;number = temp-&gt;number;</span><br><span class="line">		<span class="built_in">strcpy</span>(p-&gt;user_id, temp-&gt;user_id);</span><br><span class="line">		p-&gt;restaurant_id = temp-&gt;restaurant_id;</span><br><span class="line">		p-&gt;score = temp-&gt;score;</span><br><span class="line">		p-&gt;price = temp-&gt;price;</span><br><span class="line">		p-&gt;delivery_time_s.month = temp-&gt;delivery_time_s.month;</span><br><span class="line">		p-&gt;delivery_time_s.day = temp-&gt;delivery_time_s.day;</span><br><span class="line">		p-&gt;delivery_time_s.hour = temp-&gt;delivery_time_s.hour;</span><br><span class="line">		p-&gt;delivery_time_s.minute = temp-&gt;delivery_time_s.minute;</span><br><span class="line">		p-&gt;delivery_time_e.month = temp-&gt;delivery_time_e.month;</span><br><span class="line">		p-&gt;delivery_time_e.day = temp-&gt;delivery_time_e.day;</span><br><span class="line">		p-&gt;delivery_time_e.hour = temp-&gt;delivery_time_e.hour;</span><br><span class="line">		p-&gt;delivery_time_e.minute = temp-&gt;delivery_time_e.minute;</span><br><span class="line">		last-&gt;next = p;</span><br><span class="line">		last = last-&gt;next;</span><br><span class="line">		last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp_l);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LISTDISH *<span class="title function_">read_inf_ld</span><span class="params">(<span class="type">int</span> id)</span> <span class="comment">//Read the Information of List-Dish linklist</span></span><br><span class="line">&#123;</span><br><span class="line">	LISTDISH *head = (LISTDISH *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LISTDISH))</span><br><span class="line">	, *last = head, *p, *temp = (LISTDISH *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LISTDISH));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	FILE *fp_ld;</span><br><span class="line">	fp_ld = fopen(<span class="string">&quot;D:\\小学期\\listdish.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (id != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span> (cnt != id)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			temp-&gt;dish_id = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (temp-&gt;dish_id != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fscanf</span>(fp_ld, <span class="string">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">fscanf</span>(fp_ld, <span class="string">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);</span><br><span class="line">	<span class="keyword">while</span> (temp-&gt;dish_id != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = (LISTDISH *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LISTDISH));</span><br><span class="line">		p-&gt;dish_id = temp-&gt;dish_id;</span><br><span class="line">		p-&gt;number = temp-&gt;number;</span><br><span class="line">		last-&gt;next = p;</span><br><span class="line">		last = last-&gt;next;</span><br><span class="line">		last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp_ld, <span class="string">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp_ld);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如要读取第三个订单所点菜品信息，传入read_inf_ld()的number订单号为3.<code>int cnt = 1</code>代表当前文件指针读取的订单号，从1开始计数，每次读到-1 -1证明又读完了一单，cnt++，直到cnt &#x3D;&#x3D; number为止。然后读取接下来的这个链表，最后返回头结点，作为该订单中的一个成员。<br><img src="https://img-blog.csdnimg.cn/6b66117ee8b641998ea580f57da912ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">RECOMMEND *<span class="title function_">read_inf_recommend</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">	RECOMMEND *head = (RECOMMEND *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RECOMMEND)),*last=head</span><br><span class="line">	,*p,*temp = (RECOMMEND *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RECOMMEND));</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	FILE *fp_recommend = fopen(<span class="string">&quot;D:\\小学期\\recommend.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); </span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (cnt != id)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(temp-&gt;dish_name,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">strcmp</span>(temp-&gt;dish_name , <span class="string">&quot;-1&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fscanf</span>(fp_recommend, <span class="string">&quot;%s &quot;</span>, temp-&gt;dish_name);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp_recommend, <span class="string">&quot;%s &quot;</span>, temp-&gt;dish_name);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(temp-&gt;dish_name ,<span class="string">&quot;-1&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (RECOMMEND *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RECOMMEND));</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;dish_name, temp-&gt;dish_name);</span><br><span class="line">        last-&gt;next = p;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        last-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp_recommend, <span class="string">&quot;%s &quot;</span>, temp-&gt;dish_name);</span><br><span class="line">    &#125;</span><br><span class="line">	fclose(fp_recommend);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取推荐菜品链表也是类似。<br>得到的链表全都包括头结点（里链表也是），不包含结尾的-1，只要通过-&gt;-&gt;就能访问hh。<br>总之，结束了~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：创新思维实践 C语言五子棋"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%88%9B%E6%96%B0%E6%80%9D%E7%BB%B4%E5%AE%9E%E8%B7%B5%20C%E8%AF%AD%E8%A8%80%E4%BA%94%E5%AD%90%E6%A3%8B/"
    >北邮国院项目：创新思维实践 C语言五子棋</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%88%9B%E6%96%B0%E6%80%9D%E7%BB%B4%E5%AE%9E%E8%B7%B5%20C%E8%AF%AD%E8%A8%80%E4%BA%94%E5%AD%90%E6%A3%8B/" class="article-date">
  <time datetime="2021-07-24T23:00:00.000Z" itemprop="datePublished">2021-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>这次看了几位大佬的做法，我们也做了很多修改尝试。算是第一次尝试合作完成项目。<br>我认为学到的东西：</p>
<ol>
<li>第一次尝试写项目，把函数分到不同的.c文件中后更好看了一些。</li>
<li>在研究过程中应该分清主次。代码正确运行才是基础要求，其他什么美化界面，调字体调颜色都并非重点。（8月4日更新：评价算法的五个特性，正确性，简明性，健壮性，效率，最优性）</li>
<li>从代码中学到的，①是采用落子数来判断该轮到黑方下还是白方下（落子数为2的倍数时黑方下，否则白方下），这样也能判断出是哪一方胜利，而且落子数还可以判断棋盘是否下满（&#x3D;&#x3D;16*16时棋盘落满，平局） ②是胜利条件的判断，以中间子为参考，看两边的四个子是否和他颜色相同。</li>
<li>8月4日更新：在这次尝试中在文件中使用了全局变量，不同文件中用extern调用。但是在后来学习中意识到全局变量最好不要写在文件里，会增加耦合性。以后多人合作写不同函数的时候也要注意，尽量不要出现。</li>
</ol>
<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>在一个16*16的棋盘上，黑白双方交替落子，每次落下子后如果棋盘上出现了五个同色棋子横向&#x2F;竖向&#x2F;斜向连接，则该方胜利。如果在棋盘下满后（即下了16*16个子后）仍未分出胜负，则为平局。</p>
<h1 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h1><p>初始化棋盘，是一个<code>16*16</code>的二维数组（定义宏 N&#x3D;16），一开始每一格都初始化为0。用一个不断++的落子数变量%2来判断本回合是黑方下还是白方下，；每次玩家输入横纵坐标，该处的变量值改变（黑子为1，白子为2）。每次落子判断全盘是否有五子连珠，如果有则结束游戏，如果没有则继续下。当落子数达到<code>N*N</code>即棋盘下满，还没有出现五子连珠时，则判断为平局，结束游戏。</p>
<h1 id="五子棋胜负条件判断"><a href="#五子棋胜负条件判断" class="headerlink" title="五子棋胜负条件判断"></a>五子棋胜负条件判断</h1><p>判断原理 :<br>胜负的判断是在每颗棋子落下之后进行，所以用这一子的坐标为基准前后左右斜各个方向来看是否取胜。<br>具体思想:<br>按照五子棋规则，当一方的棋子，在横向，纵向或斜向连续五个均为同一用户的棋子时，代表胜利。<br>另外，胜利判断只需要在一个新子落子时判断，且仅需要判断新子所在的四条线上(纵横加两个斜线)是否满足条件即可。<br>所以，可以以新子坐标为基准点，判断四次。<br>比如横向的，需要判断左侧和右侧连续的同类棋子个数，如果左侧+右侧+1（自身）总数&gt;&#x3D;5，则为胜利。<br>在判断胜利的时候,首先我们要排除空子的情况,然后当两个斜线的时候, 无胜情况下，判断直线,当为两斜线及直线无胜情况下，判断横线。<br>参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">win</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>,l = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">2</span>;k&lt;N<span class="number">-2</span>;k++) </span><br><span class="line">		<span class="keyword">for</span>(l=<span class="number">2</span>;l&lt;N<span class="number">-2</span>;l++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k<span class="number">-2</span>][l<span class="number">-2</span>]==arr[k][l]&amp;&amp;arr[k<span class="number">-1</span>][l<span class="number">-1</span>]==arr[k][l]&amp;&amp;arr[k+<span class="number">1</span>][l+<span class="number">1</span>]==arr[k][l]&amp;&amp;arr[k+<span class="number">2</span>][l+<span class="number">2</span>]==arr[k][l])</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k+<span class="number">2</span>][l<span class="number">-2</span>]==arr[k][l]&amp;&amp;arr[k+<span class="number">1</span>][l<span class="number">-1</span>]==arr[k][l]&amp;&amp;arr[k<span class="number">-1</span>][l+<span class="number">1</span>]==arr[k][l]&amp;&amp;arr[k<span class="number">-2</span>][l+<span class="number">2</span>]==arr[k][l])</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">			<span class="keyword">for</span>(l=<span class="number">2</span>;l&lt;N<span class="number">-2</span>;l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k][l<span class="number">-2</span>]==arr[k][l]&amp;&amp;arr[k][l<span class="number">-1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class="number">1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class="number">2</span>]==arr[k][l])</span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">2</span>;k&lt;N<span class="number">-2</span>;k++)</span><br><span class="line">			<span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;N;l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k+<span class="number">2</span>][l]==arr[k][l]&amp;&amp;arr[k+<span class="number">1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class="number">-1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class="number">-2</span>][l]==arr[k][l])</span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">return</span> flag; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注:<br>1.	中的arr[k][l]!&#x3D;0是排除空子的情况。<br>2.	最后返回判断结果时, 有胜为1,无为0,谁胜无必要判断，因为，谁尾手了的一定是胜的。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>开始<br> <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211141306161.png" alt="在这里插入图片描述"></p>
<p>输入坐标<br> <img src="https://img-blog.csdnimg.cn/d5998cff325649e6b674ed2a6051b673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>第二回合<br> <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211141306499.png" alt="在这里插入图片描述"></p>
<p>游戏结束<br> <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211141306208.png" alt="在这里插入图片描述"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=1357960253&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>