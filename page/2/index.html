<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title> 灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">灰海宽松的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['没有一条路无风无浪', '常应常静，常清净矣', 'Love the Life You Live'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-北邮国院项目：Java Wordle"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AJava%20Wordle/"
    >北邮国院项目：Java Wordle</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AJava%20Wordle/" class="article-date">
  <time datetime="2022-07-19T23:00:00.000Z" itemprop="datePublished">2022-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Wordle-游戏介绍"><a href="#Wordle-游戏介绍" class="headerlink" title="Wordle 游戏介绍"></a>Wordle 游戏介绍</h1><blockquote>
<p>Wordle的游戏规则很简单，玩家需要猜出程序每天指定的一个5位英语单词谜底。</p>
<p>玩家可以随意提交一个英语单词，但必须是字典里有的，不能胡乱拼写。</p>
<p>如果字母在谜底中出现且位置对了就显示绿色，字母出现了但位置不对就显示黄色，字母在答案的单词中没出现就显示灰色。</p>
<p>根据反馈信息再进行下一轮猜测，在6次尝试之内猜出就算赢。<br>来源：<a target="_blank" rel="noopener" href="https://news.mydrivers.com/1/813/813695.htm#:~:text=Wordle%E7%9A%84%E6%B8%B8,%E4%BD%8D%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%B0%9C%E5%BA%95%E3%80%82">https://news.mydrivers.com/1/813/813695.htm#:~:text=Wordle%E7%9A%84%E6%B8%B8,%E4%BD%8D%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%B0%9C%E5%BA%95%E3%80%82</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/494e131e4b2641d48becd4aef3f90c7d.png" alt="在这里插入图片描述"></p>
<h1 id="成果图示"><a href="#成果图示" class="headerlink" title="成果图示"></a>成果图示</h1><p>博主大二期间学习的java课程大作业，就是写一款 wordle 游戏，主要考察 GUI 界面的开发。<br>最终成果图示：<br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/008abdff020b4e05bc56265450bc7442.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1840388526344189a27121987da22d47.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/74f2dd38063349298b84d23cafb28db2.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e9aacefcb2984adf913ea8c80fee24ff.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/07e7dd5c4a4348afb35cfc7cc009ca88.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/f163f8a63ff14878b74691ba432fd882.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/de75c6c50c9b45a3bbd2c58f95104217.png" alt="在这里插入图片描述"></p>
<h1 id="玩法介绍"><a href="#玩法介绍" class="headerlink" title="玩法介绍"></a>玩法介绍</h1><p>点击HELP 查看帮助，点击 START 开始游戏。<br>本游戏中没有虚拟键盘，输入框也不能获取鼠标焦点，只能通过键盘键入字母，回车检查答案。<br>敲下回车后，字母就会呈现灰色、黄色、绿色三种状态，并换到下一行开始下一次猜单词机会。当猜中答案或六轮游戏结束时，弹出小窗，提示用户游戏胜利&#x2F;失败。<br>注意：</p>
<ol>
<li>检查用户输入。本游戏中用户只能输入字母，当用户试图键入数字或符号时会提示只能输入字母。当用户输入不足5位就尝试检查，或尝试输入超出5位时会提示输入必须为5位字母。当用户输入非单词尝试检查会提示输入必须为词库中存在的单词（词库：words.txt，可以自己更新）</li>
<li>一些小的注意点。当用户输入中有两个e，都不在正确的位置上，那这两个e只有一个会显示黄色就够了，另一个显示灰色，否则会影响用户的判断。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Java_Wordle_Game">Java_Wordle_Game github下载地址</a><br>README：帮助信息<br>javadoc：生成的 javadoc<br>Test：测试图片及说明<br>words.txt：词库</p>
<p>运行方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>
<p>在此感谢老师同学对此项目的帮助指导！<br>欢迎大家star支持[Doge]有问题也可以与博主交流~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：MySQL 数据库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93/"
    >北邮国院笔记：MySQL 数据库</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2022-07-19T23:00:00.000Z" itemprop="datePublished">2022-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本博客学习自：黑马程序员 mysql 入门网课，b站 骆昊jackfrued 老师 mysql 网课，以及博主自己课内学习的数据库课程，侵删！</p>
<p>课内学习的课程内容因为是英方课，包括一些不常用的概念和英文，更注重整体框架的理解，大致了解即可。</p>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><p>MYSQL 的安装配置网上一搜一大把，博主就不在此发表拙见了，安装太久了自己也记不是很清具体方法了。这里指跟随课程学习了 Command Line Client 的安装（说实话，这玩意我自认为没啥用）。</p>
<p>Mysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。</p>
<p>如果选择的是 zip 下载，应该只会安装一个 mysql 文件包，在程序终端可以使用。</p>
<p>如果是选择 msi 文件安装，MYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。</p>
<p>由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。</p>
<p>开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，区别只是其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\h, ?, ?</td>
<td>获取帮助</td>
</tr>
<tr>
<td>\c</td>
<td>清除前面输入的内容（内容输入有误时使用）</td>
</tr>
<tr>
<td>\R</td>
<td>修改 每次输入命令前左侧的提示样式（默认：’mysql&gt;’）</td>
</tr>
<tr>
<td>? 需要查看帮助的命令;</td>
<td>显示该命令的帮助（如：? show）</td>
</tr>
<tr>
<td>show databases; show databases();</td>
<td>查看所有数据库，查看当前所在数据库</td>
</tr>
<tr>
<td>use ‘数据库名’;</td>
<td>选中某个数据库</td>
</tr>
<tr>
<td>（选中某个数据库后）show tables;</td>
<td>查看当前数据库中所有表</td>
</tr>
<tr>
<td>exit &#x2F; quit</td>
<td>退出</td>
</tr>
</tbody></table>
<h1 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h1><p>数据库有很多种结构，mysql 学习的是关系型数据库，说白了就是二维表的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">R[关系型数据库]--&gt;T[理论基础]</span><br><span class="line">R--&gt;S[具体表象]</span><br><span class="line">R--&gt;L[编程语言 SQL]</span><br><span class="line">T--&gt;A[关系代数]</span><br><span class="line">T--&gt;C[关系运算]</span><br><span class="line">T--&gt;P[一阶谓词逻辑]</span><br><span class="line">S--&gt;Ta[二维表]</span><br><span class="line">L--&gt;D[DDL]</span><br><span class="line">L--&gt;M[DML]</span><br><span class="line">L--&gt;Q[DQL]</span><br><span class="line">L--&gt;DCL[DCL]</span><br></pre></td></tr></table></figure>

<p>DDL: create &#x2F; drop &#x2F; alter （database 或 schema 数据库名 &#x2F; table 表名）</p>
<p>DML: insert &#x2F; update &#x2F; delete</p>
<p>DQL: select …… from</p>
<p>DCL: grant（授权） &#x2F; revoke（召回权限）</p>
<table>
<thead>
<tr>
<th>正式的关系模型术语</th>
<th>非正式的日常用语</th>
</tr>
</thead>
<tbody><tr>
<td>关系（relation）</td>
<td>表（table）</td>
</tr>
<tr>
<td>元组（tuple）记录</td>
<td>行（row）或记录（record）</td>
</tr>
<tr>
<td>势（cardinality）</td>
<td>行数（number of rows）</td>
</tr>
<tr>
<td>属性（attribute）</td>
<td>列（column）或字段（field）</td>
</tr>
<tr>
<td>度（degree）</td>
<td>列数（number of columns）</td>
</tr>
<tr>
<td>定义域（domain）</td>
<td>列的取值集合（pool of legal values）</td>
</tr>
</tbody></table>
<h1 id="ER-和-EER-模型"><a href="#ER-和-EER-模型" class="headerlink" title="ER 和 EER 模型"></a>ER 和 EER 模型</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为什么要有 ER 图和 EER 图的存在？</p>
<p><strong>真正做项目、设计数据库时，</strong>实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR &#x2F; json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）<strong>是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。</strong></p>
<h3 id="ER-模型"><a href="#ER-模型" class="headerlink" title="ER 模型"></a>ER 模型</h3><p>ER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336311.png" alt="百度百科图片"></p>
<p>相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。</p>
<h3 id="EER-模型"><a href="#EER-模型" class="headerlink" title="EER 模型"></a>EER 模型</h3><p>以下部分内容有参考自文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/356216273">为了彻底搞清楚数据库 E-R 模型设计，我肝了这篇万字长文 - 知乎 (zhihu.com)</a></p>
<p>关于两者的具体区分我还有去问b站up主 骆昊jackfrued 老师，老师表示：不用太纠结这个问题，ER图更抽象，可以理解为概念模型图（PowerDesigner）。</p>
<p>相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。</p>
<h4 id="泛化层次"><a href="#泛化层次" class="headerlink" title="泛化层次"></a>泛化层次</h4><p>包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。</p>
<p><strong>子类父类</strong>就是类似 Java 的继承，如动物是父类，猫、狗是其子类。<strong>子类父类是一对一的关系！</strong></p>
<p><strong>泛化</strong>又叫归纳，就是将几个类的共同属性提取出来作为父类；</p>
<p><strong>特化</strong>又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。</p>
<p>其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。</p>
<p><strong>mandatory &#x2F; optional</strong>：父类中的所有属性都必须包含在每一个子类中 &#x2F; 不用全部继承，选择部分继承即可（完全性限制）</p>
<p><strong>disjoint &#x2F; overlapping</strong>：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336748.png" alt="img"></p>
<p>图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D &#x2F; O，表示 disjoint &#x2F; overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。</p>
<h4 id="汇集层次"><a href="#汇集层次" class="headerlink" title="汇集层次"></a>汇集层次</h4><p>Aggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336896.png" alt="img"></p>
<p>如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。</p>
<h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336013.png" alt="img"></p>
<p>Workbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336256.png" alt="EER 图示例"></p>
<p>在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。</p>
<p><em>自动生成的 SQL 语句中，外键下方有两句话<code>ON DELETE NO ACTION</code> <code>ON UPDATE NO ACTION</code>，意为：当外键参考的主键修改&#x2F;删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改&#x2F;删除外键在使用的主键。</em></p>
<p>同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。</p>
<p><em>Power Designer 建模工具，也支持正 &#x2F; 反向工程，可以生成 SQL 方言。完整版付费。</em></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型可以通过 <code>? data types</code> 查看说明，每种数据类型也可以通过 <code>? 数据类型</code> 查看。</p>
<p><em>除了data types 其他可以用?查看的内容可以输入 <code>? contents</code> 查看。</em></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>整数 (tinyint, smallint, mediumint, int, bigint)</td>
<td>都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）</td>
</tr>
<tr>
<td>字符串 (char(位数), varchar(位数), text)</td>
<td>char 长度固定，varchar 长度可变</td>
</tr>
<tr>
<td>小数 (float, double, decimal(总位数, 小数点后位数))</td>
<td>不要用 float, double！</td>
</tr>
<tr>
<td>时间日期 (year, date, time, datetime, timestamp)</td>
<td>date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数</td>
</tr>
<tr>
<td>Mysql 中的枚举类型 (enum, boolean)</td>
<td></td>
</tr>
</tbody></table>
<p>PS: </p>
<ol>
<li><p>虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。</p>
</li>
<li><p>金额等小数一般不会用小数的数据类型存储，而是整数类型&#x2F;100使用。因为小数形式有误差，比如0.1+0.2&#x3D;0.30000000004.</p>
</li>
<li><p>decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。</p>
</li>
<li><p>时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。</p>
</li>
</ol>
<p>这里了解到了一个很有趣的“千年虫”问题 (<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/305603895">漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)</a>)。</p>
<blockquote>
<p>Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。</p>
<p>早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022&#x2F;04&#x2F;19，就是22&#x2F;04&#x2F;19）</p>
<p>尽管节约了内存空间，但是40年后1999-&gt;2000年时，问题就出现了……对计算机来说，相当于99-&gt;00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。</p>
<p>如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：</p>
<p>1.只修改核心关键的医疗、航空、金融、军事领域的程序；<br>2.对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。</p>
</blockquote>
<p>回到刚才的话题，因此时间戳也并不推荐使用。</p>
<p>5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符</p>
<h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><table>
<thead>
<tr>
<th>SQL 语句</th>
<th>作用</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建数据库 &#x2F; 表</td>
<td>create database `数据库名`; &#x2F; create table `表名` ( 字段描述 );</td>
</tr>
<tr>
<td>drop</td>
<td>删除数据库 &#x2F; 表</td>
<td>drop database `数据库名`; &#x2F; drop table `表名`;</td>
</tr>
<tr>
<td>use</td>
<td>选中数据库</td>
<td>use `数据库名`;</td>
</tr>
<tr>
<td>alter</td>
<td>更改数据库 &#x2F; 表信息</td>
<td>alter table `表名` add constraint `约束名` unique (`字段名`);</td>
</tr>
</tbody></table>
<p>PS： </p>
<p>修改表的引擎 &#x2F; 更改自增约束初始值是在 create table `表名` () 后面添加的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table `表名`(</span><br><span class="line"></span><br><span class="line">)engine = innodb auto_increment=2 comment &#x27;表示例&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary key (`列名`),</span><br></pre></td></tr></table></figure>

<p><em>复合主键语法上没错，但是开发使用时非常不好用，因为需要至少两条字段才能唯一确定一条记录。一般不会用。</em></p>
<p><em>如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。</em></p>
<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p><code>default val;</code> 设置默认值。</p>
<h3 id="自增约束、非空约束"><a href="#自增约束、非空约束" class="headerlink" title="自增约束、非空约束"></a>自增约束、非空约束</h3><p>都在字段描述后面写即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`col_name` int auto_increment not null comment &#x27;列名&#x27;,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建表时：</span><br><span class="line">create table(</span><br><span class="line">    id int primary key comment &#x27;id&#x27;;</span><br><span class="line">	age int check (age&gt;=0 &amp;&amp; age&lt;=100) comment &#x27;年龄&#x27;,</span><br><span class="line">	gender char(1) default &#x27;m&#x27; comment &#x27;性别&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改表时，主键，unique，check，外键用 add，其他用 modify</span><br><span class="line">alter table add primary key(列名);</span><br><span class="line">alter  table table_name modify 列名 数据类型  not null;# 如果是 null，就是取消非空约束</span><br></pre></td></tr></table></figure>

<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint `uk_col_name` unique (`col_name`),</span><br></pre></td></tr></table></figure>

<p>类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constraint `ck_col_sex` check (`col_sex`=&#x27;M&#x27; or `col_sex`=&#x27;F&#x27;),</span><br></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。</p>
<p>外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 外键需要先创建一个字段，然后给这个字段添加外键。原外键的字段和新的要添加外键的字段数据类型要一样。</span><br><span class="line">alter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段);</span><br><span class="line"></span><br><span class="line">alter table 表名 drop foreign key 外键名;</span><br></pre></td></tr></table></figure>

<p><em>一对多时，多的一方需要加外键约束。</em></p>
<p>之后子表引用了父表，父表被引用的记录就不能随便删除了。子表也不能随便写外键的值，必须要在父表中存在才可以引用。</p>
<table>
<thead>
<tr>
<th>外键删除更新行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no action&#x2F;restrict</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则不删除&#x2F;更新</td>
</tr>
<tr>
<td>cascade</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录也删除&#x2F;更新</td>
</tr>
<tr>
<td>set null</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录对应字段设为空值（前提：该字段可以为 null）</td>
</tr>
<tr>
<td>set default</td>
<td>父表要删除&#x2F;更新的记录如果在子表中存在关联记录，则子表中的记录也删除&#x2F;更新对应字段设为默认值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段) on update cascade on delete cascade;</span><br></pre></td></tr></table></figure>

<h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行</span><br><span class="line">insert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的</span><br></pre></td></tr></table></figure>

<p>注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 <code>default</code> ，不然系统也难以分辨哪一项使用默认值。</p>
<p><em>日期可以写字符串 2002-01-01，会自动转换</em></p>
<p>插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。</p>
<p><strong>如果主键、unique 的记录重复会报错。</strong>报错显示： <code>duplicate key for key &#39;定义的约束键名称&#39;</code></p>
<p><strong>填写了规定的 check 以外的内容会报错。</strong>报错显示：<code>check constraint &#39;定义的约束键名称&#39; is violated.</code> 不过字符串不区分大小写，规定性别只能填 ‘F’ ‘M’ 的话，填 ‘f’ ‘m’ 也行。</p>
<p><strong>如果对应的外键在原表中没有对应的记录会报错。</strong> 报错显示：<code>cannot add or update a child row: a foreign constraint fails</code> 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。</p>
<p><strong>如果没有给 NOT NULL且没有默认值的字段赋值时会报错。</strong> 报错显示：<code>Field &#39;字段名&#39; doesn&#39;t have a default value.</code> 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete from `表名`;//这可不兴用啊！</span><br><span class="line">delete from `表名` where `字段名`=&#x27;要删除的记录的对应字段值&#x27;;//不等于可以用&lt;&gt;，有的 DBMS 支持!=</span><br><span class="line">delete from `表名` where `字段名` = &#x27;字段值&#x27; or `字段名` = &#x27;字段值&#x27;;//根据多个条件删除语句</span><br><span class="line">delete from `表名` where `字段名` in (&#x27;字段值&#x27;,&#x27;字段值&#x27;);//删除多条语句</span><br></pre></td></tr></table></figure>

<p>但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： <code>Cannot delete or update a parent row</code> 。</p>
<p>删除了外键约束之后就可以随意修改两个表对应的值而不报错了。</p>
<p>另一种删除表的方式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table `表名`;</span><br></pre></td></tr></table></figure>

<p>截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update `表名` set `列名` = &#x27;值&#x27;;//把这一列的数据全都改成这个值，不常用</span><br><span class="line">update `表名` set `列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27; where `字段`=&#x27;值&#x27;;//限制条件，只修改某几个记录</span><br></pre></td></tr></table></figure>

<h1 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h1><p>学习自b站骆昊jackfrued 老师的网课以及黑马网课。</p>
<p>查询语句。</p>
<p><em>本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）</em></p>
<p><em>tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）</em></p>
<h2 id="编写顺序、执行顺序"><a href="#编写顺序、执行顺序" class="headerlink" title="编写顺序、执行顺序"></a>编写顺序、执行顺序</h2><p>编写顺序如下：<code>select from where group by having order by limit;</code></p>
<p>执行顺序：</p>
<ol>
<li><p>from 表名</p>
</li>
<li><p>where 条件（where 可以用表别名，但是不能用 select 中的字段别名）</p>
</li>
<li><p>group by 分组</p>
</li>
<li><p>having 分组条件</p>
</li>
<li><p>select 投影</p>
</li>
<li><p>order by 排序</p>
</li>
<li><p>limit 分页</p>
</li>
</ol>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>查询所有学生的所有信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `表名`;-- * 号表示所有字段</span><br></pre></td></tr></table></figure>

<p>但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。</p>
<p>实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;</span><br></pre></td></tr></table></figure>

<p>如果只查询部分列，就只写那几列就行。</p>
<h2 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合 Union"></a>联合 Union</h2><p>Union 会把查询结果联合起来。</p>
<p>union all：结果可能重复。</p>
<p>union：重复的结果合并。</p>
<p><strong>想做union操作，两个要联合的表必须字段数相同，字段类型匹配。</strong></p>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>给字段或表起别名—— alias，简写为 as。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id` as `学号` from `tb_student`;</span><br></pre></td></tr></table></figure>

<p>as 可以省略，不过还是写上可读性高一些。<em><strong>一般字段不省略，表省略</strong>。具体还得看公司编程规范的要求，没有就看个人喜好了。</em></p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>限制查询记录的条件——where（选择 Selection，只查询某几行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_sex`=&#x27;M&#x27; or `stu_name`=&#x27;Jingqing&#x27;;</span><br></pre></td></tr></table></figure>

<p>多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。</p>
<p><em>性能问题，一般不用 or 而使用 union，结果取并集。</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_sex`=&#x27;M&#x27; </span><br><span class="line">union</span><br><span class="line">select * from table where `stu_name`=&#x27;Jingqing&#x27;;</span><br></pre></td></tr></table></figure>

<p><em><strong>如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。</strong></em></p>
<p>类似 10&lt;x&lt;30 的形式不可以直接写两个等式，要拆成 x&gt;10 and x&lt;30 。</p>
<p>这里的字段如果是数字类型的，也可以进行 + - * &#x2F; % mod（也是取余）以及 &lt; &gt;  &#x3D; &gt;&#x3D; &lt;&#x3D; &lt;&gt; 等形式的运算。</p>
<p>还有一种条件写法是 <code>between …… and ……</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where `stu_age` between 10 and 30;-- 相当于 &lt;=30 and &gt;=10</span><br></pre></td></tr></table></figure>

<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select if(`stu_sex`,&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;性别&#x27; from `tb_student`;-- 有点类似三目运算符 ?:</span><br></pre></td></tr></table></figure>

<p>if 中第一项可以是表达式，如 age &gt; 10.</p>
<p><strong>这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。</strong>比如 Oracle 数据库中对应的函数是 decode，不能通用。</p>
<p>通用的分支结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select case `sex` </span><br><span class="line">when 1 then &#x27;男&#x27; </span><br><span class="line">elseif 0 then &#x27;女&#x27; </span><br><span class="line">else &#x27;未知&#x27;</span><br><span class="line">end as &#x27;性别&#x27; from `tb_student`;-- end 表示条件判断结束</span><br></pre></td></tr></table></figure>

<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>如：查询所有姓王的学生。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_name` like &#x27;王%&#x27;;-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生</span><br><span class="line">select * from `student` where `stu_name` like &#x27;王_&#x27;;-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生</span><br></pre></td></tr></table></figure>

<p>这里和正则表达式有一定联系，之后会单独学习。</p>
<p>2023-01-23 补档：我后来确实学习了正则表达式~学习笔记在这里：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq/category_11807727.html?spm=1001.2014.3001.5482">Regex_灰海宽松的博客-CSDN博客</a></p>
<p>事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `字段名` regexp &#x27;正则表达式&#x27;;</span><br></pre></td></tr></table></figure>

<p>模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。</p>
<h2 id="空值处理，以及三值逻辑"><a href="#空值处理，以及三值逻辑" class="headerlink" title="空值处理，以及三值逻辑"></a>空值处理，以及三值逻辑</h2><p><strong>下面两种写法是错误的！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_address` = null;</span><br><span class="line">select * from `student` where `stu_address` &lt;&gt; null;</span><br></pre></td></tr></table></figure>

<p>因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。</p>
<p>正确做法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` where `stu_address` is null;</span><br><span class="line">select * from `student` where `stu_address` is not null;</span><br></pre></td></tr></table></figure>

<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct `字段名` from `表名`;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序</span><br></pre></td></tr></table></figure>

<p>order by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。</p>
<h2 id="当前日期"><a href="#当前日期" class="headerlink" title="当前日期"></a>当前日期</h2><p>curdate()获取当前日期，使用 datediff(datepart, date1, date2) 函数可以和出生日期做差获取年龄。</p>
<p>now()获取当前年月日时分秒（datetime）。</p>
<h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p>floor() 函数是下取整。floor(3.99) &#x3D; 3.</p>
<p>ceil() 函数是向上取整，ceil(3.1) &#x3D; 4.</p>
<p>round() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)&#x3D;4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select floor(datediff(curdate(),`date`)/365) from `staff`;</span><br></pre></td></tr></table></figure>

<p><em>可以通过? functions 查看函数一览。还会有相应的例子提示~</em></p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>描述性统计信息：包括集中趋势和离散趋势。</p>
<p>集中趋势：平均值，中位数等。</p>
<p>离散趋势：方差，标准差等。</p>
<p>聚合函数属于 SQL 语句，所有 DBMS 都能用。</p>
<ul>
<li><p>min(字段名)</p>
</li>
<li><p>max(字段名)</p>
</li>
<li><p>avg(字段名) <em>做计算的时候会忽略 null 值</em></p>
</li>
<li><p>sum(字段名)</p>
</li>
<li><p>count(字段名) <em>做计算的时候会忽略 null 值</em></p>
<p><em><strong>如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。</strong></em></p>
<p><em>比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) &#x2F; count(stu_id) 就是错误的，因为是9个人的成绩 &#x2F; 10.</em> </p>
<p><em>如果成绩为空的学生视为 &#x3D; 0，就要用 sum(score) &#x2F; count(stu_id)，或者对 avg() 函数做如下处理：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(ifnull(`score`,0)) from student;-- 如果第一个表达式!=null，则返回第一个表达式</span><br></pre></td></tr></table></figure>

<p><em>ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。</em></p>
<p>coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。</p>
</li>
<li><p>std(字段名)，计算标准差，越小说明越稳定。</p>
<ul>
<li>std(), stddev() 和 stddev_pop()：所有数据总体的标准差</li>
<li>stddev_samp()：样本标准差，抽样计算。</li>
</ul>
</li>
<li><p>variance(字段名)，计算方差，标准差的平方。</p>
<ul>
<li>variance(), var_pop()</li>
<li>var_samp()</li>
</ul>
</li>
</ul>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>聚合函数通常和分组一起使用。分组是非常重要的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(`score`) from `student` group by `sex`;</span><br></pre></td></tr></table></figure>

<p>PS： Excel 的数据透视表有同样功能：</p>
<p>插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认</p>
<p>行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和</span><br></pre></td></tr></table></figure>

<p>group by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。</p>
<p><strong>如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `Score` where avg(score)&gt;90 group by `stu_id`; -- 错误</span><br><span class="line">select `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)&gt;90; -- 正确</span><br></pre></td></tr></table></figure>

<p>分组以前的筛选： where, 写在分组后</p>
<p>分组以后的筛选： having, 写在分组后。</p>
<p><em>其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id` from `tb_record` group by `stu_id` having avg(score)&gt;90;</span><br></pre></td></tr></table></figure>

<p><em>也是没有问题的。</em></p>
<p>查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)&gt;90;</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询 (subquery) 的用途：</p>
<ul>
<li>集合成员资格，判断某一元素是否是某一个集合的成员</li>
<li>集合之间的比较，某一个集合是否包含另一个集合等</li>
<li>集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。</li>
</ul>
<p>查询年龄最大的学生的姓名。</p>
<p>可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。</p>
<p>一种方法是嵌套子查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name` from `tb_student` </span><br><span class="line">where `stu_birth` = (</span><br><span class="line">    select min(`stu_birth`) from `tb_student`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set @a =(select min(`stu_birth`) from `tb_student`);</span><br><span class="line">select @a; -- 可以查看一下 @a 的值。</span><br></pre></td></tr></table></figure>

<p>如果子查询有很多结果，满足其中一个即可：不能用等号，要用 <strong>in</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `name` from `tb_student` </span><br><span class="line">where `stu_id` in (</span><br><span class="line">    select `stu_id` from `tb_record` group by `stu_id` where count(*)&gt;=2</span><br><span class="line">); -- 查询出所有至少选了2门课的学生姓名</span><br></pre></td></tr></table></figure>

<p>如果用了等号，报错： subquery returns more than 1 row.</p>
<p>标量子查询：结果为一个。可以做&gt; &lt; &#x3D;操作。</p>
<p>列子查询：结果为一列。可以做 IN NOT IN SOME ALL ANY 操作。（ANY SOME 等价）</p>
<p>行子查询：结果为一行。可以做 &#x3D; &lt;&gt; IN NOT IN 操作。</p>
<p>表子查询：结果为多行多列。最常用 IN NOT IN 操作。</p>
<h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><p>一对一，一对多，多对多（两个一对多）</p>
<p>一对一：其中一方设置unique的外键。</p>
<p>一对多：多的一方设置外键。</p>
<p>多对多：建立中间表，设置两个外键。</p>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;</span><br></pre></td></tr></table></figure>

<p>如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。</p>
<p>本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。</p>
<h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ol>
<li>有外键约束：利用外键连接，不用加条件，自动连接。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` </span><br><span class="line">from `tb_student` natural join `tb_college`;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。<em>注意：不管有几个同名的列，所有列都会作为连接的条件！</em></li>
<li>如果没有外键也没有同名列，就只会得到笛卡尔积的结果。</li>
</ol>
<h3 id="内-外连接"><a href="#内-外连接" class="headerlink" title="内 &#x2F; 外连接"></a>内 &#x2F; 外连接</h3><p>另一种连接方式是 inner join &#x2F; outer join </p>
<p>或者用 <code>where A.id=B.id</code> ，这种内连接方式叫做隐式内连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` </span><br><span class="line">from `tb_student` inner join `tb_college` </span><br><span class="line">on `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号</span><br></pre></td></tr></table></figure>

<p>inner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。</p>
<p>left outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。</p>
<p>right outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。</p>
<p>full outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。</p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A AS1 inner join A AS2 where 条件;-- 自连接可以是内或外连接。必须起别名！！！</span><br></pre></td></tr></table></figure>

<h3 id="θ-连接"><a href="#θ-连接" class="headerlink" title="θ 连接"></a>θ 连接</h3><p>添加条件使得两个表中的数据相互对应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` </span><br><span class="line">where `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号</span><br></pre></td></tr></table></figure>

<h3 id="三表连接"><a href="#三表连接" class="headerlink" title="三表连接"></a>三表连接</h3><p>链接条件用多个条件筛选。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`</span><br><span class="line">where `tb_course`.`cou_id`=`tb_record`.`cou_id` </span><br><span class="line">and `tb_student`.`stu_id`=`tb_record`.`stu_id`;</span><br><span class="line"></span><br><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`</span><br><span class="line">inner join `tb_record`</span><br><span class="line">on `tb_student`.`stu_id`=`tb_record`.`stu_id`</span><br><span class="line">inner join `tb_course`</span><br><span class="line">on `tb_course`.`cou_id`=`tb_record`.`cou_id`</span><br><span class="line">where `tb_course`.`cou_name` is not null; -- where 写在最后</span><br><span class="line"></span><br><span class="line">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`</span><br><span class="line">natural join `tb_record`</span><br><span class="line">natural join `tb_course`;</span><br></pre></td></tr></table></figure>

<h2 id="查询小技巧"><a href="#查询小技巧" class="headerlink" title="查询小技巧"></a>查询小技巧</h2><p>百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件</p>
<p>python -推广链接 不想看到广告推送</p>
<p>site:zhihu.com python 只搜索知乎里的 python 内容</p>
<p>2023-01-23 补充：关于信息检索，博主也有开一个新坑：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq/category_12158048.html?spm=1001.2014.3001.5482">信息检索_灰海宽松的博客-CSDN博客</a>。目前更新还不完全，不过对于搜索引擎部分应该足够用了。</p>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>limit 是 mysql 的<strong>方言</strong>。</p>
<p>limit 查询最值有个缺陷，就是只能查出一条。如果有两个最大值就只能显示一个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。</span><br><span class="line">select * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)</span><br><span class="line">select * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)</span><br></pre></td></tr></table></figure>

<h2 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h2><p>select 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）</p>
<p>查询学生姓名和平均成绩。</p>
<p>查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？</p>
<p>先通过一个查询，得到一个派生表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select `stu_id`,avg(score) from `tb_record` group by `stu_id`;</span><br></pre></td></tr></table></figure>

<p>然后把其结果作为一个新表，和学生表做关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select `stu_name`,`avg(score)`from `tb_student`</span><br><span class="line">natural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思</span><br></pre></td></tr></table></figure>

<p><strong>临时表必须要起别名！！！</strong>不然报错。</p>
<p><strong>注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！</strong>因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，<strong>没选课的学生就不会查出来。</strong></p>
<p>如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。</p>
<h1 id="DQL-例题及注意事项"><a href="#DQL-例题及注意事项" class="headerlink" title="DQL 例题及注意事项"></a>DQL 例题及注意事项</h1><h2 id="简单排序——查询最大值、次大只"><a href="#简单排序——查询最大值、次大只" class="headerlink" title="简单排序——查询最大值、次大只"></a>简单排序——查询最大值、次大只</h2><ol>
<li><p>员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。</p>
<p>做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。</p>
<p>做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。</p>
<p>做法③：查询一名没有人薪水比他大的员工（即：薪水大于这名员工的员工数&#x3D;0）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` t1 where(</span><br><span class="line">    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`</span><br><span class="line">)=0;-- 结尾改成1，就是工资第二高的人</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询除了 boss 外工资最高的人。</p>
<p>在题1的基础上，用 where 排除掉 boss。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` </span><br><span class="line">where `salary`=(</span><br><span class="line">    select max(salary) from `tb_employee` where `position`&lt;&gt;&#x27;boss&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询月薪 top 3的人。</p>
<p>这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`salary` from `tb_employee` t1 where(</span><br><span class="line">    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`</span><br><span class="line">)&lt;3 order by `salary` desc;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。</p>
<p>题目很简单，但是<strong>遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。</strong>要用 ifnull() 或 coalesce() 函数限制一下。</p>
</li>
<li><p>查询所有部门名称及员工人数。</p>
<p>部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。<strong>重点注意几种连接的不同，思考一下题中哪个信息要全部展示出来。</strong>比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dname,total from `tb_department` t1</span><br><span class="line">left join (</span><br><span class="line">    select dname, count(*) as total from `tb_department` t2 group by `dno`</span><br><span class="line">) on t1.`stu_id`=t2.`stu_id`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious</p>
<p>先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sname,salary from `tb_employee` t1</span><br><span class="line">inner join (</span><br><span class="line">	select avg(salary),dno from `tb_employee` group by dno;</span><br><span class="line">)t2 on t1.dno=t2.dno and t1.salary &gt; t2.avg(salary);-- 两个连表条件</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。</p>
<p>派生表通过薪水值、部门号和员工表、部门表相连接。</p>
</li>
<li><p>查询薪水排名4-6员工的薪水、姓名、<strong>排名</strong>。</p>
<p>问题1：怎么查出排名？</p>
<p>问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5</p>
<p>解决：mysql 8的窗口函数可以解决排名 &#x2F; top N 问题。</p>
<p>①不用窗口函数：</p>
<p>系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：<code>set @a=0;</code>或<code>select@a:=0;</code>而且变量也可以通过 as 起别名。</p>
<p>我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set @a=0;</span><br><span class="line">select row_num,ename,salary from (</span><br><span class="line">	select @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0</span><br><span class="line">    from `tb_employee` order by salary desc</span><br><span class="line">) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次</span><br></pre></td></tr></table></figure>

<p>注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.</p>
<p>另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。</p>
</li>
<li><p>查询每个部门薪水排名前两名的员工。</p>
<p>Top N 问题通过题1的做法③解决。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select eno,ename,salary,dno from `tb_employee` t1</span><br><span class="line">where (</span><br><span class="line">	select count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary&gt;t1.salary</span><br><span class="line">)&lt;2 order by t1.dno asc, t1.salary desc;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>内容来自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92654574">通俗易懂的学会：SQL 窗口函数 - 知乎</a></p>
<p>应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by</p>
<p>窗口函数不光是函数，有一套完整的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;</span><br><span class="line">                order by &lt;用于排序的列名&gt;)</span><br></pre></td></tr></table></figure>

<p>&lt;窗口函数&gt; 处放聚合函数或专用窗口函数。</p>
<p>窗口函数是以一个列的形式使用的。</p>
<h3 id="专用窗口函数"><a href="#专用窗口函数" class="headerlink" title="专用窗口函数"></a>专用窗口函数</h3><p>rank、dese rank、row_number</p>
<p>看图即知区别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152337617.png" alt="img"></p>
<h3 id="partition-by-和-group-by-的区别"><a href="#partition-by-和-group-by-的区别" class="headerlink" title="partition by 和 group by 的区别"></a>partition by 和 group by 的区别</h3><p>partition by 是把所有数据分成绩一个窗口，而并不汇总。比如上图中，如果按班级号分窗口再进行排序，就会在每个班级内部从1到无穷排序。不写的话就默认整个表是一个大窗口。</p>
<p>group by 是分组后汇总。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152337023.png" alt="img"></p>
<p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`sal`,</span><br><span class="line">rank() over (order by `sal` desc)as `r1`,</span><br><span class="line">dense_rank() over (order by `sal` desc)as `r2`,</span><br><span class="line">row_number() over (order by `sal` desc)as `r3`</span><br><span class="line">from `tb_emp`;</span><br></pre></td></tr></table></figure>

<p>第八题窗口函数做法：加一个 where r between 4 and 6 的条件。</p>
<p>第九题窗口函数做法：因为产生了分组，因此不能直接用 where r &lt;&#x3D;2。但是<strong>窗口函数的分窗口后的列做筛选，既不能直接用 where 也不能用 having</strong>。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select `ename`,`sal`,`dno`</span><br><span class="line">from(</span><br><span class="line">    select `ename`,`sal`,`dno`,</span><br><span class="line">    rank() over (partition by `dno` order by `sal` desc)as `r`</span><br><span class="line">    from `tb_emp`</span><br><span class="line">) `temp` where `r`&lt;=2;-- 不能在派生表里直接筛选</span><br></pre></td></tr></table></figure>

<p><em>窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。</em></p>
<h1 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h1><p>Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。主要是 DBA 使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br><span class="line">create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问。域名如 localhost，%代表任意路径</span><br><span class="line">alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified with mysql_native_password by &#x27;新密码&#x27;;-- with mysql_native_password 是 mysql 的修改方式</span><br><span class="line">drop user &#x27;人名&#x27;@&#x27;域名&#x27;;</span><br></pre></td></tr></table></figure>

<p>如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。</p>
<p>查看权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>授权：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 权限 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure>

<p>数据库名和表名可以用通配符 * 代替。</p>
<p>权限包括： all (privileges), select, insert, update, delete, alter, drop, create</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改</span><br><span class="line">grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;</span><br><span class="line">grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限</span><br><span class="line">grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人</span><br></pre></td></tr></table></figure>

<p>召回权限：revoke</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限 数据库名.表名 from &#x27;人名&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p>添加权限之后最好 Reconnect 刷新一下。或者执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>Workbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。</p>
<p>至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>很多内容其实在 DQL 早就介绍过。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(s1, s2, sn)</td>
<td>字符串拼接</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>转小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>转大写</td>
</tr>
<tr>
<td>LPAD(str, n, pad)</td>
<td>用 pad 对 str 左边n个字符长度进行填充</td>
</tr>
<tr>
<td>RPAD(str, n, pad)</td>
<td>用 pad 对 str 右边n个字符长度进行填充</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去掉头尾的空格</td>
</tr>
<tr>
<td>SUBSTRING(str, start, len)</td>
<td>返回 str 从指定位置 start 开始 len 长度的子字符串（从0开始）</td>
</tr>
</tbody></table>
<p>如：所有员工的工号都必须是五位数，不足的话在左端补0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名 = lpad(字段名,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>mod(x,y)</td>
<td>返回x&#x2F;y的模</td>
</tr>
<tr>
<td>rand()</td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td>round(x,y)</td>
<td>返回x四舍五入值，保留y位小数</td>
</tr>
</tbody></table>
<p>例：生成6位验证码。</p>
<p>首先靠随机数生成，然后*1000000并四舍五入，然后还要考虑开头为0的情况，因此不足六位补0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select lpad(round(rand()*1000000,0),6,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>curdate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>curtime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>year(date)</td>
<td></td>
</tr>
<tr>
<td>month(date)</td>
<td></td>
</tr>
<tr>
<td>day(date)</td>
<td></td>
</tr>
<tr>
<td>date_add(date, interval expr type)</td>
<td>date 加时间间隔 expr，可以是年月日时间，如<code>interval 70 day</code></td>
</tr>
<tr>
<td>datediff(date1, date2)</td>
<td>求两个日期相差天数</td>
</tr>
</tbody></table>
<h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>if(value, t, f)</td>
<td>true 返回t， false 返回f</td>
</tr>
<tr>
<td>ifnull(value1, value2)</td>
<td>value1 为 null 返回 value1，空返回 value2</td>
</tr>
<tr>
<td>case when val1 then res1 else default end</td>
<td>switch case</td>
</tr>
<tr>
<td>case expr when val1 then res1 else default end</td>
<td>表达式形式的 switch case</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(case workaddress </span><br><span class="line"> when &#x27;北京&#x27; then &#x27;一线城市&#x27; </span><br><span class="line"> when &#x27;上海&#x27; then &#x27;一线城市&#x27; </span><br><span class="line"> else &#x27;二线城市&#x27; </span><br><span class="line"> end) as &#x27;工作地&#x27;;</span><br><span class="line"> </span><br><span class="line">(case score </span><br><span class="line"> when score=100 then &#x27;满分&#x27; </span><br><span class="line"> when score&gt;=90 then &#x27;优秀&#x27; </span><br><span class="line"> else &#x27;懒得写了&#x27; </span><br><span class="line"> end) as &#x27;成绩所在段&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组不可分割的操作集合，要么都成功执行，要么都失败。如银行账户数据库操作，一个人给另一个人转账1000元，那么这两个人的update操作就是不可分割的，不然如果有一个操作成功执行另一个没有，就可能银行平白无故少了1000或者收款人没收到钱。</p>
<p>事务的步骤：</p>
<ol>
<li>开启事务</li>
<li>执行一条条操作。这期间如果有失败则事务回滚。或者手动进行事务回滚。</li>
<li>全部执行完后提交事务。默认mysql是自动提交事务的，每执行一条语句就会提交一条。</li>
</ol>
<h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@autocommit;-- 1：自动提交；0：手动提交</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set @@autocommit=0;-- 开启手动提交</span><br><span class="line"></span><br><span class="line">rollback;-- 回滚</span><br><span class="line"></span><br><span class="line">commit;-- 提交</span><br></pre></td></tr></table></figure>

<p>或者在<code>@@autocommit=1</code>时临时开启事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start transaction;-- 开启事务</span><br></pre></td></tr></table></figure>

<h2 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性 ACID"></a>事务四大特性 ACID</h2><p>atomicity 原子性：事务是不可分割的最小操作单元。</p>
<p>consistency 一致性：所有数据保持一致状态。</p>
<p>isolation 隔离性：事务不受外部干扰，独立进行。</p>
<p>durability 持久性：提交或回滚后，事务对数据库的操作就是永久的。</p>
<h2 id="并发事务问题及解决办法"><a href="#并发事务问题及解决办法" class="headerlink" title="并发事务问题及解决办法"></a>并发事务问题及解决办法</h2><p>多个事务同时进行时会出现的问题。</p>
<p>以下是数据库事务可以设置的几种隔离级别，分别是应对不同问题用的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336578.png" alt="image-20220801231316895"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select @@TRANSACTION_ISOLATION;-- 查看数据库隔离级别</span><br><span class="line">set session/global TRANSACTION ISOLATION LEVEL SERIALIZABLE;-- 设置当前会话/全局事务隔离级别为serializable</span><br></pre></td></tr></table></figure>

<p>read uncommitted 是数据库最低隔离级别，即：一个事务中的数据还未提交别的事务就可以读得到。</p>
<p><strong>问题1</strong>：脏读：一个事务读到另一个事务未提交的数据（Read uncommitted会发生）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544202.png" alt="image-20220802212804661"></p>
<p><strong>解决办法</strong>：read committed 限制一个事务修改的数据要等到提交后别的数据才能读得到。解决了脏读问题，但是没有解决不可重复读问题，事务2第一次读和第二次读数据可能值不一样。</p>
<p>解决后：（给要读取的左边的窗口设置 read-committed 隔离级别）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544203.png" alt="image-20220802212544087"></p>
<p><strong>问题2</strong>：不可重复读：一个事务前后读了同一个数据两次，两次值不一样。因为其他事务在这中间提交过一次。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544204.png" alt="image-20220802213646432"></p>
<p><strong>解决办法</strong>：repeatable 使得事务2开启后事务1才提交的数据事务2读取不到，避免了不可重复读的问题。但是没有解决串行化问题，即事务2再对数据的修改会覆盖事务1的修改。</p>
<p><strong>问题3</strong>：幻读：每个事务开启时把数据读入缓存内，这样重复读取的时候直接从缓存中读取，避免了重复读取数据不一样。但是数据不及时更新，比如事务1删库了，事务2还能读；或者事务1新增了一条主键为i的数据提交了，事务2随后也想新增一条主键为i的数据，提交的时候发现1已经写过了，交不进去了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336806.png" alt="image-20220802221507795"></p>
<p><strong>解决办法</strong>：serializable 让事务1在操作当前数据库时，别的事务直接操作不了。</p>
<p><strong>问题4</strong>：开启序列化后，其他事务插入会卡住，等待当前事务插入完成后再执行插入操作。会导致用户体验差，需要等待。所以序列化等级还是很少使用的。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="Mysql-体系结构"><a href="#Mysql-体系结构" class="headerlink" title="Mysql 体系结构"></a>Mysql 体系结构</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336306.png" alt="image-20220803115255247"></p>
<p>连接层：连接池部分，与客户端连接，并检查授权认证、权限、最大连接数等。</p>
<p>服务层：SQL接口一行，绝大部分核心功能如SQL解析优化、所有跨存储引擎的实现都在这一层。</p>
<p>引擎层：可插拔存储引擎一行，<strong>索引</strong>在这一层实现，决定数据库数据如何存、取、组织。如果当前引擎不满足需求还可以拓展，因此被称作可插拔。</p>
<p>存储层：最下面一行，存取数据库的相关数据。</p>
<h2 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h2><p>存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的。</p>
<p>查询建表语句：<code>show create table 表名;</code>时在结尾就可以看到该表的存储引擎。</p>
<p><code>show engines;</code>查询当前数据库支持的所有引擎。</p>
<p>创建指定引擎的表：<code>create table (...) engine=指定引擎;</code></p>
<p>修改表引擎：<code>alter table 表名 engine=指定引擎;</code></p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>高性能存储引擎，Mysql 5.5后的默认引擎。</p>
<p>支持事务、行级锁、外键。</p>
<p>文件后缀.ibd是InnoDB存储引擎的表空间文件，每个表有一个，存储表结构数据和索引。<em>表结构早期是frm，后来变成sdi，sdi又融入了ibd格式中。</em></p>
<p>有一个系统变量<code>innodb_file_per_table</code>，可以通过<code>show variables like &#39;innodb_file_per_table&#39;</code>查看，ON则表示每张表都对应一个表空间文件ibd。</p>
<p>ibd文件在mysql文件夹-data文件夹-对应数据库文件夹里。</p>
<p>ibd文件直接打开是看不了的，都是二进制。可以进入目标文件夹后，通过命令行<code>ibd2sdi 指定表名.ibd</code>，就可以查看该表的json文件信息了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544208.png" alt="image-20220803210405717"></p>
<p>表空间文件逻辑存储结构如图所示，段-区-页-行，每一行就是表中的一行数据。</p>
<p>一个区大小固定为1M，一页大小固定为16K。（大概了解，SQL优化部分还要涉及）</p>
<h2 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h2><p>数据库早期的默认存储引擎。（现在功能几乎可以被NoSQL的Mongodb取代）</p>
<p>不支持事务和外键，支持表锁，不支持行锁，访问速度快。</p>
<p>存储文件包括：</p>
<p>.MYD：数据</p>
<p>.MYI：索引</p>
<p>.sdi：表结构，可以直接打开，里面装的是json格式内容（可以通过json.cn格式化）。</p>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>存放在内存中，数据是临时的。（现在功能几乎可以被NoSQL的Redis取代）</p>
<p>访问速度快，支持hash索引。</p>
<p>存储文件只包括：.sdi，因为数据索引都存在内存里了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544209.png" alt="image-20220803211018558"></p>
<h2 id="三种存储引擎的选择"><a href="#三种存储引擎的选择" class="headerlink" title="三种存储引擎的选择"></a>三种存储引擎的选择</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544210.png" alt="image-20220803211235879"></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是高效获取数据的数据结构。</p>
<h2 id="Linux中安装Mysql"><a href="#Linux中安装Mysql" class="headerlink" title="Linux中安装Mysql"></a>Linux中安装Mysql</h2><p>首先在Linux中安装Mysql。还好前两天接触了一点虚拟机。</p>
<p><a target="_blank" rel="noopener" href="https://downloads.mysql.com/archives/community/">Mysql 下载地址</a></p>
<p>FinalShell可以直接点击上传标志上传下载的压缩包：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544211.png" alt="image-20220803220722619"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf 压缩包名 -C mysql //解压到该文件夹内</span><br><span class="line"></span><br><span class="line">//安装其中的所有rpm文件</span><br><span class="line">rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install openssl-devel</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>启动：安装好mysql后，linux会自动提供mysqld服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld //启动mysql</span><br><span class="line"></span><br><span class="line">mysql -uroot -p //然后去日志文件里找密码~</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure>

<p>查找密码可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>

<p>也可以直接打开该文件看。登录后就是用熟悉的SQL改密码.</p>
<p>linux密码默认校验规则等级为Medium，要求&gt;8位，包括数字，大小写字母和符号。可以设置强度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global validate_password.policy = 0;</span><br><span class="line">set global validate_password.length = 4;</span><br></pre></td></tr></table></figure>

<p>然后可以设置个简单点的密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;1234&#x27;;</span><br></pre></td></tr></table></figure>

<p>然后为了DataGrip可以访问，创建一个可以远程访问新用户：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;Windows&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;1234&#x27;;</span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to &#x27;Windows&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<p>可以通过ifconfig查看ip地址。查看后就可以在DataGrip中链接啦。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336010.png" alt="image-20220803223712197"></p>
<h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><p>是帮助Mysql高效<strong>获取数据</strong>的有序数据结构。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544213.png" alt="image-20220803224534102" style="zoom:80%;" />

<p>比如查找age&#x3D;45的记录，如果age采用二叉树的存储方式，很明显右边比左边更高效。</p>
<p>索引使得查询和排序成本降低，但是增删改成本增加，而且索引也要占用空间（MYI文件）。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336564.png" alt="image-20220803224920983" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544216.png" alt="image-20220803225009939" style="zoom:67%;" />

<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>二叉树比较简单，小数插在左子树，大数插在右子树。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544217.png" alt="image-20220803225242447" style="zoom:67%;" />

<p>但是如果一直往左或右插，树就变成一边倒的形状了，查询效率大大降低。</p>
<p>红黑树可以解决平衡问题。但是大数据情况下还是层级较深，检索速度较慢。</p>
<p>B树：又名多路平衡查找树。</p>
<p>首先每个节点的子节点个数叫度数。</p>
<p>以最大度数为5的5阶B树为例：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544218.png" alt="image-20220803230306405" style="zoom:67%;" />

<p>一开始插入4个数以内，都在一个节点里</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336423.png" alt="image-20220804001653602"></p>
<p>然后插入第五个数，就开始分裂，中间的数作为父节点，左右两组数作为子节点</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544220.png" alt="image-20220804001734711"></p>
<p>然后插入数还是往子节点里插入</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544221.png" alt="image-20220804001859705"></p>
<p>如果子节点够5个，中间的提到父节点处。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336894.png" alt="image-20220804002347547"></p>
<p>一直插入到父节点达到5个，父节点再次分裂。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544223.png" alt="image-20220804002649191"></p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>就是B树的所有叶子节点会形成一个单向链表</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544224.png" alt="image-20220804003347742" style="zoom:67%;" />

<p>Mysql里的B+树就是叶子结点变成了双向循环链表，提高区间访问性能。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544225.png" alt="image-20220804003507672"></p>
<h2 id="Hash-索引"><a href="#Hash-索引" class="headerlink" title="Hash 索引"></a>Hash 索引</h2><p>通过一定的Hash算法，把值都归到对应hash值的槽位上。如果出现槽位冲突，采用链表的方式解决。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544226.png" alt="image-20220804003919738"></p>
<p>只能用于&#x3D;等值查询，不能查询范围(&gt;&lt; between)，不能排序。</p>
<p>效率很高，通常一次查询就找得到。</p>
<p>只有Memory存储引擎支持。但是InnoDB具有自适应hash功能，可以在给定的条件下将B+树构建为hash索引。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336338.png" alt="image-20220804004326046" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211241544228.png" alt="image-20220804004404121" style="zoom:80%;" />

<p>有主键，主键就是聚集索引；</p>
<p>没有主键，第一个unique是聚集索引；</p>
<p>没有主键和unique唯一索引，则表会自动生成一个rowid作为隐藏的聚集索引。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336849.png" alt="image-20220804131209280"></p>
<p><code>select ... where name=&#39;Arm&#39;;</code>会先在二级索引中找到对应节点，然后根据id去聚集索引B+树中找主键，进而找到对应的row行数据。</p>
<p>因此直接<code>select ... where id=10;</code>效率会更高，哪怕name有索引也需要回表查询（回id表）。</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (col_name,...);</span><br><span class="line">-- 查看表中索引：</span><br><span class="line">SHOW INDEX FROM table_name;</span><br><span class="line">-- 删除索引</span><br><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p><code>show global status like &#39;Com_______&#39;;</code>查看当前数据库增删改查等操作的频次。如 Com_commit Com_select。</p>
<p>慢查询日志：记录了所有查询时间超过10s（long_query_time）sql语句的日志。查询变量：slow_query_log 可以看是否开启。</p>
<p>默认没有开启，需要到&#x2F;etc&#x2F;my.cnf中开启 slow_query_log。</p>
<p>开启后&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;主机吗名-slow.log中就会生成慢查询日志。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/my.cnf</span><br><span class="line"></span><br><span class="line">// 编辑，添加：</span><br><span class="line"></span><br><span class="line">slow_query_log=1</span><br><span class="line">long_query_time=10</span><br><span class="line"></span><br><span class="line">:x//保存退出</span><br><span class="line"></span><br><span class="line">systemctl restart mysqld//重启</span><br><span class="line"></span><br><span class="line">show variables like &#x27;slow_query_log&#x27;;//查询是否开启</span><br></pre></td></tr></table></figure>

<p>但是慢查询查询不到少于它规定秒数的语句。</p>
<p>show profiles 可以帮助我们了解每条sql语句耗时。首先通过：have_profiling参数 查看当前数据库是否支持profile操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select @@have_profiling;</span><br><span class="line"></span><br><span class="line">select @@profiling;-- 默认关闭</span><br><span class="line"></span><br><span class="line">set profiling=1;</span><br><span class="line"></span><br><span class="line">show profiles;-- 查看刚才执行的所有sql耗时</span><br><span class="line"></span><br><span class="line">show profile for query 数字序号;-- 查看某一条特定的sql具体查询耗时，从start到cleaning up</span><br><span class="line"></span><br><span class="line">show profile cpu for query 数字序号;-- 还可以查看cpu占用情况</span><br></pre></td></tr></table></figure>

<p>然而时间并不是准确的判定性能方法。explain才是更好的方法。explain可以查看select的详细执行状况。在任意select语句前加上explain或 desc 就可以了。</p>
<p>属性含义：</p>
<p>id：select查询的序列号，表示select或操作表的顺序，从大到小，相同id值从上到下。</p>
<p>比如查询学生表、成绩表、学生成绩表 id 都是1，但从上到下顺序是s, sc, c。子查询 id 会更大。</p>
<p>select_type：查询类型。</p>
<p>​	simple：简单类型</p>
<p>​	subquery：子查询</p>
<p>​	primary：主查询，外层查询</p>
<p>​	union：联合的后半部分</p>
<p><strong>type</strong>：连接类型，性能由好到坏分别为：null（不查询表，查询常量时）, system（系统表）, const（主键约束查询，唯一性约束查询）, eq_ref（子查询的 const）, ref（非唯一性约束查询）, range, index（用到了索引，但也是全表索引扫描）, all（全表扫描）</p>
<p>尽量往前靠。</p>
<p><strong>possible_key</strong>：这张表中可能用到的索引。</p>
<p><strong>key</strong>：实际用到的索引。</p>
<p><strong>key_len</strong>：使用到的索引中的最大可能字节数。越短越好。</p>
<p>rows：Mysql认为必须要执行查询的行数（估计值）。</p>
<p>filtered：返回的行数&#x2F;读取的行数百分比，越大越好。比如查主键就不用遍历，查一条就查得出来。</p>
<h2 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h2><p>通过 create index 给某个属性添加索引。</p>
<p><em>查询结果结尾加 &#x2F;G ，可以把列转换为行显示。</em></p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol>
<li>联合索引的<strong>最左前缀法则</strong>。比如一个索引要关联多列，那么查询从最左列开始，且不跳过索引中的列。比如我们给 profession age status 三列添加了一个索引，那么查询时就该写：<code>select * from table where profession=&quot;&quot; and age=&quot;&quot; and status=&quot;&quot;; </code> 不写 profession 查询或者只写 profession 和 status 查询会出错，会出现有 null 的列。（好像8.0可以不写最左列）原理大概是复合属性的索引是先按第一个排序，再按第二个，再第三个……所以只按后面的排序查找就出错。当然这三个查询顺序无所谓，关键是左边的一定得有。（这里的左指的是创建索引的时候的顺序，比如 <code>create index index_name on table_name(left_column, right column);</code>）</li>
<li>联合索引中如果出现范围查询（&lt; &gt;），范围查询右侧的属性失效。比如 <code>select * from table where profession=&quot;&quot; and age&gt;30 and status=&quot;&quot;; </code>  status 查询就会失效。解决办法是尽量用 &gt;&#x3D; &lt;&#x3D;。</li>
<li>索引列上不要做运算，否则会失效。 比如查询姓名三个字以“松”结尾的学生，姓名有索引，但是 <code>select * from students where substring(name,3,1)=&quot;松&quot;;</code> 不走索引。</li>
<li>查询字符串没加单引号也失效。</li>
<li>尾部模糊匹配（”abc%”）不会失效，头部模糊匹配（”%abc”）失效。</li>
<li>or 的失效情况：<code>有索引列条件 or 无索引列条件</code> ，结果是所有索引都不会被用到。处理办法就是右边的属性也建立索引。</li>
</ol>
<p>总结就是，mysql 评估说全表扫描比索引查找快，那么就决定用全表。比如当前列 null 值比较多，<code>is null</code> 查询就会全表查询，<code>is not null</code> 是索引查询。</p>
<h3 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h3><p>有的列可能用了多个索引。可以人为提示指明用哪一个。</p>
<p><code>explain select * from table use index(index_name) where 条件;</code></p>
<p><code>explain select * from table ignore index(index_name) where 条件;</code></p>
<p><code>explain select * from table force index(index_name) where 条件;</code> use 可能不接受。force 是强制使用这个索引。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>查询使用了索引，且查询返回的列都在该索引当中。</p>
<p>覆盖索引效率高于 select *。</p>
<p>如果查询多列，包括有索引列和没索引列，explain 中 extra 显示 using index condition，意为使用了索引查找，但是最后又回表查询非索引列。</p>
<p>如果查询的多列只包含索引列，explain 中 extra 显示 using where; using index 意为只使用了索引查找，因为要查询的列只在索引列中就找得到。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304041241125.png" alt="image-20230404124124952"></p>
<p>比如上例，如果 <code>select * from table where id=2;</code> 先去聚集索引表中找 id&#x3D;2 的行，然后回表找到这一行，找到这一行的所有数据。</p>
<p>如果 <code>select id, name from table where name=&#39;Arm&#39;;</code> 先去辅助索引表中找到 Arm，辅助索引表中也会存储其 id 信息。这样就已经能查到所有字段了，就不用回表了。</p>
<p>但是如果查询的字段是 <code>id, name, gender</code> ，gender 不在辅助索引表中，因此还是用回表的。先根据 arm 对应的 id 值，去聚集索引表中找到相关的行信息，再回表查询 gender。这就超出了覆盖索引的范围。</p>
<p>例：<code>select id, username, pwd from user where username=&#39;jingqing&#39;;</code> 怎样设置索引使得查询最优？</p>
<p>答：id 是主键索引，为了达成覆盖索引，我们要给 username pwd 建立复合索引。</p>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>varchar int 等类型可能是很长的字符串，导致索引变得很大，查询时浪费大量磁盘 IO。</p>
<p>创建索引时可以只选择一定长度的前缀建立索引。如：</p>
<p><code>create index index_name on table_name(column(n));</code> 表示前n个字符建立前缀。</p>
<p>至于n取多少合适，可以根据索引的选择性决定，选择性&#x3D;不重复的索引值&#x2F;记录总数，越大越好，1是最好的唯一索引。（count(distinct column)&#x2F;count(column)）</p>
<p>我们可以用 substring(column, 1, n) &#x2F; count(*) 来计算前n个前缀的选择性。</p>
<h3 id="单列索引和联合索引"><a href="#单列索引和联合索引" class="headerlink" title="单列索引和联合索引"></a>单列索引和联合索引</h3><p>包含多列的是联合索引。</p>
<p>多个查询条件时推荐使用建立联合索引。因为比如 column a 和 column b 建立了两个单列索引，同时查询两者时 mysql 也只会选择其中一个索引查询，另一个字段回表查询（如果 mysql 自动选择了单列索引，可以用 use index() 限制）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152336398.png" alt="image-20230404131344451"></p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li>什么时候用索引？数据量比较大，且查询比较频繁的表要建立。</li>
<li>哪几列建立索引？常作为查询条件的列（where, order by, group by)。</li>
<li>建议区分度高的列建立唯一索引。</li>
<li>太长的列可以建立前缀索引。</li>
<li>尽量用联合索引而不是单列索引，避免回表。</li>
<li>索引也会影响维护，因此并不是多多益善。</li>
<li>如果索引列不能存储 null，建表的时候请用 not null 约束该列。当优化器知道每列是否有 null 值时，可以更好的决定用哪个索引查询。</li>
</ol>
<h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="插入优化"><a href="#插入优化" class="headerlink" title="插入优化"></a>插入优化</h2><p><code>insert into table values(1,1...);</code></p>
<ol>
<li><p><code>insert into table values(1,1...),(1,1...),(1,1...);</code> 使用批量插入，和数据库之间建立连接也不用每条数据插入一次，效率会高。建议500~1000条数据使用批量插入。</p>
</li>
<li><p>插入的时候是自动开启和关闭事务的，插入前开启，插入后关闭。太频繁了性能也不高，我们可以手动开启和关闭事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into table values(1,1,1);</span><br><span class="line">insert into table values(2,2,2);</span><br><span class="line">insert into table values(3,3,3);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主键顺序插入，这个和 mysql 的数据组织结构有关系。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：Web 开发实践 小程序标点地图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/05/12/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%87%E7%82%B9%E5%9C%B0%E5%9B%BE/"
    >北邮国院项目：Web 开发实践 小程序标点地图</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/12/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%87%E7%82%B9%E5%9C%B0%E5%9B%BE/" class="article-date">
  <time datetime="2022-05-11T23:00:00.000Z" itemprop="datePublished">2022-05-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>web 开发实践课的大作业。本次小程序设计主要围绕 map 组件展开。</p>
<p>我们组设计了一款能够记录地图上的标点信息，并将自己的标点信息发布到帖子上的旅游类app。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/DianJi_Demo">github 代码地址</a>，希望对你有所帮助~</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/34ffd9596cbecd6cf2c5083c61472e18.png" alt="HN6nM.png"></p>
<p>小程序的主要功能就是记录地图上的标点信息，并上传到云数据库中；</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/035976c6063c4d019ea3a2e62d35bca0.gif" alt="在这里插入图片描述"></p>
<p>以及编辑文章，把文章信息上传到云数据库中；</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/00c96f64cec54457a23359ff540dcc67.gif" alt="在这里插入图片描述"></p>
<p>获取云数据库中的文章（最新发布的3篇）。</p>
<p>xxxxxxxxxx int zong(int i)&#x2F;&#x2F;纵坐标y1{    double x&#x3D;(i-51);    double y&#x3D;12.0*sin(x&#x2F;7);    int y1&#x3D;(int)(15-y);    return y1;}​int heng(int i)&#x2F;&#x2F;横坐标j{    int j&#x3D;i;    if(i&gt;101&amp;&amp;i&lt;&#x3D;202)j&#x3D;203-i;    else if(i&gt;202&amp;&amp;i&lt;&#x3D;303)j&#x3D;i-202;    else if(i&gt;303&amp;&amp;i&lt;&#x3D;404)j&#x3D;405-i;    return j;}​void dayin(char ch,int j,int y1)&#x2F;&#x2F;在(y1,j)处输出给定字符{        gotoxy(y1,j);        if(ch&#x3D;&#x3D;’ ‘)        {            if(y1&#x3D;&#x3D;15)printf(“-“);            else if(j&#x3D;&#x3D;51)printf(“|”);            else printf(“ “);        }        else printf(“#”);        gotoxy(29-y1,102-j);        if(ch&#x3D;&#x3D;’ ‘)&#x2F;&#x2F;防止坐标点和坐标轴被空格覆盖        {            if(29-y1&#x3D;&#x3D;15)printf(“-“);            else if(102-j&#x3D;&#x3D;51)printf(“|”);            else if(29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;49)printf(“-“);            else if((29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;50)||(29-y1&#x3D;&#x3D;3&amp;&amp;102-j&#x3D;&#x3D;50))printf(“1”);            else if(29-y1&#x3D;&#x3D;16&amp;&amp;102-j&#x3D;&#x3D;100)printf(“X”);            else printf(“ “);        }        else printf(“#”);        gotoxy(1,1);}​​​​int main(){    float x,y;    int tim&#x3D;20;    system(“color F0”);    system(“mode con cols&#x3D;101 lines&#x3D;30”);    clear();        for(int i&#x3D;0;i&lt;&#x3D;100;i++)&#x2F;&#x2F;打印x轴     {        gotoxy(15,i+1);        if(i!&#x3D;50)printf(“-“);        else printf(“+”);        gotoxy(1,1);        rest(1);    }        for(int i&#x3D;29;i&gt;&#x3D;0;i–)&#x2F;&#x2F;打印y轴     {        gotoxy(i+1,51);        if(i!&#x3D;14)printf(“|”);        gotoxy(1,1);         rest(1);    }    &#x2F;&#x2F;打印轴上的点    gotoxy(16,52); printf(“O”);        gotoxy(16,100);printf(“X”);        gotoxy(1,49);printf(“Y”);        gotoxy(3,50);printf(“1”);        gotoxy(26,49);printf(“-1”);                    int i&#x3D;0,j,y1;​    for(i&#x3D;52;i&lt;&#x3D;404;i++)&#x2F;&#x2F;打印函数     {        j&#x3D;heng(i),y1&#x3D;zong(i);        dayin(‘#’,j,y1);        rest(4);                if(i-51-tim&gt;0)        {            y1&#x3D;zong(i-tim);            j&#x3D;heng(i-tim);            dayin(‘ ‘,j,y1);        }    }       for(int r&#x3D;i-tim;r&lt;&#x3D;i;r++)    {        j&#x3D;heng(r);        y1&#x3D;zong(r);        dayin(‘ ‘,j,y1);        rest(4);    }     gotoxy(1,1);    rest(1000);    return 0;}c</p>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/77e31ce1557342dd8a883fe55c21c05d.png" alt="在这里插入图片描述"></p>
<p>目前有两个数据库表。databasemarkers 存储本次记录中所有标点信息；databasearticles 存储该文章发布时间、文章标题、备注、内容以及对应的标点记录id（外键）。</p>
<h1 id="1-地图标点"><a href="#1-地图标点" class="headerlink" title="1. 地图标点"></a>1. 地图标点</h1><p>小程序自带的 map 组件中有一个属性 markers，是一个对象数组。只要把相应格式的对象数组传给 map 组件，就会自动在地图上标记出点的信息。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/4e581029e11d4f26ae9ba03e9effae44.png" alt="在这里插入图片描述"></p>
<p>wxml 文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- subkey 用于调整地图样式</span></span><br><span class="line"><span class="comment">经纬度 latitude longitude 信息是地图初始的中心点。</span></span><br><span class="line"><span class="comment">本例中，要传递给 map 组件的对象数组也命名为 markers，在 js 文件中获取数据后传递给 map--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">id</span>=<span class="string">&quot;map&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">subkey</span>=<span class="string">&quot;DKEBZ-LKBW4-B3KUP-DYSCI-IG7OS-SQBJH&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">longitude</span>=<span class="string">&#x27;&#123;&#123;weidu&#125;&#125;&#x27;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">latitude</span>=<span class="string">&#x27;&#123;&#123;jingdu&#125;&#125;&#x27;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">scale</span>=<span class="string">&quot;10&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">layer-style</span>=<span class="string">&quot;1&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">show-location</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">markers</span>=<span class="string">&quot;&#123;&#123;markers&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--每次点击添加标点按钮，就会获取当前位置信息，存入 markers 数组--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&quot;default&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;recstart&quot;</span>&gt;</span></span><br><span class="line">    添加标点</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--点击结束记录，将标点信息上传到数据库 databasemarkers 中，并跳转到文章编辑页面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">size</span>=<span class="string">&quot;default&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;recstop&quot;</span>&gt;</span></span><br><span class="line">    添加标点</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cnt=cnt+<span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> db=wx.<span class="property">cloud</span>.<span class="property">database</span></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">jingdu</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">weidu</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">markers</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">	<span class="attr">recstart</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line">        cnt = cnt + <span class="number">1</span></span><br><span class="line">        wx.<span class="title function_">getLocation</span>(&#123;</span><br><span class="line">            <span class="attr">altitude</span>: <span class="string">&#x27;altitude&#x27;</span>,</span><br><span class="line">            <span class="attr">highAccuracyExpireTime</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">isHighAccuracy</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;gcj02&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">                <span class="keyword">let</span> marker = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">markers</span></span><br><span class="line">                marker.<span class="title function_">push</span>(&#123;</span><br><span class="line">                    <span class="attr">id</span>: cnt-<span class="number">1</span>,</span><br><span class="line">                    <span class="attr">latitude</span>: result.<span class="property">latitude</span>,</span><br><span class="line">                    <span class="attr">longitude</span>: result.<span class="property">longitude</span>,</span><br><span class="line">                    <span class="attr">width</span>: <span class="number">20</span>,</span><br><span class="line">                    <span class="attr">height</span>: <span class="number">30</span></span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// let pointobj = this.data.polyline[0].points</span></span><br><span class="line">                <span class="comment">// console.log(pointobj)</span></span><br><span class="line">                <span class="comment">// pointobj.push(</span></span><br><span class="line">                <span class="comment">//   &#123;</span></span><br><span class="line">                <span class="comment">// 	  latitude: result.latitude,</span></span><br><span class="line">                <span class="comment">//     longitude: result.longitude,</span></span><br><span class="line">                <span class="comment">//   &#125;</span></span><br><span class="line">                <span class="comment">// )</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(that.<span class="property">data</span>.<span class="property">markers</span>)</span><br><span class="line">                that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                    <span class="attr">jingdu</span>: result.<span class="property">latitude</span>,</span><br><span class="line">                    <span class="attr">weidu</span>: result.<span class="property">longitude</span>,</span><br><span class="line">                    <span class="attr">recmode</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">markers</span>: marker,</span><br><span class="line">                    <span class="comment">// polyline:[&#123;</span></span><br><span class="line">                    <span class="comment">//   points:pointobj</span></span><br><span class="line">                    <span class="comment">// &#125;]</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// fail: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">            <span class="comment">// complete: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">recstop</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line">      db.<span class="title function_">collection</span>(<span class="string">&quot;databasemarkers&quot;</span>).<span class="title function_">add</span>(&#123;</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">          <span class="attr">markers</span>:<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">markers</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据添加成功！&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        <span class="keyword">var</span> docstring=res.<span class="property">_id</span></span><br><span class="line">        wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/pages/addarticle/addarticle?docstring=&#x27;</span>+docstring</span><br><span class="line">      &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">onLoad</span>(<span class="params">options</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="variable language_">this</span></span><br><span class="line">        wx.<span class="title function_">getLocation</span>(&#123;</span><br><span class="line">            <span class="attr">altitude</span>: <span class="string">&#x27;altitude&#x27;</span>,</span><br><span class="line">            <span class="attr">highAccuracyExpireTime</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">isHighAccuracy</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;type&#x27;</span>,</span><br><span class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">                    <span class="attr">jingdu</span>: result.<span class="property">latitude</span>,</span><br><span class="line">                    <span class="attr">weidu</span>: result.<span class="property">longitude</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fail: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">            <span class="comment">// complete: (res) =&gt; &#123;&#125;,</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="2-发布文章"><a href="#2-发布文章" class="headerlink" title="2. 发布文章"></a>2. 发布文章</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/28e718d09b274fb89bbed42d385fab02.png" alt="在这里插入图片描述"></p>
<p>添加完标点信息后，提示输入文章标题、备注、正文信息，点击提交，文章就会发布到 databasearticles 数据库中。</p>
<p>wxml：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;inputbox&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-top: 1px solid #e4e4e4;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>题目<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入题目&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputtitle&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;line&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入备注信息&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputcomment&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;line-content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>正文<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot; 请输入正文&quot;</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputcontent&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">const db=wx<span class="selector-class">.cloud</span><span class="selector-class">.database</span>()</span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面的初始数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    dataobj:&#123;</span><br><span class="line">      comment:<span class="string">&quot;&quot;</span>,</span><br><span class="line">      content:<span class="string">&quot;&quot;</span>,</span><br><span class="line">      title:<span class="string">&quot;&quot;</span>,</span><br><span class="line">      markersid:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  inputtitle:<span class="built_in">function</span>(options)&#123;</span><br><span class="line">    <span class="selector-tag">var</span> value=options<span class="selector-class">.detail</span><span class="selector-class">.value</span></span><br><span class="line">    console<span class="selector-class">.log</span>(value)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      title:value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  inputcomment:<span class="built_in">function</span>(options)&#123;</span><br><span class="line">    <span class="selector-tag">var</span> value=options<span class="selector-class">.detail</span><span class="selector-class">.value</span></span><br><span class="line">    console<span class="selector-class">.log</span>(value)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      comment:value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  inputcontent:<span class="built_in">function</span>(options)&#123;</span><br><span class="line">    <span class="selector-tag">var</span> value=options<span class="selector-class">.detail</span><span class="selector-class">.value</span></span><br><span class="line">    console<span class="selector-class">.log</span>(value)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      <span class="attribute">content</span>:value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  submit()&#123;</span><br><span class="line">    <span class="selector-tag">var</span> mydate=new Date()</span><br><span class="line">    db<span class="selector-class">.collection</span>(&quot;databasearticles&quot;)<span class="selector-class">.add</span>(&#123;</span><br><span class="line">      data:&#123;</span><br><span class="line">        <span class="attribute">content</span>:this.data.content,</span><br><span class="line">        markersid:this.data.markersid,</span><br><span class="line">        comment:this.data.comment,</span><br><span class="line">        title:this.data.title,</span><br><span class="line">        createdate:mydate</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)<span class="selector-class">.then</span>(res=&gt;&#123;</span><br><span class="line">      console<span class="selector-class">.log</span>(&quot;数据添加成功！&quot;)</span><br><span class="line">        console<span class="selector-class">.log</span>(res)</span><br><span class="line">        wx<span class="selector-class">.navigateTo</span>(&#123;</span><br><span class="line">          url: <span class="string">&#x27;/pages/success/success&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  onLoad(options) &#123;</span><br><span class="line">    <span class="selector-tag">var</span> docstring=options<span class="selector-class">.docstring</span></span><br><span class="line">    console<span class="selector-class">.log</span>(docstring)</span><br><span class="line">    this<span class="selector-class">.setData</span>(&#123;</span><br><span class="line">      markersid:docstring</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>wxss：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inputbox</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>:<span class="number">60</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">450</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#e4e4e4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line-content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">min-height</span>:<span class="number">300</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">160</span>rpx;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">30</span>rpx;</span><br><span class="line">  <span class="attribute">border-bottom</span>:<span class="number">1px</span> solid <span class="number">#e4e4e4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line-content</span> <span class="selector-tag">label</span> &#123;</span><br><span class="line">  <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>:<span class="number">100</span>rpx;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">40</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inputbox</span> <span class="selector-class">.line-content</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">140</span>rpx;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">40</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.submit</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">180</span>rpx auto <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">98</span>rpx;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3</span>rpx solid <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">167</span>);</span><br><span class="line">  <span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">167</span>);</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">	<span class="attribute">flex-direction</span>: row;</span><br><span class="line">	<span class="attribute">align-items</span>: center;</span><br><span class="line">	<span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-获取最新发布的三篇文章"><a href="#3-获取最新发布的三篇文章" class="headerlink" title="3. 获取最新发布的三篇文章"></a>3. 获取最新发布的三篇文章</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/f2b099a392ac4f8aae5218d74c035409.png" alt="在这里插入图片描述"></p>
<p>最新发布模块可以获取云数据库中最新发布的三篇文章，原理是根据时间戳倒叙排序后取前三条记录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">collection</span>(<span class="string">&quot;databasearticles&quot;</span>)</span><br><span class="line">      .<span class="title function_">orderBy</span>(<span class="string">&#x27;createdate&#x27;</span>,<span class="string">&#x27;desc&#x27;</span>)</span><br><span class="line">      .<span class="title function_">limit</span>(<span class="number">3</span>)</span><br><span class="line">      .<span class="title function_">get</span>(&#123;</span><br><span class="line">        <span class="attr">success</span>:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">            <span class="attr">new3obj</span>:res.<span class="property">data</span><span class="comment">//new3obj 是在 data 中定义的，用来接收最新发布的三篇文章对象集合的变量</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>

<p>以上就是本小程序核心功能啦！希望对你有帮助！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Wechat-Miniprogram/" rel="tag">Wechat Miniprogram</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：Data Structure 数据结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
    >北邮国院笔记：Data Structure 数据结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2021-09-30T23:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为考试要求，博主学习的是双语的数据结构，因此自己总结一些英文的概念、知识点。希望也可以对读者学习这门课程有所帮助~<br>特别感谢许可老师的教导！</p>
<p>理解时间复杂度的定义<br>（本课程涉及到的所有算法，都需要记住时间复杂度O）</p>
<h1 id="Data-structure-notes"><a href="#Data-structure-notes" class="headerlink" title="Data structure notes"></a>Data structure notes</h1><p>Program &#x3D; Algorithm + Data Structure<br>An algorithm is a finite set of instructions that, fi followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:</p>
<ul>
<li>   Input</li>
<li>   Output</li>
<li>   Definiteness</li>
<li>   Finiteness</li>
<li>   Effectiveness</li>
</ul>
<p><em>Note:<br>A program is written in some programming language, and does not have to be finite.<br>An algorithm can be described by human languages, flow charts, some programming languages, or pseudocode.</em></p>
<p>引入 time complexities 和 space complexities 的概念。</p>
<p>$2^n^&gt;n^2^&gt;nlogn&gt;n&gt;logn&gt;1$</p>
<h1 id="单词："><a href="#单词：" class="headerlink" title="单词："></a>单词：</h1><p>Algorithm 算法<br>Definiteness 确定性<br>Finiteness 有限性<br>Effectiveness 有效性<br>Finite 有限的<br>Pseudocode 伪代码<br>Assumptions 假设<br>Asymptotic 渐近线的，渐近的<br>Notation 记号，标记法<br>For loops for循环<br>Nested 嵌套<br>Consecutive statements 顺序语句<br>Fibonacci 斐波那契<br>Euclid 欧几里得<br>Exponentiation 幂<br>Pow 指数</p>
<p>【表】<br>理解链表、数组的特点（优缺点）<br>会代码实现：单链表 循环链表 双向链表……</p>
<p><em>【栈和队列】</em><br><em>理解原理，会算法：两种实现方法</em><br><em>会应用算法，如：中序后序互转；前中后缀表达式互换；栈（队列）操作后的状态</em></p>
<h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p><strong>ADT(Abstract Data Type)</strong> is a data type that is organized in such a way that the <strong>specification</strong>  on the objects and <strong>specification</strong> of the operations on the objects are <strong>separated from</strong> the <strong>representation</strong> of the objects and the <strong>implementation</strong> on the operations.</p>
<h1 id="The-List-ADT"><a href="#The-List-ADT" class="headerlink" title="The List ADT"></a>The List ADT</h1><ol>
<li>   Array implementation<ul>
<li><pre><code>**MaxSize** has to be estimated. （大小必须事先给出。给小了数组越界；(可以再申请)给大了太浪费空间）
</code></pre>
</li>
<li><pre><code>**Find_Kth** takes O(1) time. （随机存取）
</code></pre>
</li>
<li><pre><code>**Insertion and Deletion** not only take O(N) time, but also involve a lot of data movements which takes time.（插入删除不方便，需要移动大量元素；存储密度高）
</code></pre>
</li>
</ul>
</li>
<li>   Linked Lists（是否带有头结点）<ul>
<li>   三种操作：Find_Kth、Find_Value、Find_Length take O(N) time. 注意循环逻辑，以及有无头结点时对边界情况的处理</li>
<li>   找前一个结点不方便，只能重新从头遍历、</li>
</ul>
</li>
</ol>
<h2 id="Doubly-Linked-Lists"><a href="#Doubly-Linked-Lists" class="headerlink" title="Doubly Linked Lists"></a>Doubly Linked Lists</h2><p>找前一个结点更方便。注意初始化、插入、删除、双向遍历的区别。</p>
<h2 id="Circular-Lists"><a href="#Circular-Lists" class="headerlink" title="Circular Lists"></a>Circular Lists</h2><p>头尾相接的单链表。注意判空条件（<code>L-&gt;Next==L</code>）、判断表尾结点条件(<code>p-&gt;Next==L</code>)以及插入删除时修改的操作。<br>双向循环链表不再赘述。</p>
<h2 id="Application-The-polynomial-ADT"><a href="#Application-The-polynomial-ADT" class="headerlink" title="Application: The polynomial ADT"></a>Application: The polynomial ADT</h2><p>多项式求和、求积函数，使用链表更好，因为如果出现形如x^100000^+x^5^+x^1^这种，数组会浪费大量空间，而单链表只需要将系数非0的部分申请空间创造结点。<br>（也可以建立十字链表，两个维度分别存储系数和指数）</p>
<h2 id="Cursor-Implementation-of-Linked-Lists-no-pointer"><a href="#Cursor-Implementation-of-Linked-Lists-no-pointer" class="headerlink" title="Cursor Implementation of Linked Lists (no pointer)"></a>Cursor Implementation of Linked Lists (no pointer)</h2><p>可以使用一个游标int Cursor来作为指针，游标移动访问数组，从而实现类似于指针移动的操作。<br>The cursor implementation is usually significantly <strong>faster</strong> because of the lack of memory management routines.</p>
<h1 id="The-Stack-ADT"><a href="#The-Stack-ADT" class="headerlink" title="The Stack ADT"></a>The Stack ADT</h1><p>A Stack is a <strong>Last-in-First-Out (LIFO)</strong> list. An ordered list in which insertions and deletion are made at the top only.<br>类似于一堆书，放书和拿书都只能从最顶上进行。最后放上的书最早被拿出来。<br>Push: 入栈<br>Top: 读取并返回栈顶元素<br>Pop: 栈顶元素出栈</p>
<h2 id="Application-1-Balancing-symbols-括号匹配"><a href="#Application-1-Balancing-symbols-括号匹配" class="headerlink" title="Application 1: Balancing symbols 括号匹配"></a>Application 1: Balancing symbols 括号匹配</h2><p>输入一串表达式，判断其中的括号()[]{}是否匹配。<br>检验方法：每个右括号都和离他最近的，也就是最晚输入的左括号匹配，正符合栈的后进先出原则。<br>读到左括号的时候入栈，读到右括号的时候与栈顶的左括号比较，比较后出栈。<br>最后结束输入，还要检查一下栈是否为空，若非空，栈内剩下的括号全都不匹配。<br><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/1%20STACK/7-1%20Balancing%20Symbols.cpp">7-1 Balancing symbols 代码实现</a></p>
<h2 id="Application-2-Postfix-Evaluation-后缀表达式的计算"><a href="#Application-2-Postfix-Evaluation-后缀表达式的计算" class="headerlink" title="Application 2: Postfix Evaluation 后缀表达式的计算"></a>Application 2: Postfix Evaluation 后缀表达式的计算</h2><p>Infix expression中缀表达式： a + b * c - d &#x2F; e<br>Prefix expression 前缀表达式：- + a * b c &#x2F; d e<br>Postfix expression 后缀表达式： a b c * + d e &#x2F; -<br>中缀表达式更符合人脑的计算方法，而后缀表达式更符合计算机的计算方法。<br>实际上在计算机中计算表达式，是先转化为postfix expression，再进行计算的。<br>转换方法：<br>建立堆栈。</p>
<ol>
<li>   读入的字符是操作数：直接输出</li>
<li>   读入的字符是操作符：<br> a)	堆栈是空的，则直接存入堆栈中（push）<br> b)	该操作符的优先级&gt;栈顶元素操作符，则直接入栈（push）<br> c)	该操作符的优先级&lt;&#x3D;栈顶元素操作符，则栈顶元素出栈（pop），直到该操作符的优先级大于栈顶元素（这个栈顶元素也要出栈），然后该操作符入栈（push）<br> d)	操作符是左括号，则直接入栈（pop），遇到右括号之前永不输出<br> e)	操作符是右括号，则一直出栈（pop）直到左括号出栈<br> f)	最终输入结束，栈若非空，栈中元素全部出栈。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/1%20STACK/7-2%20Infix%20to%20Postfix%20Conversion.cpp">7-2 Infix to postfix Conversion 代码实现</a></p>
<h1 id="The-Queue-ADT"><a href="#The-Queue-ADT" class="headerlink" title="The Queue ADT"></a>The Queue ADT</h1><p>A Queue is a <strong>First-In-First-Out (FIFO)</strong> list. An ordered list in which insertions take place at one end and deletions take place at the opposite end.<br>就像日常生活中的排队，先来后到，先排的有机会先出。<br>EnQueue: 入队<br>DeQueue: 出队</p>
<h2 id="Circular-Queue：循环链表"><a href="#Circular-Queue：循环链表" class="headerlink" title="Circular Queue：循环链表"></a>Circular Queue：循环链表</h2><h2 id="Application-who-is-the-last"><a href="#Application-who-is-the-last" class="headerlink" title="Application: who is the last"></a>Application: who is the last</h2><p>输入n、m；n个人坐成一个圈，从第一个人开始报数，每m个人淘汰掉第m个人，然后下一个人继续重新报数。问：谁能留到最后？<br><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/2%20QUEUE/7-4%20who%20is%20the%20last.cpp">7-4 who is the last 代码实现</a></p>
<p>树<br>【基本概念】各类树的度、高、深、节点数与叶子节点的关系；孩子兄弟节点树；<br>【二分检索树】：概念 平衡二叉树 完全二叉树 满二叉树 AVL树…… 会插入 删除；<br>【遍历树】：先序 后序 中序 层序；会代码创建树和检索、会执行画图<br>【B-树】：会画图 构建B-树，增加节点，删除节点 B-树<br>【霍夫曼树】：理解原理 给出数据 会画霍夫曼树的图；节点关系<br>理清各种树之间的关系</p>
<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h1><h2 id="Conception"><a href="#Conception" class="headerlink" title="Conception"></a>Conception</h2><ul>
<li>degree of a node: number of its subtrees</li>
<li>degree of a tree: max{degree(node)}</li>
<li>parent;children;siblings</li>
<li>leaf:a node with degree 0</li>
<li>path from n_1 to n_k: a <strong>unique</strong> sequence of n_1, n_2 …… n_k (n_i is the parent of n_{i+1})</li>
<li>length of path: number of <strong>edges</strong> on the path</li>
<li>depth of n_i: path to root (depth(root)&#x3D;0)</li>
<li>height of n_i：length of the longest path from n_i to a leaf.(Height(leaf)&#x3D;0)</li>
<li>ancestors of anode: all the nodes along the path from the node up to the root</li>
<li>descendants of a node: all the nodes in its subtrees</li>
</ul>
<h2 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h2><h3 id="FirstChild-NextSibling-Representation"><a href="#FirstChild-NextSibling-Representation" class="headerlink" title="FirstChild-NextSibling Representation"></a>FirstChild-NextSibling Representation</h3><p>Each Node carries its element and 2 pointers. The first points its FirstChild; The second points its NextSibling.<br><em>This representation is <strong>not unique</strong> since the children in a tree can be of any order.</em></p>
<h3 id="Binary-Trees"><a href="#Binary-Trees" class="headerlink" title="Binary Trees"></a>Binary Trees</h3><p>a tree in wh ich no node can have more than 2 children.<br><em>Rotate the FirstChild-NextSibling tree clockwise by 45°</em></p>
<h2 id="Tree-Traversals-significant"><a href="#Tree-Traversals-significant" class="headerlink" title="Tree Traversals (significant!)"></a>Tree Traversals (significant!)</h2><h3 id="Preorder-Traversal"><a href="#Preorder-Traversal" class="headerlink" title="Preorder Traversal"></a>Preorder Traversal</h3><p>visit This Node first;<br>visit its child recursively.</p>
<h3 id="Postorder-Traversal"><a href="#Postorder-Traversal" class="headerlink" title="Postorder Traversal"></a>Postorder Traversal</h3><p>visit its child recursively;<br>At last, visit this node itself.</p>
<h3 id="Levelorder-Traversal"><a href="#Levelorder-Traversal" class="headerlink" title="Levelorder Traversal"></a>Levelorder Traversal</h3><p>visit Tree via a queue.</p>
<ul>
<li>Enqueue root node;</li>
<li>while(queue is not empty){</li>
<li>visit first node in queue and Dequeue;</li>
<li>for its each child, enqueue.}</li>
</ul>
<h3 id="Inorder-Traversal-for-binary-trees"><a href="#Inorder-Traversal-for-binary-trees" class="headerlink" title="Inorder Traversal(for binary trees)"></a>Inorder Traversal(for binary trees)</h3><p>Recursive:</p>
<ul>
<li>visit left tree recursively.</li>
<li>visit root node.</li>
<li>visit left tree recursively.<br>Iterative:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iter_inorder</span><span class="params">(Tree)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack S;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;tree;tree=tree-&gt;Left)Push(tree,S);</span><br><span class="line">		tree=Top(S);Pop(S);</span><br><span class="line">		<span class="keyword">if</span>(!tree)<span class="keyword">break</span>;</span><br><span class="line">		visit(tree-&gt;Element);</span><br><span class="line">		tree=tree-&gt;Right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inorder traversal: infix expression<br>preorder traversal: prefix expression<br>postorder traversal: postfix expression<br><em>Depth is a evry important conception. we can use a function to calculate it:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ListDir</span><span class="params">(DirOrFile D,<span class="type">int</span> Depth)</span><span class="comment">//at first, Depth is 0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(D is a legitimate entry)&#123;</span><br><span class="line">		PrintName(D,Depth);</span><br><span class="line">		<span class="keyword">if</span>(D is a directory)</span><br><span class="line">			<span class="keyword">for</span>(each child C of D)</span><br><span class="line">				ListDir(C,Depth+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Threaded-Binary-Trees"><a href="#Threaded-Binary-Trees" class="headerlink" title="Threaded Binary Trees"></a>Threaded Binary Trees</h2><ul>
<li>If tree-&gt;Left is null, 指向中序遍历的前一个结点  a pointer to the inorder predecessor of Tree.</li>
<li>If tree-&gt;Right is null, 指向中序遍历的前一个结点  a pointer to the inorder successor of Tree.</li>
<li>最开头、最结尾结点的左、右指针指向head node. There must not be any loose threads. Therefore a threaded binary tree must have a <strong>head node</strong> of which the left child points to the first node.</li>
</ul>
<h2 id="The-Search-Tree-ADT-–-Binary-Search-Trees"><a href="#The-Search-Tree-ADT-–-Binary-Search-Trees" class="headerlink" title="The Search Tree ADT – Binary Search Trees"></a>The Search Tree ADT – Binary Search Trees</h2><ul>
<li>Every node has a key which is an integer, and it’s distinct.</li>
<li>The keys in a nonempty <strong>left</strong> subtree must be <strong>smaller</strong> than the key in the root of the subtree.</li>
<li>The keys in a nonempty <strong>right</strong> subtree must be <strong>larger</strong> than the key in the root of the subtree.</li>
<li>The left and right subtrees are also binary search trees.</li>
</ul>
<p>insert is quite easy while delete not.<br>Delete:</p>
<ul>
<li>if it’s leaf node:just delete it.</li>
<li>if it’s degree is 1: use its child to replace it.</li>
<li>if it’s degree is 2: use the <strong>largest</strong> node in its <strong>left</strong> subtree or the <strong>smallest</strong> node in its <strong>right</strong> subtree to replace it.<br><em>will the lazy deletion be in the scope of final exam?</em><br><strong>Internal path length: O(Nlog N);depth of any node is O(log N)</strong><br>要会计算Average Search Time (AST)<br><em>If you print Binary Search Tree inorder, then it is an increasing order.</em></li>
</ul>
<p>Get Depth: preorder traversal</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Height</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ekse <span class="keyword">return</span> <span class="number">1</span>+Max(Height(T-&gt;Left),Height(T-&gt;Right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AVL-Trees"><a href="#AVL-Trees" class="headerlink" title="AVL Trees"></a>AVL Trees</h2><p>If the tree is too high, AST can be very large and time complexities is O(N). So we need to balance the height by rotating.<br><strong>If |h_L-h_R|&gt;1,rotate.</strong></p>
<ul>
<li>Single Rotation: Trouble is left subtree’s left subtree or right subtree’s right subtree.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tree <span class="title function_">SingleRotatewithLeft</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	TreeNode LeftTree = T-&gt;LeftChild;</span><br><span class="line">	T-&gt;LeftChild = LeftTree-&gt;RightChild;</span><br><span class="line">	LeftTree-&gt;RightChild = T;</span><br><span class="line">	<span class="keyword">return</span> LeftTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">SingleRotatewithRight</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	TreeNode RightTree = T-&gt;RightChild;</span><br><span class="line">	T-&gt;RightChild = RightTree-&gt;LeftChild;</span><br><span class="line">	RightTree-&gt;LeftChild = T;</span><br><span class="line">	<span class="keyword">return</span> RightTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double Rotation: Trouble is left subtree’s right subtree or right subtree’s left subtree.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tree <span class="title function_">DoubleRotatewithLeft</span><span class="params">(Tree T)</span> 			</span><br><span class="line">&#123;</span><br><span class="line">	T-&gt;LeftChild = SingleRotatewithRight(T-&gt;LeftChild);</span><br><span class="line">	<span class="keyword">return</span> SingleRotatewithLeft(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">DoubleRotatewithRight</span><span class="params">(Tree T)</span> 			</span><br><span class="line">&#123;</span><br><span class="line">	T-&gt;RightChild = SingleRotatewithLeft(T-&gt;RightChild);</span><br><span class="line">	<span class="keyword">return</span> SingleRotatewithRight(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Trees-要会插入、建立"><a href="#B-Trees-要会插入、建立" class="headerlink" title="B Trees 要会插入、建立"></a>B Trees 要会插入、建立</h2><h3 id="Insertion"><a href="#Insertion" class="headerlink" title="Insertion"></a>Insertion</h3><p>考完试补全<br>$$<br>Depth(M,N)&#x3D;O(log_{[M&#x2F;2]}N)<br>$$</p>
<p>$$<br>T_{Find}(M,N)&#x3D;O(log N)<br>$$</p>
<h2 id="Forest-Empty"><a href="#Forest-Empty" class="headerlink" title="Forest Empty"></a>Forest Empty</h2><h2 id="Huffman-Tree"><a href="#Huffman-Tree" class="headerlink" title="Huffman Tree"></a>Huffman Tree</h2><p>Weighted Path Length, WPL<br>$$<br>WPL&#x3D;\sum^k_{i&#x3D;1}w_i*l_i<br>$$<br>Huffman Tree: the binary tree with the minimum weighted path length.<br>0 is appended to left branch,<br>1 is appended to right branch.</p>
<p>哈希<br>要求：<br>会算法 给出散列函数 会画图 会计算比较成功的次数 比较失败的次数 平均查找时间<br>【分离链接法】<br>【开放定址法】线性探测法 平方探测法 双散列<br>【再散列】</p>
<h1 id="HASHING"><a href="#HASHING" class="headerlink" title="HASHING"></a>HASHING</h1><p>散列表（hashing table）的实现叫散列（hashing）散列是一种用于以常数时间执行插入、删除和查找的技术，但不能排序。<br>散列函数（hashing function）是关键字被映射到0～TableSize-1范围内的函数。</p>
<ul>
<li>must be easy to compute and minimizes the number of collisions.</li>
<li>Should be unbiased. For any x and any i, we have that probability(f(x)&#x3D;i)&#x3D;1&#x2F;b. (Uniform hash function)<br>** f(x)&#x3D;x%TableSize**<br>TableSize&#x3D;prime number is good for random integer keys.</li>
</ul>
<h2 id="处理冲突的办法"><a href="#处理冲突的办法" class="headerlink" title="处理冲突的办法"></a>处理冲突的办法</h2><h3 id="open-addressing-开放定址法"><a href="#open-addressing-开放定址法" class="headerlink" title="open addressing 开放定址法"></a>open addressing 开放定址法</h3><p>find another empty cell to solve collision </p>
<h4 id="Linear-Probing-线性探测法"><a href="#Linear-Probing-线性探测法" class="headerlink" title="Linear Probing 线性探测法"></a>Linear Probing 线性探测法</h4><p>f(i)&#x3D;i (a linear function)<br>如果对应位被占了，则往下继续寻找空位。<br>下一位是否为空？若为空放入，若不为空检查下一位；<br>再下一位是否为空？……<br>查找：先去对应位找，如果没找到再继续往下遍历。</p>
<h4 id="Quadratic-Probing-平方探测法"><a href="#Quadratic-Probing-平方探测法" class="headerlink" title="Quadratic Probing 平方探测法"></a>Quadratic Probing 平方探测法</h4><p>f(i)&#x3D;i^2^<br>如果对应位被占了，则+1^1；<br>若这一位也被占了，则原位置+2^2；<br>……<br>（也有的算法是+-i^2）<br>最大加到（n&#x2F;2）的平方<br>查找：先去对应位找，如果没找到再去加1、加4等等位找。</p>
<h4 id="Double-Hashing-双散列法"><a href="#Double-Hashing-双散列法" class="headerlink" title="Double Hashing 双散列法"></a>Double Hashing 双散列法</h4><p>第一个散列函数冲突时，使用第二个散列函数。<br><strong>hash2(x)必须不恒等于0！</strong><br><em>Tips: hash2(x)&#x3D;R-(x%R) with R a prime smaller than TableSize, will work well.</em></p>
<h3 id="Rehashing-再散列"><a href="#Rehashing-再散列" class="headerlink" title="Rehashing 再散列"></a>Rehashing 再散列</h3><p>当插入数据达到N&#x2F;2时，再散列。</p>
<ul>
<li>建立一个原表的二倍大的表（接近原表二倍大的素数）</li>
<li>从原表中读取数据，用新hash function 存到新表中。</li>
</ul>
<p>堆<br>【二叉堆】<br>要求：会构建堆 插入 删除； 画图，手动执行中间数据；</p>
<h1 id="Piority-Queue-Heap"><a href="#Piority-Queue-Heap" class="headerlink" title="Piority Queue(Heap)"></a>Piority Queue(Heap)</h1><p>Can find the element with the highest \ lowest priority.</p>
<table>
<thead>
<tr>
<th></th>
<th>Insertion</th>
<th>Deletion</th>
</tr>
</thead>
<tbody><tr>
<td>Array</td>
<td>O(1)</td>
<td>find:O(n) delete:O(n)</td>
</tr>
<tr>
<td>Linked List</td>
<td>O(1)</td>
<td>find:O(n) delete:O(n)</td>
</tr>
<tr>
<td>Ordered Array</td>
<td>find:O(1) insert:O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Ordered Linked List</td>
<td>find:O(1) insert:O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>## complete binary tree</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Its nodes correspond to the nodes numbered from 1 to n in the perfect binary tree of height h.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A complete binary tree of height h has between 2^h and 2^{h+1}-1 nodes.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Array representation: BT[n+1](BT[0]is not used)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>For node i:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- parent: i&#x2F;2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- left child: 2*i</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- right child: 2*i+1</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>A min tree</strong> is a tree in which the key value in each node is no larger than the key values in its children.<br><strong>A min heap</strong> :a complete binary tree + a min tree. And the max heap is visa versa.</p>
<h2 id="Insertion-Min-Heap"><a href="#Insertion-Min-Heap" class="headerlink" title="Insertion(Min Heap)"></a>Insertion(Min Heap)</h2><p>Because a heap is a complete binary tree, the nth node only has one possible position to insert. Then, if nth node is smaller than its parent:exchange upward will its location is proper.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = ++H-&gt;Size; H-&gt;Elements[ i / <span class="number">2</span> ] &gt; X; i /= <span class="number">2</span> ) </span><br><span class="line">	H-&gt;Elements[ i ] = H-&gt;Elements[ i / <span class="number">2</span> ]; </span><br><span class="line"></span><br><span class="line">     H-&gt;Elements[ i ] = X; </span><br></pre></td></tr></table></figure>

<p><em>Another kind of Insertion is: insert all nodes first, then adjust their location. We need to check from n&#x2F;2 node. If its children node is smaller than it, choose the smallest node and exchange them. n&#x2F;2 node go downward until reach the proper location. Then do the same thing to the n&#x2F;2-1 node until the first node.</em></p>
<h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a>Deletion</h2><p>We only need to delete the root node——the smallest node.</p>
<ul>
<li>Exchange the root node with the last node——the nth node.</li>
<li>do the same thing mentioned above in the Italic text: re-arrange the new node.</li>
<li>Iteratively delete root node until delete the whole heap.<br>*<em>Those 2 operations’ time complexity are O(log N). Insertion all node is O(nlogn).</em></li>
</ul>
<p><em>For the perfect binary tree of height h containing 2h+1 - 1 nodes, the sum of the heights of the nodes is 2h+1 - 1 - (h + 1).</em></p>
<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><p>G:graph</p>
<p>V:finite nonempty set of vertices</p>
<p>E:finite set of edges</p>
<p>Undirected graph: $(v_i,v_j)$ <em>v_i and v_j are adjacent</em></p>
<p>Directed graph: $&lt;v_i,v_j&gt;$ <em>v_i is adjacent to v_j;v_j is adjacent from v_i</em></p>
<p><strong>Complete Graph</strong>: a graph that has the maximum number of edges</p>
<p><strong>Subgraph</strong></p>
<p><strong>Path from v_p to v_q</strong></p>
<p><strong>Length of a path</strong></p>
<p><strong>Simple path</strong>: v_i1, v_i2 …… v_in are distinct (on the path)  路径上的顶点不重复出现</p>
<p><strong>Cycle</strong> Simple path with v_p &#x3D; v_q</p>
<p><strong>A graph is connected</strong>: every pair of distinct v_i and v_j are connected  图中任意两点都连通</p>
<p><strong>Connected Component of an undirected G</strong>: the maximal connected subgraph</p>
<p><strong>A tree</strong>: a graph that is connected and  acyclic</p>
<p><strong>A DAG</strong>: a directed acyclic graph  有向无环图</p>
<p><strong>Strongly connected directed graph G</strong>: for every pair of v_i and v_j in V(G), there exist directed paths from v_i to v_j and from v_j to v_i.<br>(Graph without direction: <strong>weakly connected</strong>)</p>
<p><strong>Stronhly connected component</strong>: the maximal subgraph that is strongly connected</p>
<p><strong>Degree(v)</strong>: in-degree and out-degree  进入某个顶点的边数和传出该顶点的边数</p>
<h2 id="Representation-of-Graphs"><a href="#Representation-of-Graphs" class="headerlink" title="Representation of Graphs"></a>Representation of Graphs</h2><h3 id="Adjacency-Matrix-邻接矩阵法"><a href="#Adjacency-Matrix-邻接矩阵法" class="headerlink" title="Adjacency Matrix 邻接矩阵法"></a>Adjacency Matrix 邻接矩阵法</h3><p>二维矩阵存储边信息。如果v_i to v_j 有边，adj_mat[i][j]&#x3D;1，否则&#x3D;0.（undirected graph还要考虑双向，同时也要让adj_mat[j][i]&#x3D;1）</p>
<h3 id="Adjacency-Lists-邻接表法"><a href="#Adjacency-Lists-邻接表法" class="headerlink" title="Adjacency Lists 邻接表法"></a>Adjacency Lists 邻接表法</h3><p>每个顶点结点都是一个单链表的头结点，后面挂着他连接的顶点的节点。</p>
<p>如：</p>
<p>0-&gt;1-&gt;2</p>
<p>1-&gt;0</p>
<p>2-&gt;0</p>
<p>这就是一个三个顶点的无向图，01、02相连。</p>
<p>S(n+2e) Space complexities</p>
<h2 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h2><p><strong>AOV Network</strong>: digraph in which V(G) represents activities and E(G) represents precedence relations 顶点表示事件，边表示事件之间的进程关系。比如A-&gt;B，就是要先做完A才能做B</p>
<p><strong>i is a predecessor of j</strong>: there is a path from i to j  前驱</p>
<p><strong>i is an immediate predecessor</strong>: &lt;i,j&gt;&#x3D;1.  直接前驱 Then j is called a <strong>successor (immediate successor)</strong> of i 直接后继</p>
<p><strong>Partial order</strong>: transitive (i-&gt;k,k-&gt;j: i-&gt;j) &amp;&amp; irreflexive (i-&gt;j is impossible)</p>
<p>AOV network must be a dag (directed acyclic graph)</p>
<p><strong>Topological order</strong>: a linear ordering of the vertices of a graph such that, for any 2 vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.  所有时间都是按完成顺序排序的.<br>算法：</p>
<ol>
<li>找出入度为0的节点</li>
<li>visit 该节点，并删除该节点的所有出度边</li>
<li>再重新寻找入度为0，没有 visit 过的节点，循环往复</li>
</ol>
<p>If we use a special box (queue or stack) to sort, T&#x3D;O(|V|+|E|)</p>
<h2 id="Shortest-Path-Algorithms-最短路径算法"><a href="#Shortest-Path-Algorithms-最短路径算法" class="headerlink" title="Shortest Path Algorithms 最短路径算法"></a>Shortest Path Algorithms 最短路径算法</h2><p>两类问题：</p>
<ol>
<li>从物流中心（一个顶点）往其他所有顶点运输物品，怎样路径最短？</li>
<li>怎样让所有顶点之间路径总和最短？</li>
</ol>
<h3 id="1-Single-Source-Shortest-Path-Problem"><a href="#1-Single-Source-Shortest-Path-Problem" class="headerlink" title="1. Single-Source Shortest-Path Problem"></a>1. Single-Source Shortest-Path Problem</h3><p>Given as input a weighted graph, G &#x3D; ( V, E ), and a distinguished vertex, s, find the shortest weighted path from s to every other vertex in G.</p>
<p><strong>Breadth-first search 广度优先搜索</strong></p>
<p>Similar to the topological order. We will visit every node connect to the fist node (if they haven’t been visit) and Enquque; and Dequeue this node, do the same thing to every node in the Queue.</p>
<p>Just simply scan the whole table</p>
<p>T+(|V|^2+|E|)</p>
<p><strong>Dijkstra’s Algorithm 迪杰斯特拉算法</strong></p>
<p>建立三个数组，final[]标记哥哥顶点是否已经找到最短路径；dist[]最短路径长度；path[]路径上的前驱<br>第一次循环：遍历所有结点，找到还没有确定最短路径且dist最小的顶点，final[i]&#x3D;true<br>检查i结点的所有final&#x3D;false邻接节点，如果把i作为路径上的前驱，最短路径会不会缩短？如果会，更新最短路径长度dist和路径上的前驱path信息。<br>进入下一轮循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">( Table T )</span></span><br><span class="line">&#123;   <span class="comment">/* T is initialized by Figure 9.30 on p.303 */</span></span><br><span class="line">    Vertex  V, W;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        V = smallest unknown distance vertex;</span><br><span class="line">        <span class="keyword">if</span> ( V == NotAVertex )</span><br><span class="line">	<span class="keyword">break</span>; </span><br><span class="line">        T[ V ].Known = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( each W adjacent to V )</span><br><span class="line">	<span class="keyword">if</span> ( !T[ W ].Known ) </span><br><span class="line">	    <span class="keyword">if</span> ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) &#123;</span><br><span class="line">	    	Decrease( T[ W ].Dist  to</span><br><span class="line">			 T[ V ].Dist + Cvw );</span><br><span class="line">		T[ W ].Path = V;</span><br><span class="line">	    &#125; <span class="comment">/* end-if update W */</span></span><br><span class="line">    &#125; <span class="comment">/* end-for( ; ; ) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>not work for edge with negative cost!</strong></p>
<p>T&#x3D;O(|E|log|V|)</p>
<h2 id="Acylic-Graphs"><a href="#Acylic-Graphs" class="headerlink" title="Acylic Graphs"></a>Acylic Graphs</h2><p>If the graph is acyclic, vertices amy be selected in topological order since when a vertex is selected, its distance can no longer be lowered without any incoming edges from unknown nodes.</p>
<p>T&#x3D;O(|E|+|V|)</p>
<p>Application: AOE(Activity On Edge)Networks</p>
<p>EC[ j ] \ LC[ j ] :: the earliest \ latest completion time for node v_j</p>
<p><strong>CPM (Critical Path Method)</strong></p>
<p>Calculation of EC: start from v_0, for any a_i&#x3D;&lt;v,w&gt;, we have $EC[w]&#x3D;max_{(v,w)\in E(EC[v]+C_{v,w})}$</p>
<p>Calculation of LC: Start from the last vertex v_e, for any a_i &#x3D; &lt;v,w&gt;, $LC[v]&#x3D;min_{(v,w)\in E}(LC[w]-C_{v,w})$</p>
<p>Slack Time of &lt;v,w&gt;: $LC[w]-EC[v]-C_{v,w}$</p>
<p>Critical Path: path consisting entirely of zero-slack edges.</p>
<p><strong>All-Pairs Shortest Path Problem</strong></p>
<p>Method 1: Use single-source algorithm  for |V| times.<br>T &#x3D; O(|V|^3) – works fast on sparse graph. 稀疏图</p>
<p>Method 2  O( |V|^3 ) algorithm given in Ch.10, works faster on dense graphs.</p>
<h2 id="Network-Flow-Problems"><a href="#Network-Flow-Problems" class="headerlink" title="Network Flow Problems"></a>Network Flow Problems</h2><p>Find Maximum Path from s to t.</p>
<p>Step 1:  Find any path s -&gt; t in Gr ;</p>
<p>Step 2:  Take the minimum edge on this path as the amount of flow and add to G_f ;</p>
<p>Step 3:  Update G_r and remove the 0 flow edges;</p>
<p>Step 4:  If (there is a path s -&gt; t in G_r )<br>                    Goto Step 1;<br>               Else<br>                     End.</p>
<h2 id="Minimum-Spanning-Tree"><a href="#Minimum-Spanning-Tree" class="headerlink" title="Minimum Spanning Tree"></a>Minimum Spanning Tree</h2><p>is a tree which consists of V(G) and a subset of E(G). </p>
<ul>
<li>It is acyclic – the number of edges is |V|-1.</li>
<li>It is minimum for the total cost of edges is minimized.</li>
<li>A minimum spanning tree exists if G is connected.</li>
</ul>
<h2 id="2-Method-of-calculating-the-minimum-spanning-tree"><a href="#2-Method-of-calculating-the-minimum-spanning-tree" class="headerlink" title="2 Method of calculating the minimum spanning tree:"></a>2 Method of calculating the minimum spanning tree:</h2><ol>
<li><p>Prim’s Algorithm<br>very samiliar to Dijkstra’s algorithm. We choose a vertex to start, and every time add a a least cost vertex until all vertex is connected.</p>
</li>
<li><p>Kruskal’s Algorithm – maintain a forest<br>every time add a a least cost edge &lt;v,w&gt; from E until all vertex is connected.</p>
</li>
</ol>
<h2 id="DFS-–-Depth-First-Search"><a href="#DFS-–-Depth-First-Search" class="headerlink" title="DFS – Depth-First Search"></a>DFS – Depth-First Search</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListComponents</span> <span class="params">( Graph G )</span> </span><br><span class="line">&#123;   <span class="keyword">for</span> ( each V in G ) </span><br><span class="line">        <span class="keyword">if</span> ( !visited[ V ] ) &#123;</span><br><span class="line">	DFS( V );</span><br><span class="line">               <span class="built_in">printf</span>(“\n“);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span> <span class="params">( Vertex V )</span>  <span class="comment">/* this is only a template */</span></span><br><span class="line">&#123;   visited[ V ] = <span class="literal">true</span>;  <span class="comment">/* mark this vertex to avoid cycles */</span></span><br><span class="line">    <span class="keyword">for</span> ( each W adjacent to V )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[ W ] )</span><br><span class="line">	DFS( W );</span><br><span class="line">&#125; <span class="comment">/* T = O( |E| + |V| ) as long as adjacency lists are used */</span></span><br></pre></td></tr></table></figure>

<p>Applications:</p>
<ol>
<li>Undirected Graphs</li>
<li>Biconnectivity</li>
<li>Euler Circuits</li>
</ol>
<h2 id="NP-Completeness"><a href="#NP-Completeness" class="headerlink" title="NP-Completeness"></a>NP-Completeness</h2><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="Basic-String-Operations"><a href="#Basic-String-Operations" class="headerlink" title="Basic String Operations"></a>Basic String Operations</h2><p>The StrAssign、Strcopy、StrCompare、StrLength、Concat and SubString</p>
<h2 id="String-Operations-Library-in-C"><a href="#String-Operations-Library-in-C" class="headerlink" title="String Operations Library (in C)"></a>String Operations Library (in C)</h2><p>gets(str)  &#x2F;&#x2F;Input a string;</p>
<p>puts(str) &#x2F;&#x2F;Output a string；</p>
<p>strcat(str1, str2)  &#x2F;&#x2F; string Concatenation；</p>
<p>strcpy(str1, str2, k)  &#x2F;&#x2F;String copy；</p>
<p>strcmp(str1, str2) &#x2F;&#x2F;String comparision；</p>
<p>strlen(str)  &#x2F;&#x2F;Get the length of string </p>
<h2 id="Pattern-Matching-algorithm"><a href="#Pattern-Matching-algorithm" class="headerlink" title="Pattern Matching algorithm"></a>Pattern Matching algorithm</h2><p>旧模式匹配算法：每次不匹配时，子串都从头重新匹配。效率很低</p>
<p>Basic match algorithm is inefficient</p>
<h3 id="Knuth-Morris-Pratt-KMP-Algorithms"><a href="#Knuth-Morris-Pratt-KMP-Algorithms" class="headerlink" title="Knuth-Morris-Pratt (KMP Algorithms)"></a>Knuth-Morris-Pratt (KMP Algorithms)</h3><p>When dismatch happens, we don’t need to go back to first. We can use a next array to decide where to go back.</p>
<p>next[]: compare s[i] and t[j]，if equals then continue comparing following items, else compare s[i] and t [ next[j] ], till end.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">Get_next</span><span class="params">( SString T, <span class="type">int</span>  &amp;next[] )</span></span><br><span class="line">&#123;    j = <span class="number">1</span> ;  <span class="comment">// postfix pointer</span></span><br><span class="line">     k = <span class="number">0</span>;   <span class="comment">//prefix pointer</span></span><br><span class="line">     next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= T[<span class="number">0</span>] )</span><br><span class="line">     &#123;  <span class="keyword">if</span> ( k == <span class="number">0</span> || T[j] == T[k] ) </span><br><span class="line">             &#123; ++j ;  ++k ;  next[j]=k; &#125;</span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">             k = next[k];  <span class="comment">// k go back, then compare T[j] with T[ next[k] ]</span></span><br><span class="line">     &#125;<span class="comment">// end while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For example:<br>a  a  b  c  a  a  a  b  c  a  d<br>0  1  2  1  1  2  3  3  4  5  6</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：程序设计课程设计 C语言订餐系统"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/09/11/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F/"
    >北邮国院项目：程序设计课程设计 C语言订餐系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/09/11/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2021-09-10T23:00:00.000Z" itemprop="datePublished">2021-09-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>尽管快半年没有学c了，好在回顾起来还是蛮快的。而且也发现比去年的自己熟练了许多。<br>小学期要求5人合作，用C语言做一个订餐系统，能够实现用户的登录、选择餐馆、订餐、按各种规则查询与排序、修改个人信息，管理员的登录、添加菜品、按各种规则查询与排序、修改个人信息。<br>首先，我们调研了几个流行的订餐系统，<del>并解决了午饭</del>分析其页面逻辑顺序，借此设定了我们自己的订餐系统的逻辑顺序。<br>感谢blue、peppa、214、Mar鼎力相助！<br><img src="https://img-blog.csdnimg.cn/d8feaa5c8fab43efb78c7dd073d37419.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>至于写法，主要尝试了两个新知识点：<strong>文件操作与链表</strong>。<br>想要实现这样的订餐系统，必须有地方可以存储其数据。不能说放在程序里吧，每次一关一开又恢复原状了。我们使用FILE文件操作，对存放在指定位置的txt进行读写操作，读取其中的数据。<br>至于数据结构采用结构体数组还是链表，在之前学习翁恺老师的网课时我们认识到了结构体数组的一些弊端。数组大小固定，一旦初始化无法修改，少了可能越界，多了浪费内存空间，链表就可以想用一个结点开辟一个结点。而且对于插入、删除等操作还是链表香啊，数组中间插入或删除一个，后面的都要跟着动。<br>至于如何实现多人合作，可参考翁恺老师网课12.3.1多个源代码文件用devc++创建项目的方法。我们每人负责了几个函数，最后对好接口和返回值合并。其实就像同学说的，在合并之前是最没底的，也没法测试知道自己写的什么样。好在最终完成的还算顺利。</p>
<p>链表中嵌套链表，是这回我们做的一个非常有意思的尝试。我们发现每次订单中所点的菜品及其数量，和每次订单结束后推荐的菜品数量都是不固定的。对于数据结构还没开始学的我们来说有些困难。后来去问了老师，老师给出了“那你们只能在链表里套一个链表了吧”的解决方案。没想到这个方案真的能做，虽然这铁不是最佳方案。但是也非常有趣。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_dish</span> //订单中的菜品链表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> dish_id; <span class="comment">//菜品号</span></span><br><span class="line">	<span class="type">int</span> number;	 <span class="comment">//该菜品数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_dish</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LISTDISH;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">recommend_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span> dish_name[len]; <span class="comment">//推荐的菜品名称</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">recommend_d</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; RECOMMEND;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> //订单链表</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> number;				<span class="comment">//订单号</span></span><br><span class="line">	<span class="type">char</span> user_id[len];		<span class="comment">//用户id，据此可以找到用户地址</span></span><br><span class="line">	<span class="type">int</span> restaurant_id;		<span class="comment">//餐馆id</span></span><br><span class="line">	<span class="type">int</span> score;				<span class="comment">//本次订单对餐馆的打分</span></span><br><span class="line">	<span class="type">int</span> price;				<span class="comment">//本次订单的总价格</span></span><br><span class="line">	TIME delivery_time_s;	<span class="comment">//起始配送时间。TIME是一个包含月、日、时、分成员的结构体</span></span><br><span class="line">	TIME delivery_time_e;	<span class="comment">//结束配送时间</span></span><br><span class="line">	RECOMMEND *recommend_d; <span class="comment">//本次用户推荐菜品头结点指针 </span></span><br><span class="line">	LISTDISH *head_ld;		<span class="comment">//本次订单的菜品链表头结点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LIST;</span><br></pre></td></tr></table></figure>
<p>如上，在订单链表的每个结点中，都包含着一个listdish（存储本次订单所选菜品及其数量）链表的头结点和一个recommend（存储本次订单推荐的菜品）链表的头结点。访问的时候可以通过list-&gt;recommend-&gt;dish_name这样的方法直接得到本次订单中推荐菜品的菜品名称。<br>这样的结构，如何从文件中读取？<br>其他的链表都还好办。至于这三个链表，我们建立了3个txt文件（虽然listdish和recommend有许多链表，但是最好还是都存在一个txt里，不然每次新点订单还要新建txt文件。）其中listdish和recommend文本文档是这样的：<img src="https://img-blog.csdnimg.cn/bcd7964a59194715921f1261517f5d50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>每一行代表第几个订单。每两个数字为一组，第一个数字为菜品号，第二个数字为该菜品所点数量。由于不固定长度，我们采用两个-1作为结尾，当读到-1时本订单结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">LIST *<span class="title function_">read_inf_l</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LIST *head = (LIST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LIST))</span><br><span class="line">	, *last = head, *p, *temp = (LIST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LIST));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	FILE *fp_l = fopen(<span class="string">&quot;D:\\小学期\\list.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp_l, <span class="string">&quot;%d %s %d %d %d %d %d %d %d %d %d %d %d &quot;</span></span><br><span class="line">	, &amp;temp-&gt;number, temp-&gt;user_id, &amp;temp-&gt;restaurant_id</span><br><span class="line">	, &amp;temp-&gt;score, &amp;temp-&gt;price</span><br><span class="line">	, &amp;temp-&gt;delivery_time_s.month, &amp;temp-&gt;delivery_time_s.day</span><br><span class="line">	, &amp;temp-&gt;delivery_time_s.hour, &amp;temp-&gt;delivery_time_s.minute</span><br><span class="line">	, &amp;temp-&gt;delivery_time_e.month, &amp;temp-&gt;delivery_time_e.day</span><br><span class="line">	, &amp;temp-&gt;delivery_time_e.hour, &amp;temp-&gt;delivery_time_e.minute) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		p = (LIST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LIST));</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		p-&gt;head_ld = read_inf_ld(temp-&gt;number);<span class="comment">//跳转到read_inf_ld(int number)函数中获得本次订单listdish链表的头结点，number是订单号</span></span><br><span class="line">		p-&gt;recommend_d = read_inf_recommend(temp-&gt;number);<span class="comment">//跳转到read_inf_recommend(int number)函数中获得本次订单recommend链表的头结点，number是订单号</span></span><br><span class="line">		p-&gt;number = temp-&gt;number;</span><br><span class="line">		<span class="built_in">strcpy</span>(p-&gt;user_id, temp-&gt;user_id);</span><br><span class="line">		p-&gt;restaurant_id = temp-&gt;restaurant_id;</span><br><span class="line">		p-&gt;score = temp-&gt;score;</span><br><span class="line">		p-&gt;price = temp-&gt;price;</span><br><span class="line">		p-&gt;delivery_time_s.month = temp-&gt;delivery_time_s.month;</span><br><span class="line">		p-&gt;delivery_time_s.day = temp-&gt;delivery_time_s.day;</span><br><span class="line">		p-&gt;delivery_time_s.hour = temp-&gt;delivery_time_s.hour;</span><br><span class="line">		p-&gt;delivery_time_s.minute = temp-&gt;delivery_time_s.minute;</span><br><span class="line">		p-&gt;delivery_time_e.month = temp-&gt;delivery_time_e.month;</span><br><span class="line">		p-&gt;delivery_time_e.day = temp-&gt;delivery_time_e.day;</span><br><span class="line">		p-&gt;delivery_time_e.hour = temp-&gt;delivery_time_e.hour;</span><br><span class="line">		p-&gt;delivery_time_e.minute = temp-&gt;delivery_time_e.minute;</span><br><span class="line">		last-&gt;next = p;</span><br><span class="line">		last = last-&gt;next;</span><br><span class="line">		last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp_l);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LISTDISH *<span class="title function_">read_inf_ld</span><span class="params">(<span class="type">int</span> id)</span> <span class="comment">//Read the Information of List-Dish linklist</span></span><br><span class="line">&#123;</span><br><span class="line">	LISTDISH *head = (LISTDISH *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LISTDISH))</span><br><span class="line">	, *last = head, *p, *temp = (LISTDISH *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LISTDISH));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	FILE *fp_ld;</span><br><span class="line">	fp_ld = fopen(<span class="string">&quot;D:\\小学期\\listdish.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (id != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span> (cnt != id)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			temp-&gt;dish_id = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (temp-&gt;dish_id != <span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fscanf</span>(fp_ld, <span class="string">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);</span><br><span class="line">			&#125;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">fscanf</span>(fp_ld, <span class="string">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);</span><br><span class="line">	<span class="keyword">while</span> (temp-&gt;dish_id != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = (LISTDISH *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LISTDISH));</span><br><span class="line">		p-&gt;dish_id = temp-&gt;dish_id;</span><br><span class="line">		p-&gt;number = temp-&gt;number;</span><br><span class="line">		last-&gt;next = p;</span><br><span class="line">		last = last-&gt;next;</span><br><span class="line">		last-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">fscanf</span>(fp_ld, <span class="string">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp_ld);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如要读取第三个订单所点菜品信息，传入read_inf_ld()的number订单号为3.<code>int cnt = 1</code>代表当前文件指针读取的订单号，从1开始计数，每次读到-1 -1证明又读完了一单，cnt++，直到cnt &#x3D;&#x3D; number为止。然后读取接下来的这个链表，最后返回头结点，作为该订单中的一个成员。<br><img src="https://img-blog.csdnimg.cn/6b66117ee8b641998ea580f57da912ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">RECOMMEND *<span class="title function_">read_inf_recommend</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">	RECOMMEND *head = (RECOMMEND *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RECOMMEND)),*last=head</span><br><span class="line">	,*p,*temp = (RECOMMEND *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RECOMMEND));</span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	FILE *fp_recommend = fopen(<span class="string">&quot;D:\\小学期\\recommend.txt&quot;</span>, <span class="string">&quot;r&quot;</span>); </span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> (cnt != id)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(temp-&gt;dish_name,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">strcmp</span>(temp-&gt;dish_name , <span class="string">&quot;-1&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fscanf</span>(fp_recommend, <span class="string">&quot;%s &quot;</span>, temp-&gt;dish_name);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp_recommend, <span class="string">&quot;%s &quot;</span>, temp-&gt;dish_name);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">strcmp</span>(temp-&gt;dish_name ,<span class="string">&quot;-1&quot;</span>)!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (RECOMMEND *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(RECOMMEND));</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;dish_name, temp-&gt;dish_name);</span><br><span class="line">        last-&gt;next = p;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">        last-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">fscanf</span>(fp_recommend, <span class="string">&quot;%s &quot;</span>, temp-&gt;dish_name);</span><br><span class="line">    &#125;</span><br><span class="line">	fclose(fp_recommend);</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取推荐菜品链表也是类似。<br>得到的链表全都包括头结点（里链表也是），不包含结尾的-1，只要通过-&gt;-&gt;就能访问hh。<br>总之，结束了~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：创新思维实践 C语言五子棋"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%88%9B%E6%96%B0%E6%80%9D%E7%BB%B4%E5%AE%9E%E8%B7%B5%20C%E8%AF%AD%E8%A8%80%E4%BA%94%E5%AD%90%E6%A3%8B/"
    >北邮国院项目：创新思维实践 C语言五子棋</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%88%9B%E6%96%B0%E6%80%9D%E7%BB%B4%E5%AE%9E%E8%B7%B5%20C%E8%AF%AD%E8%A8%80%E4%BA%94%E5%AD%90%E6%A3%8B/" class="article-date">
  <time datetime="2021-07-24T23:00:00.000Z" itemprop="datePublished">2021-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>这次看了几位大佬的做法，我们也做了很多修改尝试。算是第一次尝试合作完成项目。<br>我认为学到的东西：</p>
<ol>
<li>第一次尝试写项目，把函数分到不同的.c文件中后更好看了一些。</li>
<li>在研究过程中应该分清主次。代码正确运行才是基础要求，其他什么美化界面，调字体调颜色都并非重点。（8月4日更新：评价算法的五个特性，正确性，简明性，健壮性，效率，最优性）</li>
<li>从代码中学到的，①是采用落子数来判断该轮到黑方下还是白方下（落子数为2的倍数时黑方下，否则白方下），这样也能判断出是哪一方胜利，而且落子数还可以判断棋盘是否下满（&#x3D;&#x3D;16*16时棋盘落满，平局） ②是胜利条件的判断，以中间子为参考，看两边的四个子是否和他颜色相同。</li>
<li>8月4日更新：在这次尝试中在文件中使用了全局变量，不同文件中用extern调用。但是在后来学习中意识到全局变量最好不要写在文件里，会增加耦合性。以后多人合作写不同函数的时候也要注意，尽量不要出现。</li>
</ol>
<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>在一个16*16的棋盘上，黑白双方交替落子，每次落下子后如果棋盘上出现了五个同色棋子横向&#x2F;竖向&#x2F;斜向连接，则该方胜利。如果在棋盘下满后（即下了16*16个子后）仍未分出胜负，则为平局。</p>
<h1 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h1><p>初始化棋盘，是一个<code>16*16</code>的二维数组（定义宏 N&#x3D;16），一开始每一格都初始化为0。用一个不断++的落子数变量%2来判断本回合是黑方下还是白方下，；每次玩家输入横纵坐标，该处的变量值改变（黑子为1，白子为2）。每次落子判断全盘是否有五子连珠，如果有则结束游戏，如果没有则继续下。当落子数达到<code>N*N</code>即棋盘下满，还没有出现五子连珠时，则判断为平局，结束游戏。</p>
<h1 id="五子棋胜负条件判断"><a href="#五子棋胜负条件判断" class="headerlink" title="五子棋胜负条件判断"></a>五子棋胜负条件判断</h1><p>判断原理 :<br>胜负的判断是在每颗棋子落下之后进行，所以用这一子的坐标为基准前后左右斜各个方向来看是否取胜。<br>具体思想:<br>按照五子棋规则，当一方的棋子，在横向，纵向或斜向连续五个均为同一用户的棋子时，代表胜利。<br>另外，胜利判断只需要在一个新子落子时判断，且仅需要判断新子所在的四条线上(纵横加两个斜线)是否满足条件即可。<br>所以，可以以新子坐标为基准点，判断四次。<br>比如横向的，需要判断左侧和右侧连续的同类棋子个数，如果左侧+右侧+1（自身）总数&gt;&#x3D;5，则为胜利。<br>在判断胜利的时候,首先我们要排除空子的情况,然后当两个斜线的时候, 无胜情况下，判断直线,当为两斜线及直线无胜情况下，判断横线。<br>参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">win</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> arr[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>,l = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">2</span>;k&lt;N<span class="number">-2</span>;k++) </span><br><span class="line">		<span class="keyword">for</span>(l=<span class="number">2</span>;l&lt;N<span class="number">-2</span>;l++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k<span class="number">-2</span>][l<span class="number">-2</span>]==arr[k][l]&amp;&amp;arr[k<span class="number">-1</span>][l<span class="number">-1</span>]==arr[k][l]&amp;&amp;arr[k+<span class="number">1</span>][l+<span class="number">1</span>]==arr[k][l]&amp;&amp;arr[k+<span class="number">2</span>][l+<span class="number">2</span>]==arr[k][l])</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k+<span class="number">2</span>][l<span class="number">-2</span>]==arr[k][l]&amp;&amp;arr[k+<span class="number">1</span>][l<span class="number">-1</span>]==arr[k][l]&amp;&amp;arr[k<span class="number">-1</span>][l+<span class="number">1</span>]==arr[k][l]&amp;&amp;arr[k<span class="number">-2</span>][l+<span class="number">2</span>]==arr[k][l])</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">			<span class="keyword">for</span>(l=<span class="number">2</span>;l&lt;N<span class="number">-2</span>;l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k][l<span class="number">-2</span>]==arr[k][l]&amp;&amp;arr[k][l<span class="number">-1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class="number">1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class="number">2</span>]==arr[k][l])</span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">2</span>;k&lt;N<span class="number">-2</span>;k++)</span><br><span class="line">			<span class="keyword">for</span>(l=<span class="number">0</span>;l&lt;N;l++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[k][l]!=<span class="number">0</span>&amp;&amp;arr[k+<span class="number">2</span>][l]==arr[k][l]&amp;&amp;arr[k+<span class="number">1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class="number">-1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class="number">-2</span>][l]==arr[k][l])</span><br><span class="line">				&#123;</span><br><span class="line">					flag=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">return</span> flag; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注:<br>1.	中的arr[k][l]!&#x3D;0是排除空子的情况。<br>2.	最后返回判断结果时, 有胜为1,无为0,谁胜无必要判断，因为，谁尾手了的一定是胜的。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>开始<br> <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211141306161.png" alt="在这里插入图片描述"></p>
<p>输入坐标<br> <img src="https://img-blog.csdnimg.cn/d5998cff325649e6b674ed2a6051b673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>第二回合<br> <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211141306499.png" alt="在这里插入图片描述"></p>
<p>游戏结束<br> <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211141306208.png" alt="在这里插入图片描述"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院项目：计算导论与程序设计 C语言函数动画"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/15/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8A%A8%E7%94%BB/"
    >北邮国院项目：计算导论与程序设计 C语言函数动画</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/12/15/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8A%A8%E7%94%BB/" class="article-date">
  <time datetime="2020-12-15T00:00:00.000Z" itemprop="datePublished">2020-12-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>绘制一个函数动画。</strong><br>要求：1.碰到边界反弹；<br>2.会像贪吃蛇一样消失。</p>
<p>老师已给出提示代码：三个辅助函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">// two functions to clear screen and set cursor position for printing.</span></span><br><span class="line"><span class="comment">// one function to take a rest in 10 microseconds.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// use this function to clear screen</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">()</span><span class="comment">//清屏</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _WIN32</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span></span><br><span class="line">    system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__APPLE__)</span></span><br><span class="line">    system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _WIN32</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setcursor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">        COORD setps;</span><br><span class="line">        setps.X = x; setps.Y = y;</span><br><span class="line">        SetConsoleCursorPosition(hCon, setps);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// use this function to positioning before calling printf  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gotoxy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//光标移动到x,y处</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _WIN32</span></span><br><span class="line">    setcursor(y - <span class="number">1</span>, x - <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[%d;%dH&quot;</span>, x, y);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__APPLE__)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[%d;%dH&quot;</span>, x, y);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> factor = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest msec * 10 microseconds</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rest</span><span class="params">(<span class="type">int</span> msec)</span><span class="comment">//当前画面静止一定时间</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _WIN32</span></span><br><span class="line">    Sleep(msec * factor);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span></span><br><span class="line">    usleep(msec * <span class="number">1000</span> * factor);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__APPLE__)</span></span><br><span class="line">    usleep(msec * <span class="number">1000</span>* factor);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>clear()</code>函数清屏；<code>gotoxy()</code>函数使光标移动到指定位置；<code>rest()</code>当前画面静止。</p>
<p><strong>思路</strong><br>1.动画绘制<br>动画的原理是一帧帧的图片有短暂的时间间隔，连起来放映之后就产生了会动的感觉。我们可以每打印一个点之后<code>rest()</code>一小段时间来形成动画的效果。</p>
<p>2.边界反弹<br>即为碰到边界反向输出。我想的方法是纵坐标y1不变，只需要设计分段函数让x反向即可。</p>
<p>3.延时消失<br>要求的消失是像贪吃蛇一样，前面一边画着点，后面尾巴一边消失。但自己怎么想都只能做到全部绘制完成之后再让它开始消失。<br>请教助教与Mc大佬之后得知他的思路是保留点数。屏幕中最多出现50个点，第51个点之后，打印第x个点时，x-50号点打印空格覆盖，让他消失。</p>
<p><strong>注意事项</strong><br>1.审题。给定的<code>gotoxy()</code>函数的横纵坐标是反着的，而且从左上角开始为(1,1)。<br>2.<code>rest()</code>的用法非常灵活，比如高人指点：用户可以输入打印速度speed，rest(100-speed)。（妙啊）<br>3.程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。所以比起重复一段好多遍，使用函数会更好。</p>
<p>感谢Mc、fOrever_jAckY、olinr1222、–_–等人指点！<br>我の代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">zong</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//纵坐标y1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> x=(i<span class="number">-51</span>);</span><br><span class="line">	<span class="type">double</span> y=<span class="number">12.0</span>*<span class="built_in">sin</span>(x/<span class="number">7</span>);</span><br><span class="line">	<span class="type">int</span> y1=(<span class="type">int</span>)(<span class="number">15</span>-y);</span><br><span class="line">	<span class="keyword">return</span> y1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">heng</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//横坐标j</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j=i;</span><br><span class="line">	<span class="keyword">if</span>(i&gt;<span class="number">101</span>&amp;&amp;i&lt;=<span class="number">202</span>)j=<span class="number">203</span>-i;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">202</span>&amp;&amp;i&lt;=<span class="number">303</span>)j=i<span class="number">-202</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">303</span>&amp;&amp;i&lt;=<span class="number">404</span>)j=<span class="number">405</span>-i;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dayin</span><span class="params">(<span class="type">char</span> ch,<span class="type">int</span> j,<span class="type">int</span> y1)</span><span class="comment">//在(y1,j)处输出给定字符</span></span><br><span class="line">&#123;</span><br><span class="line">		gotoxy(y1,j);</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(y1==<span class="number">15</span>)<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">51</span>)<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">		gotoxy(<span class="number">29</span>-y1,<span class="number">102</span>-j);</span><br><span class="line">		<span class="keyword">if</span>(ch==<span class="string">&#x27; &#x27;</span>)<span class="comment">//防止坐标点和坐标轴被空格覆盖</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">29</span>-y1==<span class="number">15</span>)<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">102</span>-j==<span class="number">51</span>)<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">29</span>-y1==<span class="number">26</span>&amp;&amp;<span class="number">102</span>-j==<span class="number">49</span>)<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>((<span class="number">29</span>-y1==<span class="number">26</span>&amp;&amp;<span class="number">102</span>-j==<span class="number">50</span>)||(<span class="number">29</span>-y1==<span class="number">3</span>&amp;&amp;<span class="number">102</span>-j==<span class="number">50</span>))<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">29</span>-y1==<span class="number">16</span>&amp;&amp;<span class="number">102</span>-j==<span class="number">100</span>)<span class="built_in">printf</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">		gotoxy(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">float</span> x,y;</span><br><span class="line">	<span class="type">int</span> tim=<span class="number">20</span>;</span><br><span class="line">	system(<span class="string">&quot;color F0&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;mode con cols=101 lines=30&quot;</span>);</span><br><span class="line">	clear();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)<span class="comment">//打印x轴 </span></span><br><span class="line">	&#123;</span><br><span class="line">		gotoxy(<span class="number">15</span>,i+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">50</span>)<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">		gotoxy(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		rest(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//打印y轴 </span></span><br><span class="line">	&#123;</span><br><span class="line">		gotoxy(i+<span class="number">1</span>,<span class="number">51</span>);</span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">14</span>)<span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">		gotoxy(<span class="number">1</span>,<span class="number">1</span>); </span><br><span class="line">		rest(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印轴上的点</span></span><br><span class="line">	gotoxy(<span class="number">16</span>,<span class="number">52</span>); <span class="built_in">printf</span>(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	gotoxy(<span class="number">16</span>,<span class="number">100</span>);<span class="built_in">printf</span>(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	gotoxy(<span class="number">1</span>,<span class="number">49</span>);<span class="built_in">printf</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	gotoxy(<span class="number">3</span>,<span class="number">50</span>);<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	gotoxy(<span class="number">26</span>,<span class="number">49</span>);<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,j,y1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">52</span>;i&lt;=<span class="number">404</span>;i++)<span class="comment">//打印函数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		j=heng(i),y1=zong(i);</span><br><span class="line">		dayin(<span class="string">&#x27;#&#x27;</span>,j,y1);</span><br><span class="line">		rest(<span class="number">4</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(i<span class="number">-51</span>-tim&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			y1=zong(i-tim);</span><br><span class="line">			j=heng(i-tim);</span><br><span class="line">			dayin(<span class="string">&#x27; &#x27;</span>,j,y1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> r=i-tim;r&lt;=i;r++)</span><br><span class="line">	&#123;</span><br><span class="line">		j=heng(r);</span><br><span class="line">		y1=zong(r);</span><br><span class="line">		dayin(<span class="string">&#x27; &#x27;</span>,j,y1);</span><br><span class="line">		rest(<span class="number">4</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	gotoxy(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	rest(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：翁恺C语言程序设计"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/27/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BF%81%E6%81%BAC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"
    >技术学习：翁恺C语言程序设计</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/11/27/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BF%81%E6%81%BAC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-11-27T00:00:00.000Z" itemprop="datePublished">2020-11-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>是翁恺老师的132PC语言程序设计网课。<br>链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1sJ411E7St?p=1">【C语言】翁恺C语言程序编程全系列</a><br>是C语言入门的地方~还是希望多多指正！</p>
<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><h2 id="计算机和编程语言"><a href="#计算机和编程语言" class="headerlink" title="计算机和编程语言"></a>计算机和编程语言</h2><p>学习目的：理解计算机是怎样工作的<br>计算机是生活中的必需品。 如果我们想要自己设计一些功能和行为，让计算机按照自己的意图做事，就需要写程序了。<br>本课程的主要目的是通过学习编程，来理解计算机是如何解决问题，计算机的能与不能，pros and cons.<br>计算机怎样解决问题？把大问题拆分成小问题分步进行<br>人：what to do。<em>比如告诉同桌开一下灯，他去把灯打开。</em><br>计算机：how to do。<em>同桌不知道如何开灯，你要和他说：走到开关前，按下开关，走回来……</em><br>程序是用特殊的编程语言写出来表达如何解决问题的。<br><strong>我们不是在用编程语言和计算机交谈，而是要求它如何做事情，向它描述做事情的过程和方法。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：hello world!</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);<span class="comment">//输出“Hello World!（换行）”引号内的部分</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>普通人能读懂的东西→</th>
<th>程序员能懂的东西→</th>
<th>计算机能懂的东西</th>
</tr>
</thead>
<tbody><tr>
<td>计算机</td>
<td>程序</td>
<td>算法</td>
</tr>
<tr>
<td>（算法：我们想让计算机做计算，先要写出计算的步骤，然后用编程语言写出来。计算机做的所有事情都是计算；计算的步骤就是算法。）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="计算机的思维方式"><a href="#计算机的思维方式" class="headerlink" title="计算机的思维方式"></a>计算机的思维方式</h2><p>例：解方程2x+6&#x3D;20 ，    x∈(1,10）直接解方程对计算机来说太难理解了。<br>计算机的思维：</p>
<ol>
<li><strong>枚举法</strong><br>代入x&#x3D;1，不行；代入x&#x3D;2，不行；代入……</li>
<li><strong>二分法</strong><br>代入x&#x3D;5，小了；代入x&#x3D;7……</li>
</ol>
<p>计算机执行程序有两种方案：</p>
<ol>
<li><strong>解释</strong>：借助一个程序，那个程序可以试图<strong>理解你的程序</strong>，然后按照你的要求执行</li>
<li><strong>编译</strong>：借助一个程序把你的程序<strong>翻译成机器语言</strong>写的程序，然后计算机就可以直接执行了。</li>
</ol>
<p>解释语言vs编译语言：语言本无解释与编译之分，只是常用的执行方式不同。<br>解释型语言有特殊的计算能力；<br>编译型语言有确定的运算性能。</p>
<h2 id="为什么编程入门从C学起？"><a href="#为什么编程入门从C学起？" class="headerlink" title="为什么编程入门从C学起？"></a>为什么编程入门从C学起？</h2><p><a target="_blank" rel="noopener" href="https://www.tiobe.com/tiobe-index//">语言排行</a><br><img src="https://img-blog.csdnimg.cn/20210714003556146.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>在很多场合，C语言是唯一的选择</li>
<li>现代编程语言在语法上差异很小，基本都和C接近</li>
<li>语言的能力、适用领域主要是由 <strong>库</strong> 和 <strong>传统</strong> 决定的。</li>
</ol>
<h2 id="C的简单历史"><a href="#C的简单历史" class="headerlink" title="C的简单历史"></a>C的简单历史</h2><p>1969诞生。<br>FORTRAN→BCPL→B语言→C语言</p>
<p><em>1967年，剑桥大学的 Martin Richards 对CPL语言进行了简化，于是产生了BCPL（Basic Combined Pogramming Language)语言。<br>1970年，美国贝尔实验室的 Ken Thompson。以BCPL语言为基础，设计出很简单且很接近硬件的B语言（取BCPL的首字母）。并且他用B语言写了第一个UNIX操作系统。<br>在1972年，美国贝尔实验室的 D.M.Ritchie 在B语言的基础上最终设计出了C语言。</em><br>因为B和BCPL都支持指针间接方式，所以C语言也支持了。<br>C语言还受到了PL&#x2F;I（和底层系统很接近，可以拿来做操作系统等）的影响，还和 PDP-II的机器语言有很大关系<br>1973&#x2F;3，第三版的Unix上出现了C语言的编译器<br>1973&#x2F;11，第四版的Unix完全用C语言重新写的。<br><img src="https://img-blog.csdnimg.cn/20201127221048977.png" alt="经典C，又叫K&amp;R the C"><br><em>经典C，又叫K&amp;R the C</em><br>1989年，ANSI发布了一个标准：ANSI C<br>1990年，ISO接受了ANSI的标准：C89<br>C的标准在1995年和1999年两次更新：C95和C99。现在的编译器都基于C99了，因此本课程也是。</p>
<h2 id="编程软件用什么"><a href="#编程软件用什么" class="headerlink" title="编程软件用什么"></a>编程软件用什么</h2><p>C语言的用途：写操作系统、嵌入式系统、驱动程序（用来驱动U盘）、底层驱动、图形引擎、图像处理、声音效果（直接给我们提供数据的代码不是用C语言写的）一些底层的东西。<br>C语言是一种工业语言，由基础人员使用。所以：<br><strong>开发效率&gt;&gt;学习过程<br>开发效率&gt;&gt;开发乐趣</strong><br>而在日常的应用中，很少直接用C语言编写。学习C的过程主要是写练习代码，而不是写真实软件。<br>C语言需要被编译才能运行，所以需要：编辑器和编译器<br>（或者IDE，Integrated Development Environment集成开发环境，一个顶俩）<br>推荐的编程软件：Dev C++。免费，安装简单，还不用建工程。<br><img src="https://img-blog.csdnimg.cn/20210714004554282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="2-入门：从Hello-World开始"><a href="#2-入门：从Hello-World开始" class="headerlink" title="2. 入门：从Hello World开始"></a>2. 入门：从Hello World开始</h1><h2 id="第一个C程序"><a href="#第一个C程序" class="headerlink" title="第一个C程序"></a>第一个C程序</h2><p>在Dev C++中：文件-&gt;新建-&gt;源代码</p>
<p><strong>输入之前确保是英文输入！！！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>梦开始的地方。<br>可以先自己敲进去运行玩玩<br><strong>上端显示星号，说明没有保存。Ctrl + S 保存并且记得选择.c格式。<br>编译之后再运行。</strong>运行后出现黑色的终端，上面显示了结果。</p>
<h2 id="详解第一个C程序"><a href="#详解第一个C程序" class="headerlink" title="详解第一个C程序"></a>详解第一个C程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本课程中所有的程序都需要用到这一段框架（直到学函数之前）<br>printf()会把” “内的内容（字符串）原封不动地输出，\n表示换行。<br>如果出现编译错误，会在下面用红色的error显示出来，而具体错误原因在下方窗口里。</p>
<h2 id="简单计算"><a href="#简单计算" class="headerlink" title="简单计算"></a>简单计算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">23</span>+<span class="number">43</span>);</span><br></pre></td></tr></table></figure>
<p>%d是占位符，说明后面会有一个整数输出到这个位置上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;23+43=%d&quot;</span>,<span class="number">23</span>+<span class="number">43</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>四则运算</th>
<th>C符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>×</td>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>÷</td>
<td>&#x2F;</td>
<td>除</td>
</tr>
<tr>
<td></td>
<td>%</td>
<td>取余</td>
</tr>
<tr>
<td>( )</td>
<td>( )</td>
<td>括号</td>
</tr>
</tbody></table>
<h1 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>找零钱问题：100-(用户输入)物品的价格&#x3D;找你的钱<br>我们需要：</p>
<ol>
<li>有办法输入数字；</li>
<li>有地方放输入的数字；</li>
<li>输入的数字参与计算。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price=<span class="number">0</span>;<span class="comment">//定义了整形变量price，类型是int，初始值=0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line"><span class="type">int</span> change=<span class="number">100</span>-price;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;找您%d元。\n&quot;</span>,change);</span><br></pre></td></tr></table></figure>
<p><strong>变量</strong>是一个保存数据的地方。<br>变量定义的一般形式就是：<br>&lt;类型名称&gt; &lt;变量名称&gt;<br>变量的名字叫“标识符”，基本原则只能由字母、数字、下划线构成，<strong>数字不能出现在第一个位置上</strong>。C语言的关键字（又叫保留字）不可用作字符。<br>如何输入：<br>输入也在终端窗口中。输入以行为单位进行，敲下回车，行结束。<br>（敲下回车之前，程序不会读到任何东西。）</p>
<h2 id="变量赋值与初始化"><a href="#变量赋值与初始化" class="headerlink" title="变量赋值与初始化"></a>变量赋值与初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price=<span class="number">0</span>;<span class="comment">//其中=是赋值运算符，把右边的值赋给左边的变量。</span></span><br></pre></td></tr></table></figure>
<p>和数学中不同，b&#x3D;a和a&#x3D;b在程序中有着相反的含义。<br>当赋值发生在刚定义变量时，就叫程序的初始化。虽然C语言并没有强制要求所有的变量在被定义的地方做初始化，但所有变量在第一次被使用（出现在&#x3D;等号右边）前都应该被赋值一次。<br>如果没有初始化呢？<br>就是使用这个变量在内存中的那个值。<br>变量初始化：&lt;类型名称&gt; &lt;变量名称&gt;&#x3D;&lt;初始值&gt;<br>也可以在组合变量定义中给单个变量单独赋初值，如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>有运算符的式子就叫表达式（比如&#x3D;是赋值运算符）<br>C语言是有类型的语言，所有变量在使用前必须先定义或声明；所有变量必须有确定的数据类型（表示在变量中可以存放什么样的数据），变量中也只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。<br><code>int charge=100-price;</code><br><em>比较C和ANSI C</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言</span></span><br><span class="line">	<span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line">	<span class="type">int</span> change=<span class="number">100</span>-price;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;找您%d元。\n&quot;</span>,change);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统的ANSI C只能在开头的地方定义变量</span></span><br><span class="line">	<span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> change=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line">	change=<span class="number">100</span>-price;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;找您%d元。\n&quot;</span>,change);</span><br></pre></td></tr></table></figure>

<h2 id="变量输入"><a href="#变量输入" class="headerlink" title="变量输入"></a>变量输入</h2><p><code>scanf()</code>函数，读到的结果赋值给后面的变量<br><strong>（注意变量前的&amp;）</strong><br>如果输入非整数（比如找钱一例中：输入字母，找我100元）应该怎么处理？这种情况后面再说。</p>
<h2 id="常量vs变量"><a href="#常量vs变量" class="headerlink" title="常量vs变量"></a>常量vs变量</h2><p>固定不变的数，是常数。直接写在程序里的，叫直接量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> amount=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>其中const是个修饰符，加在int前面，给这个变量加上一个const（不变的）属性，表示这个变量的值一旦初始化，就不能再更改了。<br> 好处：1.便于理解2.修改的时候好找<br>编译时会显示：read-only variable is not assignable<br>（一般const的变量全大写）<br>scanf的空格有讲究，以后再说。输入时如果要两个数，在中间、最后敲空格或回车，计算机读到两个数字时停止<br>当scanf扫描数字时输入字母，可能会出来很多奇怪的数字。（应该是ASCII码吧？）后面再细说。</p>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>C语言中两个整数做运算得到的结果也只能是个整数（去掉小数部分）。而10和10.0在c中是完全不同的两个数字，10.0是浮点数（浮点数指小数点时可以浮动的，是计算机中表示分数和无理数的一种方式。人们用浮点数来称呼有小数点的数）（其实还有定点数。但是在c语言中无）<br>当浮点数和整数放在一起运算时，计算机会自动把整数转化为浮点数计算<br>（如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a/b*3&quot;</span>);<span class="comment">//改进为a/b*3.0</span></span><br></pre></td></tr></table></figure>
<p><em>有一次尝试printf(“%f”,3&#x2F;2);输出的是整数。应该是先进行整数运算再以%f形式输出，而不是以%f形式输出。所以应该改进为3&#x2F;2.0</em></p>
<p>有单精度float(%f)和双精度double(%lf)<br>(计算机里会有这种纯粹的整数，是因为运算快、占地小。而且日常生活中大多也是整数运算。)</p>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>一个表达式是一系列运算符和算子的结合，用来计算一个值<br>运算符(operator)是指进行运算的动作，比如加&#x2F;减法运算符+-<br>算子(operand)是指参与运算的值，可能是常数&#x2F;变量&#x2F;一个方法的返回值<br><img src="https://img-blog.csdnimg.cn/20201128140525222.png" alt="在这里插入图片描述"></p>
<p>计算时间差：这里只记录分钟错位的情况（1:40和2:10）<br>方法：全部记为分钟（小时*60）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> hour1,min1;</span><br><span class="line"><span class="type">int</span> hour2,min2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;hour1,&amp;min1);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;hour2,&amp;min2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t1=hour1*<span class="number">60</span>+min1;<span class="comment">//把小时转化为分钟单位</span></span><br><span class="line"><span class="type">int</span> t2=hour2*<span class="number">60</span>+min2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t=t2-t1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;时间差是%d小时%d分。“,t/60,t%60);//t/60是小时部分；t%60取余，是分钟部分</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>（double输入的时候用<code>%lf</code>，输出的时候用<code>%f</code>就行）<br>运算符优先级</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>运算</th>
<th>结合关系</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>+</td>
<td>单目不变</td>
<td>自右向左</td>
<td>a*+b</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>单目取负</td>
<td>自右向左</td>
<td>a*-b</td>
</tr>
<tr>
<td>2</td>
<td>*</td>
<td>乘</td>
<td>自左向右</td>
<td>a*b</td>
</tr>
<tr>
<td>2</td>
<td>&#x2F;</td>
<td>除</td>
<td>自左向右</td>
<td>a&#x2F;b</td>
</tr>
<tr>
<td>2</td>
<td>%</td>
<td>取余</td>
<td>自左向右</td>
<td>a%b</td>
</tr>
<tr>
<td>3</td>
<td>+</td>
<td>加</td>
<td>自左向右</td>
<td>a+b</td>
</tr>
<tr>
<td>3</td>
<td>-</td>
<td>减</td>
<td>自左向右</td>
<td>a-b</td>
</tr>
<tr>
<td>4</td>
<td>&#x3D;</td>
<td>赋值</td>
<td>自右向左</td>
<td>a&#x3D;b</td>
</tr>
<tr>
<td>（a+b,a-b是双目；+a,-a是单目，相当于正负号）</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>赋值也是运算，也有结果。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>a=6</code>的结果就是a被赋予的值，也就是6</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>如 <code>a=b=6</code>：自右向左，a&#x3D;(b&#x3D;6)。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>嵌入式赋值：<code>int c=1+(b=a)</code><br>缺点：不利于阅读；容易产生错误<br>运算符的结合关系一般自左向右；单目<code>+-</code>和赋值<code>=</code>自右向左<br>下面的式子过于复杂，不利于阅读和理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result=a=b=<span class="number">3</span>+c;</span><br><span class="line">result=(result=result*<span class="number">2</span>)*<span class="number">6</span>*(result=<span class="number">3</span>+result);</span><br></pre></td></tr></table></figure>

<p>所以应该把它拆开来计算。<br>（C语言没有幂次，所以只能一个个乘。）</p>
<h2 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h2><p>交换a和b的值（a&#x3D;6,b&#x3D;5）<br><strong>错误</strong>示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=b;</span><br><span class="line">b=a;</span><br></pre></td></tr></table></figure>

<p>程序表达的是顺序执行的动作，而不是关系.所以这样做先把b赋给a，然后再把a赋给b，都是5.<br>方法：再找一个变量c，c&#x3D;a储存一下a的值，然后a&#x3D;b,b&#x3D;c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c=a;</span><br><span class="line">a=b;</span><br><span class="line">b=c;</span><br></pre></td></tr></table></figure>

<p>断点</p>
<p><img src="https://img-blog.csdnimg.cn/20201128141427591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>DEV C++中，在左边数字那里点击一下，然后程序运行时就会在这一行停止。<br><img src="https://img-blog.csdnimg.cn/2020112814144933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p> 运行也只能到这一行<br>点下一行，就会运行到下一行。<br>这样可以方便排bug<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45660901/article/details/109129667">C语言：使用Dev C++断点调试</a></p>
<h2 id="复合赋值"><a href="#复合赋值" class="headerlink" title="复合赋值"></a>复合赋值</h2><p><code>a+=5</code>表示<code>a=a+5</code>(注意两个运算符之间无空格)<br>类似有<code>-=</code>，<code>*=</code>，<code>/=</code><br>（<code>a*=b+5</code>表示<code>a=a*(b+5)</code>,如果想先算<code>a=a*b</code>记得加括号）<br>INC递增、DEC递减运算符：<code>++</code>，<code>--</code>：单目运算符，只能有一个算子，这个算子还只能是变量（如<code>a++</code>后缀形式，<code>++a</code>前缀形式）让该变量+1&#x2F;-1；<br><code>a++</code>运算式的值是a+1以前的值；<code>++a</code>运算式的值是a+1以后的值。无论哪个，a的值都+1了<br> <img src="https://img-blog.csdnimg.cn/20201128141516408.png" alt="在这里插入图片描述"></p>
<p><code>++</code>和<code>--</code>可以单独使用，但不要把它组合进表达式，复杂。</p>
<h1 id="4-判断（选择结构）"><a href="#4-判断（选择结构）" class="headerlink" title="4. 判断（选择结构）"></a>4. 判断（选择结构）</h1><p>if条件判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">	要执行的语句，只有条件成立时才会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断的条件"><a href="#判断的条件" class="headerlink" title="判断的条件"></a>判断的条件</h2><p>计算两个值之间的关系，叫做关系运算<br>&#x3D;&#x3D;判断相等<br>!&#x3D;不相等<br>还有&gt;；&gt;&#x3D;；&lt;；&lt;&#x3D;，当两个值的关系复合这些关系运算符的预期时，关系运算的结果为整数1，否则为整数0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">5</span>&gt;<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">5</span>==<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果:1（换行）0<br>所有关系运算符的优先级都比算数运算低，比赋值运算高<br>(编程语言都是可以人为验证的)<br>如<code>int r=a&gt;0;</code>先判断a是否&gt;0,再把0&#x2F;1的值赋给r<br><code>==</code>和<code>!=</code>优先级比其他的低<br>连续的关系运算是从左到右进行的<br><code>5&gt;3==6&gt;4</code>→<code>1==1</code>成立<br><code>6&gt;5&gt;4</code>→<code>1&gt;4</code>不成立</p>
<h2 id="找零计算器"><a href="#找零计算器" class="headerlink" title="找零计算器"></a>找零计算器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">i1=&gt;inputoutput: 输入购买的金额</span><br><span class="line">i2=&gt;inputoutput: 输入支付的票面</span><br><span class="line">o1=&gt;operation: 计算找零</span><br><span class="line">c=&gt;condition: 判断余额是否充足</span><br><span class="line">o2=&gt;inputoutput: 打印找零</span><br><span class="line">o3=&gt;inputoutput: 告知用户余额不足以购买</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">st-&gt;i1-&gt;i2-&gt;o1-&gt;c</span><br><span class="line">c(yes)-&gt;o2-&gt;e</span><br><span class="line">c(no)-&gt;o3-&gt;e</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> price=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> bill=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//读入金额和票面</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入金额：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入票面：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;bill);</span><br><span class="line"><span class="comment">//计算找零</span></span><br></pre></td></tr></table></figure>

<p><code>//</code>是（单行）注释，把程序分成了三个部分：初始化，读入金额和票面，计算并打印找零；<br>c99可以，ASCII不支持<br>comment对程序的功能没有任何影响，但是往往能使程序更容易被人类读者理解。<br><code>/* */</code>中间可以有多行注释。</p>
<h2 id="否则"><a href="#否则" class="headerlink" title="否则"></a>否则</h2><p>比如刚刚的找零计算器：金额&lt;票面<br><code>else&#123;  &#125;</code>是<code>if</code>的补集<br>输入两数，找最大者：<br>方案一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入两个整数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)max=a;</span><br><span class="line"><span class="keyword">else</span> max=b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;大的那个是%d\n&quot;</span>,max);</span><br></pre></td></tr></table></figure>
<p>方案二</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入两个整数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="type">int</span> max=b;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)max=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;大的那个是%d\n&quot;</span>,max);</span><br></pre></td></tr></table></figure>



<p>可以对比两种方案，方案二绝绝子</p>
<h2 id="没有大括号的if语句"><a href="#没有大括号的if语句" class="headerlink" title="没有大括号的if语句"></a>没有大括号的if语句</h2><p>if语句可以不加大括号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（a&gt;b）</span><br><span class="line">	max=a;</span><br></pre></td></tr></table></figure>

<p>If这行结束并没有语句结束的标志<code>;</code>而后面的赋值语句写在下一行且缩进了，结束时有“；”。这表明这条赋值语句是if语句的一部分，if语句拥有和控制这条赋值语句，决定他是否要被执行。<br>就是说，没有大括号，后面一句话是有效的，也只能这一句是有效的（包含在if里）。</p>
<h2 id="嵌套的if-else"><a href="#嵌套的if-else" class="headerlink" title="嵌套的if-else"></a>嵌套的if-else</h2><p>找三个数中的最大数：先比较两个数谁更大，较大的再和c比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;c)max=a;</span><br><span class="line">	<span class="keyword">else</span> max=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(b&gt;c)max=b;</span><br><span class="line">	<span class="keyword">else</span> max=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="级联的if-else-if"><a href="#级联的if-else-if" class="headerlink" title="级联的if-else if"></a>级联的if-else if</h2><p>如分段函数。这时可以用级联的else if 表达多种情况<br>每个else是前一个if的else，但是前面两个都不满足的话就只剩下第三个了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">i=&gt;inputoutput: 输入</span><br><span class="line">o=&gt;inputoutput: 输出</span><br><span class="line">c1=&gt;condition: 是否满足条件1</span><br><span class="line">c2=&gt;condition: 是否满足条件2</span><br><span class="line">o1=&gt;inputoutput: 输出条件1</span><br><span class="line">o2=&gt;inputoutput: 输出条件2</span><br><span class="line">o3=&gt;inputoutput: 输出条件3</span><br><span class="line">en=&gt;end: 结束</span><br><span class="line">st-&gt;i-&gt;c1</span><br><span class="line">c1(yes)-&gt;o1-&gt;en</span><br><span class="line">c1(no)-&gt;c2</span><br><span class="line">c2(yes)-&gt;o2-&gt;en</span><br><span class="line">c2(no)-&gt;o3-&gt;en</span><br></pre></td></tr></table></figure>
<p>其实相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>()</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较该分段函数的两种写法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)f=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>更建议上面的方法，有单一出口（都是输出f），因为代码要降低重复性，出问题的时候才好统一处理。</p>
<h2 id="if-else的常见错误"><a href="#if-else的常见错误" class="headerlink" title="if-else的常见错误"></a>if-else的常见错误</h2><ol>
<li>   忘记写大括号的话，条件成立时只执行后面一句</li>
<li>   If后面无分号</li>
<li>   &#x3D;&#x3D;和&#x3D;：if只要求括号里是0或非0</li>
<li>   使人困惑的else<br><strong>尊重warning！</strong><br>大括号内的语句加tab缩进是代码风格。<br>3.2.4 多路分支</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(print)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与if的自顶向下判断不同，<code>switch</code>从几个<code>case</code>中找出3后执行,就是说几个case的判断是同时的.<br>但是switch语句只能判断int整形变量,而且case后面的必须是常量（如<code>mon=1</code>，case 1）<br>Switch是先跳到对应的case处，然后一条条向下执行直到遇到break跳出switch<br>如果进入下一个case前还没有碰到break，那就进入下一个case<br>按成绩分等级的题：可以先&#x2F;10，再分case。</p>
<p><strong>注意一定要在每个case后加上break.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> ( i%<span class="number">3</span> ) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;zero&quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出的是onetwo。<br> 解释：switch是一个路标牌，计算控制表达式的值后，就知道跳转到哪了（在哪里上车），但是分支符号只是说明switch内部位置的路标，在执行完分支后，如果后面没有break（下车提示），就会顺序执行到下面的case，直到遇到break，或者switch结束（终点站）<br> 也就是说，程序跳到了one那个case，然后因为没有break就继续往下顺延，又输出了two。</p>
<h1 id="5-循环（循环结构）"><a href="#5-循环（循环结构）" class="headerlink" title="5. 循环（循环结构）"></a>5. 循环（循环结构）</h1><p>写程序在写的是步骤，一步一步走。<br>判断一个数的位数<br>人vs计算机<br>人一看就出来了，很快啊<br>计算机：判断数的范围来确定数的位数（100~999范围内是三位数）但人对数字处理比文字弱<br>但是位数太多也不能用这种方法了。改用一步步查位数的方法。<br>所以从最左边开始约，每次约一位，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	n/=<span class="number">10</span>;i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	n/=<span class="number">10</span>;i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>……不过这样也是无限循环。<br>所以我们可以引入新函数，while。条件满足，就会不断重复大括号里的内容。<br>（尝试的时候不要拿太大的数去试，计算机里的整数是有范围的。）</p>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>数字位数的算法<br>1.	用户输入x；<br>2.	初始化n为0；<br>3.	X&#x2F;&#x3D;10，去掉个位；<br>4.	cnt++;<br>5.	如果x&gt;0，回到3；<br>6.	否则cnt就是结果。</p>
<p>do-while循环：进入循环的时候不做检查，而是执行完一轮循环体的代码之后再来检查循环条件是否满足，满足的话继续，不满足的话结束循环<br>(while();最后一定要有分号！！！)<br>while和do while很像，区别在于do while在循环体执行结束时才来判断条件。也就是说无论如何，循环都会执行至少一遍。</p>
<h2 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h2><p>if和while的区别在于，if判断只一次，不管结果如何都结束了。<br><strong>While一定要有结束循环的条件！！</strong>否则会一直循环，超时<br>While可以翻译为当。循环有可能一次都没有被执行。条件成立是循环成立的条件。<br>如何看出程序运行结果？<br>人脑模拟计算机的运行，在纸上列出所有变量，随着程序的进展不断重新计算变量的值。当程序运行结束时，留在表格最下面的就是程序的最终结果。<br>测试程序常常使用边界数据，如有效范围两端的数据、特殊的倍数等等。<br>（此题求位数，特殊数据可以是个位数、10、0、负数）<br>然后可以发现，0是1位数，但是用while算法的话算出来是0位数。那我们可以用do-while就能得到1位数了。<br>或者if(x&gt;0),做while；else位数&#x3D;1，单独列出x&#x3D;0的情况。<br>另一种调试方法：在适当的位置加上printf输出<br>作用不只有输出数据。比如在while括号内加一个printf(“in loop”);证明程序到这个地方了，也就是进入while循环了（还可以看循环了几次）</p>
<h2 id="循环计算"><a href="#循环计算" class="headerlink" title="循环计算"></a>循环计算</h2><p>编程难在小问题。<br>如：有的时候可能需要保存原始数据。<br>求log2x：x&#x2F;&#x3D;2，计数（当x&gt;1时）<br>但是如果printf（“log2 of %d is %d.”,x,计数）；最后输出的x总是1，因为循环算完的时候x总是1<br>所以我们开始要把原始的x保存一下。又是一个小细节~诸如此类，还有很多。<br>如：</p>
<ul>
<li>While可以用do while吗？</li>
<li>为什么计数从0开始，可以从1开始吗？</li>
<li>为什么while判断条件是x&gt;1?</li>
<li>循环最后输出的是多少？</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,ret=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="type">int</span> t=x;</span><br><span class="line">	<span class="keyword">while</span>(x&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		x/=<span class="number">2</span>;</span><br><span class="line">		ret++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;log2 of %d is %d.&quot;</span>,t,ret);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实都是相互牵扯的。<br>1、	当x&#x3D;1的时候，结果是0.也就是说我们希望当x&#x3D;1时不要进入这个循环。<br>2、	计数ret是我们希望进入这个循环是最小的数。<br>如果想改成while(x&gt;2)，那我们的计数ret就要相应改成初始值&#x3D;1.但是x&#x3D;1时条件不满足。为了兼顾两种情况，还得用上面的方法。<br>也可以ret&#x3D;-1，while(x&gt;0)<br>编程肯定会有很多不同的方法。<br>对于很大次数的循环，我们可以模拟较少的循环次数，然后做出推断，解决上面提到的四个问题。因为很多小细节，要多加注意。</p>
<h2 id="猜数游戏"><a href="#猜数游戏" class="headerlink" title="猜数游戏"></a>猜数游戏</h2><p>计算机想一个数，用户来猜，猜不对的话告诉用户大了还是小了，最后猜中了告诉用户猜了多少次。</p>
<ol>
<li><pre><code>因为要不断重复去猜，所以我们要用到循环
</code></pre>
</li>
<li><pre><code>实际写出程序之前，我们可以先用文字描述出程序的思路。
</code></pre>
</li>
<li>   核心重点是循环的条件。</li>
<li>   人们往往会考虑循环终止的条件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">i=&gt;inputoutput: 用户输入猜的数</span><br><span class="line">ocnt=&gt;operation: count++</span><br><span class="line">o=&gt;operation: 计算机随机想一个数，记在number里</span><br><span class="line">c=&gt;condition: 判断a是否等于number</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">o2=&gt;inputoutput: 告诉用户大了还是小了</span><br><span class="line">oe=&gt;operation: 输出cnt猜的次数</span><br><span class="line"></span><br><span class="line">st-&gt;o-&gt;i-&gt;ocnt-&gt;c</span><br><span class="line">c(yes)-&gt;oe-&gt;e</span><br><span class="line">c(no)-&gt;o2(right)-&gt;i</span><br></pre></td></tr></table></figure>

<p>循环的条件是a!&#x3D;number<br>用函数rand()召唤随机整数<br>使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先加入两个头文件#include&lt;stdlib.h&gt;和#include&lt;time.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	srand(time(<span class="number">0</span>));<span class="comment">//Main里加上srand(time(0));  先不用管什么意思</span></span><br><span class="line">	<span class="type">int</span> a=rand();<span class="comment">//如果想要a是100以内的整数：用取余即可（a%=100）</span></span><br><span class="line">	<span class="type">int</span> number=rand()%<span class="number">100</span>+<span class="number">1</span>;<span class="comment">//这样召唤出来的数范围是1~100</span></span><br><span class="line">	<span class="comment">//不管怎样用户都要进入这个循环，输入至少一个数；所以应该用do-while循环。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算平均数"><a href="#算平均数" class="headerlink" title="算平均数"></a>算平均数</h2><p>读入一系列正整数，输入-1时终止。然后输出他们的平均数<br>变量-&gt;算法-&gt;流程图-&gt;程序<br>num:我们需要读到的那一个数。<br>sum(总和)：每读到一个数把他加到sum里就完事了<br>另一个变量count记录累加的次数，最后算平均数÷count</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowchat</span><br><span class="line">st=&gt;start: sum=0,cnt=0</span><br><span class="line">i1=&gt;inputoutput: 读num</span><br><span class="line">c=&gt;condition: num!=-1?</span><br><span class="line">o=&gt;operation: sum+=num, cnt++</span><br><span class="line">op=&gt;inputoutput: 计算和打印结果</span><br><span class="line">e=&gt;end: end</span><br><span class="line">st-&gt;i1-&gt;c</span><br><span class="line">c(yes)-&gt;o-&gt;i1</span><br><span class="line">c(no,left)-&gt;op-&gt;e</span><br></pre></td></tr></table></figure>



<p> 注意转化成浮点数来求平均值。<br>浮点数转化方法： 1.0*sum&#x2F;count</p>
<h2 id="整数逆序"><a href="#整数逆序" class="headerlink" title="整数逆序"></a>整数逆序</h2><p>整数分解方法：%10得到个位数，&#x2F;10;再%10得到十位数……<br>整数逆序问题注意结尾0的处理；<br>如果不用考虑0的话，我们可以每得到一位就输出一位。%10一下输出一下，&#x2F;10，再%10输出一下，很快啊<br>考虑0：那就应该把逆序数算出来在输出了。搞一个ret&#x3D;0,每次ret&#x3D;ret*10+n%10;</p>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>阶乘<code>n!=n*(n-1)*(n-2)*……*2*1</code><br>程序：输入n，输出n!<br>需要借助一个变量i从1~n.这里的循环，我们用for来处理。<br>for循环像一个计数器。达到一个数之前一直进行循环，在过程中<code>i++</code>或<code>i--</code><br><code>for(int i=0;i&lt;n;i++)</code>n次循环<br>求和时，初始值为0；求积时，初始值为1<br>still, 可以尝试细节。<br>比如阶乘，第一项是1，乘不乘不变。如果去掉的话，可以吗？对all n有影响吗？<br>或者把方向反过来，从n乘到1可以吗？</p>
<h2 id="循环的计算和选择"><a href="#循环的计算和选择" class="headerlink" title="循环的计算和选择"></a>循环的计算和选择</h2><p>循环的起点终点对结果都有影响<br>有固定次数，明确起点与终点：for<br>至少执行一次:do while<br>可能一次不执行：while</p>
<h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><p>设定判定变量isprime&#x3D;1;<br>如果出现可以整除，isprime&#x3D;0;break;<br>break:结束循环<br>continue:可以跳过此循环剩下的部分，进入下一轮循环<br><img src="https://img-blog.csdnimg.cn/20201210204728145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="嵌套的循环"><a href="#嵌套的循环" class="headerlink" title="嵌套的循环"></a>嵌套的循环</h2><p>如：输出100内的素数，for里有for（第一个for遍历1~100，第二个检验该数是不是素数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;<span class="comment">//再scan x</span></span><br><span class="line"><span class="type">int</span> isprime=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;x;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">		isprime=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//再根据isprime是不是1判断x是不是素数</span></span><br></pre></td></tr></table></figure>
<p>除了特别设计，每一层循环的控制变量应该不一样（i），要注意。所以在第一层循环每层开始的时候重新赋值或定义int i，免得上次循环完的i这次拿来接着用，乱套了。<br>&#x2F;t可以对齐，具体以后再讲</p>
<h2 id="从嵌套的循环中跳出"><a href="#从嵌套的循环中跳出" class="headerlink" title="从嵌套的循环中跳出"></a>从嵌套的循环中跳出</h2><p>凑硬币：用1,2,5元凑出100<br>如果我们想，发现了一种合适的就结束：在if内加break跳出（下图是错误示例）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(one=<span class="number">1</span>;one&lt;x*<span class="number">10</span>;one++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(two=<span class="number">1</span>;two&lt;x*<span class="number">10</span>/<span class="number">2</span>;two++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(five=<span class="number">1</span>;five&lt;x*<span class="number">10</span>/<span class="number">5</span>;five++)<span class="comment">//break跳出的是这层循环，而没有跳出上面的两层循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(one+two*<span class="number">2</span>+five*<span class="number">5</span>==x*<span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角加%d个两角加%d个五角得到%d元\n&quot;</span>,one,two,five,x);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是图中的break只跳出了第三层for循环；接着又进到了第二层for循环（图中蓝色位置），Break和continue都只能在他那一层循环里做；<br>如何一直跳出呢？</p>
<p>方法一：连环跳<br>加一个判定变量<code>exit=0;</code><br>if内写 <code>exit=1;</code><br>在两个for后面都写上<code>if(exit)break;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接力break</span></span><br><span class="line"><span class="type">int</span> x,one,two,five,x;</span><br><span class="line"><span class="type">int</span> <span class="built_in">exit</span>=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(one=<span class="number">1</span>;one&lt;x*<span class="number">10</span>;one++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(two=<span class="number">1</span>;two&lt;x*<span class="number">10</span>/<span class="number">2</span>;two++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(five=<span class="number">1</span>;five&lt;x*<span class="number">10</span>/<span class="number">5</span>;five++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(one+two*<span class="number">2</span>+five*<span class="number">5</span>==x*<span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角加%d个两角加%d个五角得到%d元\n&quot;</span>,one,two,five,x);</span><br><span class="line">				<span class="built_in">exit</span>=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">exit</span>==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">exit</span>==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：<code>goto out</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goto</span></span><br><span class="line"><span class="type">int</span> x,one,two,five,x;</span><br><span class="line"><span class="type">int</span> <span class="built_in">exit</span>=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(one=<span class="number">1</span>;one&lt;x*<span class="number">10</span>;one++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(two=<span class="number">1</span>;two&lt;x*<span class="number">10</span>/<span class="number">2</span>;two++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(five=<span class="number">1</span>;five&lt;x*<span class="number">10</span>/<span class="number">5</span>;five++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(one+two*<span class="number">2</span>+five*<span class="number">5</span>==x*<span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角加%d个两角加%d个五角得到%d元\n&quot;</span>,one,two,five,x);</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>（除了这种多重break的结构建议使用goto，别的地方不建议。）</p>
<h1 id="补充：PTA-例题"><a href="#补充：PTA-例题" class="headerlink" title="补充：PTA 例题"></a>补充：PTA 例题</h1><h2 id="前n项和"><a href="#前n项和" class="headerlink" title="前n项和"></a>前n项和</h2><p>求1+1&#x2F;2+1&#x2F;3+……+1&#x2F;n.<br>在这个循环里，起点数字1，终点数字n都是明确的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=<span class="number">1.0</span>/i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f&quot;</span>,n,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>例2：1-1&#x2F;2+1&#x2F;3-1&#x2F;4+……<br>解决方案：定义一个<code>sign=1;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum+=sign*<span class="number">1.0</span>/i;</span><br><span class="line">sign=-sign;</span><br></pre></td></tr></table></figure>


<p>技巧：如果我们<code>double sign=1.0</code>，算式中就出现小数了，就不用*1.0了。</p>
<h2 id="整数分解"><a href="#整数分解" class="headerlink" title="整数分解"></a>整数分解</h2><p>比如输入：12345<br>输出：1 2 3 4 5<br>考虑之前逆序输出的方法，我们可以先把这个数逆过来之后再逆序输出（鬼才）<br>即：</p>
<ol>
<li>先求x的逆序数t</li>
<li>逆序逐位输出t</li>
</ol>
<p>这种方法的缺陷在于：对于末尾有0出现的数字（如700）只能得到7<br>我们可以回想3位数的题，我们用三位数&#x2F;100得到最高位数字。<br>所以我们知道位数之后，可以正序逐位得到每一位的数字。</p>
<p>可以先一个while循环求出x的位数和mask（位数），（还是记得提前把x保存下来）然后正序输出。<br>123456 &#x2F; 100000 &#x3D; 1<br>123456%100000 &#x3D; 23456<br>23456 &#x2F; 10000 &#x3D; 2<br>……</p>
<h2 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h2><p>算法1：枚举。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">循环t++</span><br><span class="line"><span class="keyword">if</span>(u/t==<span class="number">0</span>&amp;&amp;v/t==<span class="number">0</span>)gcd=t;<span class="comment">//不断刷新gcd</span></span><br><span class="line"><span class="keyword">if</span>(t==u||t==v)<span class="keyword">break</span>;<span class="comment">//并输出gcd;</span></span><br></pre></td></tr></table></figure>
<p>效率更高的算法2：辗转相除</p>
<ol>
<li>如果b&#x3D;0，计算结束，a就是最大公约数；</li>
<li>否则，让a&#x3D;b，b&#x3D;a%b；</li>
<li>回到第一步<br>（可以使用之前提到过的变量表格法来人工运行）</li>
</ol>
<h2 id="求符合给定条件的整数集"><a href="#求符合给定条件的整数集" class="headerlink" title="求符合给定条件的整数集"></a>求符合给定条件的整数集</h2><p> 给定&lt;&#x3D;6的正整数A，从A开始的连续四个数字，请输出所有由它们组成的无重复数字的三位数。<br> 输出满足条件的三位数，从小到大，且每行6个整数，行末无多余空格。<br> 如：输入A&#x3D;2<br> 234 235 243 245 253 254<br> 324 325 342 345 352 354<br> 423 425 432 435 452 453<br> 523 524 532 534 542 543<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,a,j,k,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    i=a;</span><br><span class="line">    <span class="comment">//思路：i,j,k都从a开始，从小到大逐渐增加到a+3，三者不能相等</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i&lt;=a+<span class="number">3</span>)&#123;</span><br><span class="line">        j=a;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=a+<span class="number">3</span>)&#123;</span><br><span class="line">            k=a;</span><br><span class="line">            <span class="keyword">while</span>(k&lt;=a+<span class="number">3</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i!=j&amp;&amp;j!=k&amp;&amp;i!=k)&#123;</span><br><span class="line">                   <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d&quot;</span>,i,j,k);</span><br><span class="line">                   cnt++;</span><br><span class="line">                   <span class="keyword">if</span>(cnt==<span class="number">6</span>)&#123;</span><br><span class="line">                       <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                       cnt=<span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               k++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br> <img src="https://img-blog.csdnimg.cn/20210704210542652.png" alt="在这里插入图片描述"></p>
<h2 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h2><p> 水仙花数指一个N位正整数（N&gt;&#x3D;3)，它的每位上的数字的N次幂之和等于它自己。如：153&#x3D;1^3^+3^3^+5^3^;<br> 给定一个N（3&lt;&#x3D;N&lt;&#x3D;7），按顺序输出所有N位水仙花数。<br> 输入：3<br> 输出：<br> 153<br> 370<br> 371<br>第一个循环：遍历所有N位数。<br>第二个循环来求和，循环里面第三个循环来求每一位的N次幂（N次循环），最后if判断是否&#x3D;&#x3D;sum。</p>
<h2 id="打印乘法口诀表"><a href="#打印乘法口诀表" class="headerlink" title="打印乘法口诀表"></a>打印乘法口诀表</h2><p> <img src="https://img-blog.csdnimg.cn/20201215143203579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>a*b，a、b两重循环。<br>还要注意对齐问题。如果结果是一位数，输出两个空格；两位数输出一个空格。</p>
<h2 id="统计素数并求和"><a href="#统计素数并求和" class="headerlink" title="统计素数并求和"></a>统计素数并求和</h2><p> 给定M和N区间内的素数的个数并对它们求和。</p>
<p>读题后得知:包含两头[M,N]<br>先定义<code>isprime=1;</code>当可以被比他小的数整除的时候就isprime&#x3D;0。<br>这道题很好做。注意特殊情况，如m&#x3D;1时，循环直接不判断，<code>isprime=1</code><br>可以在m~n循环开始前判断，<code>if(m==1)m++;</code></p>
<h2 id="猜数游戏-1"><a href="#猜数游戏-1" class="headerlink" title="猜数游戏"></a>猜数游戏</h2><p>输入要猜的数字和猜的最大次数，大了输出too big,小了输出too small，直到猜对或者次数用光或者用户输入负数为止<br>还有就是注意不同次数猜到的输出结果也有区别。<br>一次猜到：BINGO！<br>两次猜到：LUCKY YOU！<br>三次以上猜到：GOOD GUESS!<br>&#x2F;&#x2F;也不难，1.考的是语文的阅读理解；2.你是否有足够的耐心。（文中条件太多）</p>
<h2 id="n项求和"><a href="#n项求和" class="headerlink" title="n项求和"></a>n项求和</h2><p>2&#x2F;1+3&#x2F;2+5&#x2F;3+8&#x2F;5+……的前n项之和（从第二项开始，每一项的分子是前一项的分子和分母之和，分母是前一项的分子）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dividend=<span class="number">2</span>;<span class="comment">//分母</span></span><br><span class="line">divisor=<span class="number">1</span>;<span class="comment">//分子</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">	sum+=dividend/divisor;</span><br><span class="line">	t=dividend;</span><br><span class="line">	dividend+=divisor;</span><br><span class="line">	divisor=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f/n&quot;</span>,sum);</span><br></pre></td></tr></table></figure>

<p>因为分子分母变大的相当快，所以出于范围考虑，也建议使用double储存dividend（分子）和divisor（分母）<br>(inf是越界，即无穷；nan是无效数字)</p>
<h2 id="约分最简分式"><a href="#约分最简分式" class="headerlink" title="约分最简分式"></a>约分最简分式</h2><p>输入一个分式，如32&#x2F;45，输出最简形式。</p>
<ol>
<li>scanf(“%d&#x2F;%d”)这样处理输入</li>
<li>辗转相除法寻找最大公约数；<br>念数字：比如输入-12：fu yi er<br>先判断-的情况之后switch case很好办。以后学会数组之后会有更优解。</li>
</ol>
<h2 id="求a的连续和"><a href="#求a的连续和" class="headerlink" title="求a的连续和"></a>求a的连续和</h2><p>输入a,n，计算a+aa+aaa+……+n个a的和<br>循环的每一轮a1&#x3D;a1*10+a。</p>
<h1 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h1><p>C语言是有类型的语言。C语言的变量，必须：<br>1.在使用前定义;<br>2.确定类型.<br>如果我们一开始直接说a&#x3D;6:使用了未定义的标识符a。</p>
<p>C语言之后语言朝着两个方向发展：</p>
<ol>
<li>C++和Java更强调类型，对类型的检查更加严格</li>
<li>JavaScript、Python、PHP不着重类型，甚至不需要事先定义。<br>支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误；<br>反对强类型的观点认为过于强调类型，迫使程序员面对底层，实现而非事务逻辑</li>
</ol>
<p>总的来说，早期语言、面向底层的语言强调类型。<br>C语言需要类型，但是对类型的安全检查并不足够：<br>（以下斜体的是c99类型）<br>整数：char、short、int、long、<em>long long</em>；<br>浮点数：float,double,<em>long double</em>；<br>逻辑：<em>bool</em>；<br>指针；<br>以及自定义类型。<br>类型的不同之处在于：</p>
<ol>
<li>类型名称：int,long,double……</li>
<li>输入输出时的格式化（占位符）：%d,%ld,%lf……</li>
<li>所表达的数的范围：char&lt;short&lt;int&lt;float&lt;double</li>
<li>内存中占据的大小：1~16个字节</li>
</ol>
<p>内存中的表达形式：二进制数（补码）、编码（浮点是编码形式）<br>编码形式不能直接进行运算，而两个整数可以。<br>Sizeof()是一个运算符，给出某个类型或变量在内存中所占据的字节数。如：<br><code>sizeof(int)</code><br><code>sizeof(i)</code><br>(1个字节是8个比特，所以<code>int</code>4个字节32个比特)<br>sizeof是一个静态运算符，在编译时其结果就已经决定了<br>比如上一行写sizeof(a++),但输出a之后会发现a其实没有++。</p>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="type">char</span>)=<span class="number">1</span>;<span class="comment">//char1字节（8比特）</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">short</span>)=<span class="number">2</span>;<span class="comment">//short2字节</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">int</span>)=<span class="number">4</span>;<span class="comment">//由编译器决定，通常代表“1个字”</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">long</span>)=<span class="number">4</span>;<span class="comment">//由编译器决定，通常代表“1个字”</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)=<span class="number">8</span>;<span class="comment">//long long 8字节</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201217163149797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>说一台计算机的字长的时候，我们指的是寄存器RAM是多少字长（比特）的。<br>每一次从CPU中取数据取32个比特<br>所以说int就是用来表达寄存器的，不同计算机可能得到不一样的<code>sizeof(int)</code>。</p>
<h2 id="整数的内部表达"><a href="#整数的内部表达" class="headerlink" title="整数的内部表达"></a>整数的内部表达</h2><p>计算机内部，一切都是二进制的，<strong>只是说我们以不同的方式去看待它</strong>。<br>十进制：18→二进制：00100010<br>十进制用负号来表示负数，运算一般在结果上再加负号。<br>而二进制怎么表示负数呢？<br>一个字节（8位）可以表达的数：00000000 ~ 11111111（0~255）</p>
<p>三种方案：</p>
<ol>
<li><p>像十进制一样，有一种特殊的标志（类似符号）来表示负数（缺陷：计算机做加减法的时候，要像判断十进制的负号一样，我们需要一个东西去控制加号还是减号。不过每次计算机都要特别地去判断这个符号的正负，这样就会比较复杂。）</p>
</li>
<li><p>从0000 0000到1111 11111，取中间的数为0，如1000 0000表示0，比他小的是负数，比他大的是正数，各一半（缺陷：所有数都要和这个数做减法来计算其值，会比较复杂）</p>
</li>
<li><p><strong>补码</strong><br>思路：本质上来看，（互为相反数的）负数+正数&#x3D;0。这是提供思路的一种方法。<br>比如我们希望-1+1→0，如何能够做到？<br>如0→0000 0000，1→0000 0001，我们让一个数+1得到0。这个数字选谁？<br>全1的数字1111 1111。因为0000 0001+1111 1111→1 0000 0000多出来的一位（溢出）那一位被丢掉了，相加结果即是00000000。妙啊<br>或者换个角度：-1&#x3D;0-1&#x3D;(1)0000 0000-0000 0001→1111 1111<br>（1111 1111被当作纯二进制看待时是255，被当做补码看待时是-1）<br>所以对于-a来说，他的补码就是0-a，实际就是2^n^-a，n是该种类型的位数<br>补码的意义就是拿补码和原码可以加出一个溢出的0。<br>另一个好处是这样我们做计算的时候，不需要调整加减，全部都是加法（+补码就是-原码）。</p>
</li>
</ol>
<h2 id="整数的范围：如何推算整数类型所能表达的数的范围，越界了会怎样？"><a href="#整数的范围：如何推算整数类型所能表达的数的范围，越界了会怎样？" class="headerlink" title="整数的范围：如何推算整数类型所能表达的数的范围，越界了会怎样？"></a>整数的范围：如何推算整数类型所能表达的数的范围，越界了会怎样？</h2><p>一个字节（8位）：0000 0000<del>1111 1111<br>其中0000 0000→0<br>0000 0001 ~ 0111 1111→1</del>127（纯二进制数）<br>1000 0000 ~ 1111 1111→-128 ~ -1（用补码表示的数）<br>还是那句话，关键在于我们以什么样的方式去看待这个数。当成纯二进制数，1111 1111就是255；当成整数，就是-1 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="number">255</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">255</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d%d&quot;</span>,c,i);</span><br></pre></td></tr></table></figure>
<p>输出结果：c&#x3D;-1,i&#x3D;255。<br>因为对于字符c来说，255→1111 1111<br>而对于整形变量i来说，266→0000 0000  0000 0000  0000 0000  1111 1111</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1字节</td>
<td>-128~127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-2^15^~2^15^-1</td>
</tr>
<tr>
<td>int</td>
<td>取决于编译器</td>
<td>-2^31^~2^31^-1</td>
</tr>
<tr>
<td>long</td>
<td>4字节</td>
<td>-2^31^~2^31^-1</td>
</tr>
<tr>
<td>long long</td>
<td>8字节</td>
<td>-2^63^~2^63^-1</td>
</tr>
</tbody></table>
<p>比如char长度256，会被分成三部分：<code>-128~-1,0,1~127</code><br>所有整数类型范围都是-2^(n-1)^~2^(n-1)^-1<br>如果我们希望一个数据从计算机中拿出来时我们将其视为纯二进制看待，我们要在其前面加上一个关键字unsigned.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c=<span class="number">255</span>;</span><br></pre></td></tr></table></figure>
<p>unsigned使得这个类型在正整数表达部分范围扩大一倍，但是不能表达负数了。<br>如果一个字面量常数想要表达自己是unsigned，可以在后面加u&#x2F;U：<code>255U</code><br>Similarly,想表达自己是个long,后面加<code>l</code><br>unsigned的初衷不是为了扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位。<br>整数是以纯二进制方式进行运算的。<br> <img src="https://img-blog.csdnimg.cn/20201218001911386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>补码就是顺时针-，逆时针+</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="number">127</span>;</span><br><span class="line">c++;</span><br></pre></td></tr></table></figure>
<p>然后c变成了-128。<br>Similarly，-128-1变成了127。<br>unsigned（无符号）则是直接加减。<br>但是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c=<span class="number">255</span>;</span><br><span class="line">c++;</span><br></pre></td></tr></table></figure>
<p>并不像预想中的得到256，我们得到c&#x3D;0，因为256在8比特里是全0，第九位是1被丢掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=<span class="number">0</span>;</span><br><span class="line">c--;</span><br></pre></td></tr></table></figure>
<p>得到255。<br>所以对于unsigned，也是顺时针-，逆时针+<br> <img src="https://img-blog.csdnimg.cn/20201218001926886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(++a&gt;<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int数据类型的最大数是：%d\n&quot;</span>,a<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">while</span>((a/=<span class="number">10</span>)!=<span class="number">0</span>)b++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;int数据类型最大的数的数位是:%d&quot;</span>,b);</span><br></pre></td></tr></table></figure>


<p>可以用这种方法推算int 的最大范围。<code>while(++a&gt;0)</code>使得a加到127→-128越界后变成负数，然后<code>printf(&quot;%d&quot;,a-1);</code>再返回到127，得到int可以表达的最大数<br>同理，如果想得到unsigned的最大范围，参考上面的表，<code>while(a!=0);</code></p>
<h2 id="整数的格式化：如何格式化地输入输出整数，如何处理8进制-16进制"><a href="#整数的格式化：如何格式化地输入输出整数，如何处理8进制-16进制" class="headerlink" title="整数的格式化：如何格式化地输入输出整数，如何处理8进制&#x2F;16进制"></a>整数的格式化：如何格式化地输入输出整数，如何处理8进制&#x2F;16进制</h2><p>整数的输入输出只有两种形式：int和long long<br>%d：int<br>%u: unsigned<br>%ld: long long<br>%lu: unsigned long long<br>若int i&#x3D;-1;储存在计算机中是二进制形式，即全1，若以%u即unsigned形式输出，得到的结果就是int 型的最大值（4294967295）<br>如此仍然可见，重点在于我们以什么样的正确的方式去看待这个结果。<br>8进制（octal）：一个以0开始的数字字面量<br>16进制（Hexadecimal）：一个以0x开始的数字字面量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="number">012</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0x12</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d,i=%d\n&quot;</span>,c,i);</span><br></pre></td></tr></table></figure>
<p>得到结果（%d转化为十进制）：c&#x3D;10,i&#x3D;18<br>（计算机内部同样还是二进制的形式）<br>想要输出8进制：<code>%o</code>或<code>%O</code><br>想输出16进制:<code>%x</code>或<code>%X</code>,小写的x输出小写的字母，大写的输出大写的<br>(但是这样输出的结果前面是没有0和0x的。所以可以写<code>printf(“c=0%o,i=0x%x\n”,c,i);</code><br>8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关。<br><code>scanf</code>中也可以用%o，表示读进来的数我们把其当做8进制来读。<br>16进制很适合表达二进制数据，因为4位二进制正好是一个16进制位（0001 0010→1 2）<br>八进制的一个数字正好表达3位二进制，因为早期计算机的字长是12的倍数，并非8。</p>
<h2 id="整数类型的选择"><a href="#整数类型的选择" class="headerlink" title="整数类型的选择"></a>整数类型的选择</h2><p><code>char,short,int,long,long long</code><br>每种类型有不同大小，不同范围，内部是什么样，表达出来是什么样，……<br>C语言这些又多又复杂的原因：1.C语言的严谨性，为了准确表达内存，做底层程序的需要<br>2.C语言要和硬件打交道，要准确表达计算机里的东西（内存、寄存器、接口……）<br>建议：没有特殊需要，就选择int<br>原因 ：</p>
<ol>
<li>现在CPU字长（CPU和内存之间的通道。如果char可能会从32位中先挑出来8个，可能会花费时间）普遍是32位&#x2F;64位，一次内存读写、一次计算都是int，选择更短的类型不会更快，甚至可能会更慢</li>
<li>现代编译器一般会设计内存对齐，（比如这个东西虽然占据8bit，在内存中仍然占据了一个int。这个事等到结构再讲）所以更短的类型实际在内存中也可能占据一个int的大小。除非在做顶层的硬件，告诉你硬件多大你就要用多大去运算<br>至于Unsigned与否，只是输出的形式不同，内部的计算还是一样的</li>
</ol>
<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p><code>float，double</code><br>32位，64位<br>10^38^,10^308^<br>7位有效数字，15<br>但是float靠近0的部分（0~10^38^）有很小一部分不能表达（这应该是之前的题目为什么if判断浮点数不写做差&#x3D;&#x3D;0，而是写做差&lt;1e-6）<br>float还能表达0，+-inf（无穷），nan（非有效数字）<br>%e&#x2F;%E:科学计数法<br>1234.56789输出得到：1.234567e+03<br>-5.67E+16，科学计数法可选的有：+-号，e或E，小数点，E后面的符号+-<br>Double ff&#x3D;1E-10；<br>输出精度：<code>%.数字f</code>可以指定输出小数点后几位，这样输出的结果是做四舍五入的<br>%.3f,-0.0045→-0.004<br>%.30f→后面输出30位，-0.0049→-0.00489999……（计算机最终只能用离散的数字来表示数字，这就是浮点数的误差。Double更准确，但可能依然不精确）<br>%.3f，-0.00049→-0.000</p>
<h2 id="浮点数的范围和精度"><a href="#浮点数的范围和精度" class="headerlink" title="浮点数的范围和精度"></a>浮点数的范围和精度</h2><p>Inf无穷，nan输出不存在的浮点数<br>正数除0.0→inf<br>负数除0.0→-inf<br>0.0&#x2F;0.0→nan<br>(如果是整数，12&#x2F;0编译不过)<br>浮点数范围不包括无穷大，但它可以表示。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a,b,c;</span><br><span class="line">a=<span class="number">1.345f</span>;</span><br><span class="line">b=<span class="number">1.123f</span>;</span><br><span class="line">c=a+b;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">2.468</span>)<span class="built_in">printf</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;不相等，c=%.10f，或%f&quot;</span>,c,c);</span><br></pre></td></tr></table></figure><br>加f:表明身份，让它是float<br>结果：不相等！c&#x3D;2.4679999352，或2.468000<br>f1&#x3D;&#x3D;f2不一定成功，应该写<code>fabs(f1-f2)&lt;1e-12</code><br>所以浮点数不能做精确计算，最后误差会累积起来的。只能在一定范围内相信小数点</p>
<p><a target="_blank" rel="noopener" href="https://www.guokr.com/article/27173/">Android计算器低级错误？都是二进制惹的祸！</a><br>而传统计算器直接用整数做运算<br>而浮点数内部是编码形式<br> <img src="https://img-blog.csdnimg.cn/20201218003830483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>从左到右分别表示正数负数、指数、小数<br>如果没有特殊需要，就用double<br>现代cpu能直接对double做硬件计算，性能不会比float差，而且在64位的机器上数据存储的速度也不会比float慢 </p>
<h2 id="字符类型：char是整数也是字符"><a href="#字符类型：char是整数也是字符" class="headerlink" title="字符类型：char是整数也是字符"></a>字符类型：char是整数也是字符</h2><p>char是整数，也是字符。（character）<br>原因1：我们可以用单引号表示字符的字面量<code>&#39;a&#39;</code>,<code>&#39;1&#39;</code><br><code>&#39;&#39;</code>也是字符<br>我们可以在printf和scanf里用%c来输入和输出字符。<br>计算机内部每一个值都有一个字符去表达它（ASCII）如1对应的码是49<br>输入1给计算机的方法：<code>scanf(&quot;%c&quot;,&amp;c);</code>输入1<br>或者<code>scanf(&quot;%d&quot;,&amp;c);</code>输入49<br>输出同样，因为<code>49==&#39;1&#39;</code><br>注意空格的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c&quot;</span>,&amp;i,&amp;c);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %c&quot;</span>,&amp;i,&amp;c); </span><br></pre></td></tr></table></figure>
<p>这样中间几个空格回车都没关系，中间的空格会全部被读掉<br>从A到Z的ASCII码都是连着的<br>一个字符加一个数字可以转到后面那个对应ASCII码的字符处<br><code>int i=&#39;Z&#39;-&#39;A&#39;;</code>&#x2F;&#x2F;两个字符相减，得到它们在表中的距离<br>字母在ASCII表中顺序排列，且大小写字母分开排列<br><code>&#39;a&#39;-&#39;A&#39;</code>可以得到小写字母与大写字母之间的距离，所以<code>&#39;a&#39;+(&#39;A&#39;-&#39;a&#39;)</code>可以转小写为大写<br><img src="https://img-blog.csdnimg.cn/20210705220127970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h2><p>用来表达无法印出来的控制字符或特殊字符，由一个反斜杠\开头，后面跟着一个字符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，&quot;</span><span class="string">&quot;如输入\&quot;5 7\&quot;表示5英尺7英寸：&quot;</span>);</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>回退一格</td>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\t</td>
<td>到下一个表格位</td>
<td>&#39;</td>
<td>单引号</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\</td>
<td>反斜杠本身</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>（作业时就会有最后结尾多个空格，使用&#x2F;b来删掉的情况，但其实应该说是覆盖了吧，总之这样运行的时候是不正确的，还是要想办法控制输出的空格等的格式正确）<br>例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;123\b\n456\n&quot;</span>); </span><br></pre></td></tr></table></figure>
<p> 得到结果：<br> <img src="https://img-blog.csdnimg.cn/20201218181947242.png" alt="在这里插入图片描述"></p>
<p>但是到了其他程序那边运行<br>123<br>456<br>原因：dev c++那个黑框框，是别人写的程序(shell)来帮助我们运行的；部分东西是经过它处理的，比如\b\n，不同shell对此处理不一样。如dev c++用<strong>BS</strong>字符来表示。<br>\b\n都是控制字符<br>BS是回到上一格，没输出东西就什么结果都没有，输出了就把他盖住了<br>也不能否认有的程序，输出的时候把\b翻译成删除<br>\t:到下一个表格位（在每一行中有一些固定的位置，\t代表输出的固定的位置）<br>比如</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;123\t456\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;12\t456\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p> <img src="https://img-blog.csdnimg.cn/20201218182117390.png" alt="在这里插入图片描述"></p>
<p>\n换行\r回车，源自打字机的动作<br>一直敲键盘，打字机的轴就往左移<br>敲一下回车就回到右边，这叫回车<br>然后往上调一下纸，这叫换行。<br>不过dev c++把回车就当做回车+换行了。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动类型转换：当运算符两边出现不一样的类型时，会自动转成较大的类型，即能表达的数范围更大的类型。<br><code>char-&gt;short-&gt;int-&gt;long-&gt;long long</code><br><code>int-&gt;float-&gt;double</code><br>对于printf，任何小于int的类型都会被转换成int；float会被转换成double。所以printf输出double的时候写%f就也行。<br>但scanf不会，想输入short时，需要%hd。<br>强制类型转换：(类型)值<br> 如：<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)<span class="number">10.2</span>;</span><br><span class="line">(<span class="type">short</span>)<span class="number">32</span>;</span><br></pre></td></tr></table></figure><br>但是注意安全性，小的变量不总能表达大的量。如<code>(short)32768</code>，因为short最大范围是32767，所以会被转化为-32768<br><strong>只是从那个变量计算出了一个新类型的值，他并不改变那个变量的值或类型。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">32768</span>;</span><br><span class="line"><span class="type">short</span> s=(<span class="type">short</span>)i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br></pre></td></tr></table></figure>
<p>i输出仍然是32768。强制类型转换不会改变这个变量自身的类型或值。</p>
<p>如果想计算a，b的int型相除得到的i的int型的值：<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a=<span class="number">1.0</span>;</span><br><span class="line"><span class="type">double</span> b=<span class="number">2.0</span>;</span><br><span class="line"><span class="type">int</span> i=(<span class="type">int</span>)a/b;</span><br></pre></td></tr></table></figure><br>实际上是先int a，再&#x2F;浮点数b,<strong>强制类型转换的优先级高于四则运算。</strong><br>所以正确的写法是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=(<span class="type">int</span>)(a/b);</span><br><span class="line">(<span class="type">double</span>)(a/b);</span><br></pre></td></tr></table></figure>

<h2 id="逻辑类型：表示关系运算和逻辑运算结果的量"><a href="#逻辑类型：表示关系运算和逻辑运算结果的量" class="headerlink" title="逻辑类型：表示关系运算和逻辑运算结果的量"></a>逻辑类型：表示关系运算和逻辑运算结果的量</h2><p>bool类型<br>首先要包含头文件#include&lt;stdbool.h&gt;，然后可以使用bool，true,false。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b=<span class="number">6</span>&gt;<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>只要bool量不是0，都&#x3D;1.</p>
<h2 id="逻辑运算：对逻辑量进行与、或、非运算"><a href="#逻辑运算：对逻辑量进行与、或、非运算" class="headerlink" title="逻辑运算：对逻辑量进行与、或、非运算"></a>逻辑运算：对逻辑量进行与、或、非运算</h2><p> 逻辑运算是对逻辑量进行的运算，结果只有0或1。<br> 逻辑量是关系运算或逻辑运算的结果。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>逻辑非</td>
<td>!a</td>
<td>a的true或false反转</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>a&amp;&amp;b</td>
<td>只有a&amp;b都是true时结果才是true</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>a||b</td>
<td>只有a&amp;b都是false时结果才是false</td>
</tr>
</tbody></table>
<p>例：表达数学区间时，(4,6)或[4,6]：<br>同样像之前if一样，不可以写4&lt;x&lt;6这种式子。因为4&lt;x的结果是一个逻辑值（0或1）<br><code>x&gt;4&amp;&amp;x&lt;6</code>或<code>x&gt;=4&amp;&amp;x&lt;=6</code><br>判断一个字符是大写字母：<code>c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;</code><br>优先级：!&gt;&amp;&amp;&gt;||<br>例：<code>!done&amp;&amp;(count&gt;MAX)</code>：done是0且<code>count&gt;MAX</code>时结果为1</p>
<p>所有的优先级</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>()</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>!，+，-，++，–</td>
<td>从右到左（单目的+和-）</td>
</tr>
<tr>
<td>3</td>
<td>*，&#x2F;，%</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td>+，-</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td>&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D;</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td>&#x3D;&#x3D;，!&#x3D;</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td>||</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td>&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</td>
<td>从右到左</td>
</tr>
</tbody></table>
<p><strong>短路：逻辑运算自左向右，如果左边足以决定结果，就不会进行右边的计算了</strong><br><code>a==6&amp;&amp;b==1</code>如果左边<code>a!=6</code>就终止了。<br>即：&amp;&amp;左边false就不做右边了；||左边是true就不做右边了。就算右边是赋值的话右边也不会做了。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;a++&gt;<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">&#125;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br></pre></td></tr></table></figure><br>这样输出结果a&#x3D;-1，没有进行右边的a++。<br><strong>所以不要把赋值和复合赋值组合进表达式！</strong></p>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符1：问号<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnt=(cnt&gt;<span class="number">20</span>)?cnt<span class="number">-10</span>:cnt+<span class="number">10</span>;</span><br><span class="line"><span class="comment">//格式：条件?条件满足时的值:条件不满足时的值</span></span><br></pre></td></tr></table></figure><br>相当于 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">20</span>)cnt-=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span> cnt+=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这种条件运算符<code>?</code>的优先级高于赋值运算符，但是低于其他运算符，但是这样会很麻烦。<br>条件运算符自右向左，先计算右边的分支<br>不建议使用嵌套的条件表达式！太复杂，太难理解</p>
<p>条件运算符2：逗号<br>逗号是个运算符，连接两个表达式，并且以右边的表达式的值作为其结果。<br>逗号的优先级是最低的，所以两边的表达式会先运算，而右边的表达式的值留下来作为运算的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">3</span>+<span class="number">4</span>,<span class="number">5</span>+<span class="number">6</span>;<span class="comment">//编译时会提示warning。因为赋值的优先级也要高于逗号，该式子其实是</span></span><br><span class="line">(i=<span class="number">3</span>+<span class="number">4</span>),(<span class="number">5</span>+<span class="number">6</span>);<span class="comment">//右边编译错误,i=7</span></span><br><span class="line">如果写作i=(<span class="number">3</span>+<span class="number">4</span>,<span class="number">5</span>+<span class="number">6</span>);<span class="comment">//编译时同样会warning，因为3+4没有用到;i=11</span></span><br></pre></td></tr></table></figure>
<p>逗号表达式主要在for中使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">10</span>;i&lt;j; i++,j--)</span><br></pre></td></tr></table></figure>
<p>目前来说，逗号表达式只有这一个用处。</p>
<h1 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h1><h2 id="初见函数"><a href="#初见函数" class="headerlink" title="初见函数"></a>初见函数</h2><p>回想起区间[m,n]内素数求和的例子，对于每个数我们定义<code>isPrime=1</code>，如果最后仍然&#x3D;1的话<code>sum+=i</code>.<br>这样让这一层循环显得很大，而这一层代码的功能很单纯<br>我们可以以函数的形式把这一堆代码取出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">2</span>;k&lt;i<span class="number">-1</span>;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">			ret=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//有1~i-1间的因数就可以判断i不是素数了，break节约时间</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前从第一个程序<code>printf</code>开始就是在用函数。只不过这次我们在自己定义了一个函数。<br>这样<code>main</code>里面很简洁，而且<code>isPrime</code>可以很方便地多次使用<br>PS: 程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。<br>（吓得我立刻就去改大作业了）我们用函数替换，可以把重复的代码提出。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//闭区间内所有数求和的函数</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(i=begin;i&lt;=end;i++)&#123;</span><br><span class="line"> 		sum+=i;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d到%d的和是%d\n&quot;</span>,begin,end,sum);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	sum(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><p>函数是一块代码，接收0个&#x2F;多个参数做一件事情，并返回0个&#x2F;1个值。<br>可以先想象成数学中的函数y&#x3D;f(x)。<br>调用函数时要写出 函数名(参数值);<br>（）起到了表示函数调用的重要作用，即使没有参数我们也需要（）。<br>不给括号的话，会给warning，而且函数不会被调用。<br>如果有参数，参数的数量、顺序都必须正确。而且函数知道每一次是哪里调用它，还会返回到正确的地方。</p>
<h2 id="从函数中返回"><a href="#从函数中返回" class="headerlink" title="从函数中返回"></a>从函数中返回</h2><p><code>int</code>函数会有返回值<code>return</code><br><code>return</code>停止函数的执行，并返回一个值<br><code>return;</code><br><code>return 一个值;</code><br>可以写<code> c=函数()</code>；这样c&#x3D;函数的返回值。<br>可以把这个值赋给变量&#x2F;传给函数&#x2F;丢掉。<br>没有返回值的函数:<code>void</code>，不能使用带值的<code>return</code> ，可以没有<code>return </code>。调用的时候也不可以做返回值的赋值。</p>
<h2 id="函数原型：用来告诉编译器这个函数长什么样"><a href="#函数原型：用来告诉编译器这个函数长什么样" class="headerlink" title="函数原型：用来告诉编译器这个函数长什么样"></a>函数原型：用来告诉编译器这个函数长什么样</h2><p>使用函数的先后顺序：先写函数再调用。<img src="https://img-blog.csdnimg.cn/20201219230956156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以先想象成数学函数<code>y=f(x)</code><br>C的编译器自上而下分析你的代码，它会记住函数<code>sum()</code>长什么样子要几个参数，每个参数的类型如何，返回什么类型<br>如果把函数放在后面，C语言可能会猜，你在<code>main</code>函数里使用的这个函数是什么类型。如果后面发现后面的函数类型和它猜测的不符，就输出<code>error</code> 。<br>因此也可以先不用写完函数，光把一句函数头放到前面编译也能通过。<br>（事先声明了函数的样子）<br>下面函数还会判断一下和你之前的声明是否一致</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>;<span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//略去不表，其中用到了sum(a,b)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span><span class="comment">//定义</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">for</span>(i=begin;i&lt;=end;i++)&#123;</span><br><span class="line"> 		sum+=i;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d到%d的和是%d\n&quot;</span>,begin,end,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数头以分号结尾，就构成了函数的原型；<br>在函数里定义的参数类型与输入的变量的类型不一样，会发生自动类型转换。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>;</span><br></pre></td></tr></table></figure><br>在以前是把函数原型写在调用它的函数(main())里面的。<br>函数的原型里可以不写参数名，但一般仍然写上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Void sum(int ,int)</span><br></pre></td></tr></table></figure>
<p>不过对于人类读者，一般来说写上会更好理解。</p>
<h2 id="参数传递：调用哪个函数的时候，是用表达式的值来初始化函数的参数"><a href="#参数传递：调用哪个函数的时候，是用表达式的值来初始化函数的参数" class="headerlink" title="参数传递：调用哪个函数的时候，是用表达式的值来初始化函数的参数"></a>参数传递：调用哪个函数的时候，是用表达式的值来初始化函数的参数</h2><p>传递给函数的值可以是表达式的结果<code>(max(a+b,c))</code><br>包括字面量、变量、函数返回值（函数调用里有函数）、计算结果<br>当调用函数的值与参数类型不匹配：编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的。这是C语言传统上最大的漏洞。<br>后续语言如c++&#x2F;java在这方面会很严格。<br> 这样的函数代码能交换a,b的值吗？</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//形参</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">	b=<span class="number">6</span>;</span><br><span class="line">	swap(a,b);<span class="comment">//实参</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//形参</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="type">int</span> t=a;</span><br><span class="line"> 	a=b;</span><br><span class="line"> 	b=t;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>不能。<br>C语言在调用函数时，永远只能传值给函数。<br>每个函数有它自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。<br>后面递归还会再提。<br>过去对于函数参数表中的参数叫做形式参数。调用函数时给的数值叫做实际参数。<br>（见上图）<br>由于易误会，我们不再这么称呼。我们把参数表中叫做参数，调用函数的叫做值。</p>
<h2 id="本地变量：定义在函数内部的变量是本地变量，参数也是本地变量"><a href="#本地变量：定义在函数内部的变量是本地变量，参数也是本地变量" class="headerlink" title="本地变量：定义在函数内部的变量是本地变量，参数也是本地变量"></a>本地变量：定义在函数内部的变量是本地变量，参数也是本地变量</h2><p>函数每次运行都会产生一个独立的变量空间，其中的变量是函数这一次运行所独有的。（本地变量）<br>所有我们定义在函数内部的变量就是本地变量。（我们现在学过的都是定义在函数内部的）我们写在函数参数表里的参数也是本地变量。</p>
<h3 id="变量的生存期和作用域"><a href="#变量的生存期和作用域" class="headerlink" title="变量的生存期和作用域"></a>变量的生存期和作用域</h3><p>生存期：这个变量出现和消亡的时间<br>作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用）<br>对于本地变量，这两个答案都是：大括号内（块）</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//形参</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">	b=<span class="number">6</span>;</span><br><span class="line">	swap(a,b);<span class="comment">//实参</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//形参</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="type">int</span> t=x;</span><br><span class="line"> 	x=y;</span><br><span class="line"> 	y=t;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>比如仍然是上例，进入swap函数之后（离开了自己的变量空间）a,b就没了。还在生存，但是不在当前的作用域了（显示：Not found in current context)<br>而回到原函数中之后，x,y,t就不存在了<br>所以在swap函数里交换a,b不会影响到原函数<br>本地变量的规则<br>1.	本地变量定义在块内。可以是函数的块内，语句的块内，如：<br>if (a&lt;b)int i&#x3D;10;<br>离开if语句之后未定义使用i编译错误。（没声明）<br>程序运行进入这个块前，其中的变量不存在。离开后就消失了。<br> 如果在块里定义了块外已经定义过的变量，就把块外的变量掩盖了；出来之后又回到块外的值。（C语言）<br>但是不能在块里面定义同名变量（多次定义）<br>本地变量不会被默认初始化，不会得到一个初始值。而参数进入函数的时候被初始化了。</p>
<h2 id="函数庶事：一些细节，main-的解释"><a href="#函数庶事：一些细节，main-的解释" class="headerlink" title="函数庶事：一些细节，main()的解释"></a>函数庶事：一些细节，<code>main()</code>的解释</h2><p>函数没有参数的时候写void f(void)。而写void f()在传统C语言中表示f的函数的参数表未知，并不表示没有参数。（编译器可能会猜测什么类型）<br>所以不要写空的括号<br>调用函数时的逗号和逗号运算符怎么区分？再加一层括号就是逗号运算符f((a,b))<br>C语言不允许函数嵌套定义。<br>（也最好不要写return (i);虽然意思上没变，但是会让人误会return 是个函数）<br><code>int main(void)</code>也是个函数，所以<code>return 0;</code>也是有意义的。</p>
<h1 id="8-数组"><a href="#8-数组" class="headerlink" title="8. 数组"></a>8. 数组</h1><h2 id="初试数组"><a href="#初试数组" class="headerlink" title="初试数组"></a>初试数组</h2><p>之前提到过如何计算用户输入的数字的平均数？<br>之前的做法：每读到一个数（!&#x3D;-1）加到sum里，cnt++,最后sum&#x2F;cnt<br>这样我们不需要记录每一个数<br>如果题目还要求：输出所有大于平均数的数？这样就必须记录每一个数了，因为我们是最后才计算平均数的，要最后再用每个数和平均数做判断<br>如何记录很多数？int num1,num2……？不好。这样下去无穷无尽。</p>
<p>使用数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number[<span class="number">100</span>];<span class="comment">//定义数组，表示数组可以放100个int</span></span><br><span class="line"><span class="built_in">scanf</span>(“%d”,&amp;x);</span><br><span class="line"><span class="keyword">while</span>(x!=<span class="number">-1</span>)&#123;</span><br><span class="line">	number[cnt]=x;<span class="comment">//对数组中的元素赋值</span></span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="built_in">scanf</span>(“%d”,&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后再加个cnt长度的循环，判断每一个数与平均数比较大小<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">double</span> average=sum/cnt;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(number[i]&gt;average)&#123;<span class="comment">//使用数组中的元素</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,number[i]);<span class="comment">//遍历数组</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个程序的安全隐患在于没有考虑使用的数组下标是否会超过100.定义的时候注意要求。</p>
<h2 id="数组的使用：如何定义和使用数组，数组的下标和下标的范围"><a href="#数组的使用：如何定义和使用数组，数组的下标和下标的范围" class="headerlink" title="数组的使用：如何定义和使用数组，数组的下标和下标的范围"></a>数组的使用：如何定义和使用数组，数组的下标和下标的范围</h2><p>定义数组：<br>&lt;类型&gt;变量名称[元素数量];&#x2F;&#x2F;方括号表示这是个数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> grades[<span class="number">100</span>];</span><br><span class="line"><span class="type">double</span> weight[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>
<p>元素数量必须是整数。在c99之前，元素数量必须是编译时确定的字面量。(a[n]不行)vscode中好像就不行，提示<code>variable-sized object may not be initialized</code><br>数组是一种容器，特点是：<br>其中所有元素具有相同的数据类型；<br>一旦创建，不能改变大小；<br>其中元素在内存中连续依次排列（从0开始）；<br>如：定义十个单元a[10]→a[0]~a[9]<br> <img src="https://img-blog.csdnimg.cn/20210106133313945.png" alt="在这里插入图片描述"></p>
<p>每个单元就是一个int类型的变量。像普通变量一样可以出现在赋值的左边或右边。<em>左边的叫左值，右边的叫右值。</em><br>数组的每个单元就是数组类型的一个变量。使用数组时[]中的数字&#x2F;变量叫下标或索引，从0开始计数<br>（要习惯数数从0开始到n-1）<br>但编译器和运行环境不会检查数组下标是否越界，无论读、写数组单元。<br>不过数组越界时可能出问题:<code>segmentation fault</code>，运气好的话不会造成严重的后果。<br>所以这是程序员的责任来保证程序只适用有效的下标值（范围：[0,数组大小-1]）</p>
<p>防止读入数字超过100个的方法：<br>方法一：cnt&#x3D;100之后停止读数；<br>方法二：利用c99数组大小可以是动态的的特性，定义<code>number[cnt];//用户先输入cnt</code></p>
<p>可不可以int a[0];?<br>可以，但是没用。</p>
<h2 id="数组的例子：统计个数"><a href="#数组的例子：统计个数" class="headerlink" title="数组的例子：统计个数"></a>数组的例子：统计个数</h2><p>不停输入0~9范围内的整数，读到-1停止，统计每种数字出现的次数。<br>和上一道题不同的是，不用记录每次输入的数字，我们需要记录的是每种数字出现的次数。<br>学到了定义数组为0的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)count[i]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>和打印方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="built_in">printf</span>(“%d\n”,count[i]);</span><br></pre></td></tr></table></figure>
<p>该题中出现多次数字10。根据之前学到的方法，我们可以定义const number&#x3D;10（c99才能用）;每一个10用number代替。</p>
<p>通常用到数组的程序都需要的环节：</p>
<ol>
<li>确定数组大小；</li>
<li>定义数组；</li>
<li>初始化数组；</li>
<li>数组参与运算；</li>
<li>遍历数组输出。</li>
</ol>
<h2 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h2><p>搜索：在一组给定数据中，怎样找出某个数据是否存在？<br>（往函数中传数组：int sum(a[])）<br>数组的集成初始化：<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="comment">/*直接用大括号给出数组所有元素的初始值；</span></span><br><span class="line"><span class="comment">不需要给出数组的大小，编译器替你数了。*/</span></span><br></pre></td></tr></table></figure><br>依次初始化数组的每一个单元<br>如果<code>a[13]=&#123;2&#125;;</code>只有a[0]是2，后面的单元都是0<br>所以如果想定义一个数组全为0：<code>a[13]=&#123;0&#125;;</code><br>C99还可以在大括号里给指定的位置赋值。<br>用[n]在初始化数据中给出定位，没有定位的数据接在前面的位置后面；其他位置的值补0.</p>
<p><code>int a[0]=&#123;[0]=2,[2]=3,6&#125;;</code><br>这个例子里，a[0]&#x3D;2，a[2]&#x3D;3，a[3]&#x3D;6<br>我们也可以不给出数组大小，让编译器计算。比如上例可写为：<br><code>int a[]=&#123;[0]=2,[2]=3,6&#125;;</code><br>这样会根据大括号里最大的数字下标来算数组的大小。即下标最大为3<br>这样特别适合初始数据稀疏的数组。</p>
<h2 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h2><p>sizeof给出整个数组所占据的内容的大小，单位是字节。（n*4，sizeof(a)&#x2F;sizeof(a[0])就能得到数组元素个数）<br>不能直接把一个数组赋给另一个数组<code>b[]=a;</code><br>&#x3D;&#x3D;数组变量本身不能被赋值&#x3D;&#x3D;。如果想把一个数组的值全部交给另一个数组，必须遍历。</p>
<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p>通常使用for循环，从0开始到&lt;n，这样循环体最大的i正好是数组最大的有效下标。<br>常见错误：1.循环结束条件是&lt;&#x3D;数组长度<br>2.离开循环之后继续使用i作为数组元素下标。</p>
<p>数组作为函数参数时，往往需要另一个参数来传递数组大小。<br>原因：1、数组传入函数之后我们不能用sizeof来计算数组的元素个数；<br>2.不能在[]中给出数组的大小。<br>具体原因后面再说。</p>
<h2 id="数组例子：素数"><a href="#数组例子：素数" class="headerlink" title="数组例子：素数"></a>数组例子：素数</h2><p>之前找素数的例子。我们可以定义isPrime()函数来判断一个数是否是素数。<br>isPrime()函数：我们从2到x-1都拿去除x，循环要走很多遍，重复执行的次数很多（程序很差）。<br>优化：当x是!&#x3D;2的偶数，一定不是素数，就直接不用判断。<br>因为剩下需要判断的书都是奇数，肯定%2&#x3D;1，这样我们判断接下来的数时for循环除数就可以从3开始的奇数判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;x;i+=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>再次优化：我们不需要走到x。我们只要走到sqrt(x)就够了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=<span class="built_in">sqrt</span>(x);i+=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>引入：当我们想了解一个函数时，在编译器中输入man 函数名称（man sqrt）就能得到其相关信息。（man:manual手册）<br>Windows用户：打开浏览器搜索。<br>再再次优化：我们不需要拿比x小的数字来测试x是不是素数，我们只需要拿比x小的素数就够了。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> knowsPrimes[],<span class="type">int</span> numberofKnownPrimes)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> number=<span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> prime[number]=&#123;<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">while</span>(count&lt;number)&#123;</span><br><span class="line">		<span class="keyword">if</span>(isPrime(i,prime,count))&#123;</span><br><span class="line">			prime[count++]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;<span class="comment">//prime数组装着所有素数</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,prime[i]);</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> knowsPrimes[],<span class="type">int</span> numberofKnownPrimes)</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line"> 	<span class="type">int</span> i;</span><br><span class="line"> 	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numberofKnownPrimes;i++)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(x%knownPrimes[i]==<span class="number">0</span>)&#123;</span><br><span class="line"> 			ret=<span class="number">0</span>;</span><br><span class="line"> 			<span class="keyword">break</span>;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>一边构造素数表，一边利用表来证明素数。<br>其中<code>prime[cnt++]=i</code>;一举两得，<code>cnt++</code>的同时还把i的值放到了对应的数组位上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(count&lt;number)&#123;</span><br><span class="line">	<span class="keyword">if</span>(isPrime(i,prime,count))&#123;</span><br><span class="line">		prime[count++]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i=%d \tcnt=%d\t&quot;</span>,i,count);</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样加个括号在里面<code>int i</code>之后，我们使用i就不会影响到外面的i的值了（但是我宁愿重新定义个变量j&#x3D;i。因为太绕了）</p>
<p> 同样的方法，我们可以先输出一个表头。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t\t\t&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;number;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://img-blog.csdnimg.cn/202101061824553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>换一个思路，使得最后这张表里留下来的数都是素数。<br>欲构造n以内的素数表：<br>1.	令x&#x3D;2<br>2.	将2x,3x……直到ax&lt;n的数标记为非素数<br>3.	令x为下一个没有被标记为非素数的数，重复2；直到所有的数都已经被尝试完毕。<br>（从2,3,4,5,6,7,8……删掉2的所有倍数，再删掉3的所有倍数，再删掉5的所有倍数……）<br>1.	先开辟数组prime[n]，初始化其所有元素为1，prime[x]&#x3D;1表示x是素数，prime[x]&#x3D;0表示x不是素数<br>2.	令x&#x3D;2<br>3.	如果x是素数，则<code>for(int i=2;x*i&lt;n;i++)</code>令<code>prime[i*x]=0</code><br>4.	x++，重复3直到x&#x3D;&#x3D;n，否则结束。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> maxNumber=<span class="number">25</span>;</span><br><span class="line">	<span class="type">int</span> isPrime[maxNumber];</span><br><span class="line">	<span class="type">int</span> i,x;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxNumber;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		isPrime[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(x=<span class="number">2</span>;x&lt;maxNumber;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(isPrime[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">2</span>;i*x&lt;maxNumber;i++) isPrime[i*x]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此可见，算法的思考方式不见得与人相同。</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><code>int a[3][5];</code>通常理解为a是一个3行5列的矩阵<br> <img src="https://img-blog.csdnimg.cn/20210106182540563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>最好先行号再列号，和线性代数也是相对应的。<br>二维数组的遍历需要两个for循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">5</span>]=&#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>a[i][j]</code>表示一个int<br><code>a[i,j]</code>是逗号运算符（等于逗号右边的值），表示<code>a[j]</code>，不是正确表达二维数组的方式。<br>二维数组的列数必须给出，行数可以交给编译器来数。</p>
<p>给数的时候每行一个{}，用逗号分隔。如果省略表示0。<br>也可以用定位（注意只能是c99）<br>二维数组是逐行填满的，所以也可以不加大括号，当做一维数组去初始化<br>PS: tic-tac-toe 井字棋判断输赢问题：行列对角线分开检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> board[size][size];</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> num0fX;<span class="comment">//X是一方</span></span><br><span class="line"><span class="type">int</span> num0fO;<span class="comment">//O是一方</span></span><br><span class="line"><span class="type">int</span> result=<span class="number">-1</span>;<span class="comment">//-1：平局，1：X方赢，0:O方赢</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读入矩阵</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;board[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查行</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;size&amp;&amp;result==<span class="number">-1</span>;i++)&#123;</span><br><span class="line">	num0fO=num0fX=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(board[i][j]==<span class="number">1</span>)num0fX++;</span><br><span class="line">		<span class="keyword">else</span> num0fO++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(num0fO==size)result=<span class="number">0</span>;<span class="comment">//O方赢</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num0fX==size)result=<span class="number">1</span>;<span class="comment">//X方赢</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，遍历j检查列。<br>其实这样代码是重复的，我们可以想个办法用一个两重循环遍历行与列。<br>对角线就是<code>board[i][i]</code>和<code>board[i][2-i]</code>两种情况。</p>
<h1 id="9-指针"><a href="#9-指针" class="headerlink" title="9. 指针"></a>9. 指针</h1><h2 id="取地址运算：-运算符取得变量的地址"><a href="#取地址运算：-运算符取得变量的地址" class="headerlink" title="取地址运算：&amp;运算符取得变量的地址"></a>取地址运算：&amp;运算符取得变量的地址</h2><p>scanf里一定要加&amp;（运算符）作用：取得变量的地址，其操作数必须是变量<br>C语言的变量是放在内存里的，&amp;是取出该变量的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x&quot;</span>,&amp;i);<span class="comment">//%x是以16进制输出；&amp;i是一个地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,&amp;i);</span><br><span class="line"></span><br><span class="line">p=(<span class="type">int</span>)&amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0x%x&quot;</span>,p);</span><br></pre></td></tr></table></figure>
<p>上面几条得到的是一样的结果。（前提是<code>%lu</code>,<code>sizeof(int)</code>和<code>sizeof(&amp;i)</code>的值相等，在32位编译器中满足，而64位中不满足）<br>%p：会把值作为地址以十六进制输出，前面加0x<br>地址的大小是否与int相同取决于编译器。所以输出地址时应该用<code>%p</code>，而不要把地址转化为int类型后输出。<br>&amp;不能对没有地址的东西取地址（<code>&amp;(a+b)</code>，<code>&amp;(a++)</code>，<code>&amp;(++a)</code>）；&amp;右边必须有一个明确的变量，才能去取这个地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br></pre></td></tr></table></figure>
<p>连续定义的a和b之间的地址差了4。说明他们是相邻相邻地址之间差了4（因为int 占据了四个字节）先定义的变量地址值更高。他们都是本地变量，分配在一个叫做堆栈的地方（stack）自顶向下。<br>数组a[1]的地址比a[0]大4.<br>数组的地址：<code>printf</code>输出<code>%p</code>时，<code>&amp;a</code>，<code>a</code>，<code>&amp;a[0]</code>输出的地址相同。</p>
<h2 id="指针-就是记录地址的变量"><a href="#指针-就是记录地址的变量" class="headerlink" title="指针 就是记录地址的变量"></a>指针 就是记录地址的变量</h2><p>如果我们能够取得一个变量的地址传给一个函数，能否在那个函数里通过这个地址访问这个变量？<br><code>scanf</code>的原型就是个函数，他一定有办法可以接收到该地址。（就是这个&amp;）<br>经过之前的尝试我们知道如果我们把这个地址交给一个整数，不太靠谱。所以我们需要一个新参数可以保存别的变量的地址，如何表达能够保存地址的变量？<br>指针就是保存地址的变量。<br><code>*</code>是一个单目运算符，用来访问指针的值所表示的地址上的变量。*可以做右值也可以做左值。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *p=&amp;i;<span class="comment">//（p指向了i）*p理解为指向p指针地址所存在的值=i的地址。</span></span><br><span class="line"><span class="type">int</span>* p,q;</span><br><span class="line"><span class="type">int</span>  *p,q;</span><br></pre></td></tr></table></figure>
<p>上面两种一样。这告诉我们，<strong>其实我们是定义了<code>*p</code>，而不是<code>int *</code>型变量。</strong><br>所以第四种不是定义了p，q的地址，只定义了p的地址，要想都定义需要<code>*p</code>,<code>*q</code><br>普通变量的值是实际的值。<br>而指针变量的值是具有实际值的（别的）变量的地址。<br>我们在函数里可以通过指针访问外面的普通变量。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>*p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">6</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;&amp;i=%p\n&quot;</span>,&amp;i);</span><br><span class="line">	f(&amp;i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;p=%p\n&quot;</span>,p);</span><br><span class="line">&#125;<span class="comment">//该函数在被调用的时候得到了某个变量的地址</span></span><br></pre></td></tr></table></figure><br>void f(int *p);</p>
<p>p是地址，*p是该地址中的数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们调用的时候可以这么写：</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;f(&amp;i);</span><br></pre></td></tr></table></figure>
<p>在函数外面可以通过这个指针访问外面的这个i。如在f函数中输入<code>*p=26;</code>再输出i时会发现i变成26了。虽然传进来的是地址值，但可以通过这种方法在函数中访问p地址中的i的值，还可以通过地址改变i的值。<br><em>左值为什么叫左值？因为出现在赋值号左边的是值，可以接收值。</em><br> 指针的运算符&amp;和*是起相反作用的，<br> <code>*&amp;yptr-&gt;*(&amp;yptr)-&gt;*(yptr的地址)-&gt;得到那个地址上的变量，即yptr</code><br> <code>&amp;*yptr-&gt;&amp;(*yptr)-&gt;&amp;(y)-&gt;得到y的地址，即yptr</code><br>有的时候<code>int i; scanf(&quot;%d&quot;,i);</code>没有报错的原因：C语言把你传入的那个值当成地址了。尽管没有报错，但运行一定会出错。</p>
<h2 id="指针的用处"><a href="#指针的用处" class="headerlink" title="指针的用处"></a>指针的用处</h2><ol>
<li><p>现在在函数里利用指针就能使交换两个变量成为可能。可以直接对该地址的变量改变值。和之前的swap函数（传递的是两个值）不一样。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *pa,<span class="type">int</span> *pb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t=*pa;</span><br><span class="line">	*pa=*pb;</span><br><span class="line">	*pb=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数要返回多个值的时候，某些值就只能通过指针返回。</strong><br>传入的参数实际上是 需要保存带回的结果 的变量。传入的这些参数的作用是得到结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">写一个求最大值最小值的函数，要返回最大值和最小值两个值。</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],min,max;</span><br><span class="line">minmax(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]),&amp;min,&amp;max);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> len,<span class="type">int</span> *min,<span class="type">int</span> *max)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeof(a)/sizeof(a[0])是数组元素个数。</span></span><br><span class="line"><span class="comment">函数内部：一个len次的循环来比较每一个a[i]和*min,*max大小，然后令*min,*max不断改变主函数中min和max的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数要返回运算的状态，结果通过指针返回。</p>
</li>
</ol>
<p>比如函数计算得不到有效结果，让函数返回不属于有效范围内的特殊值来表示出错：比如作业中在str1数组中找str2数组，如果找不到的话返回NULL<br>状态用return返回值；实际的值通过指针参数返回，这样可以把return返回值放到if里判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给你两个数做除法，当分母等于<span class="number">0</span>时返回<span class="number">0</span>，分母不等于<span class="number">0</span>的时候要返回<span class="number">1</span>和除法的结果。</span><br><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		*result=a/b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">如果返回<span class="number">1</span>再输出a/b结果。</span><br></pre></td></tr></table></figure>
<p>后续语言采用了异常机制来解决这样的问题。<br>指针最常见的错误：定义了指针变量，还没有让它指向任何变量，就开始使用。比如一上来就<code>int *p=12;</code>这就不行。<br>一定要先让他先得到实际的变量的地址！</p>
<h2 id="指针与数组：为什么数组函数之后的sizeof不对了"><a href="#指针与数组：为什么数组函数之后的sizeof不对了" class="headerlink" title="指针与数组：为什么数组函数之后的sizeof不对了"></a>指针与数组：为什么数组函数之后的sizeof不对了</h2><p> <img src="https://img-blog.csdnimg.cn/2021012110484493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>sizeof(a)（a是个数组）返回的是int*的sizeof，而不是int []的sizeof<br>如果我们在minmax函数中改变a[0]的值，在main()函数中a[0]的值也会被改变，和指针一样。<br>可以看出函数参数表中int a[]这其实是个指针！（在函数的注释中可以写<code>int a[]</code>，也可以写<code>*a</code>）<br>但我们仍然可以用数组的运算符[]进行运算<br>所以下面这四种函数原型是等价的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *ar,<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> *,<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sun</span><span class="params">(<span class="type">int</span> ar[],<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> [],<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>数组变量是特殊的指针，因为数组变量本身表达地址，所以int a[10];int <em>p&#x3D;a;&#x2F;&#x2F;无需用&amp;取地址。但是数组的单元表达的是变量，需要用&amp;取地址。如：<br><code>a==&amp;a[0]</code><br>[]运算符可以对数组做，也可以对指针做<br><code>P[0]</code>就相当于<code>*P</code><br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pritnf(<span class="string">&quot;min=%d,max=%d\n&quot;</span>,min,max);</span><br><span class="line"><span class="type">int</span> *p=&amp;min;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>,*p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[0]=%d\n&quot;</span>,p[<span class="number">0</span>]);<span class="comment">//得到的是一样的结果。</span></span><br></pre></td></tr></table></figure><br>虽然min是个数，但是p[0]实际上就是min.不过普通变量min没有min[0].<br>同样，</em>运算符也可以对数组做。<br><code>*a=a[0]</code><br>数组变量是const的指针，所以不能通过指针的方式被赋值。<br><code>int b[]-&gt;int * const b;</code><br>所以（a，b是两个数组）不能写<code>b=a;</code>他是个常量指针，不能被赋值。</p>
<h2 id="指针与const：指针本身和所指的变量都可能const（本节只适用于c99）"><a href="#指针与const：指针本身和所指的变量都可能const（本节只适用于c99）" class="headerlink" title="指针与const：指针本身和所指的变量都可能const（本节只适用于c99）"></a>指针与const：指针本身和所指的变量都可能const（本节只适用于c99）</h2><p>如果指针是const，表示指针一旦得到了某个变量的地址，不能再指向其他变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> q=&amp;I;<span class="comment">//q是const</span></span><br><span class="line">*q=<span class="number">26</span><span class="comment">//可以改变i的值</span></span><br><span class="line">q++<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;I;</span><br><span class="line">*p=<span class="number">26</span>;<span class="comment">//error!(*p)是const，不能通过p做赋值。</span></span><br><span class="line">I=<span class="number">26</span>;<span class="comment">//可以直接改i</span></span><br><span class="line">P=&amp;j;<span class="comment">//改变p指向的地址，可以</span></span><br></pre></td></tr></table></figure>
<p>辨析意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> I;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*p1=&amp;I;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>*p2=&amp;I;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p3=&amp;I;</span><br></pre></td></tr></table></figure>
<p>加const只有两种意思：1. 地址不可改变；2.不能通过该地址来赋值。<br>判断谁被const的标志是：*在const前面还是后面。<br>转换：总可以把一个非const的值转化成const的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*x)</span>;</span><br><span class="line"><span class="type">int</span> a=<span class="number">15</span>;</span><br><span class="line">f(&amp;a);<span class="comment">//可以</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b=a;</span><br><span class="line">f(&amp;b);<span class="comment">//可以</span></span><br><span class="line">b=a+<span class="number">1</span>;<span class="comment">//不行！</span></span><br></pre></td></tr></table></figure>

<p>当我们要传递的参数类型比地址大的时候，这是常用的手段：既能用比较少的字节数传递值给参数，又能避免函数对外面的变量的修改。<br><code>Const int a[]=&#123;1,2,3,4,5,6&#125;;</code><br>数组变量已经是const的指针了，这里的const表示数组的每个单元都是const int。所以必须通过初始化进行赋值。<br>因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值。<br>为了保护数组不被函数破坏，可以这样设置参数为const。<br><code>int sum(const int a[],int length);</code></p>
<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>指针加一，会发生什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="type">char</span> *p=ac;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p的地址是%p\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p+1的地址是%p\n&quot;</span>,p+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>输出<br>0xbffbbd5e<br>0xbffbbd5f<br>当我们把<code>char</code>换成<code>int</code>时，输出<br>0xbffbad2c<br>0xbffbad30（加了4）<br>因为<code>sizeof(char)=1,sizeof(int)=4</code>，可见对指针+1会让指针指向下一个单元。*(p+1)也就是从ac[0]跳到了ac[1]。<br><strong>注意是<code>*(p+1)</code>而不是<code>*p+1</code>，因为<code>*</code>号是单目运算符，优先级高。</strong><br>由此可以猜测如果指针不是指向一片连续的空间（比如数组），那这种运算是没有意义的。</p>
<p>这种运算可以+，+&#x3D;，-，-&#x3D;，++，–，指针做差(p1-p得到的是两个指针之间的距离，即地址差&#x2F;sizeof()，int 和char结果都是一样的)<br><code>*p++</code>：取出p所指的数据，之后顺便把指针移动到下一个位置。（++的优先级比<code>*</code>高）不需要括号，常常用于数组类连续空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=ac;</span><br><span class="line"><span class="keyword">while</span>(*p!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*p++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（在某些CPU上，<code>*p++</code>被直接翻译成一条指令，使得取得p地址内的值之后，p指针++。）<br><code>&gt;,&gt;=,&lt;,&lt;=,!=</code>也都可以对指针做，比较指针在内存中的地址。数组中单元的地址是线性递增的。</p>
<p>0地址<br>有，但是通常不随便碰，所以指针最好不要有0值。<br>因此我们可以用0地址来表示特殊的事情：<br>1.返回的指针是无效的<br>2.指针没有真正被初始化（先初始化为0地址）<br>NULL是一个预定定义的符号，表示0地址，建议使用，因为有的编译器不接受用0来表示0地址。<br>所有指针大小都是一样的，不管指向什么类型，因为他们都是地址。但指向不同类型的指针之间不能互相赋值，避免用错。</p>
<p>指针的类型转换<br><code>void*</code>表示不知道指向什么东西的指针，计算时与<code>char*</code>相同。<br>指针也可以转换类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=&amp;i;<span class="type">void</span>*q=(<span class="type">void</span>*)p;</span><br></pre></td></tr></table></figure>
<p>并没有改变p所指的变量的类型， 而是让后人用不同的眼光通过p看他所指的变量。（初学者可以不用做）<br>指针的用处<br>需要传入较大的数据时指针用作参数<br>穿如数组后对数组进行操作<br>函数返回不止一个结果<br>需要用函数来修改不止一个变量<br>动态申请的内存……</p>
<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>输入数据时先读入个数n，再输入n个数，并且要记录每个数据<br>C99可以用变量做数组定义的大小。C99之前该怎么做？<br>动态内存分配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>另：编译时输入man malloc可以查看使用方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> *a;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	a=(<span class="type">int</span>*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="comment">//用完之后</span></span><br><span class="line">	<span class="built_in">free</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向malloc申请的空间的大小是以字节为单位的<br>如果申请失败会返回0，或称作NULL<br>free()：把申请的空间还给系统，只能还该空间的首地址。<strong>一定要还。</strong><br>习惯养成：定义指针的时候就先初始为0<br><code>void *p=0;</code>之后再<code>free(p)</code>，不管有没有使用malloc，free()都没有问题。<br>常见问题就是申请了没有free，长时间运行内存逐渐下降。做大程序时问题显现出来。<br>新手：忘了<br>老手：找不到合适的free的时机<br>问题2：free了又free<br>问题3：地址变过了，直接去free()。<br>纸上得来终觉浅。</p>
<h1 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10. 字符串"></a>10. 字符串</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> word[]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;!&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>得到的字符数组应该是这样子的</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>word[0]</td>
<td>H</td>
</tr>
<tr>
<td>word[1]</td>
<td>e</td>
</tr>
<tr>
<td>word[2]</td>
<td>l</td>
</tr>
<tr>
<td>word[3]</td>
<td>l</td>
</tr>
<tr>
<td>word[4]</td>
<td>o</td>
</tr>
<tr>
<td>word[5]</td>
<td>!</td>
</tr>
<tr>
<td>不过这只是字符数组而不是字符串。因为他不能用字符串的方式做运算。</td>
<td></td>
</tr>
<tr>
<td>定义一个C语言的字符串，结尾要加上word[6]&#x3D;’\0’。</td>
<td></td>
</tr>
<tr>
<td>对C语言来说，字符串就是以0（整数0）结尾的一串字符数组。</td>
<td></td>
</tr>
<tr>
<td>0和’\0’是一样的，但是和’0’不同。0标志着字符串的结束，但他自己不是字符串的一部分，计算字符串长度的时候不包含这个0。</td>
<td></td>
</tr>
<tr>
<td>字符串以数组的形式存在，以数组或指针的形式访问（更多以指针的形式）</td>
<td></td>
</tr>
<tr>
<td>PS:string.h里有很多处理字符串的函数。</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//一个指针指向了一个字符数组</span></span><br><span class="line"><span class="type">char</span> word[]=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//字符数组，结尾0</span></span><br><span class="line"><span class="type">char</span> line[<span class="number">10</span>]=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//字符数组，结尾0</span></span><br></pre></td></tr></table></figure>
<p>字符串常量<br>“Hello”双引号括起来的叫做字符串的字面量&#x2F;常量，我们在scanf和printf里已经见过很多次了。”Hello”会被编译器变成一个（长度为6的）字符数组放在某处，结尾自动添上个0。<br>两个相邻的字符串常量会被自动连接起来。<br>比如<code>printf</code>里出现连续两个<code>&quot; &quot;</code> <code>&quot; &quot;</code>，会接起来输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;123456789&quot;</span></span><br><span class="line"><span class="string">&quot;10111213&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>另一种连接方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;123456789\</span></span><br><span class="line"><span class="string">10111213&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>会输出12345678910111213，回车可以用反斜杠的方式搞定。<strong>不过这种方法连换行开头的Tab也会输出</strong>，要小心使用。<br><em>人的眼睛横向是有极限的hh。所以程序员喜欢把显示器转过来</em><br>C语言的字符串是以字符数组的形态存在的，因为是个数组，所以不能用运算符对字符串做运算。但可以通过数组的方式遍历字符串。（后面会有很多应用）<br>字符串唯一特殊的地方是字符串字面量可以用来初始化字符数组。</p>
<h2 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">&#x27;B&#x27;</span>;<span class="comment">//尝试把H替换为B，然后输出s[0]</span></span><br></pre></td></tr></table></figure>
<p>编译无问题，但是运行时没法输出s[0]，出错了。<br>再做另一个尝试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *s=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>*s1=<span class="string">&quot;Hello&quot;</span>;<span class="comment">//两个一样的字符串变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i的地址是%p\n&quot;</span>,&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s的地址是%p\n&quot;</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;s1的地址是%p\n&quot;</span>,s1);</span><br></pre></td></tr></table></figure>
<p>比较得到的地址结果我们可以得出的结论：</p>
<p>1.i的地址相对很大，s和s1的地址相对很小。<br>2.s和s1的指向了同一个地址。</p>
<p>其实s和s1指向的地址是程序的代码端，他是<strong>只读的</strong>。<br>因此，实际上s是<code>const char*s;</code>由于历史的原因，编译器接受不带<code>const</code>的写法（所以编译通过了）。但试图对s所指的字符串做写入会导致严重的后果。<br>如果需要修改字符串，应该用数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[]=<span class="string">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>尝试输出s的地址会发现，s的地址和上例中的i的地址一样较大（也就是说在本地变量那里），而且s可以修改。<br>需要使用字符串的时候，我们要把它写成指针的形式还是数组的形式呢？<br>数组：</p>
<ol>
<li>字符串有确定的地址；</li>
<li>作为本地变量，空间会自动被回收。</li>
</ol>
<p>指针：这个字符串不知道在哪；所以通常用来</p>
<ol>
<li>只读的，不可写的字符串</li>
<li>处理函数的参数（前面知道如果数组作为指针，函数的参数实际上和指针是一样的）；</li>
<li>动态分配空间malloc。</li>
</ol>
<p>因此，如果要构造一个字符串：数组<br>如果要处理一个字符串：指针。</p>
<p>因此，字符串可以表示为<code>char*</code>的形式，而<code>char*</code>不一定是字符串。<br>他可能是指向字符的指针，可能指向的是字符的数组。只有当<code>char*</code>所指的字符数组有结尾的0，才能说他所指的是字符串。</p>
<h2 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h2><p>所以字符串的地位如此。尽管相较之前的语言，C语言有很多处理字符串的方法，但比起现在的新语言，C语言对字符串的处理还是不足。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *t=<span class="string">&quot;title&quot;</span>;</span><br><span class="line"><span class="type">char</span> *s;</span><br><span class="line">s=t;</span><br></pre></td></tr></table></figure>
<p>只是让指针s指向指针t所指的字符串，并没有产生新的字符串。<br>至于如何真的复制一个字符串给s，等到以后字符串函数会学到的。<br>字符串的输入输出：<code>%s</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
<p>输入不再是简单的整数、一个字符，这时候，我们就要考虑下scanf的停止条件了。<br><code>scanf()</code>只能读入一个单词，因为碰到空格、tab键或回车就会终止。空格、回车是分隔符，是用来分隔两个单词的。<br>如果用这种方法读入两个单词可以连续两次scanf：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s%s&quot;</span>,str1,str2);</span><br></pre></td></tr></table></figure>
<p>空格不会被读入，输出是没有中间的分隔符（空格）的。<br><code>scanf()</code>是不安全的，因为不知道读入的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">8</span>],str2[<span class="number">8</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str1);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str2);</span><br></pre></td></tr></table></figure>
<p>输入12345678 12345678，结果第一个字符串为空，第二个字符串却是12345678读了八个字符。（运气好没有崩溃）<br>为什么？涉及到在内存中是怎么排列的。<br>安全的方法：<code>scanf(&quot;%7s%7s&quot;,str,str1);</code>意思是：最多只能读七个字符。多出的部分会分配给下一个字符串。<br>这样输入12345678,8就会分配给下一个字符串。<br>加入的这个数字，最多应该比定义字符串的个数小1（ 比如上例最多为7）<br>C语言中常见的错误：误以为<code>char*</code>就是定义了字符串类型。其实是一个需要初始化的指针。不初始化可能会出错。（可能会出现：程序在一个地方没问题，到了其他地方就出错了）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> zero[<span class="number">100</span>]=<span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>空的字符串，zero[0]&#x3D;’\0’，不过仍然是有效的字符串。<br>但是如果写成：<code>char zero[]=&quot;&quot;;</code>长度就是1了。</p>
<h2 id="字符串数组，以及程序参数"><a href="#字符串数组，以及程序参数" class="headerlink" title="字符串数组，以及程序参数"></a>字符串数组，以及程序参数</h2><p>如果我们想写一个数组来表示很多个字符串？<br><code>char **a</code>：a是个指针，指向另一个指针，另一个指针指向一个字符串<br><code>char a[][]</code>：a是个二维数组的变量，第二维（后面的括号）一定要有确定的大小，否则编译不能通过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[][<span class="number">10</span>]=&#123;</span><br><span class="line">	<span class="string">&quot;hello&quot;</span>,</span><br><span class="line">	<span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;;<span class="comment">//每个字符串长度不要超过n，即10</span></span><br></pre></td></tr></table></figure>
<p>还有一种写法：<code>char *a[]</code>，a[0]相当于char*，像矩阵的排列方法想的话，a[i]就是指向每一行的字符串的指针。<br>这和二维数组不一样，二维数组a[0]就是第一行的字符串。<br>填坑：以前做的一道题：输入数字月份，输出对应的月份英文单词。现在可以用数组做。<br>现在回归到int main()主函数，之前说过括号里面什么都不用写，要写也就写个void<br>其实里面是是<code>int main(int argc,char const*argv[])</code><br>argc告诉我们，后面的数组有多少个字符串。<br>然后我们试着输出后面字符串的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d:%s\n&quot;</span>,i,argv[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>./a.out</code>运行，只输出了0:.&#x2F;a.out<br>第二次输入<code>./a.out 123</code>，输出了<br><code>0:./a.out  1:123</code><br>然后随便输入，<code>./a.out 123 asd asd asd asd</code>这些字符串都会被一个个记录下来。<br>它从第2个字符串开始记录所有你输入的字符串，而第一个参数，即argv[0]，则是输入的这个文件的名字（<code>./a.out</code>）即可执行程序的名字。<br>如果将a.out 称之为my，<code>ln -s a.out my</code> ，然后我们看my，<code>ls -l my</code> 发现my是个指向a.out 的链接。如果执行my <code>./my 123</code> 输出的字符串argv[0]也是<code>./my</code>而不是<code>./a.out</code>了。<br>关于到底是怎样运行程序的，建议搜索busybox，看看别的box是怎么做的。（蒙……）等做快捷方式的时候会更理解。</p>
<h2 id="字符、字符串操作"><a href="#字符、字符串操作" class="headerlink" title="字符、字符串操作"></a>字符、字符串操作</h2><h3 id="单字符输入输出"><a href="#单字符输入输出" class="headerlink" title="单字符输入输出"></a>单字符输入输出</h3><p>putchar(int c)函数：向标准输出写一个字符，但是输入是int类型，返回类型也是int 表示写了几个字符，一般为1，EOF(即：值-1)表示失败。(end of fail)<br>getchar()：从标准输入读入一个字符，返回类型也是int(因为要返回EOF表示输入结束了）<br>写一个程序进一步理解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch;</span><br><span class="line"><span class="keyword">while</span>((ch=getchar())!=EOF)&#123;</span><br><span class="line">	<span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;EOF\n&quot;</span>);<span class="comment">//这样来看读入什么会EOF</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>不管怎么输入数字串、字符串都不停止，直到输入Ctrl-C，程序直接结束但没有看到EOF，这表示我们将程序强制结束了而不是正确的输入EOF。<br>第二次尝试输入Ctrl-D，得到输出EOF（Windows要输入Ctrl-Z)。而且另一件奇怪的事情是，即便输入12435435数字串，敲下回车之前都不会有回应，敲下回车后才原封不动地输出这一串。为什么？getchar()不是一个个读的吗？<br>原因：之前提到过中介shell，shell先处理输入的东西再给程序，输出的东西也先经过处理再呈现给我们。（当时在讲\b会变成什么样子）<br>用户（键盘等输入）→shell→程序<br>用户←shell←程序<br>shell对输入的东西做了行编辑，也就是敲下回车前输入的部分都在shell里处理，放在缓冲区里，按下回车后才送到程序那里。如：输入123，shell缓冲区里为“1，2，3，回车”。然后getchar()再读缓冲区。<br>如果按下Ctrl-D，shell会生成一个EOF的标志。而按下Ctrl-C，shell直接关闭了程序。<br>所以用户的输入是让shell填写缓冲区，而scanf()和getchar()都是在缓冲区内读。</p>
<h3 id="字符串函数strlen"><a href="#字符串函数strlen" class="headerlink" title="字符串函数strlen"></a>字符串函数strlen</h3><p><code>string.h</code>头文件中处理字符串的函数比如：<code>strlen</code>、<code>strcmp</code>、<code>strcpy</code>、<code>strcat</code>、<code>strchr</code>、<code>strstr</code>等<br><code>strlen(const char*s)</code>：返回s的字符串长度（不包括结尾0）由参数表中的const可知该函数不会修改传入的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> line[]=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lu\n%lu&quot;</span>,<span class="built_in">strlen</span>(line),<span class="keyword">sizeof</span>(line));</span><br></pre></td></tr></table></figure>
<p>输出结果：strlen&#x3D;5,sizeof&#x3D;6（结尾的0）<br>我们能不能写出一个strlen函数呢？<br>sizeof不行，因为我们得到的是指针所占据的大小。<br>我们需要遍历数组：<code>H,e,l,l,o,\0</code><br>因为不知道数组有多大，用while循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s[cnt]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">	cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br></pre></td></tr></table></figure>

<h3 id="字符串数组strcmp"><a href="#字符串数组strcmp" class="headerlink" title="字符串数组strcmp"></a>字符串数组strcmp</h3><p><code>int strcmp(const char*s1,const char*s2)</code>：比较两个字符串。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>相等</td>
</tr>
<tr>
<td>1</td>
<td>s1大</td>
</tr>
<tr>
<td>-1</td>
<td>s2大</td>
</tr>
<tr>
<td>大小是怎么定义的？</td>
<td></td>
</tr>
<tr>
<td>我们做一个尝试：</td>
<td></td>
</tr>
<tr>
<td><code>printf(&quot;%d\n&quot;,s1==s2);</code>来判断s1和s2是否相等。</td>
<td></td>
</tr>
<tr>
<td>然而即便s1和s2内容相同还是输出了0.因为实际上<code>s1==s2</code>比较的是s1和s2的地址，所以数组之间的这种比较永远是0。</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1[]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2[]=<span class="string">&quot;bbc&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>再用<code>strcmp</code>比较两者输出了-1.这很合理，因为ASCII码b&gt;a.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1[]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2[]=<span class="string">&quot;Abc&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>输出32？32是<code>&#39;a&#39;-&#39;A&#39;</code>的结果。所以这回给出的结果是不相等的字符的差值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1[]=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2[]=<span class="string">&quot;abc &quot;</span>;<span class="comment">//多了个空格</span></span><br></pre></td></tr></table></figure>
<p>输出-32，是空格位<code>\0-&#39; &#39;</code>造成的。<br>接下来我们自己尝试写strcmp。我们需要下标idx，s1[idx]与s2[idx]比较，当s1[idx]和s2[idx]都&#x3D;&#x3D;’\0’时停止（假设长度相等）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(s1[idx]!=<span class="string">&#x27;\0&#x27;</span>&amp;&amp;s1[idx]==s2[idx])<span class="comment">//当出现不相等的字符或者字符串到了末尾时，返回差值</span></span><br><span class="line">	idx++;</span><br><span class="line"><span class="keyword">return</span> s1[idx]-s2[idx];</span><br></pre></td></tr></table></figure>
<p>改进：idx可不可以不用？<br>用指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*s1==*s2</span><br><span class="line">s1++;</span><br><span class="line">s2++;</span><br><span class="line"><span class="keyword">return</span> *s1-*s2;</span><br></pre></td></tr></table></figure>
<p>这是处理字符串的两种手段，数组和指针。看个人喜好。</p>
<h3 id="字符串函数strcpy"><a href="#字符串函数strcpy" class="headerlink" title="字符串函数strcpy"></a>字符串函数strcpy</h3><p><code>char*strcpy(char* restrict dst,char* restrict src);</code><br>把src拷贝到dst的空间里，包括结尾的\0.<br>restrict表示src和dst不能重叠。比如src是<br><code>H E L L O \0</code><br>，dst的内容是:<br><code>空 空 空 H E L L O \0</code><br>也就是说想把HELLO挪到第一位开始，这是不行的。因为strcpy对于多核计算机，为了提高效率，拷贝可能是交给不同的核不同的段，分别拷贝。<br>函数参数中的第一个参数是目的，而第二个参数是源。而且这个函数是有返回值的，返回dst</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *dst=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)+<span class="number">1</span>);<span class="comment">//不包含结尾的\0，所以+1</span></span><br><span class="line"><span class="built_in">strcpy</span> (dst,src);</span><br></pre></td></tr></table></figure>
<p>+1是重点。<br>接下来尝试自己写strcpy()函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">mycpy</span><span class="params">(<span class="type">char</span>*dst,<span class="type">const</span> <span class="type">char</span>*src)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> idx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(src[idx]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dst[idx]=src[idx];</span><br><span class="line">		idx++;</span><br><span class="line">	&#125;</span><br><span class="line">	dst[idx+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> dst;</span><br></pre></td></tr></table></figure>
<p>指针的做法是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ret=dst;</span><br><span class="line"><span class="keyword">while</span>(*src!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	*dst=*src;</span><br><span class="line">	*dst++;</span><br><span class="line">	*src++;</span><br><span class="line">&#125;</span><br><span class="line">*dst=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>当然do-while也行.<br>也可以这样优化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(*src)*dst++ = *src++;</span><br></pre></td></tr></table></figure>
<p>更艹的是，<code>*dst++ = *src++;</code>的结果就是*src，所以我们可以直接写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(*dst++ = *src++);</span><br></pre></td></tr></table></figure>

<h3 id="字符串函数strcat"><a href="#字符串函数strcat" class="headerlink" title="字符串函数strcat"></a>字符串函数strcat</h3><p><code>char*strcat(char* restrict s1,const char* restrict s2);</code><br>把s2拷贝到s1后面，接成一个长字符串；返回s1.（s1结尾的\0被s2开头替换掉）<br>如：s1: H E L L O \0<br>       s2:W O R L D\0<br> 结果：s1: H E L L O W O R L D \0<br>s1必须要有足够的空间。<br><em>cpy和cat有可能没有足够的空间，因此这两个函数是不够安全的，不建议使用。</em><br>安全版本：<code>strncpy</code>和<code>strncat</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>*<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span>* <span class="keyword">restrict</span> s1,<span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> s2,<span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">char</span>*<span class="title function_">strncat</span><span class="params">(<span class="type">char</span>* <span class="keyword">restrict</span> s1,<span class="type">const</span> <span class="type">char</span>* <span class="keyword">restrict</span> s2,<span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">char</span>*<span class="title function_">strncat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2,<span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>
<p>会拷贝能拷贝的最多的字符，多的部分掐掉。而strncmp则是只判断前几个字符。</p>
<h3 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a>字符串搜索函数</h3><p><code>char* strchr(const char* s,int c);</code><br><code>char* strrchr(const char* s,int c);//从右边开始找</code><br>返回的是指针，返回NULL表示没找到。<br>那如果像HELLO出现两个L，怎样寻找第二个呢?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">strchr</span>(s,<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,p);</span><br></pre></td></tr></table></figure>
<p>输出llo。<br>想找第二个的方法是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p=<span class="built_in">strchr</span>(p+<span class="number">1</span>,<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果想把l后面的东西cpy到另一个字符串中去：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *t=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t,p);</span><br><span class="line"><span class="built_in">free</span>(t);</span><br></pre></td></tr></table></figure>
<p>如果我们想要l前面的部分？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c=*p;</span><br><span class="line">*p=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//把l的位置改成&#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> *t=(<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(t,s);<span class="comment">//只拷贝了第一个l前面的部分。</span></span><br></pre></td></tr></table></figure>
<p>t就是想要的结果，即he<br>在字符串中找字符串：<code>char* strchr(const char* s1,const char*s2);</code><br>不分大小写寻找：<code>char* strcasestr(const char* s1,const char*s2);</code></p>
<h1 id="11-枚举"><a href="#11-枚举" class="headerlink" title="11. 枚举"></a>11. 枚举</h1><p>常量符号化：用符号而不是具体的数字来表示程序中的数字。<br>让用户输入颜色的代号，我们输出对应的颜色：可以用const int 和switch来解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> red=<span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> yellow=<span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> green=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> color=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> *colorname=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你喜欢的颜色的代码&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;color);</span><br><span class="line">	<span class="keyword">switch</span>(color)&#123;</span><br><span class="line">	<span class="keyword">case</span> red:colorname=<span class="string">&quot;red&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> yellow:colorname=<span class="string">&quot;yellow&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> green:colorname=<span class="string">&quot;green&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:colorname=<span class="string">&quot;unknown&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,colorname);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>再把这件事再往前推进一点，我们使用枚举而不是单独定义const int变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span>&#123;</span>RED,YELLOW,GREEN&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> color=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">char</span> *colorname=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入你喜欢的颜色代码：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;color);</span><br><span class="line">	<span class="keyword">switch</span>(color)&#123;</span><br><span class="line">	<span class="keyword">case</span> RED:colorname=<span class="string">&quot;red&quot;</span>;<span class="keyword">break</span>;<span class="comment">//在case处就可以直接使用RED YELLOW和GREEN来取代0,1,2</span></span><br><span class="line">	<span class="keyword">case</span> YELLOW:colorname=<span class="string">&quot;yellow&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> GREEN:colorname=<span class="string">&quot;green&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:colorname=<span class="string">&quot;unknown&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是%s\n&quot;</span>,colorname);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举是一种用户定义的数据类型，使用以下格式定义：<br><code>enum 枚举类型名&#123;名字0,名字1……名字n&#125;;</code>enum是enumeration。<br>枚举类型名通常不用，我们用的是大括号中的名字，因为他们就是常量符号，<strong>类型一定是int</strong>，值从0到n。比如上例中，RED&#x3D;0,YELLOW&#x3D;1,GREEN&#x3D;2。<br>当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字。<br>在函数中使用时要记得说上前缀enum</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;</span>red,yellow,green&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> color c)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">color</span> <span class="title">t</span>=</span> red;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">	f(t);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="keyword">enum</span> color c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以像int一样输入输出。<br>因为定义中的名字是从0到n按顺序排列的，这样要遍历时或者要建立数组时就会很方便。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">COLOR</span>&#123;</span>RED,YELLOW,GREEN,numcolors&#125;;<span class="comment">//结尾的numcolors表示数组的结尾，同时也可以表示enum中元素的个数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> color=<span class="number">-1</span>; </span><br><span class="line">	<span class="type">char</span> *ColorNames[numcolors]=&#123;</span><br><span class="line">		<span class="string">&quot;red&quot;</span>,<span class="string">&quot;yellow&quot;</span>,<span class="string">&quot;green&quot;</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">char</span> *colorname=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;请输入你喜欢的颜色的代码&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;color);</span><br><span class="line">	<span class="keyword">if</span>(color&gt;=<span class="number">0</span>&amp;&amp;color&lt;numcolors) colorname=ColorNames[color];</span><br><span class="line">	<span class="keyword">else</span> colorname=<span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;你喜欢的颜色是%s&quot;</span>,colorname);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，声明枚举量的时候可以指定特殊值，不一定非要按顺序从0开始。<br><code>enum color&#123;red=1,yellow,green=5&#125;;</code>如果输出%d,green 就会输出5。<br>但是枚举只是int，即使给它赋不存在的值（比如上例中，我们<code>enum color c=0;</code>也没有关系）也不会有warning或error。<br>枚举虽然可以当做类型来使用，但是并不好用。现在通常定义一些排比的符号量，这样比const int一个个来方便。<br>枚举比后面会讲到的宏（marco）好，因为枚举有类型int。</p>
<h2 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h2><p>我们已经知道，在c中我们要表达的数据，要有变量，还要有类型。<br>如果要表达的数据比较复杂（比如日期，包括年、月、日；或时间，包括时、分、秒），而我们又希望用一个整体去表达，就要用到C语言的结构。<br>结构是一个复合的数据类型，在里面有很多各种类型的“成员”，然后可以用一个变量来表达多个数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span></span><br><span class="line">		<span class="type">int</span> day;</span><br><span class="line">		<span class="type">int</span> month;</span><br><span class="line">		<span class="type">int</span> year;</span><br><span class="line">	&#125;;<span class="comment">//声明时，结尾有个分号！！</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>;</span><span class="comment">//像枚举一样不要忘记开头，struct</span></span><br><span class="line">	today.day=<span class="number">12</span>;</span><br><span class="line">	today.month=<span class="number">3</span>;</span><br><span class="line">	today.year=<span class="number">2021</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Today&#x27;s date is %i-%i-%i.&quot;</span>,today.year,today.month,today.day);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，和之前本地、全局变量一样，如果结构是在一个函数内部声明的，则该结构只能在该函数内部使用。在函数外声明就可以在多个函数内使用了。<br>另一种声明方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br></pre></td></tr></table></figure>
<p>p1和p2都是一种无名结构，都包含x和y。没有声明结构名字，临时造了两个无名结构出来。<br>不过，最常见的还是要声明结构名字的形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br></pre></td></tr></table></figure>
<p>p1,p2都是point，都包含x和y。</p>
<table>
<thead>
<tr>
<th>month</th>
<th>day</th>
<th>year</th>
</tr>
</thead>
<tbody><tr>
<td>11</td>
<td>23</td>
<td>2007</td>
</tr>
<tr>
<td>today的内存中包含month, day, year.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>还有一件要注意的事就是 <em>声明结构类型</em> 和 <em>定义结构变量</em> 要区分。<strong>声明类型后</strong>方可定义变量。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>结构初始化：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>=</span>&#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">2021</span>&#125;;<span class="comment">//注意顺序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thismonth</span>=</span>&#123;.month=<span class="number">3</span>,.year=<span class="number">2021</span>&#125;;<span class="comment">//剩下没有被赋值的部分都是0，和数组一样</span></span><br></pre></td></tr></table></figure>
<p>和数组相比，结构中的成员可以是不同类型的。<br>数组用[]运算符和下标来访问；而结构用<code>.</code>运算符和名字来访问。<br><strong>结构的运算</strong><br>可以用<code>结构名字.成员名字</code>来访问某个成员，也可以直接用结构名字来访问整个结构变量。可以做赋值、取地址，传递给函数参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1=(<span class="keyword">struct</span> point)&#123;<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">p1=p2;</span><br></pre></td></tr></table></figure>
<p>这两种操作，数组变量都做不了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">today</span>,<span class="title">day</span>;</span></span><br><span class="line">today=(<span class="keyword">struct</span> date)&#123;<span class="number">12</span>,<span class="number">3</span>,<span class="number">2021</span>&#125;;</span><br><span class="line">day=today;</span><br></pre></td></tr></table></figure>
<p>和数组不同，结构变量的名字并不是结构变量的地址，取地址要加上&amp;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">pdate</span>=</span>&amp;today;</span><br></pre></td></tr></table></figure>

<h2 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h2><p>结构像int等类型一样，可以作为函数的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numberofdays</span><span class="params">(<span class="keyword">struct</span> date d)</span></span><br></pre></td></tr></table></figure>
<p>整个结构可以作为参数的值传入函数。这时候会在函数内部新建一个结构变量，并复制该参数的值。当然，函数也可以返回一个结构。<br>（貌似美国的写法是月&#x2F;日&#x2F;年）<br><code>&amp;date.month</code>中，取成员运算符<code>.</code>的优先级高于取地址运算符<code>&amp;</code></p>
<p>怎样输入结构？我们不能用scanf直接读入一个结构。<br>先尝试写一个读入结构的函数：先在main函数里定义，然后把该参数传入getstruct函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>=</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">gtestruct(p);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getstruct</span><span class="params">(<span class="keyword">struct</span> point p)</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p.x);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而这不像指针，这样读入的结构是不会传入原函数中的。（只是一个克隆体而不是直接对结构本身做操作）<br>记住函数是有返回值的，我们要做的是在输入函数中创建一个临时的结构变量，返回给调用者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> point <span class="title function_">getstruct</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p.x);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p.y);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main函数中：y=getstruct();</span></span><br></pre></td></tr></table></figure>
<p>然而，在函数中建立一个拷贝来回传递，既费空间又费时间。还是结构指针的方法会好很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">myday</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> *<span class="title">p</span>=</span>&amp;myday;</span><br><span class="line">(*p).month=<span class="number">12</span>;<span class="comment">//正常应该这样写</span></span><br><span class="line">p-&gt;month=<span class="number">12</span>;<span class="comment">//也可以简写成这样</span></span><br></pre></td></tr></table></figure>
<p>-&gt;表示指向结构变量中的成员</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getstruct</span><span class="params">(<span class="keyword">struct</span> point *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">p</span>=</span>&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	print(getstruct(&amp;p));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> point *<span class="title function_">getstruct</span><span class="params">(<span class="keyword">struct</span> point *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;x);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p-&gt;y);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;<span class="comment">//像这样传入一个参数，对其做处理后再返回该参数的函数，可以直接套用在其他函数中。</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> point *p)</span><span class="comment">//const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,p-&gt;x,p-&gt;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构中的结构"><a href="#结构中的结构" class="headerlink" title="结构中的结构"></a>结构中的结构</h2><p>结构中的数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[100];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">dates</span>[]=</span>&#123;</span><br><span class="line">	&#123;<span class="number">3</span>,<span class="number">21</span>,<span class="number">2021</span>&#125;,&#123;<span class="number">3</span>,<span class="number">22</span>,<span class="number">2021</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2i&quot;</span>,dates[<span class="number">1</span>].month);<span class="comment">//不知道%.2i什么意思</span></span><br></pre></td></tr></table></figure>
<p>结构里的变量也可以是另外一个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt1</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">point</span> <span class="title">pt2</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有这样的定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> <span class="title">r</span>;</span></span><br><span class="line"><span class="comment">/*则可以有：</span></span><br><span class="line"><span class="comment">r.pt1.x;</span></span><br><span class="line"><span class="comment">r.pt1.y;</span></span><br><span class="line"><span class="comment">r.pt2.x;</span></span><br><span class="line"><span class="comment">r.pt2.y;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//如果有这样的定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rectangle</span> *<span class="title">rp</span>;</span></span><br><span class="line">rp=&amp;r;</span><br><span class="line"><span class="comment">//那么下面的四种形式是等价的</span></span><br><span class="line">r.pt1.x</span><br><span class="line">rp-&gt;pt1.x</span><br><span class="line">(r.pt1).x</span><br><span class="line">(r-&gt;pt1).x</span><br><span class="line"><span class="comment">//但是不能写r-&gt;pt1-&gt;x,因为pt1不是指针而是结构。</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210321211749511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图所示，rp指向r。<br>甚至可以做结构里的结构里的数组。<br><img src="https://img-blog.csdnimg.cn/20210321211941973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20210321212110996.png" alt="在这里插入图片描述"><br>（这里也能看出这么写会好看很多~）</p>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><p>比如我们之前讲struct的时候要一直加上struct前缀。如何摆脱呢？<br>自定义数据类型(<code>typedef</code>)<br><code>typedef int length;</code><br>这样使得length成为int类型的别名。可以直接把length当做int类型来用<br><code>length a,b;</code><br><code>length a[10];</code><br>声明的新类型是某种类型的别名，改变了程序的可读性，简化了复杂的名字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADate</span>&#123;</span></span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line">&#125;Date;</span><br><span class="line"></span><br><span class="line">Date a=&#123;<span class="number">3</span>,<span class="number">24</span>,<span class="number">2021</span>&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> *<span class="type">char</span>[<span class="number">10</span>] String;<span class="comment">//string是十个字符串的数组的类型。</span></span><br></pre></td></tr></table></figure>

<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>union，表面上与struct非常相似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unit xxx&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">&#125;xxx1,xxx2;</span><br><span class="line"></span><br><span class="line">xxx1.a=<span class="number">1</span>;</span><br><span class="line">xxx2.b=<span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>和struct不同的是，union中所有变量（即a,b）占据的是相同的空间，大家联合起来使用同一个空间。<br>比如一个int 4个字节，也可以被看做是char的数组0~3<br>比如char是1234，则转化为十六进制应该是00 00 04 D2<br>我们通过下面的方法来看看是不是这么储存的。<br><img src="https://img-blog.csdnimg.cn/20210327000411512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>占位符的意思是：1.输出两位，即如果不足10要补个0（比如2→02）<br>2.这就是一个字节了，不要再扩展了<br>3.以十六进制输出<br>这个在文件那里还会再讲。<br>我们现在的X86是小端机器，放数的时候其实是小端在前<br>也是很有用的，比如做文件时，比如当我们要把一个整数以二进制形式输到一个文件中去时，可以作为中间的媒介（没懂……）。</p>
<h1 id="12-全局变量"><a href="#12-全局变量" class="headerlink" title="12. 全局变量"></a>12. 全局变量</h1><h2 id="全局变量：定义在函数之外的变量，全局的生存期和作用域"><a href="#全局变量：定义在函数之外的变量，全局的生存期和作用域" class="headerlink" title="全局变量：定义在函数之外的变量，全局的生存期和作用域"></a>全局变量：定义在函数之外的变量，全局的生存期和作用域</h2><p>定义在函数内部的是本地变量。而定义在外面的是全局变量。<br>本地变量最大特点是生存期、作用域都在函数内部，出来就用不了了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> gAll=<span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in %s, gAll is %d&quot;</span>,__func__,gAll);<span class="comment">//__func__是输出当前函数名称</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在主函数中先输出gAll，然后执行函数f，在函数f中把gAll+2,然后返回主函数，再次输出gAll，会发现输出结果是12 14。可见我们可以在任何函数中直接访问、改变全局变量。<br>如果全局变量没赋初值，会自动被赋予0值，不像本地变量会出现奇怪的值。<br>如果是指针的话，没赋初值会得到NULL，因为只能用编译时已知的值来初始全局变量。而初始化发生在main函数前。<br>如果int gAll&#x3D;f();不可以，因为这时候电脑表示他还不知道f()是什么<br>如果<code>int gAll=12; int g2=gAll;</code>也不行（Dev C++可以）<br>但是如果<code>const int gAll=12; int g2=gAll;</code>就可以了。<strong>但是不建议这样做。</strong><br>如果函数内部有和全局变量同名的变量，那么全局变量会被隐藏。<br>比如在主函数中输出gAll，然后进入函数f，int gAll&#x3D;1，输出gAll，再回到主函数再次输出gAll，会得到12 1 12（因为f函数里的gAll生存期就是f）</p>
<h2 id="静态本地变量：能在函数结束后继续保持原值的本地变量"><a href="#静态本地变量：能在函数结束后继续保持原值的本地变量" class="headerlink" title="静态本地变量：能在函数结束后继续保持原值的本地变量"></a>静态本地变量：能在函数结束后继续保持原值的本地变量</h2><p>在本地变量前加上static修饰符，成为静态本地变量。离开函数之后，静态本地变量还会存在。<br>静态本地变量的初始化只会在第一次进入这个函数时做，以后再进入函数时还是会保持上次离开的值。就是即便输入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f()&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">	a+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>f()连续执行三次，不是每次都会a&#x3D;1，而是1 3 3 5 5 7。<br>静态本地变量实际是特殊的全局变量。他们位于相同的内存区域；（可以试着看下全局变量、本地变量、静态本地变量的地址%p，静态本地变量和全局变量地址都是一样的）<br>静态本地变量有全局内的生存期，<strong>但是只有函数内的局部作用域</strong>（static在这里的意思是局部作用域，本地可访问。）</p>
<h2 id="后记：返回指针的函数，使用全局变量的贴士"><a href="#后记：返回指针的函数，使用全局变量的贴士" class="headerlink" title="后记：返回指针的函数，使用全局变量的贴士"></a>后记：返回指针的函数，使用全局变量的贴士</h2><p>关于指针以前讲过，如果指针返回本地变量的地址，这是一件很危险的事情。因为离开函数之后本地变量就不存在了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *p=f();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*p=%d&quot;</span>,*p);</span><br><span class="line">	g();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*p=%d&quot;</span>,*p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *<span class="title function_">f</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">12</span>;</span><br><span class="line">	<span class="keyword">return</span> &amp;i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">24</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;k=%d&quot;</span>,k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出*p&#x3D;12,k&#x3D;24,*p&#x3D;24.<br>可以得知，在函数f中本地变量i那个地址又给了k使用。这就容易出问题。<br>但是全局变量和静态本地变量可以。<br>返回函数在malloc内的地址是安全的，但是也容易出问题。最好的办法是返回传入的指针。<br><strong>tips</strong><br>1.不要用全局变量在函数之间传递参数和结果（可以，但是有问题。详见丰田汽车案？？）。使用全局变量和静态本地变量的函数是线程不安全的，尽量避免全局变量。</p>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>编译预处理指令<br>我们在第一节课就见过了。就是#开头的（#include）。他们不是C语言的一部分，但是C语言离不开他们。<br>现在要定义PI&#x3D;3.14159，我们可以定义一个const的全局变量；但以前没有const的时候，用#define来定义一个宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br></pre></td></tr></table></figure>
<p>这样C语言在编译预处理时会把所有PI变成3.14159。<br>我们可以通过下面的方法看在编译过程中留下来的零始文件<br>gcc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc xxx.c --save-temps</span><br><span class="line">ls-l</span><br></pre></td></tr></table></figure>
<p>可以看到会出现<code>xxx. c</code>,<code> xxx. i</code>, <code>xxx. s</code>, <code>xxx. o</code>, <code>xxx. out</code><br>文件c-&gt;i这一步做了π的替换，i-&gt;s这一步产生汇编代码文件，s-&gt;o产生目标代码文件 ，最后再和其他可链接的东西链接起来生成可执行的out。<br><em>可以发现.i比.c大很多</em><br>如果用tail来输出c和i的结尾部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail xxx.c;</span><br><span class="line">tail xxx.i;</span><br></pre></td></tr></table></figure>
<p>可以看到.i中把已经所有的PI替换为3.14159。<br>同样的，我们也可以<code>#define FORMAT &quot;%f\n&quot;</code>FORMAT是按格式输出。<br>在main函数中写：<code>printf(FORMAT,2*PI);</code>编译出来也是没有问题的。<strong>不过注意如果FORMAT是写在双引号里面，printf输出的就是FORMAT这六个字母了。</strong><br>#define会先对程序进行预处理，把宏都替换掉；<br><code>#define 单词 值</code><br>#define会对后面的值原封不动地进行文本替换，<strong>所以千万小心结尾不要加分号。因为这不是c的语句，c的语句结尾才需要加分号。</strong><br>如果一个宏中嵌套有其他宏的名字，还会再次被替换；<br>如果一个宏的值超过一行，最后一行之前的行末需要加\，应该是处理回车的问题。<br>宏的结尾可以有注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> prt printf(<span class="string">&quot;123&quot;</span>);\</span></span><br><span class="line"><span class="meta">			printf(<span class="string">&quot;456&quot;</span>);</span></span><br></pre></td></tr></table></figure>
<p>我们还可以定义没有值的宏<code>#define -DEBUG</code>用来做条件编译，例如如果存在编译这一部分代码；如果不存在编译其他部分代码。<br>c编译器里有一些预先定义的宏，可以直接用的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__LINE__<span class="comment">//行号</span></span><br><span class="line">__FILE__<span class="comment">//文件名</span></span><br><span class="line">__DATE__<span class="comment">//编译时日期</span></span><br><span class="line">__TIME__<span class="comment">//编译时时间</span></span><br><span class="line">__STDC__</span><br></pre></td></tr></table></figure>

<h2 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h2><p>还可以定义像函数一样的宏，带参数。<br><code>#define cube (x)((x)*(x)*(x))</code><br>第一个括号内是单词名字，后面是它的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cube(<span class="number">5</span>));<span class="comment">//输入tail 文件名，输出((5)*(5)*(5))</span></span><br></pre></td></tr></table></figure>
<p>也可以括号内做运算，如输出cube(i+2)。<br><strong>一些细节</strong><br>x要加括号。否则比如：（rad to deg 弧度制转化为角度制）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RADTODEG(x) (x*<span class="number">57.29578</span>);</span><br><span class="line">RADTODEG(x) (x)*<span class="number">57.29578</span>;</span><br><span class="line">RADTODEG(x) ((x)*<span class="number">57.29578</span>);</span><br></pre></td></tr></table></figure>
<p>如果x&#x3D;5+2，第一个计算的就是5+2<em>57.29578；<br>如果计算180&#x2F;RADTODEG(1)，第二个计算的就是180&#x2F;1</em>57.29578。这样就能看出来如果宏带有参数，整个宏的值和每个参数都要有括号。<br>可以带有多个函数<br><code>#define MIN(a,b) ((a)&gt;(b)? (b):(a))</code><br>也可以嵌套、组合使用其他宏。<br><strong>千万不要加分号，这不是c的语句</strong>，比如if和else中间多了个加分号的宏，展开时就会有两个分号；第二个分号相当于有个空行，就把if和else分开了。<br>大型的参数中，带参数的宏非常常见，运行效率比函数高。（牺牲空间换取效率）<br>宏有一个缺点：没有类型检查。<br>C语言有inline机制，有类型检查，也许会逐渐取代宏。<br>还有很多编译预处理指令，比如条件编译、error等等，这些补充内容本课中不会讲到了。</p>
<h1 id="13-文件和位运算"><a href="#13-文件和位运算" class="headerlink" title="13. 文件和位运算"></a>13. 文件和位运算</h1><h2 id="多个源代码文件"><a href="#多个源代码文件" class="headerlink" title="多个源代码文件"></a>多个源代码文件</h2><p>main中的代码太长，可以分出几个函数；而一个源代码文件(.c)太长可以分出很多.c文件。<br>如果我们直接把函数拿到另一个源代码文件里，编译很明显不会通过。我们需要新建一个项目。<br>新建-项目，选择console application终端应用，把它保存到和两个目标源代码文件同一个文件夹里。<br>新建之后会自带一个.c文件，这个是假的，删掉即可。然后项目-添加，添加两个目标源代码文件，这样就可以编译并运行了。<br>对于一个项目，Dev C++会把里面所有的文件编译并链接起来。<br>其实Dev C++是个比较特殊的(IDE)集成开发环境，绝大多数其他的IDE都需要你先建一个项目（哪怕只有一个源代码文件），然后才能进行其他操作。<br>比如有的IDE是有编译和构建两个按钮，前者对单个源代码文件进行编译，后者对所有源代码文件链接。因为一个源代码文件是一个编译单元，编译器每次只对一个编译单元进行编译（形成.o目标代码文件）。</p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>在刚才的多个源代码文件中，我们在main文件里有加入一条声明：<br><code>int max(int a,int b);</code>如果不加这条声明，其实C语言也会默认a和b是Int类型的。<br>可是如果a,b都是double，我们又不加声明呢？输出了一个奇怪的大数字。<br>main中默认a,b是int→传入double 的max→以int形式传回来，链接的确没有问题，但传入传出都是错的。<br>如何让他们一致？我们需要头文件。<br>1.再新建一个源代码文件，会提示要不要在项目中添加，点yes；<br>2.命名为.h的文件（如max.h）输入一句话，就是那句函数的原型<br><code>int max(int a,int b);</code><br>3.在所有调用这个函数的源代码文件：main.c和max.c文件中都加入该头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;max.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>这下如果两边的max函数类型不一样，编译就会提示有问题了。<br>#include是一个编译预处理指令，会把该头文件下的所有内容原封不动地插入他所在的地方；因此也不是必须在最开头。<br>注意到#include后面的括号有两种：<br>“”：先去找系统内指定目录有没有这个头文件，没有再去当前目录找。<br>&lt;&gt;：只在系统内找这个头文件。<br><img src="https://img-blog.csdnimg.cn/20210405152044555.png" alt="在这里插入图片描述"><br>这样查看stdio.h里都有什么<br>关于#include的误区：#include不是用来引入库的。而是<strong>原封不动地把库里的东西插入到这一行来</strong><br>stdio.h里只有printf的原型，其代码在另外的地方。比如windows在.lib里，unix在.a里。而stdlib.h里有malloc的原型<br>而现在的C语言编译器会默认引入所有标准库<br>#include&lt;stdio.h&gt;只是为了让编译器知道printf函数的原型，保证调用时给出的参数值是正确的类型。<br>应该在使用、定义该函数的地方都包含该头文件，把所有对外公开的函数的原型和全局变量的声明都放进去。<br><strong>全局变量也可以在多个源代码文件中共享；不过也像函数一样要有恰当的方法。</strong><br>如果在函数前加static：只能在该源代码文件中使用<br>如果在全局变量前加static：只能在该编译单元中使用。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>上节课的问题：怎样让全局变量在多个.c文件中共享？<br>在.h中输入<br><code>extern int gAll;</code><br><code>int x;</code>是变量的定义；<code>extern int x;</code>是变量的声明。<br>声明不产生代码（单纯地记住这句声明：这个项目中不管在哪里，有一个全局变量gAll）；而定义产生代码。<br>只有声明才可以被放在头文件中。否则一个项目中多个编译单元里会有重名的实体。<br>重复声明：同一个头文件中，同名的结构不能被重复声明。如果头文件里有结构的声明，很难这个文件不会在一个编译单元里被#include多次。（比如我们在max.h里定义过该struct，然后在min.h里要用到这个结构就会#include”max.h”；这样在主函数中就要#include”max.h”  #include”min.h”，就会重复声明，再次出现在.i中。尽管再怎么避免这件事的发生，在.h中加入了结构，还是很有可能会发生的。）<br>为了解决这种情况，我们需要在max.h和min.h开头加入标准头文件结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAX_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAX_H__<span class="comment">//如果没有定义过max.h则定义max.h</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中间是声明</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这样，只要max.h被定义过了，在其他头文件就不会被重复#include了。<br>#pragma once也能起到相同的作用，但是并不是所有的编译器都支持。所以还是用标准头文件结构。</p>
<h2 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h2><p>从第一天学c语言就接触到了printf和scanf.下面彻底研究下占位符%d有多少细节。<br>printf: <code>%[flags][width][.prec][hIL]type</code><br>flag：标志，有以下几种</p>
<table>
<thead>
<tr>
<th>flag</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>左对齐（和width一起用）</td>
</tr>
<tr>
<td>+</td>
<td>输出前面带正负号</td>
</tr>
<tr>
<td>(space)</td>
<td>正数留空</td>
</tr>
<tr>
<td>0</td>
<td>空格用0填充（不能和-同时使用）</td>
</tr>
<tr>
<td>width（宽度）或prec</td>
<td></td>
</tr>
<tr>
<td>width或prec</td>
<td>含义</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>number</td>
<td>最小字符数（包括小数点）</td>
</tr>
<tr>
<td>*</td>
<td>下一个读入的参数是字符数</td>
</tr>
<tr>
<td>.number</td>
<td>小数点后面的位数</td>
</tr>
<tr>
<td>.*</td>
<td>下一个参数是小数点后的位数</td>
</tr>
<tr>
<td>hIL：类型修饰符</td>
<td></td>
</tr>
<tr>
<td>类型修饰</td>
<td>含义</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>hh</td>
<td>单个字节</td>
</tr>
<tr>
<td>h</td>
<td>short</td>
</tr>
<tr>
<td>l</td>
<td>long</td>
</tr>
<tr>
<td>ll</td>
<td>long long</td>
</tr>
<tr>
<td>L</td>
<td>long double</td>
</tr>
<tr>
<td>type：类型</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td>用于</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>i或d</td>
<td>int</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
</tr>
<tr>
<td>o</td>
<td>八进制</td>
</tr>
<tr>
<td>x</td>
<td>十六进制</td>
</tr>
<tr>
<td>X</td>
<td>大写字母的十六进制</td>
</tr>
<tr>
<td>f或F</td>
<td>float, 6</td>
</tr>
<tr>
<td>e或E</td>
<td>指数</td>
</tr>
<tr>
<td>g</td>
<td>float</td>
</tr>
<tr>
<td>G</td>
<td>float</td>
</tr>
<tr>
<td>a或A</td>
<td>十六进制浮点</td>
</tr>
<tr>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>s</td>
<td>字符串</td>
</tr>
<tr>
<td>p</td>
<td>指针</td>
</tr>
<tr>
<td>n</td>
<td>读入&#x2F;写出的个数</td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/img_convert/6c7df1265cac54661ecbc7d56f261a38.png" alt="在这里插入图片描述"></td>
<td></td>
</tr>
<tr>
<td>%n是当操作做到这里时，已经输出了多少个字符，并且填到指针所指的变量里。</td>
<td></td>
</tr>
<tr>
<td>scanf: <code>%[flag]type</code></td>
<td></td>
</tr>
<tr>
<td>flag</td>
<td>含义</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>*</td>
<td>跳过</td>
</tr>
<tr>
<td>数字</td>
<td>最大字符数</td>
</tr>
<tr>
<td>hh</td>
<td>char</td>
</tr>
<tr>
<td>h</td>
<td>short</td>
</tr>
<tr>
<td>l</td>
<td>long, double</td>
</tr>
<tr>
<td>ll</td>
<td>long long</td>
</tr>
<tr>
<td>L</td>
<td>long double</td>
</tr>
<tr>
<td>type</td>
<td>用于</td>
</tr>
<tr>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>d</td>
<td>int</td>
</tr>
<tr>
<td>i</td>
<td>整数，可能是十六进制或八进制</td>
</tr>
<tr>
<td>u</td>
<td>unsigned int</td>
</tr>
<tr>
<td>o</td>
<td>八进制</td>
</tr>
<tr>
<td>x</td>
<td>十六进制</td>
</tr>
<tr>
<td>a, e, f, g</td>
<td>float</td>
</tr>
<tr>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>s</td>
<td>字符串（单词）</td>
</tr>
<tr>
<td>[…]</td>
<td>所允许的字符</td>
</tr>
<tr>
<td>p</td>
<td>指针</td>
</tr>
<tr>
<td>%i会根据输入（如0x12、012）来判断是十六进制还是八进制还是十进制。</td>
<td></td>
</tr>
<tr>
<td>[…]举例</td>
<td></td>
</tr>
<tr>
<td>GPS中会读到一串字符，用逗号分隔</td>
<td></td>
</tr>
<tr>
<td><img src="https://img-blog.csdnimg.cn/c5275fbd01b84b269fc5941013c21ef1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></td>
<td></td>
</tr>
<tr>
<td>占位符<code>%[^,]</code>表示读入逗号前的所有字符</td>
<td></td>
</tr>
<tr>
<td>printf和scanf是有返回值的。scanf是返回几个item，即这次读入了几个<strong>变量</strong>；而printf则是这次输出了多少个<strong>字符</strong>。因此当我们面对要求严格的程序，比如长期运行的大程序，就需要判断每次调用scanf和printf的返回值来了解程序运行中是否会存在问题。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p>我们之前运行程序的时候在命令行里输入.&#x2F;test（test是文件名）即可。<br>对文件做输入输出：.&#x2F;test &gt; 12.out，然后再输入scanf标准输入的内容，但是程序没有printf标准输出了。但是打开12.out文件（输入more 12.out），会输出标准输入和标准输出。<br>同样，当我们输入 cat &gt;12.in ，输入标准输入，然后再Ctrl D结束程序，再查看12.in文件（输入more 12.in）会输出标准输入。<br>然后运行test文件的时候这样写：.&#x2F;test &lt; 12.in，12.in的内容会输入给.&#x2F;test，然后我们会得到其输出。<br>（当然还可以.&#x2F;test &lt; 12.in &gt; 12.out，输入是文件，输出也是文件。12.out里也有我们所期望的结果。）<br>以上是程序运行中的重定向。我们用&lt;来指定一个文件的输入，用&gt;来指定输出到一个文件中。<br>然而这并不是一般的文件输入输出方式，一般的方式需要做一个FILE，在stdlib.h中已经声明好过。<br><img src="https://img-blog.csdnimg.cn/7833df6bba82491a905fb29beb0a3fb4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>用fopen打开文件打开后用fscanf和fprintf函数来读写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE* fp=fopen(<span class="string">&quot;file&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//file是文件名，r表示读</span></span><br><span class="line"><span class="keyword">if</span>(fp)&#123;<span class="comment">//如果没打开，会返回NULL</span></span><br><span class="line">	<span class="built_in">fscanf</span>(fp,...);<span class="comment">//读文件。省略号的东西和正常的scanf一样了。后面还可以printf</span></span><br><span class="line">	fclose(fp);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;&#125;<span class="comment">//无法打开的反馈。如：输出 无法打开文件</span></span><br></pre></td></tr></table></figure>
<p>直接.&#x2F;test运行即可，会打开12.in然后正常输出。<br>如果删掉12.in(rm 12.in)就无法打开文件。<br>fopen第一个参数是文件名的字符串，第二个参数字符串用途如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>打开只读</td>
</tr>
<tr>
<td>r+</td>
<td>打开读写，从文件头开始读&#x2F;写</td>
</tr>
<tr>
<td>w</td>
<td>打开只写，如果不存在则新建，如果存在则清空</td>
</tr>
<tr>
<td>w+</td>
<td>打开读写，如果不存在则新建，如果存在则清空</td>
</tr>
<tr>
<td>a</td>
<td>打开追加，如果不存在则新建，如果存在不清空，从文件尾开始</td>
</tr>
<tr>
<td>在结尾加x</td>
<td>只新建，如果文件已存在则不能打开</td>
</tr>
</tbody></table>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>所有文件最终都是二进制的。文本文件，只是用一种简单的方式可以进行读写的文件。如more, tail 可以打开文件，cat 打开文件或定向到其他文件，vi 做完整的编辑，etc。但是二进制没这么简单。<br>选择文本还是二进制？<br>UNIX（和windows一样都是操作系统。）喜欢用文本文件储存数据、配置程序。交互式终端的出现（类似windows的cmd窗口）使得人们喜欢用文本和计算机“交流”。因此，UNIX的shell就提供了一些读写文本的小程序。<br>windows（更准确要说DOS），个人计算机的制作者并不继承、熟悉UNIX文化（宛如在围墙之外，不熟悉围墙内）全凭自己的理解做出草根文化的DOS，更喜欢用二进制文件。<br>PC和DOS刚开始的时候能力有限，二进制更加接近底层。<br>文本、二进制各有优劣。<br>文本方便人类读写，而且跨平台；缺点是程序的输入输出要经过格式化，开销大。<br>二进制的缺点是人类读写困难而且不跨平台；（如不同计算机int大小不一致）优点是读写快。<br>在这里，我们要回顾下为什么程序要使用文件。</p>
<ol>
<li>有配置（比如窗口大小、字体颜色）UNIX用文本文件就能编辑，Windows是用一个大文件：注册表编辑。</li>
<li>数据：保存数据，如学生成绩。稍微大一些的数据都放数据库那了。</li>
<li>媒体：如图片音频，这些不能是文本文件，只能是二进制文件。<br>其实现在程序通过第三方库来读写文件，很少直接读写二进制文件了。<br>对二进制的读写<br><img src="https://img-blog.csdnimg.cn/315f53aa992043e0b61922ea6c69283d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第一个参数是指针，要读写的内存；第二个参数是那块内存（一个结构）的大小；第三个参数是有几个这样的内存，第四个参数是文件指针。返回成功读写的字节数。<br>因为二进制文件的读写一半是通过对一个结构变量的操作来进行的，所以nitem就是用来说明这次读写了几个结构变量。<br>这里老师做了一个非常有意思的东西，建议去看看（我懒了）<br>fwrite可以把数据以二进制形式写到文件中，fread类似。<br>定位：找出现在处在文件中的位置，或跳到指定位置。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">/*whence：SEEK_SET 从头开始</span></span><br><span class="line"><span class="comment">SEEK_CUR 从当前位置开始</span></span><br><span class="line"><span class="comment">SEEK_END 从末尾开始*/</span></span><br></pre></td></tr></table></figure>
如：<code>fseek(fp, 0L, SEEK_END);</code>当前位置就在结尾了。这时如果我们令<code>long size=ftell(fp);</code>得到的就是文件大小。<br>我们可以先这样获得文件大小，然后除以sizeof来得知内部储存了多少个数据；然后用户说我想看第几个数据，我们再利用fseek函数跳到那个位置，输出每一项。<br>这样的二进制文件不具备可移植性；即在int为32位的机器上写出的数据文件不能在int为64位的机器上正确读出。解决方案1是放弃int，使用typedef具有明确大小的类型；2是用文本。</li>
</ol>
<h2 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h2><p>按位运算，即把整数当做二进制进行运算。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>·&amp;</td>
<td>按位的与</td>
</tr>
<tr>
<td>·|</td>
<td>按位的或</td>
</tr>
<tr>
<td>·~</td>
<td>按位取反</td>
</tr>
<tr>
<td>·&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>·&gt;&gt;</td>
<td>右移</td>
</tr>
<tr>
<td><strong>按位与 &amp;</strong></td>
<td></td>
</tr>
<tr>
<td>如果<code>(x)_i==1且(y)_i==1</code>，那么(x&amp;y)_i&#x3D;1（第i位）否则&#x3D;0</td>
<td></td>
</tr>
<tr>
<td>如：</td>
<td></td>
</tr>
<tr>
<td>0101 1010 5A</td>
<td></td>
</tr>
<tr>
<td>1000 1100 8C 做运算后：</td>
<td></td>
</tr>
<tr>
<td>0000 1000 08</td>
<td></td>
</tr>
<tr>
<td>按位与的应用：</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li><p>让某一位或某些位&#x3D;0，如x &amp; 0xFE（1111 1110） 会让最后一位变为0</p>
</li>
<li><p>取某个数中的某一段：如x &amp; 0xFF (在32位int中是 0000 0000 0000 0000 0000 0000 1111 1111）这样只会留下最后8位<br> 按位或<br>应用：</p>
</li>
<li><p>使得某一位&#x2F;某几位变为1： x | 0x01</p>
</li>
<li><p>把两个数拼起来： 0x00FF | 0xFF00</p>
</li>
</ol>
<p>按位取反：0变为1,1变为0<br>和补码不太一样，补码是用1 0000 0000-该数。可以试下(char)~c和(char)-c的值。<br>逻辑运算，相当于把所有非0值变为1后做按位运算。<br>因此还是有不同的，如果忘记逻辑运算是两个&amp;|的话就会出问题。<br>按位异或^，两位相等结果为0，两位不等结果为1.<br>对同一个值做两次异或，还是原来的值。可以拿来做加密的编码，也可以判断两段码是否相等。</p>
<h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><p>i&lt;&lt;j：i中所有位向左移动j个位置，右边填入0<br>所有小于int的类型，移位以int的方式做，结果是int。<br>往左移1位就等价于乘了2.最多移动多少位取决于int的大小。x&lt;&lt;1<br>右移相当于&#x2F;2。<br>对于小于int的类型，移位以int的方式做，且结果是int；<br>对于unsigned类型，左边填0<br>对于signed类型，左边填入原来的最高位（判断符号的01），保持符号不变。而往左移动的时候是不管符号位的。<br><strong>移位的位数不要用负数，这是没有定义的行为！</strong></p>
<h2 id="位运算例子"><a href="#位运算例子" class="headerlink" title="位运算例子"></a>位运算例子</h2><p>有什么用处？<br>例1：输出一个数字的二进制<img src="https://img-blog.csdnimg.cn/a53db9fa01cc4a4eb879f037023e958c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>unsigned后面没有跟类型，则是默认为unsigned int。<br>mask依次是<br>1000 0000<br>0100 0000<br>0010 0000<br>…<br><img src="https://img-blog.csdnimg.cn/65a8051495764a2591e167e33f00a79d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样每一位依次取余，看每一位。<br>另外一件事：做单片机时常遇到这样的特殊功能寄存器（SFR）<br><img src="https://img-blog.csdnimg.cn/e496aecfb5674ba4b1032c73ce6af982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>怎么把对应比特置为0或1？<br><img src="https://img-blog.csdnimg.cn/3ea1897a45ee46c58fa0dfb8b34e8939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第几位就是1u&lt;&lt;几<br>如SBS是1，左移2位是100<br>PE是1，左移3位是1000<br>   100<br> 1000<br> 1100（或后得到的结果）<br> 用或使某些比特为1，用和使某些比特为0。</p>
<h2 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h2><p>在SFR表中可知，有的也不止一个比特。但之前的技巧只能控制一个比特。<br>如何控制多个比特？位段，把一个int的若干位组合成一个结构。<br><img src="https://img-blog.csdnimg.cn/5b55e7fbca914f539618dadfe3e240ee.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>冒号后面的数字表示 该成员占几个比特。<br><img src="https://img-blog.csdnimg.cn/9f5dd64930a3484e82e04f80d8e3a193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>prtBin函数就是刚刚看过的输出二进制位。<br>输出：sizeof(uu)&#x3D;4<br>二进制输出后五位10010<br>当我们把uu.trailing&#x3D;0注释掉后，sizeof(uu)没变，但是二进制位输出变了。后五位仍然是10010，前面没有赋初值（没有让trailing&#x3D;0），是乱七八糟的0和1.<br>当我们int trailing&#x3D;32，仍然让uu.trailing&#x3D;0，这时sizeof(uu)&#x3D;8（所有位数加起来超过了32，所以用两个int来表达）二进制输出仍然只有后五位10010.<br>位段可以直接用位段的成员名称来访问，比移位、与、或还要方便。<br>编译器会安排其中的位的排列，不具有可移植性（比如老师的例子是从最右边排起，可能自己试验时会从最左边排。）所需要的位超过一个int时会安排多个int。<br>总而言之，位段是操作和硬件相关的底层操作。</p>
<h1 id="14-可变数组"><a href="#14-可变数组" class="headerlink" title="14. 可变数组"></a>14. 可变数组</h1><p>之前的数组是固定大小的，运行过程中无法改变。只能说尽量大一些。<br>resizable array<br>growable 可变大的<br>get the current size 能知道现在的大小<br>access to the elements 能访问其中单元<br><img src="https://img-blog.csdnimg.cn/90ec8639fe1f41d5961988f135cd0a28.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>create：创建数组<br>free：回收数组空间<br>size：告知单元数量<br>at：访问某个单元<br>inflate：长大<br>结构Array 包括*array指针和size大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array <span class="title function_">array_create</span><span class="params">(<span class="type">int</span> init_size)</span>&#123;</span><br><span class="line">	Array a;</span><br><span class="line">	a.size=init_size;</span><br><span class="line">	a.<span class="built_in">array</span>=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*init_size);</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么不返回Array<em>指针呢？<br>因为a是本地变量，返回Array</em>就无效了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_free</span><span class="params">(Array *a)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">	<span class="comment">//保险起见，令a-&gt;size=0, a-&gt;array=NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="可变数组的数据访问"><a href="#可变数组的数据访问" class="headerlink" title="可变数组的数据访问"></a>可变数组的数据访问</h2><p>size：读入结构指针，直接return a-&gt;size即可。<br>既然如此为啥不直接用a.size呢？<br>第一种方法叫做封装，保护a-&gt;size。今后随着版本升级、算法改进，可能a-&gt;size不能直接用了。<br>at</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">array_at</span><span class="params">(Array *a, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;(a-&gt;<span class="built_in">array</span>[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的是指针而不是int，（这样可以赋值，<code>*array_at(&amp;a,0)=10</code>）所以想输出a的值需要加<code>*</code>。<br>如果不习惯函数前加<code>*</code>的写法，也可以创造get和set两个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_get</span><span class="params">(<span class="type">const</span> Array *a,<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> a-&gt;<span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">array_set</span><span class="params">(Array *a,<span class="type">int</span> index,<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">	a-&gt;<span class="built_in">array</span>[index]=value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是另一种写法。</p>
<h2 id="可变数组自动增长"><a href="#可变数组自动增长" class="headerlink" title="可变数组自动增长"></a>可变数组自动增长</h2><p>最后就是inflate自动增长了。但我们malloc的空间是不能长大的，所以我们malloc一块新空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">array_inflate</span><span class="params">(Array *a, <span class="type">int</span> more_size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *p=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(a-&gt;size+more_size);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a-&gt;size;i++)p[i]==a-&gt;<span class="built_in">array</span>[i];<span class="comment">//把老空间里的东西放到新空间里去。</span></span><br><span class="line">	<span class="built_in">free</span>(a-&gt;<span class="built_in">array</span>);</span><br><span class="line">	a-&gt;<span class="built_in">array</span>=p;</span><br><span class="line">	a-&gt;size+=more_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在array_at中判断if(index&gt;&#x3D;a-&gt;size)就增加。增加多少？如果我们需要多少就增加多少， 即inflate中more_size参数是index-a-&gt;size，那每次index增加我们都要多申请。（比如现有空间是9，index需要10，我们就要申请10的空间然后把原来的9放进来再free原来的空间；然后index如果需要11，我们又要再重新申请11……）还不如说每次多申请5个10个的。<br>block概念：每次多申请block，const block_size&#x3D;常数，<br><code>array_inflate(a,(index/block_size+1)*block_size-a-&gt;size);</code>多申请这些空间。<br>因为这些是写在array_at中的，所以在主函数中直接用array_at就可，越界的话会在array_at中自动申请。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(number!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number);</span><br><span class="line">	*array_at(&amp;a,cnt++)=number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是可以无限读入整数，并自动增长的数组。</p>
<h2 id="可变数组的缺陷"><a href="#可变数组的缺陷" class="headerlink" title="可变数组的缺陷"></a>可变数组的缺陷</h2><p>每次长大，都可能会重新申请新的内存空间。</p>
<ol>
<li>每次都要拷贝，很花时间</li>
<li>每次都是在之前的内存结尾申请空间，不断往后排，所以最后其实我们不需要那么多内存空间，但我们的内存空间不够了。</li>
<li>如果我们每次都只申请一块block大的内存，把他们链起来，不需要拷贝了节约时间，也可以充分利用给内存的每一块。</li>
</ol>
<h1 id="15-链表"><a href="#15-链表" class="headerlink" title="15. 链表"></a>15. 链表</h1><p><img src="https://img-blog.csdnimg.cn/a787a8aaa9d1420db7ad02d26aab0149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际上的解决方法是每一块都分为两部分，前一块是数据，后一块是指针，指向下一块。然后还需要指向开头的head，以及结尾不指向任何东西(NULL)。这就是链表（linked-list）。每个块就是结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>
<p>第一个例子：像可变数组一样，不停读入数字直到-1为止。<br><em>这件事回想起来，从平均数就开始做了。一开始我们不需要记录每一个数，只需要求平均数即可。后来讲到数组，需要输出比平均数大的数，就需要记录输入的每一个数，用到数组了。不过数组大小需要用户事先告诉我们。但现在是不知道会读入多少个数。</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number);</span><br><span class="line">	<span class="keyword">if</span>(number!=<span class="number">-1</span>)<span class="comment">//add to linked-list</span></span><br><span class="line">&#125;<span class="keyword">while</span>(number!=<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>首先我们需要有head开头的指针。一开始head指针是NULL，不停往后挂结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node *head=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node *p=(Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">p-&gt;value=number;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//find the last, attach</span></span><br><span class="line">Node *last=head;</span><br><span class="line"><span class="keyword">if</span>(last)<span class="comment">//判断head是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(last-&gt;next)last=last-&gt;next;</span><br><span class="line">	last-&gt;next=p;</span><br><span class="line">&#125;<span class="keyword">else</span> head=p;<span class="comment">//即：p就是第一个结点</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure>


<h2 id="链表的函数"><a href="#链表的函数" class="headerlink" title="链表的函数"></a>链表的函数</h2><p>上面的这些操作（把新的结点挂到上一个结尾）尝试拿出来单独写成一个add函数。<br>函数的参数应该有什么？head头指针，以及每次要传入的数据data。</p>
<p><strong>错误的方案1</strong>：<br><code>void add(Node *head,int number);</code><br>每次新定义一个临时结点p，p-&gt;last&#x3D;number，p-&gt;next&#x3D;NULL;然后我们把这个结点挂在链表的末尾。<br>有两种情况：1、p是链表的第一个元素，即head&#x3D;NULL，那直接令head&#x3D;p完事。<br>2、p不是第一个元素，我们现在只知道链表头是head，我们要先找到last链表的结尾结点，然后把p挂在结尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">last=head;</span><br><span class="line"><span class="keyword">while</span>(last-&gt;next)last=last-&gt;next;<span class="comment">//找到结尾last结点</span></span><br><span class="line">last-&gt;next=p;</span><br></pre></td></tr></table></figure>


<p>但是head&#x3D;p是有问题的，head的值并没有得到修改。如果想不通，可以阅读作者的<a target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq/article/details/119529824">另一篇文章</a>，里面有写作者自己的一些理解。<br>如果我们把head放在外面作为一个全局变量？不好，在全局变量时讲过，不要用head做全局变量。因为add只能对这个链表的head起作用，如果程序中出现其他链表，不能再做操作。<br><strong>方案2</strong>：如果add函数返回指针，然后return 理想的head指针，在函数中令head&#x3D;add函数呢？不错。<br><strong>方案3</strong>：传给add的参数不再是head，而是head的地址。我们知道通过指针可以直接修改该地址中的值。<br><img src="https://img-blog.csdnimg.cn/d58d8a0f6b6143be96948ce6ebf1ed90.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>方案4</strong>：我们定义一个结构list，其中包含*head。在原函数中定义list，list.head&#x3D;NULL；然后把list的指针<code>&amp;list</code>传入add函数，add的参数是list的指针，在函数中就可以对list-&gt;head进行修改。</p>
<p>方案4的好处在于我们用自己定义的list结构来代表整个链表。除了定义的这个head，还可以有tail指向结尾，这样每次last不用遍历整个链表才能找到结尾；等等。<br>这里讲的比较细，是因为链表的放入东西、插入东西都是比较简单的。对于工程化的东西，我们要深究。</p>
<h2 id="链表的搜索"><a href="#链表的搜索" class="headerlink" title="链表的搜索"></a>链表的搜索</h2><p>输出链表中读到的所有东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node *p;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="built_in">list</span>.head;p;p=p-&gt;next)<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,p-&gt;value);<span class="comment">//遍历</span></span><br></pre></td></tr></table></figure>
<p>则这一段可以单独拿出来写作函数，称之为print，参数为list的指针。<br>可见for循环不一定非要是++。<br>然后进一步，我们希望能实现搜索的功能：输入一个数字，在链表中寻找这个数字，如果找到了就将其删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p=<span class="built_in">list</span>.head;p;p=p-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;value==number)<span class="built_in">printf</span>(<span class="string">&quot;找到了！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a>链表的删除</h2><p>删除某个值，我们要做两件事。<br>第一，前面的指针指向他后面的值。<br>第二，free it.<br>也就是说，如果前面的指针是q，我们要删除的部分指针是p，则要q&#x3D;p,p&#x3D;p-&gt;next。<br><img src="https://img-blog.csdnimg.cn/cea76557c5ab45d2978ed5c2f71e1109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>怎么考虑到边界情况？<br><strong>一个很重要的思想</strong>：<br>判断出现在arrow箭头左边的指针变量是否是NULL。如图中for循环内出现了p-&gt;next，p-&gt;value，q-&gt;next.因为在for循环中判断了p会不会是空指针，所以p-&gt;是安全的。但是q-&gt;next就不安全了，没有判断q是否是NULL。<br>也就是说当要删除的节点p是第一个时，q&#x3D;NULL，这就是边界情况。这时可以让head等于所指的next。<br><img src="https://img-blog.csdnimg.cn/74365d3720d047f3bb9855a838ed2065.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后别忘记<code>free(p)</code>.</p>
<h2 id="链表的清除"><a href="#链表的清除" class="headerlink" title="链表的清除"></a>链表的清除</h2><p>所有节点都是malloc出来的，所以最后都要清除干净。<br>可以这样做：令p&#x3D;head，q&#x3D;p-&gt;next<br>每次<code>free(p)，p=q</code>把最开头的清除，直到p&#x3D;NULL时就清除完成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p=head;p;p=q)</span><br><span class="line">&#123;</span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表这里只是简单地介绍了一下。在之后的数据结构等还会深入研究。</p>
<h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><p>至此，老师的课已经全部过了一遍。虽然还有很多没有记住的要点，没有理解的地方，还要反复翻看、实践，结合其他老师的课和学校的教材来看。<br>其实这门课拖拖拉拉的已经听了一年了快。不过对我来说只要能吃透，就是值的。<br>谢谢老师！收藏夹-1.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=1357960253&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>