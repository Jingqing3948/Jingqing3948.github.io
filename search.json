[{"title":"北邮国院笔记：Data Structure 数据结构","url":"/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"前言\n因为考试要求，博主学习的是双语的数据结构，因此自己总结一些英文的概念、知识点。希望也可以对读者学习这门课程有所帮助~\n特别感谢许可老师的教导！\n理解时间复杂度的定义\n（本课程涉及到的所有算法，都需要记住时间复杂度O）\nData structure notes\nProgram = Algorithm + Data Structure\nAn algorithm is a finite set of instructions that, fi followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:\n\nInput\nOutput\nDefiniteness\nFiniteness\nEffectiveness\n\nNote:\nA program is written in some programming language, and does not have to be finite.\nAn algorithm can be described by human languages, flow charts, some programming languages, or pseudocode.\n引入 time complexities 和 space complexities 的概念。\n$2^n^&gt;n^2^&gt;nlogn&gt;n&gt;logn&gt;1$\n单词：\nAlgorithm 算法\nDefiniteness 确定性\nFiniteness 有限性\nEffectiveness 有效性\nFinite 有限的\nPseudocode 伪代码\nAssumptions 假设\nAsymptotic 渐近线的，渐近的\nNotation 记号，标记法\nFor loops for循环\nNested 嵌套\nConsecutive statements 顺序语句\nFibonacci 斐波那契\nEuclid 欧几里得\nExponentiation 幂\nPow 指数\n【表】\n理解链表、数组的特点（优缺点）\n会代码实现：单链表 循环链表 双向链表……\n【栈和队列】\n理解原理，会算法：两种实现方法\n会应用算法，如：中序后序互转；前中后缀表达式互换；栈（队列）操作后的状态\nADT\nADT(Abstract Data Type) is a data type that is organized in such a way that the specification  on the objects and specification of the operations on the objects are separated from the representation of the objects and the implementation on the operations.\nThe List ADT\n\nArray implementation\n\n\nMaxSize has to be estimated. （大小必须事先给出。给小了数组越界；(可以再申请)给大了太浪费空间）\nFind_Kth takes O(1) time. （随机存取）\nInsertion and Deletion not only take O(N) time, but also involve a lot of data movements which takes time.（插入删除不方便，需要移动大量元素；存储密度高）\n\n\nLinked Lists（是否带有头结点）\n\n\n三种操作：Find_Kth、Find_Value、Find_Length take O(N) time. 注意循环逻辑，以及有无头结点时对边界情况的处理\n找前一个结点不方便，只能重新从头遍历、\n\nDoubly Linked Lists\n找前一个结点更方便。注意初始化、插入、删除、双向遍历的区别。\nCircular Lists\n头尾相接的单链表。注意判空条件（L-&gt;Next==L）、判断表尾结点条件(p-&gt;Next==L)以及插入删除时修改的操作。\n双向循环链表不再赘述。\nApplication: The polynomial ADT\n多项式求和、求积函数，使用链表更好，因为如果出现形如x^100000^+x^5^+x^1^这种，数组会浪费大量空间，而单链表只需要将系数非0的部分申请空间创造结点。\n（也可以建立十字链表，两个维度分别存储系数和指数）\nCursor Implementation of Linked Lists (no pointer)\n可以使用一个游标int Cursor来作为指针，游标移动访问数组，从而实现类似于指针移动的操作。\nThe cursor implementation is usually significantly faster because of the lack of memory management routines.\nThe Stack ADT\nA Stack is a Last-in-First-Out (LIFO) list. An ordered list in which insertions and deletion are made at the top only.\n类似于一堆书，放书和拿书都只能从最顶上进行。最后放上的书最早被拿出来。\nPush: 入栈\nTop: 读取并返回栈顶元素\nPop: 栈顶元素出栈\nApplication 1: Balancing symbols 括号匹配\n输入一串表达式，判断其中的括号()[]{}是否匹配。\n检验方法：每个右括号都和离他最近的，也就是最晚输入的左括号匹配，正符合栈的后进先出原则。\n读到左括号的时候入栈，读到右括号的时候与栈顶的左括号比较，比较后出栈。\n最后结束输入，还要检查一下栈是否为空，若非空，栈内剩下的括号全都不匹配。\n7-1 Balancing symbols 代码实现\nApplication 2: Postfix Evaluation 后缀表达式的计算\nInfix expression中缀表达式： a + b * c - d / e\nPrefix expression 前缀表达式：- + a * b c / d e\nPostfix expression 后缀表达式： a b c * + d e / -\n中缀表达式更符合人脑的计算方法，而后缀表达式更符合计算机的计算方法。\n实际上在计算机中计算表达式，是先转化为postfix expression，再进行计算的。\n转换方法：\n建立堆栈。\n\n读入的字符是操作数：直接输出\n读入的字符是操作符：\na)\t堆栈是空的，则直接存入堆栈中（push）\nb)\t该操作符的优先级&gt;栈顶元素操作符，则直接入栈（push）\nc)\t该操作符的优先级&lt;=栈顶元素操作符，则栈顶元素出栈（pop），直到该操作符的优先级大于栈顶元素（这个栈顶元素也要出栈），然后该操作符入栈（push）\nd)\t操作符是左括号，则直接入栈（pop），遇到右括号之前永不输出\ne)\t操作符是右括号，则一直出栈（pop）直到左括号出栈\nf)\t最终输入结束，栈若非空，栈中元素全部出栈。\n\n7-2 Infix to postfix Conversion 代码实现\nThe Queue ADT\nA Queue is a First-In-First-Out (FIFO) list. An ordered list in which insertions take place at one end and deletions take place at the opposite end.\n就像日常生活中的排队，先来后到，先排的有机会先出。\nEnQueue: 入队\nDeQueue: 出队\nCircular Queue：循环链表\nApplication: who is the last\n输入n、m；n个人坐成一个圈，从第一个人开始报数，每m个人淘汰掉第m个人，然后下一个人继续重新报数。问：谁能留到最后？\n7-4 who is the last 代码实现\n树\n【基本概念】各类树的度、高、深、节点数与叶子节点的关系；孩子兄弟节点树；\n【二分检索树】：概念 平衡二叉树 完全二叉树 满二叉树 AVL树…… 会插入 删除；\n【遍历树】：先序 后序 中序 层序；会代码创建树和检索、会执行画图\n【B-树】：会画图 构建B-树，增加节点，删除节点 B-树\n【霍夫曼树】：理解原理 给出数据 会画霍夫曼树的图；节点关系\n理清各种树之间的关系\nTree\nConception\n\ndegree of a node: number of its subtrees\ndegree of a tree: max{degree(node)}\nparent;children;siblings\nleaf:a node with degree 0\npath from n_1 to n_k: a unique sequence of n_1, n_2 …… n_k (n_i is the parent of n_{i+1})\nlength of path: number of edges on the path\ndepth of n_i: path to root (depth(root)=0)\nheight of n_i：length of the longest path from n_i to a leaf.(Height(leaf)=0)\nancestors of anode: all the nodes along the path from the node up to the root\ndescendants of a node: all the nodes in its subtrees\n\nRepresentation\nFirstChild-NextSibling Representation\nEach Node carries its element and 2 pointers. The first points its FirstChild; The second points its NextSibling.\nThis representation is not unique since the children in a tree can be of any order.\nBinary Trees\na tree in wh ich no node can have more than 2 children.\nRotate the FirstChild-NextSibling tree clockwise by 45°\nTree Traversals (significant!)\nPreorder Traversal\nvisit This Node first;\nvisit its child recursively.\nPostorder Traversal\nvisit its child recursively;\nAt last, visit this node itself.\nLevelorder Traversal\nvisit Tree via a queue.\n\nEnqueue root node;\nwhile(queue is not empty){\nvisit first node in queue and Dequeue;\nfor its each child, enqueue.}\n\nInorder Traversal(for binary trees)\nRecursive:\n\nvisit left tree recursively.\nvisit root node.\nvisit left tree recursively.\nIterative:\n\nvoid iter_inorder(Tree)&#123;\tStack S;\tfor(;;)\t&#123;\t\tfor(;tree;tree=tree-&gt;Left)Push(tree,S);\t\ttree=Top(S);Pop(S);\t\tif(!tree)break;\t\tvisit(tree-&gt;Element);\t\ttree=tree-&gt;Right;\t&#125;&#125;\ninorder traversal: infix expression\npreorder traversal: prefix expression\npostorder traversal: postfix expression\nDepth is a evry important conception. we can use a function to calculate it:\nstatic void ListDir(DirOrFile D,int Depth)//at first, Depth is 0&#123;\tif(D is a legitimate entry)&#123;\t\tPrintName(D,Depth);\t\tif(D is a directory)\t\t\tfor(each child C of D)\t\t\t\tListDir(C,Depth+1);\t&#125;&#125;\nThreaded Binary Trees\n\nIf tree-&gt;Left is null, 指向中序遍历的前一个结点  a pointer to the inorder predecessor of Tree.\nIf tree-&gt;Right is null, 指向中序遍历的前一个结点  a pointer to the inorder successor of Tree.\n最开头、最结尾结点的左、右指针指向head node. There must not be any loose threads. Therefore a threaded binary tree must have a head node of which the left child points to the first node.\n\nThe Search Tree ADT – Binary Search Trees\n\nEvery node has a key which is an integer, and it’s distinct.\nThe keys in a nonempty left subtree must be smaller than the key in the root of the subtree.\nThe keys in a nonempty right subtree must be larger than the key in the root of the subtree.\nThe left and right subtrees are also binary search trees.\n\ninsert is quite easy while delete not.\nDelete:\n\nif it’s leaf node:just delete it.\nif it’s degree is 1: use its child to replace it.\nif it’s degree is 2: use the largest node in its left subtree or the smallest node in its right subtree to replace it.\nwill the lazy deletion be in the scope of final exam?\nInternal path length: O(Nlog N);depth of any node is O(log N)\n要会计算Average Search Time (AST)\nIf you print Binary Search Tree inorder, then it is an increasing order.\n\nGet Depth: preorder traversal\nint Height(Tree T)&#123;\tif(T==NULL)return 1;\tekse return 1+Max(Height(T-&gt;Left),Height(T-&gt;Right));&#125;\nAVL Trees\nIf the tree is too high, AST can be very large and time complexities is O(N). So we need to balance the height by rotating.\nIf |h_L-h_R|&gt;1,rotate.\n\nSingle Rotation: Trouble is left subtree’s left subtree or right subtree’s right subtree.\n\nTree SingleRotatewithLeft(Tree T)&#123;\tTreeNode LeftTree = T-&gt;LeftChild;\tT-&gt;LeftChild = LeftTree-&gt;RightChild;\tLeftTree-&gt;RightChild = T;\treturn LeftTree;&#125;Tree SingleRotatewithRight(Tree T)&#123;\tTreeNode RightTree = T-&gt;RightChild;\tT-&gt;RightChild = RightTree-&gt;LeftChild;\tRightTree-&gt;LeftChild = T;\treturn RightTree;&#125;\n\nDouble Rotation: Trouble is left subtree’s right subtree or right subtree’s left subtree.\n\nTree DoubleRotatewithLeft(Tree T) \t\t\t&#123;\tT-&gt;LeftChild = SingleRotatewithRight(T-&gt;LeftChild);\treturn SingleRotatewithLeft(T);&#125;Tree DoubleRotatewithRight(Tree T) \t\t\t&#123;\tT-&gt;RightChild = SingleRotatewithLeft(T-&gt;RightChild);\treturn SingleRotatewithRight(T);&#125;\nB Trees 要会插入、建立\nInsertion\n考完试补全\n$$\nDepth(M,N)=O(log_{[M/2]}N)\n$$\n$$\nT_{Find}(M,N)=O(log N)\n$$\nForest Empty\nHuffman Tree\nWeighted Path Length, WPL\n$$\nWPL=\\sum^k_{i=1}w_i*l_i\n$$\nHuffman Tree: the binary tree with the minimum weighted path length.\n0 is appended to left branch,\n1 is appended to right branch.\n哈希\n要求：\n会算法 给出散列函数 会画图 会计算比较成功的次数 比较失败的次数 平均查找时间\n【分离链接法】\n【开放定址法】线性探测法 平方探测法 双散列\n【再散列】\nHASHING\n散列表（hashing table）的实现叫散列（hashing）散列是一种用于以常数时间执行插入、删除和查找的技术，但不能排序。\n散列函数（hashing function）是关键字被映射到0～TableSize-1范围内的函数。\n\nmust be easy to compute and minimizes the number of collisions.\nShould be unbiased. For any x and any i, we have that probability(f(x)=i)=1/b. (Uniform hash function)\n** f(x)=x%TableSize**\nTableSize=prime number is good for random integer keys.\n\n处理冲突的办法\nopen addressing 开放定址法\nfind another empty cell to solve collision\nLinear Probing 线性探测法\nf(i)=i (a linear function)\n如果对应位被占了，则往下继续寻找空位。\n下一位是否为空？若为空放入，若不为空检查下一位；\n再下一位是否为空？……\n查找：先去对应位找，如果没找到再继续往下遍历。\nQuadratic Probing 平方探测法\nf(i)=i^2^\n如果对应位被占了，则+1^1；\n若这一位也被占了，则原位置+2^2；\n……\n（也有的算法是±i^2）\n最大加到（n/2）的平方\n查找：先去对应位找，如果没找到再去加1、加4等等位找。\nDouble Hashing 双散列法\n第一个散列函数冲突时，使用第二个散列函数。\nhash2(x)必须不恒等于0！\nTips: hash2(x)=R-(x%R) with R a prime smaller than TableSize, will work well.\nRehashing 再散列\n当插入数据达到N/2时，再散列。\n\n建立一个原表的二倍大的表（接近原表二倍大的素数）\n从原表中读取数据，用新hash function 存到新表中。\n\n堆\n【二叉堆】\n要求：会构建堆 插入 删除； 画图，手动执行中间数据；\nPiority Queue(Heap)\nCan find the element with the highest \\ lowest priority.\n\n\n\n\nInsertion\nDeletion\n\n\n\n\nArray\nO(1)\nfind:O(n) delete:O(n)\n\n\nLinked List\nO(1)\nfind:O(n) delete:O(n)\n\n\nOrdered Array\nfind:O(1) insert:O(n)\nO(1)\n\n\nOrdered Linked List\nfind:O(1) insert:O(n)\nO(1)\n\n\n## complete binary tree\n\n\n\n\nIts nodes correspond to the nodes numbered from 1 to n in the perfect binary tree of height h.\n\n\n\n\nA complete binary tree of height h has between 2^h and 2^{h+1}-1 nodes.\n\n\n\n\nArray representation: BT[n+1](BT[0]is not used)\n\n\n\n\nFor node i:\n\n\n\n\n- parent: i/2\n\n\n\n\n- left child: 2*i\n\n\n\n\n- right child: 2*i+1\n\n\n\n\n\nA min tree is a tree in which the key value in each node is no larger than the key values in its children.\nA min heap :a complete binary tree + a min tree. And the max heap is visa versa.\nInsertion(Min Heap)\nBecause a heap is a complete binary tree, the nth node only has one possible position to insert. Then, if nth node is smaller than its parent:exchange upward will its location is proper.\nfor ( i = ++H-&gt;Size; H-&gt;Elements[ i / 2 ] &gt; X; i /= 2 ) \tH-&gt;Elements[ i ] = H-&gt;Elements[ i / 2 ];      H-&gt;Elements[ i ] = X; \nAnother kind of Insertion is: insert all nodes first, then adjust their location. We need to check from n/2 node. If its children node is smaller than it, choose the smallest node and exchange them. n/2 node go downward until reach the proper location. Then do the same thing to the n/2-1 node until the first node.\nDeletion\nWe only need to delete the root node——the smallest node.\n\nExchange the root node with the last node——the nth node.\ndo the same thing mentioned above in the Italic text: re-arrange the new node.\nIteratively delete root node until delete the whole heap.\n*Those 2 operations’ time complexity are O(log N). Insertion all node is O(nlogn).\n\nFor the perfect binary tree of height h containing 2h+1 - 1 nodes, the sum of the heights of the nodes is 2h+1 - 1 - (h + 1).\nGraph\nG:graph\nV:finite nonempty set of vertices\nE:finite set of edges\nUndirected graph: $(v_i,v_j)$ v_i and v_j are adjacent\nDirected graph: $&lt;v_i,v_j&gt;$ v_i is adjacent to v_j;v_j is adjacent from v_i\nComplete Graph: a graph that has the maximum number of edges\nSubgraph\nPath from v_p to v_q\nLength of a path\nSimple path: v_i1, v_i2 …… v_in are distinct (on the path)  路径上的顶点不重复出现\nCycle Simple path with v_p = v_q\nA graph is connected: every pair of distinct v_i and v_j are connected  图中任意两点都连通\nConnected Component of an undirected G: the maximal connected subgraph\nA tree: a graph that is connected and  acyclic\nA DAG: a directed acyclic graph  有向无环图\nStrongly connected directed graph G: for every pair of v_i and v_j in V(G), there exist directed paths from v_i to v_j and from v_j to v_i.\n(Graph without direction: weakly connected)\nStronhly connected component: the maximal subgraph that is strongly connected\nDegree(v): in-degree and out-degree  进入某个顶点的边数和传出该顶点的边数\nRepresentation of Graphs\nAdjacency Matrix 邻接矩阵法\n二维矩阵存储边信息。如果v_i to v_j 有边，adj_mat[i][j]=1，否则=0.（undirected graph还要考虑双向，同时也要让adj_mat[j][i]=1）\nAdjacency Lists 邻接表法\n每个顶点结点都是一个单链表的头结点，后面挂着他连接的顶点的节点。\n如：\n0-&gt;1-&gt;2\n1-&gt;0\n2-&gt;0\n这就是一个三个顶点的无向图，01、02相连。\nS(n+2e) Space complexities\nTopological Sort\nAOV Network: digraph in which V(G) represents activities and E(G) represents precedence relations 顶点表示事件，边表示事件之间的进程关系。比如A-&gt;B，就是要先做完A才能做B\ni is a predecessor of j: there is a path from i to j  前驱\ni is an immediate predecessor: &lt;i,j&gt;=1.  直接前驱 Then j is called a successor (immediate successor) of i 直接后继\nPartial order: transitive (i-&gt;k,k-&gt;j: i-&gt;j) &amp;&amp; irreflexive (i-&gt;j is impossible)\nAOV network must be a dag (directed acyclic graph)\nTopological order: a linear ordering of the vertices of a graph such that, for any 2 vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.  所有时间都是按完成顺序排序的.\n算法：\n\n找出入度为0的节点\nvisit 该节点，并删除该节点的所有出度边\n再重新寻找入度为0，没有 visit 过的节点，循环往复\n\nIf we use a special box (queue or stack) to sort, T=O(|V|+|E|)\nShortest Path Algorithms 最短路径算法\n两类问题：\n\n从物流中心（一个顶点）往其他所有顶点运输物品，怎样路径最短？\n怎样让所有顶点之间路径总和最短？\n\n1. Single-Source Shortest-Path Problem\nGiven as input a weighted graph, G = ( V, E ), and a distinguished vertex, s, find the shortest weighted path from s to every other vertex in G.\nBreadth-first search 广度优先搜索\nSimilar to the topological order. We will visit every node connect to the fist node (if they haven’t been visit) and Enquque; and Dequeue this node, do the same thing to every node in the Queue.\nJust simply scan the whole table\nT+(|V|^2+|E|)\nDijkstra’s Algorithm 迪杰斯特拉算法\n建立三个数组，final[]标记哥哥顶点是否已经找到最短路径；dist[]最短路径长度；path[]路径上的前驱\n第一次循环：遍历所有结点，找到还没有确定最短路径且dist最小的顶点，final[i]=true\n检查i结点的所有final=false邻接节点，如果把i作为路径上的前驱，最短路径会不会缩短？如果会，更新最短路径长度dist和路径上的前驱path信息。\n进入下一轮循环。\nvoid Dijkstra( Table T )&#123;   /* T is initialized by Figure 9.30 on p.303 */    Vertex  V, W;    for ( ; ; ) &#123;        V = smallest unknown distance vertex;        if ( V == NotAVertex )\tbreak;         T[ V ].Known = true;        for ( each W adjacent to V )\tif ( !T[ W ].Known ) \t    if ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) &#123;\t    \tDecrease( T[ W ].Dist  to\t\t\t T[ V ].Dist + Cvw );\t\tT[ W ].Path = V;\t    &#125; /* end-if update W */    &#125; /* end-for( ; ; ) */&#125;\nnot work for edge with negative cost!\nT=O(|E|log|V|)\nAcylic Graphs\nIf the graph is acyclic, vertices amy be selected in topological order since when a vertex is selected, its distance can no longer be lowered without any incoming edges from unknown nodes.\nT=O(|E|+|V|)\nApplication: AOE(Activity On Edge)Networks\nEC[ j ] \\ LC[ j ] :: the earliest \\ latest completion time for node v_j\nCPM (Critical Path Method)\nCalculation of EC: start from v_0, for any a_i=&lt;v,w&gt;, we have $EC[w]=max_{(v,w)\\in E(EC[v]+C_{v,w})}$\nCalculation of LC: Start from the last vertex v_e, for any a_i = &lt;v,w&gt;, $LC[v]=min_{(v,w)\\in E}(LC[w]-C_{v,w})$\nSlack Time of &lt;v,w&gt;: $LC[w]-EC[v]-C_{v,w}$\nCritical Path: path consisting entirely of zero-slack edges.\nAll-Pairs Shortest Path Problem\nMethod 1: Use single-source algorithm  for |V| times.\nT = O(|V|^3) – works fast on sparse graph. 稀疏图\nMethod 2  O( |V|^3 ) algorithm given in Ch.10, works faster on dense graphs.\nNetwork Flow Problems\nFind Maximum Path from s to t.\nStep 1:  Find any path s -&gt; t in Gr ;\nStep 2:  Take the minimum edge on this path as the amount of flow and add to G_f ;\nStep 3:  Update G_r and remove the 0 flow edges;\nStep 4:  If (there is a path s -&gt; t in G_r )\nGoto Step 1;\nElse\nEnd.\nMinimum Spanning Tree\nis a tree which consists of V(G) and a subset of E(G).\n\nIt is acyclic – the number of edges is |V|-1.\nIt is minimum for the total cost of edges is minimized.\nA minimum spanning tree exists if G is connected.\n\n2 Method of calculating the minimum spanning tree:\n\n\nPrim’s Algorithm\nvery samiliar to Dijkstra’s algorithm. We choose a vertex to start, and every time add a a least cost vertex until all vertex is connected.\n\n\nKruskal’s Algorithm – maintain a forest\nevery time add a a least cost edge &lt;v,w&gt; from E until all vertex is connected.\n\n\nDFS – Depth-First Search\nvoid ListComponents ( Graph G ) &#123;   for ( each V in G )         if ( !visited[ V ] ) &#123;\tDFS( V );               printf(“\\n“);        &#125;&#125;void DFS ( Vertex V )  /* this is only a template */&#123;   visited[ V ] = true;  /* mark this vertex to avoid cycles */    for ( each W adjacent to V )        if ( !visited[ W ] )\tDFS( W );&#125; /* T = O( |E| + |V| ) as long as adjacency lists are used */\nApplications:\n\nUndirected Graphs\nBiconnectivity\nEuler Circuits\n\nNP-Completeness\nKMP\nBasic String Operations\nThe StrAssign、Strcopy、StrCompare、StrLength、Concat and SubString\nString Operations Library (in C)\ngets(str)  //Input a string;\nputs(str) //Output a string；\nstrcat(str1, str2)  // string Concatenation；\nstrcpy(str1, str2, k)  //String copy；\nstrcmp(str1, str2) //String comparision；\nstrlen(str)  //Get the length of string\nPattern Matching algorithm\n旧模式匹配算法：每次不匹配时，子串都从头重新匹配。效率很低\nBasic match algorithm is inefficient\nKnuth-Morris-Pratt (KMP Algorithms)\nWhen dismatch happens, we don’t need to go back to first. We can use a next array to decide where to go back.\nnext[]: compare s[i] and t[j]，if equals then continue comparing following items, else compare s[i] and t [ next[j] ], till end.\nvoid  Get_next( SString T, int  &amp;next[] )&#123;    j = 1 ;  // postfix pointer     k = 0;   //prefix pointer     next[1]=0;    while ( j &lt;= T[0] )     &#123;  if ( k == 0 || T[j] == T[k] )              &#123; ++j ;  ++k ;  next[j]=k; &#125;         else               k = next[k];  // k go back, then compare T[j] with T[ next[k] ]     &#125;// end while&#125;\nFor example:\na  a  b  c  a  a  a  b  c  a  d\n0  1  2  1  1  2  3  3  4  5  6\n","categories":["邮途（北邮国院课内学习）","Lecture"],"tags":["C"]},{"title":"北邮国院笔记：MySQL 数据库","url":"/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93/","content":"前言\n本博客学习自：黑马程序员 mysql 入门网课，b站 骆昊jackfrued 老师 mysql 网课，以及博主自己课内学习的数据库课程，侵删！\n课内学习的课程内容因为是英方课，包括一些不常用的概念和英文，更注重整体框架的理解，大致了解即可。\n安装配置\nMYSQL 的安装配置网上一搜一大把，博主就不在此发表拙见了，安装太久了自己也记不是很清具体方法了。这里指跟随课程学习了 Command Line Client 的安装（说实话，这玩意我自认为没啥用）。\nMysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。\n如果选择的是 zip 下载，应该只会安装一个 mysql 文件包，在程序终端可以使用。\n如果是选择 msi 文件安装，MYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。\n由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。\n常用命令\n其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。\n开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，区别只是其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。\n\n\n\n命令\n作用\n\n\n\n\n\\h, ?, ?\n获取帮助\n\n\n\\c\n清除前面输入的内容（内容输入有误时使用）\n\n\n\\R\n修改 每次输入命令前左侧的提示样式（默认：‘mysql&gt;’）\n\n\n? 需要查看帮助的命令;\n显示该命令的帮助（如：? show）\n\n\nshow databases; show databases();\n查看所有数据库，查看当前所在数据库\n\n\nuse ‘数据库名’;\n选中某个数据库\n\n\n（选中某个数据库后）show tables;\n查看当前数据库中所有表\n\n\nexit / quit\n退出\n\n\n\n关系型数据库\n数据库有很多种结构，mysql 学习的是关系型数据库，说白了就是二维表的结构。\ngraph LR\nR[关系型数据库]-->T[理论基础]\nR-->S[具体表象]\nR-->L[编程语言 SQL]\nT-->A[关系代数]\nT-->C[关系运算]\nT-->P[一阶谓词逻辑]\nS-->Ta[二维表]\nL-->D[DDL]\nL-->M[DML]\nL-->Q[DQL]\nL-->DCL[DCL]\nDDL: create / drop / alter （database 或 schema 数据库名 / table 表名）\nDML: insert / update / delete\nDQL: select …… from\nDCL: grant（授权） / revoke（召回权限）\n\n\n\n正式的关系模型术语\n非正式的日常用语\n\n\n\n\n关系（relation）\n表（table）\n\n\n元组（tuple）记录\n行（row）或记录（record）\n\n\n势（cardinality）\n行数（number of rows）\n\n\n属性（attribute）\n列（column）或字段（field）\n\n\n度（degree）\n列数（number of columns）\n\n\n定义域（domain）\n列的取值集合（pool of legal values）\n\n\n\nER 和 EER 模型\n介绍\n为什么要有 ER 图和 EER 图的存在？\n**真正做项目、设计数据库时，**实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR / json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。\nER 模型\nER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。\n\n相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。\nEER 模型\n以下部分内容有参考自文章：为了彻底搞清楚数据库 E-R 模型设计，我肝了这篇万字长文 - 知乎 (zhihu.com)\n关于两者的具体区分我还有去问b站up主 骆昊jackfrued 老师，老师表示：不用太纠结这个问题，ER图更抽象，可以理解为概念模型图（PowerDesigner）。\n相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。\n泛化层次\n包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。\n子类父类就是类似 Java 的继承，如动物是父类，猫、狗是其子类。子类父类是一对一的关系！\n泛化又叫归纳，就是将几个类的共同属性提取出来作为父类；\n特化又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。\n其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。\nmandatory / optional：父类中的所有属性都必须包含在每一个子类中 / 不用全部继承，选择部分继承即可（完全性限制）\ndisjoint / overlapping：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）\n\n图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D / O，表示 disjoint / overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。\n汇集层次\nAggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。\n\n如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。\n弱实体\n一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。\n\nWorkbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）\n\n在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。\n自动生成的 SQL 语句中，外键下方有两句话ON DELETE NO ACTION ON UPDATE NO ACTION，意为：当外键参考的主键修改/删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改/删除外键在使用的主键。\n同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。\nPower Designer 建模工具，也支持正 / 反向工程，可以生成 SQL 方言。完整版付费。\n数据类型\n数据类型可以通过 ? data types 查看说明，每种数据类型也可以通过 ? 数据类型 查看。\n除了data types 其他可以用?查看的内容可以输入 ? contents 查看。\n\n\n\n数据类型\n作用\n\n\n\n\n整数 (tinyint, smallint, mediumint, int, bigint)\n都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）\n\n\n字符串 (char(位数), varchar(位数), text)\nchar 长度固定，varchar 长度可变\n\n\n小数 (float, double, decimal(总位数, 小数点后位数))\n不要用 float, double！\n\n\n时间日期 (year, date, time, datetime, timestamp)\ndate：年月日time：时间datetime：年月日时分秒timestamp：时间戳，现在距离 1970-1-1 的毫秒数\n\n\nMysql 中的枚举类型 (enum, boolean)\n\n\n\n\nPS:\n\n\n虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。\n\n\n金额等小数一般不会用小数的数据类型存储，而是整数类型/100使用。因为小数形式有误差，比如0.1+0.2=0.30000000004.\n\n\ndecimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。\n\n\n时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。\n\n\n这里了解到了一个很有趣的“千年虫”问题 (漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com))。\n\nGrace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。\n早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022/04/19，就是22/04/19）\n尽管节约了内存空间，但是40年后1999-&gt;2000年时，问题就出现了……对计算机来说，相当于99-&gt;00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。\n如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：\n1.只修改核心关键的医疗、航空、金融、军事领域的程序；\n2.对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。\n\n回到刚才的话题，因此时间戳也并不推荐使用。\n5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符\nDDL\n\n\n\nSQL 语句\n作用\n使用示例\n\n\n\n\ncreate\n创建数据库 / 表\ncreate database `数据库名`; / create table `表名` ( 字段描述 );\n\n\ndrop\n删除数据库 / 表\ndrop database `数据库名`; / drop table `表名`;\n\n\nuse\n选中数据库\nuse `数据库名`;\n\n\nalter\n更改数据库 / 表信息\nalter table `表名` add constraint `约束名` unique (`字段名`);\n\n\n\nPS：\n修改表的引擎 / 更改自增约束初始值是在 create table `表名` () 后面添加的。\ncreate table `表名`()engine = innodb auto_increment=2 comment &#x27;表示例&#x27;;\n约束\n主键约束\nprimary key (`列名`),\n复合主键语法上没错，但是开发使用时非常不好用，因为需要至少两条字段才能唯一确定一条记录。一般不会用。\n如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。\n默认约束\ndefault val; 设置默认值。\n自增约束、非空约束\n都在字段描述后面写即可\n`col_name` int auto_increment not null comment &#x27;列名&#x27;,\n# 创建表时：create table(    id int primary key comment &#x27;id&#x27;;\tage int check (age&gt;=0 &amp;&amp; age&lt;=100) comment &#x27;年龄&#x27;,\tgender char(1) default &#x27;m&#x27; comment &#x27;性别&#x27;);# 修改表时，主键，unique，check，外键用 add，其他用 modifyalter table add primary key(列名);alter  table table_name modify 列名 数据类型  not null;# 如果是 null，就是取消非空约束\n唯一约束\nconstraint `uk_col_name` unique (`col_name`),\n类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）\n检查约束\n检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。\nconstraint `ck_col_sex` check (`col_sex`=&#x27;M&#x27; or `col_sex`=&#x27;F&#x27;),\n外键约束\n首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。\n外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。\n# 外键需要先创建一个字段，然后给这个字段添加外键。原外键的字段和新的要添加外键的字段数据类型要一样。alter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段);alter table 表名 drop foreign key 外键名;\n一对多时，多的一方需要加外键约束。\n之后子表引用了父表，父表被引用的记录就不能随便删除了。子表也不能随便写外键的值，必须要在父表中存在才可以引用。\n\n\n\n外键删除更新行为\n说明\n\n\n\n\nno action/restrict\n父表要删除/更新的记录如果在子表中存在关联记录，则不删除/更新\n\n\ncascade\n父表要删除/更新的记录如果在子表中存在关联记录，则子表中的记录也删除/更新\n\n\nset null\n父表要删除/更新的记录如果在子表中存在关联记录，则子表中的记录对应字段设为空值（前提：该字段可以为 null）\n\n\nset default\n父表要删除/更新的记录如果在子表中存在关联记录，则子表中的记录也删除/更新对应字段设为默认值\n\n\n\nalter table 子表名 add constraint 外键名 foreign key (要添加外键的字段) references 父表名(父表字段) on update cascade on delete cascade;\nDML\n插入\ninsert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行insert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的\n注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 default ，不然系统也难以分辨哪一项使用默认值。\n日期可以写字符串 2002-01-01，会自动转换\n插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。\n**如果主键、unique 的记录重复会报错。**报错显示： duplicate key for key '定义的约束键名称'\n**填写了规定的 check 以外的内容会报错。**报错显示：check constraint '定义的约束键名称' is violated. 不过字符串不区分大小写，规定性别只能填 ‘F’ ‘M’ 的话，填 ‘f’ ‘m’ 也行。\n如果对应的外键在原表中没有对应的记录会报错。 报错显示：cannot add or update a child row: a foreign constraint fails 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。\n如果没有给 NOT NULL且没有默认值的字段赋值时会报错。 报错显示：Field '字段名' doesn't have a default value. 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。\n删除\ndelete from `表名`;//这可不兴用啊！delete from `表名` where `字段名`=&#x27;要删除的记录的对应字段值&#x27;;//不等于可以用&lt;&gt;，有的 DBMS 支持!=delete from `表名` where `字段名` = &#x27;字段值&#x27; or `字段名` = &#x27;字段值&#x27;;//根据多个条件删除语句delete from `表名` where `字段名` in (&#x27;字段值&#x27;,&#x27;字段值&#x27;);//删除多条语句\n但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： Cannot delete or update a parent row 。\n删除了外键约束之后就可以随意修改两个表对应的值而不报错了。\n另一种删除表的方式是：\ntruncate table `表名`;\n截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。\n更新\nupdate `表名` set `列名` = &#x27;值&#x27;;//把这一列的数据全都改成这个值，不常用update `表名` set `列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27; where `字段`=&#x27;值&#x27;;//限制条件，只修改某几个记录\nDQL\n学习自b站骆昊jackfrued 老师的网课以及黑马网课。\n查询语句。\n本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）\ntb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）\n编写顺序、执行顺序\n编写顺序如下：select from where group by having order by limit;\n执行顺序：\n\n\nfrom 表名\n\n\nwhere 条件（where 可以用表别名，但是不能用 select 中的字段别名）\n\n\ngroup by 分组\n\n\nhaving 分组条件\n\n\nselect 投影\n\n\norder by 排序\n\n\nlimit 分页\n\n\nSelect\n查询所有学生的所有信息\nselect * from `表名`;-- * 号表示所有字段\n但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。\n实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）\nselect `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;\n如果只查询部分列，就只写那几列就行。\n联合 Union\nUnion 会把查询结果联合起来。\nunion all：结果可能重复。\nunion：重复的结果合并。\n想做union操作，两个要联合的表必须字段数相同，字段类型匹配。\n别名\n给字段或表起别名—— alias，简写为 as。\nselect `stu_id` as `学号` from `tb_student`;\nas 可以省略，不过还是写上可读性高一些。一般字段不省略，表省略。具体还得看公司编程规范的要求，没有就看个人喜好了。\n条件\n限制查询记录的条件——where（选择 Selection，只查询某几行）\nselect * from table where `stu_sex`=&#x27;M&#x27; or `stu_name`=&#x27;Jingqing&#x27;;\n多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。\n性能问题，一般不用 or 而使用 union，结果取并集。\nselect * from table where `stu_sex`=&#x27;M&#x27; unionselect * from table where `stu_name`=&#x27;Jingqing&#x27;;\n如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。\n类似 10&lt;x&lt;30 的形式不可以直接写两个等式，要拆成 x&gt;10 and x&lt;30 。\n这里的字段如果是数字类型的，也可以进行 + - * / % mod（也是取余）以及 &lt; &gt;  = &gt;= &lt;= &lt;&gt; 等形式的运算。\n还有一种条件写法是 between …… and ……\nselect * from table where `stu_age` between 10 and 30;-- 相当于 &lt;=30 and &gt;=10\n分支结构\n如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？\nselect if(`stu_sex`,&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;性别&#x27; from `tb_student`;-- 有点类似三目运算符 ?:\nif 中第一项可以是表达式，如 age &gt; 10.\n**这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。**比如 Oracle 数据库中对应的函数是 decode，不能通用。\n通用的分支结构：\nselect case `sex` when 1 then &#x27;男&#x27; elseif 0 then &#x27;女&#x27; else &#x27;未知&#x27;end as &#x27;性别&#x27; from `tb_student`;-- end 表示条件判断结束\n模糊查询\n如：查询所有姓王的学生。\nselect * from `student` where `stu_name` like &#x27;王%&#x27;;-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生select * from `student` where `stu_name` like &#x27;王_&#x27;;-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生\n这里和正则表达式有一定联系，之后会单独学习。\n2023-01-23 补档：我后来确实学习了正则表达式~学习笔记在这里：Regex_灰海宽松的博客-CSDN博客\n事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。\nselect * from `student` where `字段名` regexp &#x27;正则表达式&#x27;;\n模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。\n空值处理，以及三值逻辑\n下面两种写法是错误的！\nselect * from `student` where `stu_address` = null;select * from `student` where `stu_address` &lt;&gt; null;\n因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。\n正确做法：\nselect * from `student` where `stu_address` is null;select * from `student` where `stu_address` is not null;\n去重\nselect distinct `字段名` from `表名`;\n排序\nselect `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序\norder by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。\n当前日期\ncurdate()获取当前日期，使用 datediff(datepart, date1, date2) 函数可以和出生日期做差获取年龄。\nnow()获取当前年月日时分秒（datetime）。\n取整\nfloor() 函数是下取整。floor(3.99) = 3.\nceil() 函数是向上取整，ceil(3.1) = 4.\nround() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)=4\nselect floor(datediff(curdate(),`date`)/365) from `staff`;\n可以通过? functions 查看函数一览。还会有相应的例子提示~\n聚合函数\n描述性统计信息：包括集中趋势和离散趋势。\n集中趋势：平均值，中位数等。\n离散趋势：方差，标准差等。\n聚合函数属于 SQL 语句，所有 DBMS 都能用。\n\n\nmin(字段名)\n\n\nmax(字段名)\n\n\navg(字段名) 做计算的时候会忽略 null 值\n\n\nsum(字段名)\n\n\ncount(字段名) 做计算的时候会忽略 null 值\n如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。\n比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) / count(stu_id) 就是错误的，因为是9个人的成绩 / 10.\n如果成绩为空的学生视为 = 0，就要用 sum(score) / count(stu_id)，或者对 avg() 函数做如下处理：\nselect avg(ifnull(`score`,0)) from student;-- 如果第一个表达式!=null，则返回第一个表达式\nifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。\ncoalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。\n\n\nstd(字段名)，计算标准差，越小说明越稳定。\n\nstd(), stddev() 和 stddev_pop()：所有数据总体的标准差\nstddev_samp()：样本标准差，抽样计算。\n\n\n\nvariance(字段名)，计算方差，标准差的平方。\n\nvariance(), var_pop()\nvar_samp()\n\n\n\n分组\n聚合函数通常和分组一起使用。分组是非常重要的操作。\nselect avg(`score`) from `student` group by `sex`;\nPS： Excel 的数据透视表有同样功能：\n插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认\n行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。\nselect * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和\ngroup by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。\n如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.\nselect `stu_id`,avg(score) from `Score` where avg(score)&gt;90 group by `stu_id`; -- 错误select `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)&gt;90; -- 正确\n分组以前的筛选： where, 写在分组后\n分组以后的筛选： having, 写在分组后。\n其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：\nselect `stu_id` from `tb_record` group by `stu_id` having avg(score)&gt;90;\n也是没有问题的。\n查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：\nselect `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)&gt;90;\n子查询\n子查询 (subquery) 的用途：\n\n集合成员资格，判断某一元素是否是某一个集合的成员\n集合之间的比较，某一个集合是否包含另一个集合等\n集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。\n\n查询年龄最大的学生的姓名。\n可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。\n一种方法是嵌套子查询：\nselect `stu_name` from `tb_student` where `stu_birth` = (    select min(`stu_birth`) from `tb_student`);\n另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）\nset @a =(select min(`stu_birth`) from `tb_student`);select @a; -- 可以查看一下 @a 的值。\n如果子查询有很多结果，满足其中一个即可：不能用等号，要用 in 。\nselect `name` from `tb_student` where `stu_id` in (    select `stu_id` from `tb_record` group by `stu_id` where count(*)&gt;=2); -- 查询出所有至少选了2门课的学生姓名\n如果用了等号，报错： subquery returns more than 1 row.\n标量子查询：结果为一个。可以做&gt; &lt; =操作。\n列子查询：结果为一列。可以做 IN NOT IN SOME ALL ANY 操作。（ANY SOME 等价）\n行子查询：结果为一行。可以做 = &lt;&gt; IN NOT IN 操作。\n表子查询：结果为多行多列。最常用 IN NOT IN 操作。\n多表连接\n一对一，一对多，多对多（两个一对多）\n一对一：其中一方设置unique的外键。\n一对多：多的一方设置外键。\n多对多：建立中间表，设置两个外键。\n笛卡尔积\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;\n如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。\n本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。\n自然连接\n\n有外键约束：利用外键连接，不用加条件，自动连接。\n\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student` natural join `tb_college`;\n\n没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。注意：不管有几个同名的列，所有列都会作为连接的条件！\n如果没有外键也没有同名列，就只会得到笛卡尔积的结果。\n\n内 / 外连接\n另一种连接方式是 inner join / outer join\n或者用 where A.id=B.id ，这种内连接方式叫做隐式内连接。\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student` inner join `tb_college` on `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号\ninner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。\nleft outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。\nright outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。\nfull outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。\n自连接\nselect * from A AS1 inner join A AS2 where 条件;-- 自连接可以是内或外连接。必须起别名！！！\nθ 连接\n添加条件使得两个表中的数据相互对应：\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` where `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号\n三表连接\n链接条件用多个条件筛选。\nselect `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`where `tb_course`.`cou_id`=`tb_record`.`cou_id` and `tb_student`.`stu_id`=`tb_record`.`stu_id`;select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`inner join `tb_record`on `tb_student`.`stu_id`=`tb_record`.`stu_id`inner join `tb_course`on `tb_course`.`cou_id`=`tb_record`.`cou_id`where `tb_course`.`cou_name` is not null; -- where 写在最后select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`natural join `tb_record`natural join `tb_course`;\n查询小技巧\n百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件\npython -推广链接 不想看到广告推送\nsite:zhihu.com python 只搜索知乎里的 python 内容\n2023-01-23 补充：关于信息检索，博主也有开一个新坑：信息检索_灰海宽松的博客-CSDN博客。目前更新还不完全，不过对于搜索引擎部分应该足够用了。\n分页查询\nlimit 是 mysql 的方言。\nlimit 查询最值有个缺陷，就是只能查出一条。如果有两个最大值就只能显示一个。\nselect * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。select * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)select * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)\n派生表\nselect 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）\n查询学生姓名和平均成绩。\n查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？\n先通过一个查询，得到一个派生表：\nselect `stu_id`,avg(score) from `tb_record` group by `stu_id`;\n然后把其结果作为一个新表，和学生表做关联。\nselect `stu_name`,`avg(score)`from `tb_student`natural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思\n**临时表必须要起别名！！！**不然报错。\n**注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！**因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，没选课的学生就不会查出来。\n如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。\nDQL 例题及注意事项\n简单排序——查询最大值、次大只\n\n\n员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。\n做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。\n做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。\n做法③：查询一名没有人薪水比他大的员工（即：薪水大于这名员工的员工数=0）。\nselect `ename`,`salary` from `tb_employee` t1 where(    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`)=0;-- 结尾改成1，就是工资第二高的人\n\n\n查询除了 boss 外工资最高的人。\n在题1的基础上，用 where 排除掉 boss。\nselect `ename`,`salary` from `tb_employee` where `salary`=(    select max(salary) from `tb_employee` where `position`&lt;&gt;&#x27;boss&#x27;);\n\n\n查询月薪 top 3的人。\n这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。\nselect `ename`,`salary` from `tb_employee` t1 where(    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`)&lt;3 order by `salary` desc;\n\n\n查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。\n题目很简单，但是**遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。**要用 ifnull() 或 coalesce() 函数限制一下。\n\n\n查询所有部门名称及员工人数。\n部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。**重点注意几种连接的不同，思考一下题中哪个信息要全部展示出来。**比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。\nselect dname,total from `tb_department` t1left join (    select dname, count(*) as total from `tb_department` t2 group by `dno`) on t1.`stu_id`=t2.`stu_id`;\n\n\n查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious\n先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。\nselect sname,salary from `tb_employee` t1inner join (\tselect avg(salary),dno from `tb_employee` group by dno;)t2 on t1.dno=t2.dno and t1.salary &gt; t2.avg(salary);-- 两个连表条件\n\n\n查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。\n派生表通过薪水值、部门号和员工表、部门表相连接。\n\n\n查询薪水排名4-6员工的薪水、姓名、排名。\n问题1：怎么查出排名？\n问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5\n解决：mysql 8的窗口函数可以解决排名 / top N 问题。\n①不用窗口函数：\n系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：set @a=0;或select@a:=0;而且变量也可以通过 as 起别名。\n我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。\nset @a=0;select row_num,ename,salary from (\tselect @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0    from `tb_employee` order by salary desc) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次\n注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.\n另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。\n\n\n查询每个部门薪水排名前两名的员工。\nTop N 问题通过题1的做法③解决。\nselect eno,ename,salary,dno from `tb_employee` t1where (\tselect count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary&gt;t1.salary)&lt;2 order by t1.dno asc, t1.salary desc;\n\n\n窗口函数\n内容来自：通俗易懂的学会：SQL 窗口函数 - 知乎\n应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by\n窗口函数不光是函数，有一套完整的语法。\n&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;                order by &lt;用于排序的列名&gt;)\n&lt;窗口函数&gt; 处放聚合函数或专用窗口函数。\n窗口函数是以一个列的形式使用的。\n专用窗口函数\nrank、dese rank、row_number\n看图即知区别。\n\npartition by 和 group by 的区别\npartition by 是把所有数据分成绩一个窗口，而并不汇总。比如上图中，如果按班级号分窗口再进行排序，就会在每个班级内部从1到无穷排序。不写的话就默认整个表是一个大窗口。\ngroup by 是分组后汇总。\n\n使用：\nselect `ename`,`sal`,rank() over (order by `sal` desc)as `r1`,dense_rank() over (order by `sal` desc)as `r2`,row_number() over (order by `sal` desc)as `r3`from `tb_emp`;\n第八题窗口函数做法：加一个 where r between 4 and 6 的条件。\n第九题窗口函数做法：因为产生了分组，因此不能直接用 where r &lt;=2。但是窗口函数的分窗口后的列做筛选，既不能直接用 where 也不能用 having。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。\nselect `ename`,`sal`,`dno`from(    select `ename`,`sal`,`dno`,    rank() over (partition by `dno` order by `sal` desc)as `r`    from `tb_emp`) `temp` where `r`&lt;=2;-- 不能在派生表里直接筛选\n窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。\nDCL\nData Control Language，给用户授权，不同用户能操作数据权限也是不一样的。主要是 DBA 使用。\nselect * from user;create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问。域名如 localhost，%代表任意路径alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified with mysql_native_password by &#x27;新密码&#x27;;-- with mysql_native_password 是 mysql 的修改方式drop user &#x27;人名&#x27;@&#x27;域名&#x27;;\n如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。\n查看权限：\nselect grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n授权：\ngrant 权限 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;\n数据库名和表名可以用通配符 * 代替。\n权限包括： all (privileges), select, insert, update, delete, alter, drop, create\ngrant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人\n召回权限：revoke\nrevoke 权限 数据库名.表名 from &#x27;人名&#x27;@&#x27;%&#x27;;\n添加权限之后最好 Reconnect 刷新一下。或者执行：\nflush privileges;\nWorkbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。\n至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。\n函数\n很多内容其实在 DQL 早就介绍过。\n字符串函数\n\n\n\n函数\n说明\n\n\n\n\nCONCAT(s1, s2, sn)\n字符串拼接\n\n\nLOWER(str)\n转小写\n\n\nUPPER(str)\n转大写\n\n\nLPAD(str, n, pad)\n用 pad 对 str 左边n个字符长度进行填充\n\n\nRPAD(str, n, pad)\n用 pad 对 str 右边n个字符长度进行填充\n\n\nTRIM(str)\n去掉头尾的空格\n\n\nSUBSTRING(str, start, len)\n返回 str 从指定位置 start 开始 len 长度的子字符串（从0开始）\n\n\n\n如：所有员工的工号都必须是五位数，不足的话在左端补0：\nupdate 表名 set 字段名 = lpad(字段名,5,&#x27;0&#x27;);\n数值函数\n\n\n\n函数\n说明\n\n\n\n\nCEIL(x)\n向上取整\n\n\nfloor(x)\n向下取整\n\n\nmod(x,y)\n返回x/y的模\n\n\nrand()\n返回0~1内的随机数\n\n\nround(x,y)\n返回x四舍五入值，保留y位小数\n\n\n\n例：生成6位验证码。\n首先靠随机数生成，然后*1000000并四舍五入，然后还要考虑开头为0的情况，因此不足六位补0。\nselect lpad(round(rand()*1000000,0),6,&#x27;0&#x27;);\n日期函数\n\n\n\n函数\n说明\n\n\n\n\ncurdate()\n返回当前日期\n\n\ncurtime()\n返回当前时间\n\n\nnow()\n返回当前日期和时间\n\n\nyear(date)\n\n\n\nmonth(date)\n\n\n\nday(date)\n\n\n\ndate_add(date, interval expr type)\ndate 加时间间隔 expr，可以是年月日时间，如interval 70 day\n\n\ndatediff(date1, date2)\n求两个日期相差天数\n\n\n\n流程函数\n\n\n\n函数\n说明\n\n\n\n\nif(value, t, f)\ntrue 返回t， false 返回f\n\n\nifnull(value1, value2)\nvalue1 为 null 返回 value1，空返回 value2\n\n\ncase when val1 then res1 else default end\nswitch case\n\n\ncase expr when val1 then res1 else default end\n表达式形式的 switch case\n\n\n\n(case workaddress  when &#x27;北京&#x27; then &#x27;一线城市&#x27;  when &#x27;上海&#x27; then &#x27;一线城市&#x27;  else &#x27;二线城市&#x27;  end) as &#x27;工作地&#x27;; (case score  when score=100 then &#x27;满分&#x27;  when score&gt;=90 then &#x27;优秀&#x27;  else &#x27;懒得写了&#x27;  end) as &#x27;成绩所在段&#x27;;\n事务\n事务是一组不可分割的操作集合，要么都成功执行，要么都失败。如银行账户数据库操作，一个人给另一个人转账1000元，那么这两个人的update操作就是不可分割的，不然如果有一个操作成功执行另一个没有，就可能银行平白无故少了1000或者收款人没收到钱。\n事务的步骤：\n\n开启事务\n执行一条条操作。这期间如果有失败则事务回滚。或者手动进行事务回滚。\n全部执行完后提交事务。默认mysql是自动提交事务的，每执行一条语句就会提交一条。\n\n开启事务\nselect @@autocommit;-- 1：自动提交；0：手动提交\nset @@autocommit=0;-- 开启手动提交rollback;-- 回滚commit;-- 提交\n或者在@@autocommit=1时临时开启事务：\nstart transaction;-- 开启事务\n事务四大特性 ACID\natomicity 原子性：事务是不可分割的最小操作单元。\nconsistency 一致性：所有数据保持一致状态。\nisolation 隔离性：事务不受外部干扰，独立进行。\ndurability 持久性：提交或回滚后，事务对数据库的操作就是永久的。\n并发事务问题及解决办法\n多个事务同时进行时会出现的问题。\n以下是数据库事务可以设置的几种隔离级别，分别是应对不同问题用的。\n\nselect @@TRANSACTION_ISOLATION;-- 查看数据库隔离级别set session/global TRANSACTION ISOLATION LEVEL SERIALIZABLE;-- 设置当前会话/全局事务隔离级别为serializable\nread uncommitted 是数据库最低隔离级别，即：一个事务中的数据还未提交别的事务就可以读得到。\n问题1：脏读：一个事务读到另一个事务未提交的数据（Read uncommitted会发生）\n\n解决办法：read committed 限制一个事务修改的数据要等到提交后别的数据才能读得到。解决了脏读问题，但是没有解决不可重复读问题，事务2第一次读和第二次读数据可能值不一样。\n解决后：（给要读取的左边的窗口设置 read-committed 隔离级别）\n\n问题2：不可重复读：一个事务前后读了同一个数据两次，两次值不一样。因为其他事务在这中间提交过一次。\n\n解决办法：repeatable 使得事务2开启后事务1才提交的数据事务2读取不到，避免了不可重复读的问题。但是没有解决串行化问题，即事务2再对数据的修改会覆盖事务1的修改。\n问题3：幻读：每个事务开启时把数据读入缓存内，这样重复读取的时候直接从缓存中读取，避免了重复读取数据不一样。但是数据不及时更新，比如事务1删库了，事务2还能读；或者事务1新增了一条主键为i的数据提交了，事务2随后也想新增一条主键为i的数据，提交的时候发现1已经写过了，交不进去了。\n\n解决办法：serializable 让事务1在操作当前数据库时，别的事务直接操作不了。\n问题4：开启序列化后，其他事务插入会卡住，等待当前事务插入完成后再执行插入操作。会导致用户体验差，需要等待。所以序列化等级还是很少使用的。\n存储引擎\nMysql 体系结构\n\n连接层：连接池部分，与客户端连接，并检查授权认证、权限、最大连接数等。\n服务层：SQL接口一行，绝大部分核心功能如SQL解析优化、所有跨存储引擎的实现都在这一层。\n引擎层：可插拔存储引擎一行，索引在这一层实现，决定数据库数据如何存、取、组织。如果当前引擎不满足需求还可以拓展，因此被称作可插拔。\n存储层：最下面一行，存取数据库的相关数据。\n存储引擎简介\n存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的。\n查询建表语句：show create table 表名;时在结尾就可以看到该表的存储引擎。\nshow engines;查询当前数据库支持的所有引擎。\n创建指定引擎的表：create table (...) engine=指定引擎;\n修改表引擎：alter table 表名 engine=指定引擎;\nInnoDB\n高性能存储引擎，Mysql 5.5后的默认引擎。\n支持事务、行级锁、外键。\n文件后缀.ibd是InnoDB存储引擎的表空间文件，每个表有一个，存储表结构数据和索引。表结构早期是frm，后来变成sdi，sdi又融入了ibd格式中。\n有一个系统变量innodb_file_per_table，可以通过show variables like 'innodb_file_per_table'查看，ON则表示每张表都对应一个表空间文件ibd。\nibd文件在mysql文件夹-data文件夹-对应数据库文件夹里。\nibd文件直接打开是看不了的，都是二进制。可以进入目标文件夹后，通过命令行ibd2sdi 指定表名.ibd，就可以查看该表的json文件信息了。\n\n表空间文件逻辑存储结构如图所示，段-区-页-行，每一行就是表中的一行数据。\n一个区大小固定为1M，一页大小固定为16K。（大概了解，SQL优化部分还要涉及）\nMYISAM\n数据库早期的默认存储引擎。（现在功能几乎可以被NoSQL的Mongodb取代）\n不支持事务和外键，支持表锁，不支持行锁，访问速度快。\n存储文件包括：\n.MYD：数据\n.MYI：索引\n.sdi：表结构，可以直接打开，里面装的是json格式内容（可以通过json.cn格式化）。\nMemory\n存放在内存中，数据是临时的。（现在功能几乎可以被NoSQL的Redis取代）\n访问速度快，支持hash索引。\n存储文件只包括：.sdi，因为数据索引都存在内存里了。\n\n三种存储引擎的选择\n\n索引\n索引是高效获取数据的数据结构。\nLinux中安装Mysql\n首先在Linux中安装Mysql。还好前两天接触了一点虚拟机。\nMysql 下载地址\nFinalShell可以直接点击上传标志上传下载的压缩包：\n\nmkdir mysqltar -xvf 压缩包名 -C mysql //解压到该文件夹内//安装其中的所有rpm文件rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpmyum install openssl-develrpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpmrpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpmrpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm\n启动：安装好mysql后，linux会自动提供mysqld服务。\nsystemctl start mysqld //启动mysqlmysql -uroot -p //然后去日志文件里找密码~\nsystemctl restart mysqld\nsystemctl stop mysqld\n查找密码可以执行：\ngrep &#x27;temporary password&#x27; /var/log/mysqld.log\n也可以直接打开该文件看。登录后就是用熟悉的SQL改密码.\nlinux密码默认校验规则等级为Medium，要求&gt;8位，包括数字，大小写字母和符号。可以设置强度为：\nset global validate_password.policy = 0;set global validate_password.length = 4;\n然后可以设置个简单点的密码：\nalter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;1234&#x27;;\n然后为了DataGrip可以访问，创建一个可以远程访问新用户：\ncreate user &#x27;Windows&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;1234&#x27;;grant all privileges on *.* to &#x27;Windows&#x27;@&#x27;%&#x27;;\n可以通过ifconfig查看ip地址。查看后就可以在DataGrip中链接啦。\n\n索引介绍\n是帮助Mysql高效获取数据的有序数据结构。\n\n比如查找age=45的记录，如果age采用二叉树的存储方式，很明显右边比左边更高效。\n索引使得查询和排序成本降低，但是增删改成本增加，而且索引也要占用空间（MYI文件）。\n\n\nB树\n二叉树比较简单，小数插在左子树，大数插在右子树。\n\n但是如果一直往左或右插，树就变成一边倒的形状了，查询效率大大降低。\n红黑树可以解决平衡问题。但是大数据情况下还是层级较深，检索速度较慢。\nB树：又名多路平衡查找树。\n首先每个节点的子节点个数叫度数。\n以最大度数为5的5阶B树为例：\n\n一开始插入4个数以内，都在一个节点里\n\n然后插入第五个数，就开始分裂，中间的数作为父节点，左右两组数作为子节点\n\n然后插入数还是往子节点里插入\n\n如果子节点够5个，中间的提到父节点处。\n\n一直插入到父节点达到5个，父节点再次分裂。\n\nB+树\n就是B树的所有叶子节点会形成一个单向链表\n\nMysql里的B+树就是叶子结点变成了双向循环链表，提高区间访问性能。\n\nHash 索引\n通过一定的Hash算法，把值都归到对应hash值的槽位上。如果出现槽位冲突，采用链表的方式解决。\n\n只能用于=等值查询，不能查询范围(&gt;&lt; between)，不能排序。\n效率很高，通常一次查询就找得到。\n只有Memory存储引擎支持。但是InnoDB具有自适应hash功能，可以在给定的条件下将B+树构建为hash索引。\n索引分类\n\n\n有主键，主键就是聚集索引；\n没有主键，第一个unique是聚集索引；\n没有主键和unique唯一索引，则表会自动生成一个rowid作为隐藏的聚集索引。\n\nselect ... where name='Arm';会先在二级索引中找到对应节点，然后根据id去聚集索引B+树中找主键，进而找到对应的row行数据。\n因此直接select ... where id=10;效率会更高，哪怕name有索引也需要回表查询（回id表）。\n创建索引\nCREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (col_name,...);-- 查看表中索引：SHOW INDEX FROM table_name;-- 删除索引DROP INDEX index_name ON table_name;\n性能分析\nshow global status like 'Com_______';查看当前数据库增删改查等操作的频次。如 Com_commit Com_select。\n慢查询日志：记录了所有查询时间超过10s（long_query_time）sql语句的日志。查询变量：slow_query_log 可以看是否开启。\n默认没有开启，需要到/etc/my.cnf中开启 slow_query_log。\n开启后/var/lib/mysql/主机吗名-slow.log中就会生成慢查询日志。\nvi /etc/my.cnf// 编辑，添加：slow_query_log=1long_query_time=10:x//保存退出systemctl restart mysqld//重启show variables like &#x27;slow_query_log&#x27;;//查询是否开启\n但是慢查询查询不到少于它规定秒数的语句。\nshow profiles 可以帮助我们了解每条sql语句耗时。首先通过：have_profiling参数 查看当前数据库是否支持profile操作\nselect @@have_profiling;select @@profiling;-- 默认关闭set profiling=1;show profiles;-- 查看刚才执行的所有sql耗时show profile for query 数字序号;-- 查看某一条特定的sql具体查询耗时，从start到cleaning upshow profile cpu for query 数字序号;-- 还可以查看cpu占用情况\n然而时间并不是准确的判定性能方法。explain才是更好的方法。explain可以查看select的详细执行状况。在任意select语句前加上explain或 desc 就可以了。\n属性含义：\nid：select查询的序列号，表示select或操作表的顺序，从大到小，相同id值从上到下。\n比如查询学生表、成绩表、学生成绩表 id 都是1，但从上到下顺序是s, sc, c。子查询 id 会更大。\nselect_type：查询类型。\n​\tsimple：简单类型\n​\tsubquery：子查询\n​\tprimary：主查询，外层查询\n​\tunion：联合的后半部分\ntype：连接类型，性能由好到坏分别为：null（不查询表，查询常量时）, system（系统表）, const（主键约束查询，唯一性约束查询）, eq_ref（子查询的 const）, ref（非唯一性约束查询）, range, index（用到了索引，但也是全表索引扫描）, all（全表扫描）\n尽量往前靠。\npossible_key：这张表中可能用到的索引。\nkey：实际用到的索引。\nkey_len：使用到的索引中的最大可能字节数。越短越好。\nrows：Mysql认为必须要执行查询的行数（估计值）。\nfiltered：返回的行数/读取的行数百分比，越大越好。比如查主键就不用遍历，查一条就查得出来。\n使用索引\n通过 create index 给某个属性添加索引。\n查询结果结尾加 /G ，可以把列转换为行显示。\n使用规则\n\n联合索引的最左前缀法则。比如一个索引要关联多列，那么查询从最左列开始，且不跳过索引中的列。比如我们给 profession age status 三列添加了一个索引，那么查询时就该写：select * from table where profession=&quot;&quot; and age=&quot;&quot; and status=&quot;&quot;;  不写 profession 查询或者只写 profession 和 status 查询会出错，会出现有 null 的列。（好像8.0可以不写最左列）原理大概是复合属性的索引是先按第一个排序，再按第二个，再第三个……所以只按后面的排序查找就出错。当然这三个查询顺序无所谓，关键是左边的一定得有。（这里的左指的是创建索引的时候的顺序，比如 create index index_name on table_name(left_column, right column);）\n联合索引中如果出现范围查询（&lt; &gt;），范围查询右侧的属性失效。比如 select * from table where profession=&quot;&quot; and age&gt;30 and status=&quot;&quot;;   status 查询就会失效。解决办法是尽量用 &gt;= &lt;=。\n索引列上不要做运算，否则会失效。 比如查询姓名三个字以“松”结尾的学生，姓名有索引，但是 select * from students where substring(name,3,1)=&quot;松&quot;; 不走索引。\n查询字符串没加单引号也失效。\n尾部模糊匹配（“abc%”）不会失效，头部模糊匹配（“%abc”）失效。\nor 的失效情况：有索引列条件 or 无索引列条件 ，结果是所有索引都不会被用到。处理办法就是右边的属性也建立索引。\n\n总结就是，mysql 评估说全表扫描比索引查找快，那么就决定用全表。比如当前列 null 值比较多，is null 查询就会全表查询，is not null 是索引查询。\nSQL 提示\n有的列可能用了多个索引。可以人为提示指明用哪一个。\nexplain select * from table use index(index_name) where 条件;\nexplain select * from table ignore index(index_name) where 条件;\nexplain select * from table force index(index_name) where 条件; use 可能不接受。force 是强制使用这个索引。\n覆盖索引\n查询使用了索引，且查询返回的列都在该索引当中。\n覆盖索引效率高于 select *。\n如果查询多列，包括有索引列和没索引列，explain 中 extra 显示 using index condition，意为使用了索引查找，但是最后又回表查询非索引列。\n如果查询的多列只包含索引列，explain 中 extra 显示 using where; using index 意为只使用了索引查找，因为要查询的列只在索引列中就找得到。\n\n比如上例，如果 select * from table where id=2; 先去聚集索引表中找 id=2 的行，然后回表找到这一行，找到这一行的所有数据。\n如果 select id, name from table where name='Arm'; 先去辅助索引表中找到 Arm，辅助索引表中也会存储其 id 信息。这样就已经能查到所有字段了，就不用回表了。\n但是如果查询的字段是 id, name, gender ，gender 不在辅助索引表中，因此还是用回表的。先根据 arm 对应的 id 值，去聚集索引表中找到相关的行信息，再回表查询 gender。这就超出了覆盖索引的范围。\n例：select id, username, pwd from user where username='jingqing'; 怎样设置索引使得查询最优？\n答：id 是主键索引，为了达成覆盖索引，我们要给 username pwd 建立复合索引。\n前缀索引\nvarchar int 等类型可能是很长的字符串，导致索引变得很大，查询时浪费大量磁盘 IO。\n创建索引时可以只选择一定长度的前缀建立索引。如：\ncreate index index_name on table_name(column(n)); 表示前n个字符建立前缀。\n至于n取多少合适，可以根据索引的选择性决定，选择性=不重复的索引值/记录总数，越大越好，1是最好的唯一索引。（count(distinct column)/count(column)）\n我们可以用 substring(column, 1, n) / count(*) 来计算前n个前缀的选择性。\n单列索引和联合索引\n包含多列的是联合索引。\n多个查询条件时推荐使用建立联合索引。因为比如 column a 和 column b 建立了两个单列索引，同时查询两者时 mysql 也只会选择其中一个索引查询，另一个字段回表查询（如果 mysql 自动选择了单列索引，可以用 use index() 限制）。\n\n设计原则\n\n什么时候用索引？数据量比较大，且查询比较频繁的表要建立。\n哪几列建立索引？常作为查询条件的列（where, order by, group by)。\n建议区分度高的列建立唯一索引。\n太长的列可以建立前缀索引。\n尽量用联合索引而不是单列索引，避免回表。\n索引也会影响维护，因此并不是多多益善。\n如果索引列不能存储 null，建表的时候请用 not null 约束该列。当优化器知道每列是否有 null 值时，可以更好的决定用哪个索引查询。\n\nSQL 优化\n插入优化\ninsert into table values(1,1...);\n\n\ninsert into table values(1,1...),(1,1...),(1,1...); 使用批量插入，和数据库之间建立连接也不用每条数据插入一次，效率会高。建议500~1000条数据使用批量插入。\n\n\n插入的时候是自动开启和关闭事务的，插入前开启，插入后关闭。太频繁了性能也不高，我们可以手动开启和关闭事务。\nstart transaction;insert into table values(1,1,1);insert into table values(2,2,2);insert into table values(3,3,3);commit;\n\n\n主键顺序插入，这个和 mysql 的数据组织结构有关系。\n\n\n","categories":["邮途（北邮国院课内学习）","Lecture"],"tags":["MySQL"]},{"title":"北邮国院笔记：Microprocessor 微处理器","url":"/2023/07/14/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMicroprocessor%20%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/","content":"前言\n主要围绕考试提纲里的所有问题展开，没有拓展内容，Exam oriented Study。\n关注微信公众号：灰海宽松，回复 “微处理器” 可获取本文pdf格式。\nIntroduction-随便聊\n嵌入式系统是什么？专用的计算机系统。为专门功能可能对计算机架构，外设等做出一些取舍。\n通常的限制：Cost（比如大量部署传感器节点），Size and weight limits（特定应用场景，比如下水道流量检测系统，需要体积小的节点），Power and energy limits（比如部署在极端环境下，喜马拉雅山顶采集节点，不方便去充电），Environment（防水，防高温等）\nMCU MPU两种嵌入式系统区别：focus on 控制 还是 处理。控制比如点灯，机械臂，电机这些都是。处理比如摄像头采集到的数据进行图像处理。\n编程语言：靠近计算机底层，主要使用汇编和c。\nOS：嵌入式系统里不一定有操作系统结构。操作系统这个东西说白了就是更好地帮助管理计算机资源调度用的。现在我们来分析一下我们lab2的代码主函数：\nvoid main()&#123;    //background    while(1)&#123;            &#125;&#125;void IRQ_Handler()&#123;    //interrupt handler function, frontground&#125;\n后台部分：一个循环，重复去执行要做的任务。\n这种方法乍一看也没啥问题。但是想想这样的计算机能做什么，只能按顺序执行一遍又一遍所有任务，甚至没法变顺序。\n前台部分：中断处理，我们lab2里的uart_rx_isr函数，一般也用IRQ_Handler（实际上如果对lab2里的uart_rx_isr溯源一下，就会发现其实他也是被IRQ_Handler调用的，这个方法在启动对应中断时，触发中断就会自动调用）。\n前后台合起来的系统还是一个裸机无os系统，只不过加了中断之后允许我们用中断的任务去打断后台轮询，改变一下执行顺序。比如串口中断发个数过来，CPU把手头后台的事情放下，去处理一下前台中断，处理完了再回来。\n我们课程仅限于裸机开发的内容。\n计算机系统简要介绍\nVon Neumann Architecture\n运算器控制器 (合在CPU中) 存储器 main memory 输入设备输出设备 IO，以及三条传输总线：数据，控制，地址 data bus / control bus / address bus.\n\n前面介绍过MPU重点在于数据计算处理，MCU则是控制，因此MPU不需要一些外设去控制外接的组件。\nHarvard Architecture\n和冯诺依曼区别就是在于指令和数据分开存储。这样寻指取指取数效率高。\nStored Program Concept\n主要两个部分：RAM存储程序和数据，ROM存储不变只读的程序和数据。\ncpu执行指令就是三个步骤的重复执行：fetch decode execute 取指解码执行\nassembly\n如果高级语言相当于人话翻译给计算机，汇编语言相当于计算机语言翻译给我们。更贴近底层，因此运行效率也更高，而且可以直接操作硬件。\nADD r3, r1, r2 \t;r3 = r1 + r2SUB r3, r0, r3 MOV r2, r1 \t\t;r2 = r1\n; 是注释。变量r123是寄存器register，是可以操纵硬件的部分，我们可以通过对其赋值来操作硬件。\n高级语言通过 compiler 翻译为汇编语言，汇编语言通过 assembler翻译为二进制机器语言。\nARM架构\nARM是一个指令集，前面讲的几个汇编指令这些都算做指令。\nARM公司有意思的地方是，他们不做ARM设备，他们只设计指令集架构，然后授权（知识产权核，IP核）给其他半导体厂商做。\nA：application，主打高性能，手机电脑有许多就是ARM架构的。\nR：realtime，主打实时，比如车联网对实时性要求很高。\nM：microcontroller，应用于小型嵌入式系统，我们使用的板子。\nm系列有m0到m7（简单说就是性能逐渐增加？），而且向下兼容即m7兼容m0~m6.\nSoC\n我们的板子上有一个黑色的小芯片，上面写着stm32blabla一串字符。这个就是整个板子的核心，相当于囊括了上文提到的计算机架构的芯片结构，system on chips。\n\n设计soc规则：首先选用IP核，设计ARM处理器，外加一系列存储、IO外设结构，全部集成在黑芯片上。\nARM处理器 processor 是 architecture 的具体涵盖，多了很多新内容比如定时器。\n我们主要学习m4架构。\n\n只看非optional大概了解即可，处理器核访问代码，数据接口。\nregister\n前面我们已经简单介绍了register。事实上如果想对内存中数据做处理，也要先拿到处理器核中的寄存器里做运算，然后返回回去。\narm register 如下：\n\n通用寄存器：临时变量，可以存储计算数据之类的。\nSP：栈顶指针寄存器，指向栈顶。\nLR：函数返回用，保存返回地址。比如要调用函数了，把PC的值存入LR，然后PC跳转到函数起始位置；函数返回的时候LR的值还给PC。\nPC：指向程序当前执行到的位置（下一个要执行的指令的地址）程序计数器。每条指令取了之后PC自动加一条指令，比如32位指令集PC+=4B。\nPSR系列是状态寄存器，指明当前程序状态。比如当前是用户模式还是内核模式？IPSR指明当前是否允许中断？等。\nxPSR包括：\n\nAPSR：计算用，如标志是否进位，结果是否为0，是否为负，是否溢出等。\nIPSR：中断处理相关。\nEPSR：执行相关，指明指令集，中断是否继续等信息。\n\n\nMemory Map\nm4有4g的内存空间默认映射到一片空间中，用户也可以根据自己喜好修改。有存储代码的code region，存储数据的sram region，存储外设的peripheral region，external ram region，external device region，Internal Private Peripheral Bus (PPB)。\n\nBit-band Operations\n位带操作。\n如果我们要读写32位数据中的某一位，比如第三位（从左往右是31:0，第三位是右边第4个），有的寄存器允许我们直接获取r[3]，但是大多数是不允许直接获取的。\n如何处理？如果写入1，那么r|0000 0000 0000 0000 0000 0000 0000 1000.\n如果写入0，那么 r &amp; 1111 1111 1111 1111 1111 1111 1111 0111.\n读取：看 r &amp; 0000 0000 0000 0000 0000 0000 0000 1000 结果是否为0.\n这样很麻烦，比如我们要给0x2000 0000处的数据第3位写1，详细汇编代码：\n\nLDR是把后面的数据加载到前面的寄存器中，[R1]是把R1的值当做一个地址，取得其中存储的数据。\n这样挺麻烦的，但是因为有内存映射我们可以直接写入和获取“位带别名地址”中的数据。\n\n\n0x2000 0000处的第0位到第31位分别是：\n0x2200 0000\n0x2200 0004\n0x2200 0008\n0x2200 000c……\n0x2200 007c\n所以直接获取，修改0x2200 000c的数据即可。\n0x2000 0000映射到0x2200 0000是 sram 区域映射，0x4000 0000映射到0x4200 0000是外设 peripheral 区域映射。\n操作更快，指令更少，而且只访问一位更安全，比如刚取出0x2000 0000的32位数据，这时候中断修改了0x2000 0000的数据，这时我们取得的数据就是旧的错误数据了，修改完第3位再写回去，相当于中断白改了。\nProgram Image\n\nvector：向量表，存储比如main堆栈的地址（MSP），异常的地址等信息。\nstart-up：板子上电或rst时的启动代码。\nprogram code：我们烧进去的程序代码。\nc lib code：库函数代码。\n复位时，先读取 msp 地址找到 main 在哪。然后读取 reset vector 执行 BIOS 初始化代码，再开始读取第一条，第二条指令……\n\nEndianness\n两种存储规范。\n比如十进制数字，1234，一千二百三十四。然后我们记录到数据库中，地址从低到高存储为4321，权值大的位1存在地址最高处，这就是大端存储 Big endian。否则，权值大的位存在地址低处，1234地址从低到高，就是小端存储 Little endian。m4两种方法都支持。\n\n术语“little endian(小端)”和“big endian(大端)”出自Jonathan Swift的《格列佛游记》（Gulliver’s Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。\n一下是Jonathan Swift在1726年关于大小端之争历史的描述：\n“…下面要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由Blefuscu的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”（此段译文摘自网上蒋剑锋译的 《格列佛游记》第一卷第4章。）\n在他那个时代，Swift是在讽刺英国（Lilliput）和法国（Blefuscu）之间的持续的冲突。Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了.\n大端、小端基础知识 - 知乎 (zhihu.com)\n\nInstruction Set\n指令集。早期arm指令集32位，性能好能实现的功能强大。但是太长了处理效率低。\nthumb-1 指令集16位，处理效率高了，性能也降了。早期arm架构如果是支持两种指令集的，就要频繁切换模式，效率低。\n后来thumb-2指令集包含早期16位和新的32位，和arm指令集的混合指令集性能没减太多，代码量和处理效率还高了。\nAssembly\n汇编语法。\n顺序结构\nlabel\t\t\t\t\t\t\t; 可省略，用于跳转到此位置\t助记符 operand1, operand2, … ; Comments\tMOV r1, #0x01\t\t\t\t\t; 数据0x01放入r1MOV r1, #&#x27;A&#x27;\t\t\t\t\t; 数据A的ascii码放入r1MOV R0, R1 \t\t\t\t\t\t; move R1 into R0MOVS R0, R1 \t\t\t\t\t; move R1 into R0, 并且更新APSR的状态LDR R1, [R0]\t\t\t\t\t; R0存的是一个地址值如0x2000 0000, 这个指令是取出R0代表的地址中的数据存入R1STR R1, [R0]\t\t\t\t\t; 写回去LDR R0, =0x12345678 \t\t\t; Set R0 to 0x12345678; 等效于：; LDR R0, [PC, #offset] ; ...; DCD 0x12345678; 也就是先在文档末尾的一条指令里写入数据0x12345678，然后编译器自动计算PC+多少offset到达DCD的位置，把其值返给R0; DCD是声明一个字 32bit，DCB是声明一个Byte; 如果多个数值的声明可以用标签声明LDR R3, =MY_NUMBERALIGN 4 ; 字要先用这个声明，代表停止长度MY_NUMBER DCD 0x2000ABCCHELLO_TEXT DCB “Hello\\n”, 0 ; Null terminated stringLDRB R1, [R0]\t\t\t\t\t; B: 只写8位，就是说R0地址处的数据写入R1后，R1高24位清零SDRH R1, [R0]\t\t\t\t\t; H: 只写16位LDRSH R1, [R0]\t\t\t\t\t; 视作signed有符号数，写16位LDRB R0, [R1, #0x3]\t\t\t\t; 从R1+3读取一个字节给R0LDR R3, [R0, R2, LSL #2]\t\t; 从R0+（R2&lt;&lt;2)读取一个字节给R3LDR R0, [R1], #4\t\t\t\t; 赋完值后，令R1=R1+4ADD R0, R0, R1ADDS R0, R0, R1\t\t\t\t\t; 加完更新APSR状态，比如有溢出或者进位则更新ADC R0, R1, R2\t\t\t\t\t; R1+R2还要+APSR的carry位; SUB SBC类似MUL R0, R1, R2UDIV R0, R1, R2SDIV R0, R1, R2\t\t\t\t\t; signed\n例题：应该是因为有可能减成负的所以signed\n\n指令有1字长，半字长的。hw1是指明功能用的，hw2是一些拓展比如立即数。\n\n地址从低到高分别是：4F F0 0A 00 0A 68 10 44……\nPC每次取到半个字 hw，就+2B跳转到下一个hw。\n选择结构\n\tCMP R0, R1\t\t\t\t\t\t; 相当于if，比较后更新APSR。EQ= LT&lt; GT&gt; LE&lt;= GE &gt;=\tBEQ BRANCH_1\t\t\t\t\t; B是跳转，BL是跳转到函数执行完后返回，BX是根据地址最低位判断目标地址是arm还是thumb在决定跳转到整字还是半字。bx操作数不能是立即数，必须是寄存器\tB BRANCH_2\tBRANCH_1\t...\tB IFEND\t\t\t\t\t\t\t; 不写这个就继续执行BRANCH_2了，像switch的breakBRANCH_2\t...B IFEND\n循环结构\nWHILE_BEGIN \tUDIV R2, R0, R1 ; R2 = n / x\tMUL R3, R2, R1 ; R3 = R2 * x\tCMP R0, R3 ; n == (n / x) * x\tBEQ WHILE_END\tSUBS R1, R1, #1 ; x--\tB WHILE_BEGIN ; loop backWHILE_END\nStack\n内存中有一片内存空间类似栈的数据结构。SP指针指向栈顶。\n这个栈地址是从高到低的，也就是存入数据 SP–，取出数据 SP++，类似一个翻转过来的，倒着的书堆。\n满堆栈：sp指针指向最后一个栈顶数据。\n空堆栈：指向最后一个数据的下一个要放入数据的空位置。\n我们的课程中使用空堆栈，指向下一个空位置，存数据就先存入再SP-4，取数据就先SP+4再出栈。不过这两条指令都不需要我们手动执行，有专门的指令：\nPUSH &#123;R0, R4-R7&#125; \t; Push r0, r4, r5, r6, r7POP &#123;R2-R3, R5&#125; \t; Pop to r2, r3, r5。入栈出栈顺序不是按照书写顺序而是自动根据寄存器地址，高地址值给高地址寄存器\n存入5个数据和取出3个数据。\nFunctions\nBL先保存当前PC值到LR，然后PC跳转到函数地址，\nBX LR跳转到LR中的地址用于函数返回。\nArchitecture Procedure Call Standard (AAPCS) ：规范定义哪些寄存器主函数和函数通用，哪些是独有的。\narm AAPCS规定：r0-r3是通用寄存器（类似全局变量），但main和函数的R4 – R8, R10-R11不通用（类似临时变量，到了函数里这些值就变了，不是原函数的），要压入栈保存。函数调用和返回的时候要保存和恢复通用寄存器值。这些由调用原函数的子函数 callee-procedure 执行。\n简单的参数的函数调用：传参给R0-R3作为函数参数，R4-R11压入栈，然后跳转到函数处。\n\nProgram Memory Use\nROM里都是只读数据，比如常量常数。\n\nconst, static, volatile\n貌似是不会过多涉及具体代码实现的部分，就先简单介绍一下了。\nconst 就是定义常量变量，定义后无法再次修改。\nstatic 通常定义静态函数，静态函数里的值是通用的，也就是每次调用该函数其值都是接着上次调用该函数的值继续。\nvolatile：一个在嵌入式里挺重要的东西，软考题里出现过几次。大概就是禁止编译器优化该变量来防止不必要的错误。\n比如编译器优化num变量，这样每次修改num变量的值的时候都不会立刻写入内存中，可能会先把修改时的值写入寄存器，函数返回时写回内存。\n现在比如我们在main中num+=5, 修改值后的num暂时存在寄存器里。然后我们调用中断，从内存中读取当前num的值并+1.但是内存中值还没改，还是原值。返回后，main再把自己手中的num值写回内存，最后内存中num值只+5，而不是我们期望的+6.\nvolatile 声明后的变量不会做这样的优化，值改变了就立刻写回内存，虽然可能效率低但是安全。\nInterrupts\n比如我们程序的逻辑是按键按下的时候点亮小灯。第一种做法是 Polling 轮询，一直看：按键按下了吗？没有。按下了吗？没。按下了吗？……\n这样主要是效率低浪费CPU资源，如果为了节约资源轮询间隔大了，又不能及时响应。\n中断允许CPU专心处理background的事情，触发中断的时候先放下后台处理前台。对于无os的裸机也能实现简单的多线程切换。\n异常处理流程\n\n\n结束当前正在执行的指令。\n\n\n当前模式寄存器值压栈保存。\n\n\n\n切换模式。\n\n\nPC LR更新（根据异常处理器提供的值）。PC去查中断向量表，看要跳到哪里，EXC_RETURN Code赋值给LR。\n\n\n更新IPSR状态。\n\n\n开始执行异常代码。\n\n\n退出，BX LR把 EXC_RETURN Code 值返回给PC。\n\n\n出栈。\n\n\nTiming\n中断执行也是耗时的，需要一定的时间保存源程序状态，执行中断，恢复。\nFMax_Int：最大中断执行频率，即：单位时间内最多执行几次中断。\nF_CPU：CPU频率，即：单位时间内CPU有多少次指令周期。\nC_ISR：执行中断内容需要多少周期。\nC_Overhd：中断保存、恢复数据等准备工作用多少周期。\n中断一次执行所需周期：C_Overhd+C_ISR\n因此， $F_{Max_Int=}F_{CPU}/(C_{ISR}+C_{Overhd})$\nU_int：中断处理实际消耗的利用率，上面那个毕竟是最大值。\n$U_{int}=F_{Int}/F_{Max_Int}$\n中断执行速度（和频率一样）：F_Int\n非中断执行速度：(1-U_Int)*F_Int\nGPIO\nGeneral Purpose Input Output,\nMemory-Mapped IO\n把设备，控制等寄存器映射到内存里。好处就是访问设备方式和内存一样，也不用设计复杂的IO电路，便捷；缺点在于占用了内存空间。\nPeripheral-Mapped IO\nIO有一块专门的存储区域，和内存不一样，也有专门的不同的电路指令去访问IO。好处就是节省内存空间，也能清晰的知道什么时候发生IO了；缺点在于开发、设计上的造价增加。\nGPIO\n通用IO可以判断引脚高低电平，可以给引脚赋值高低电平进行控制。\nstm32有几组GPIO，每个有16个Pin，可以配置为input output pullin pullup等模式，以及定时器、串口、中断等功能。\n什么是上下拉模式？如果不设置为上下拉，引脚浮空的时候（没有设置输入为高或低电平的时候）浮空引脚可能收到电磁波干扰等等问题导致输入状态不确定，有0有1的，容易造成错误。\n下拉：三极管控制默认接地，无输入的时候默认低电平。\n上拉：三极管控制默认接Vdd 芯片工作电压。\n\n大多数引脚是这两个功能都有的，我们初始化GPIO的时候选用一个，寄存器根据值控制接通相应电路。\n\n输入输出信号真的可以被称为“信号”。输入规定为0-0.5视作低电平，0.5-Vdd视作高电平，范围以外的值无效。输出电流也只有5mA左右是没有能力直接驱动一些设备的，我们可以通过一些电路比如三极管，放大器等，电路接收到信号得知”需要输出驱动电流了“然后输出大电流。\nControl\n每个GPIO口有：\n4 * 32bit configuration registers: 配置相关信息，比如in/out，上啦下拉，开漏输出或推挽输出，输出频率等。\n\n推挽输出 push-pull：能输出高低电平。\n开漏输出 open-drain：没有能力输出高电平，想输出高电平需要设置上拉电路来输出。\n\n2 * 32bit data registers: 输入输出数据寄存器。\n1 * 32bit set/reset registers: 设置或复位寄存器。\n1 * 32bit locking registers: 锁定寄存器。\n2 * 32bit alternate function selection register.\nMode\n如图，32个Pin，每个两位来设置4种模式（in out 可选 模拟）。\n\nPull\n只有3种模式（无pull，上拉，下拉）。\n\ndata\n输入输出数据寄存器分开的。\n\nCMSIS\n先说一下考试定义：\nCMSIS transforms memory mapped registers  into C structs\n#define PORT0 ((struct PORT*)0x2000030)\n\n再说一下和一些嵌入式前辈讨论的理解，以下内容不许考试写：\n\n李肯老师：arm-M推出的一系列API和软件组件，包括核心功能、DSP库、RTOS支持和调试接口等。\n李肯老师：如果芯片厂不想再多一层，CMSIS就够用；但有的厂商会再在上面封一层，可能叫driver层。\n李肯老师：另外CMSIS有个限定，就是ARM的ARM Cortex-M处理器；虽然它很常见，但并不是所有的处理器都是这个内核；这个需要注意。\n榊：这种与内核相关的文件，比如启动文件，内核文件是CMSIS规定。\n\n榊：对比STM32F103和GD32E23的启动文件，我们会发现是一样的：\n\n榊：而芯片厂商要做的是根据这个arm规定的接口二次开发库函数。\n\n李肯老师c站账号：架构师李肯的博客_CSDN博客-程序人生,粉丝福利领域博主\n榊老师c站账号：风正豪的博客_CSDN博客-C语言,MSP430F5529,Linux领域博主\n平时李肯老师的交流群会讨论很多嵌入式相关问题，欢迎有兴趣的同学来学习[Doge]\n以上内容感兴趣的看个乐呵。\n例：\ntypedef enum &#123;Reset, //!&lt; Resets the pin-mode to the default value.Input, //!&lt; Sets the pin as an input with no pull-up or pull-down.Output, //!&lt; Sets the pin as a low impedance output.PullUp, //!&lt; Enables the internal pull-up resistor and sets as input.PullDown //!&lt; Enables the internal pull-down resistor and sets as input.&#125; PinMode;gpio_set_mode(P1_10, Input);gpio_set_mode(P2_8, Output);int PBstatus=gpio_get(P1_10); gpio_set(P2_8, 1);\n以上代码是老师提供的driver，大意就是选定pin，传入特定参数，即可设置模式，设置输出。\n感兴趣可以看看我的这篇文章，如果使用arm定义的cmsis直接去开发也是可以的：\nSTM32 学习笔记_4 GPIO：LED，蜂鸣器，按键，传感器的使用_灰海宽松的博客-CSDN博客\n#include &quot;stm32f10x.h&quot;int main(void)&#123;    /* 控制gpio需要三个步骤：开启rcc时钟，初始化，输入输出函数控制 */    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);        GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);        GPIO_SetBits(GPIOA,GPIO_Pin_0);    while(1)&#123;&#125;&#125;\ndrivers二次开发，可以帮助简化。\n当然这一段都是题外话了。考试就理解为“cmsis是变量宏定义直接映射到寄存器上；drivers是对其添加进一步行为”即可。\nSerial Communication\n串口通信，一种发送消息的通信方式。\n串，指的是发数据的方式：一位一位串行发，并行是可能有多路通道，每路同时发一个数据，多路同时到达。\n串口通信有单工 Simplex，半双工 Half Duplex，全双工 Full Duplex。\n两种传输方式：同步 Synchronous，共用一个时钟；异步 Asynchronous，有各自的时钟。\n同步很简单，发送方接收方比如都规定时钟信号下降沿收发。\n\n异步：需要通过异步通讯协议 Asynchronous Comm. Protocol 来协调。\n\n1位起始位标志开始传输，7/8/9位数据位，1位可选奇偶校验位，1位停止位。\nRT两方需要有相同的波特率。\n当然这只是最简单的串口通信因为只有双方。如果更多方通信我们需要校验地址来判断是哪个发给哪个；数据需要更复杂的校验方式。\n异步通信不需要同步时钟之类电路，开销小，但是开发起来难度大一些因为需要起始结束位啥的。\nRS232\n异步通信，Reversed Polarity 标准电压（-3~-15是1,3~15是0.还有一些其他标准比如TTL是+5为1，-5为0.）\n发送数据有两种类型，ascii码和二进制，都得转化为二进制传输。\nuart\n针对stm32f401.\n全双工异步串口。\n为了处理RT缓冲数据（因为发收数据需要时间）我们可以通过缓冲区数组，头指针表示已经发到的位置，尾指针表示要发的数据的结尾。增加新数据，尾指针++；发一个数据，头指针++直到碰到尾。\n原来发送方一直是发高电平，start frame 起始帧是1帧低电平来表示开始发数据了。\n如何判断是1帧低电平？通过在这一帧里多次采样判断是不是真的是一帧低电平。\n为什么多次采样？因为异步两个信号有一定的偏移，多次采样准，能确定是不是真的一整帧都低电平。\n采样是有一定采样率的，不是说真的能像模拟信号一样一直采。\n采样率 oversampling=16: 这个是最大可以达到的采样频率而不是真的一帧采了16次。\n\n接收方首先第一次检测到0位，开始怀疑：有可能是串口有消息。这是start frame的第一次采样。\n然后每隔一帧检测一次，3 5 7检测3次，如果2个都是0，说明确实有可能。\n然后连着检测8910，如果还是2个0，说明确实是start frame。\n\n8采样率因为采样间隔长了，更容易碰到左右边界的高电平，所以容错率低。但是速度更快。\n计算\n波特率计算：\n$T_x/R_x(baud)=\\frac{f_{PCLK}}{8*(2-OVER8)*USARTDIV}$\nOVER8是过采样率，fPCLK是时钟频率。\nUSARTDIV是一个浮点数\nUSARTDIV浮点数怎么存储？通过算法转化为十六进制。\n\n小数部分用一个16进制位表示，比如例1是C也就是12，转换后即为12/16也就是0.75.\n例2转换为一位16进制，就是0.62*16约等于10也就是A。\n整数部分直接转换十六进制即可，例2的25转为19，例1的27转为1B。\n然后整数小数部分拼接起来（最多3个整数位，1个小数位，32位寄存器）。\nTimer\n想让程序定时运行，比如led 1s闪烁一次。如何做到？\n第一种方法是愚蠢的delay延时，我自己估算一下：嗯，delay(2000)差不多1s。然后在程序中delay，点亮，delay，熄灭……\n太浪费资源了。\n第二种方法，32是有定时器中断的。\n定时器中断大概原理是，32上有时钟晶振按固定频率周期输出0101010……定时器里有一个cnt，收到一个时钟晶振就++。\n我们可以设置定时器溢出值，比如溢出值是1000，cnt加到1000会自动触发定时器中断。然后归0，继续++。\n\n执行周期数量：1+1+1+1+(0xFFFFFFFF一直-1-1-1直到变为0x00FFFFFF的循环次数)+(r0+1的执行次数，1次)\n定时器也有一些扩展方法，比如我们可以设定++还是–；可以设定信号源是时钟或者外部输入的方波信号；可以读取计数值……\n我们课件常用方法好像是–到0触发中断，然后恢复初值。\n\nPWM\nPWM这个东西是什么？\nPWM（Pulse Width Modulation）脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域。\n就好比说，你骑自行车速度只能是100和0，模拟电信号只能输出高低。\n但是呢，你骑自行车是有惯性的，以100速度蹬一脚，以0速度蹬1脚，100速度蹬一脚……\n整体来看你的自行车平均速度是50（我们假设加速度不需要时间哈）\n这个应用场景有很多，比如设定led闪烁频率：高低高低高低……，因为频率极高，我们肉眼看不出来在闪，给我们呈现的视觉效果就是以一半的亮度在亮。高低低高低低就是1/3亮度。\n比如电机通过这个方式调速度。\n那么他有什么应用场景。第一，输入捕获 Input capture。\n对于一个这种有惯性的系统，我们也可以反过来读取其波形来判断其速度。比如电机放一个转速检测传感器，把输入波形作为定时器的时钟源信号，定时器一直++：检测上升下降沿时记录cnt值，通过差值比较计算时间间隔。\n\n第二，输出比较 output compare。\n定时器一直++，与预先设定好的阈值比较，如果相等触发中断输出。\n\n这就是PWM。占空比相当好算。\nLow Power Timer\n我们目前假设的是CPU一直运作的，只是在后台和前台之间切换。有一种低功耗定时器使得没有发生定时器中断的时候CPU被置为低功耗状态，只有发生定时器中断的时候才启动。（使用 __WFI() wait for instruction 指令）\n\nSysTick\nM系列自带的一个系统时钟，使用处理器时钟或者参考时钟作为时钟源。\n有四位寄存器：\n\n每次赋值是load，一直–到0时重新load赋值。ctrl是控制启用系统时钟。这个是CMSIS有提供的数据结构和相关操作函数的时钟处理部分。\n\ninit 参数是中断间隔的毫秒数。timer_set_callback() 里跟一个可以是自己定义的函数，使得触发定时器中断时该函数被执行。以上代码意思是每隔100ms LED灯翻转一次，且 CPU 常态下处于低功耗状态。\nI2C\n连接多个模块的传输方案：I2C，使用两根总线。\n\n两根总线分别是时钟总线 SCL 和数据总线 SDA。\n通信过程\n现在我们串一遍I2C上一个模块（master）要给另一个模块（slave）发消息的过程。\n\n\nMCU 使用一定的方法标识自己开始传输了。\nMCU 发送 LCD slave 的地址+一位读写位，其他模块接收到发现地址不是自己的，就不做处理。\nLCD 接收到后知道目标是自己，于是返回 ack。\nMCU 收到 ACK 后发送一帧数据。\n发送完 MCU 等着 ACK，收到 ACK 后继续发送下一帧数据。\n一直发送到发送停止位 stop 结束。\n\n\n数据长度可以设置，比如789.\n总线上的器件是开漏输出的半双工通信。\n\n默认总线是上拉电阻拉成高电平。\n当器件输出 out 为低电平时，总线导通到接地，总线被拉低（整条总线都被拉低）。江协科技老师举的例子很好，就像公交车上的一根横杆，有人拉住横杆拽下来，整条横杆都被拉低了，其他人都知道“横杆被一个人拉低了，说明有人正在使用总线”。\n然后是总线传输数据的方式，SCL SDA 两根总线在何种情况下表示 start stop 0 1 bit?\n\n首先都是 SCL 为高电平时 SDA 的数值才有意义。\nSDA 从高到低，表示 start 位。从低到高，表示 stop 位。\nstart 位后，SDA 高电平表示1，低电平表示0.\n发送完 1byte 数据后，总线保持拉高状态。如果接收方把总线拉低了，发送方发现总线1→0了（不是发送方自己拉的，是接收方给他拉下来的，但是发送方能察觉到），说明接收方成功接收了并且拉了拉总线以示“收到”。如果 SDA 还是保持在高电平，说明接收方没有成功收到或者成功发送 ACK。\n\n问题处理\nI2C 是一种很简单的主从通信协议了，但是局限性也很多，比如7 bit 的地址线只允许 2^7 个设备；一次顶多两个设备主从通信；一个设备的快慢会影响到整条总线的通信等。\n问题1：从设备处理速度太慢了，赶不及在下一个时钟周期接收新数据帧怎么办？\n方法：clock stretching, 拉低一段时间 SCL 假装下一个时钟周期还没到。\n\n问题2：多个设备同时发数据冲突了怎么办？\n方法：Bus Aribitation，前面我们知道总线被一个设备拉低了，所有设备都能接收到总线拉低的信号。因此如果两个设备同时开始发信息，前面数据一致都无所谓，等到第一次数据不一致的时候，一个设备发送数据0，一个发送数据1，这时 SDA 总线被 DATA2 的0拉低了。\n\n发送 DATA1 数据的设备就明白了：有人同时在和我一起发数据，因此总线不是我预期的1而是被他拉低为0了。那我 quit，你发吧。然后就只有 DATA2 发送的数据了。\n问题3：以上发送的数据每次都是 1byte 8bits 很正好。那如果要发送的地址不是 8bits 呢？\n方法：少于 8bits 用一些固定的额外的 start 位填充，多于 8bits 的地址用两个 bytes，不够的也是用额外的 start 位填充。\n\n问题3：如果我 master 发完数据，想紧接着再收数据，变成 slave，可行吗？\n方法：通过一个 sr 信号，也就是 repeat start 重发 start 位，来标识自己是 read 而不再是 write 了重新开始通信。\n\n编址格式\nslave 地址编址有一些固定格式。\n\n0000 000 0：广播，对所有 slave 结点讲话。如果 slave 无视（NACK），就不会参与广播。如果返回 ACK 就参与进来了。不过多个 slave 都返回 ACK 的话 master 是不知道都有谁回应了的。\n第二个 byte 发送一些行为相关，比如：start，clear，reset software\n编程应用\nslave mode:\n\nI2C 设备默认工作在 slave mode。\n外设时钟在 I2C_CR2 寄存器中编程。频率介于 2kHz~100kHz。\n硬件自动等待发过来的 start 和 addr 信息。\n如果 addr 信息和  OAR1 中存储的地址相同，说明目标是自己。如果 ACK 位为1，则发送 ack pulse。\n设置 ADDR 位，1表示匹配。\n如果 ITEVFEN 就是中断事件 flag 为1，则生成中断。\nTRA 位标明 slave 是 R 还是 T 模式（收 or 发）。\nBTF 位标识收没收完。\n\n\n\n这么说起来还是有点混乱 I2C 到底经历了哪些才顺利发送了数据？\n首先，从主模式的概念。master 主模式驱动时钟信号，发起传输；slave 从模式响应传输。\n主模式\n\n发送：\n所有 EV 事件都会拉低 SCL，直到相应软件序列执行完成。\nS：start 事件。比如CR2 寄存器中设置外设时钟，配置时钟寄存器，上升时钟寄存器，使能 CR1 来启用时钟，CR1 中设置 start 位，等待总线被拉低表示就绪，发送启动信号，并切换为主模式。\nEV5：启动事件成功进行，设置 SB 寄存器=1. SB 寄存器=1后才可以进行地址阶段，执行完地址阶段会自动清除 SB 和 EV5 事件。\nAddress：地址阶段。传输7位地址+1位读写位，然后等待从机的 ack。收到 ack 进入 EV6.\nEV6：设置 addr 位=1代表地址阶段顺利执行， master 收到 ack了。清除 EV6 后自动进入 EV8.\nEV8：设置 TxE ，准备写入主机要传入的数据。TxE 表示数据寄存器为空可以写入。每次数据写入 DR 都会清空 TxE 和 EV8 事件。写完数据数据传过去了，主机收到 ack 后继续传输。以 BTF=1 表示数据传输的结尾。\nvoid i2c_write(uint8_t address, uint8_t *buffer, int buff_len) &#123;\tint i = 0;    // Send in sequence: Start bit, Contents of buffer 0..buff_len, Stop    while (((I2C1-&gt;SR2&gt;&gt;1)&amp;1)); // wait until I2C1 is not busy anymore    I2C_GenerateSTART(I2C1, ENABLE); // Send I2C1 START condition    // wait for I2C1 EV5 --&gt; Slave has acknowledged start condition    while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));    // Send slave Address for write then wait for EV6    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Transmitter);    while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));    while (i &lt; buff_len)&#123;        I2C_SendData(I2C1, buffer[i]); // send data then wait for EV8_2        while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));        i++;    &#125;    I2C_GenerateSTOP(I2C1, ENABLE); // send stop bit&#125;\n\n接收：\n前面和 master transmit 都一样。\nTxE 改为 RxE 了，=1标识接收到了数据。\nmaster 自己设置 stop 事件后（发送 NACK）停止接收。\nvoid i2c_read(uint8_t address, uint8_t *buffer, int buff_len) &#123;    int i = 0;    // Start bit, Contents of buffer from 0..buff_len, sending a NACK    // for the last item and an ACK otherwise, Stop bit    I2C_GenerateSTART(I2C1, ENABLE);    while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); //EV5    // Send slave Address for write then wait for EV6    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Receiver);    while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));    I2C_AcknowledgeConfig(I2C1, ENABLE); // going to send ACK    while (i &lt; buff_len - 1)&#123;        while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); //EV7        buffer[i] = I2C_ReceiveData(I2C1); // get data byte        i++;    &#125;    I2C_AcknowledgeConfig(I2C1, DISABLE); // going to send NACK    while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); //EV7    buffer[i] = I2C_ReceiveData(I2C1); // get the last byte    I2C_GenerateSTOP(I2C1, ENABLE); // send stop&#125;\n从模式\n\n发送：\nstart 启动事件由 master 发起。从机校验地址并决定是否发送 ack 位。\nEV1：设置 addr 位表示地址匹配。\nEV3-1：设置 TxE 位，开始传入数据。一直到主机返回 NACK 表示不想再要数据了，或者 AF=1 说明 ack 失败了为止。\n\n接收：\n前面到 EV1 和 slave transmit 都一样。\n\n数据从 DR 寄存器中读。\n读入一个 byte 后，如果 ack 位已经设置，则返回 ack 信息。\nRxE 位是接收数据的状态寄存器。\n主机生成停止条件时停止。\n\n异常情况：\n总线错误，NACK，仲裁失败，时钟异常超时。\n\n","categories":["邮途（北邮国院课内学习）","Lecture"],"tags":["Miprocessor"]},{"title":"伦敦国王学院EEM笔记：Machine Learning 机器学习","url":"/2025/01/01/%E4%BC%A6%E6%95%A6%E5%9B%BD%E7%8E%8B%E5%AD%A6%E9%99%A2EEM%E7%AC%94%E8%AE%B0%EF%BC%9AMachine%20Learning%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"概率论基础\n在正式开始机器学习方法之前，我们先学习一些概率论（Probability）的知识以便后面进入算法正题。\n随机变量\n离散随机变量\n离散随机变量（Discrete Random Variables）x 可能在集合 X 的范围内取值，比如投掷硬币的概率随机变量 x，取值集合 X ={正面，反面}。随机变量实质是函数。\n投硬币是一个离散的例子，X 还可能是连续的集合。\n注意区分随机变量 x 和它的取值 realization x 的区别，x = x 意思是随机向量 x 取值为 x（类似于投硬币事件 x 投出了 “正面” 结果吧。第二个 x 是斜体）\n\n[!TIP]\n英文教材表达：random varible x takes value x.\n\n对于每个不同的 x 值，都有它在这个随机变量 x 里的概率，用函数表示就是：\nx~p(x)= Pr [x = x]\np(x)的范围肯定是 0 到 1 的，概率不可能大于 1.rv x 中的所有概率求和 = 1.\n\n\n伯努利二元随机变量（Binary/Bernoulli variable）：x 中只有两个值，类似投硬币的正反。这两个值概率互补，比如投硬币正反概率各 50%。\n\n\n分类随机变量（Categorical/Multinoulli variable）：有多个结果。\n\n\n$$\n\\begin{aligned}\nX&amp;={0, 1, … , C-1}\\\np(k)&amp;= q_k\\\nRandom; Variable; q&amp;= [q_0, q_1, … , q_{C-1}]\n\\end{aligned}\n$$\n且随机向量内所有元素求和 = 1.\n机器学习中常用一种叫做独热编码（one-hot vector）的方式表示随机变量，就是对于多分类问题的结果预测里面只有一个值 = 1，其他的都是 0（也就是预测结果一定是某一个结果，比如：这张图片有100%的概率是猫，0%的概率是狗或者老鼠。也类似嵌入式的位掩码，只有一个元素生效）。 比如：\n\n连续随机变量\n连续随机变量（Continuous）通常用概率密度函数表示，$x\\sim p(\\textit x)$，同样 p(x)在域上求积分 = 1.\n比如经典的高斯变量，$x \\sim N(\\mu, \\sigma ^2)$，表示公式：\n$$\np(x)= N(x|\\mu,\\sigma ^2) = \\frac{1}{\\sqrt{2\\pi \\sigma ^2}}exp(-\\frac{(x-\\mu)^2}{2\\sigma ^2})\n$$\n\n期望\n期望（Expection）也叫平均值，最有可能的结果。离散随机变量的期望：\n$$\nE_{\\mathbb{x}\\sim p(x)}[\\mathbb{x}] =\\sum_{x\\in\\mathcal{X}}p(x)\\cdot x\n$$\n离散变量的 函数 的期望：给定 x 和其概率分布，求 f(x) 的期望值是多少。可以理解为首先 x 有多大的概率等于这个值，然后再用 x 的这个值代入 f(x)得到的结果，我们要计算这个结果的期望值。\n$$\nxE_{\\mathbb{x}\\sim p(x)}[f(\\mathbb{x})] =\\sum_{x\\in \\mathcal{X}}p(x)\\cdot f(x)\n$$\n比如下题，cat 是分类分布，表示 x 有 0.1 的概率 = 0,0.2 的概率 = 1,0.7 的概率 = 2，求 f(x)的期望值：\n$$\n\\begin{aligned}\nx\\sim Cat([0.1,0.2,0.7]), and, f(x)= x^2\\\\\nE_{x\\sim Cat(q)}[x^2] = 0.1 \\cdot 0^2+0.2\\cdot 1^2+0.7\\cdot 2^2 = 3\n\\end{aligned}\n$$\n连续函数求期望的方式类似，求积分而已。\n$$\nxE_{\\mathbb{x}\\sim p(x)}[f(\\mathbb{x})] =\\int_{-\\infty }^{+\\infty }p(x)f(x)dx\n$$\n高斯随机变量 $N(µ, σ^2)$ 的期望，对于 f(x)= x 函数来说 $= µ$，对于 $f(x)= x^2$ 函数来说 $= µ^2+σ^2$.\n\n高斯随机变量的期望是线性的. 也就是说满足 $E(af(x)+bg(x))=aE(f(x))+bE(g(x))$ 。\n\n向量\n基础向量（Vector）操作矩阵乘法等不再赘述。这里指的向量的表示形式是列向量（L×1 长度）。\ninner product 内积：两个长度相同的列向量每个元素相乘，$x^Ty$。内积一般用来衡量两个向量的相似度（similarity）.\n比如下面这两对 xy，内积都 = 6，说明其相似度差不多。\n\n范数（norm）：就是向量的标量长度，可以通过 $x^Tx$ 计算。\nL1 范数：$x^Tx$\nL2 范数：L1 范数再开根，代表向量长度。\n比如上面的笑脸图，除了右上角的 y 的 L2 范数 = 6，其他向量 L2 范数 = 8.\n$\\widetilde{x}$：x 的归一化，相当于一个和 x 方向相同但是长度 = 1 的向量，用 x/L2 范数（‖x‖）就可以得到。\n矩阵\n对角矩阵（Diagonal matrix）：只有对角线上的值（$a_{ii}$）非零\n$$\nDiag(a)=\n\\begin{bmatrix}\na_1 &amp; 0 &amp; {…} &amp; 0 \\\n0 &amp; a_2 &amp; \\  &amp; 0\\\n{…} &amp; \\  &amp; {…} &amp; {…}\\\n0 &amp; 0 &amp; {…} &amp; a_L\n\\end{bmatrix}\n$$\nL×1 列向量的对角矩阵相当于把列向量中的元素均匀分到 L×L 矩阵的对角线上。两个列向量的乘积 = 一方的对角矩阵与另一方列向量的乘积。\nSymmetric matrix 对称矩阵：矩阵转置仍然等于其本身。对角矩阵很明显就是对称的。\n随机向量\n随机向量（Random Vector）是随机变量中所有元素按列向量排列。其中某个元素的概率：$Pr[x=x_i]$\n联合随机向量（Joint pmf p(x)）：多个维度的事件同时发生的概率。类似于：第一次硬币投出正面，第二次投出反面的概率。 $p(x)=Pr[x_1 = x_1\\ and\\ x_2=x_2\\ …\\ and\\ x_L = x_L]$\n伯努利随机向量（Bernoulli random vector）：只有两种情况，类似投硬币，一正一反。\n联合伯努利随机向量（Jointly Bernoulli random vector）：2 个维度的伯努利向量。\n\n\n\nx1\\x2\n0\n1\n\n\n\n\n0\np(0,0)= 0.45\np(0,1)= 0.05\n\n\n1\np(1,0)= 0.1\np(1,1)= 0.4\n\n\n\n连续随机变量的联合表示从二维的平面变为三维的空间了，两个自变量 x 是两个维度，得到的最终概率值是一个维度。比如下图是高斯随机变量的联合表示图，x y 坐标决定 z 坐标值：\n\n边际分布（Marginal Distributions）：只考虑多个变量中的部分变量的概率。比如上面的表格，x1~Bern(0.5)，x2~Bern(0.45)（伯努利的写法是 Bern(= 1 部分的概率)）\n条件概率（Conditional Distributions）：给定其他变量为 xx 的条件下，这个变量为 xxx 的概率是多少。比如上表格，x2 = 0 的话 x1 的概率分布：P(x1 = 0 | x2 = 0)= 0.45/0.55, P(x1 = 1 | x2 = 0)= 0.1/0.55, (x1|x2 = 0)~Bern(0.18)\n应用：比如生成式语言模型，已经生成了之前 1k 个词后下一个词为“xxx”的概率为多少。\n独立性（Independence）：两个变量没有什么关系。两者同时发生的概率就是两者分别发生的概率的乘积，p(x1, x2)= p(x1)p(x2).\np(x1, x2) = p(x1)p(x2|x1).\n贝叶斯定理\n贝叶斯定理（Bayes）被称为：改变信念 brief 的定理，大概是从概率角度上让人更改自己的偏好。所以也常用在机器学习中。\n$$\np(x_2|x_1) = p(x_2) \\frac{p(x_1|x_2)}{p(x_1)}\n$$\n\n[!NOTE]\n以吴军老师在中文分词领域举的一个例子来说，对于一个句子：南京市长江大桥，可以有两种划分：\n\n南京市 / 长江大桥\n南京市长 / 江大桥\n\n到底哪一种更合理？我们可以计算条件概率：\n\nP(长江大桥|南京市) = 出现“南京市”时，出现“长江大桥”的概率；\nP(江大桥|南京市长) = 出现“南京市长”时，出现“江大桥”的概率。\n\n提前准备好大量的中文语料，计算出两种分词的条件概率，我们就可以得出哪种分词更合理。\n一文搞懂贝叶斯定理（应用篇） - Blogs - 廖雪峰的官方网站 (liaoxuefeng.com)\n\n生成式大模型，搜索引擎等常见其应用。\n推理\n现在我们已经有一定概率论基础了。我们开始学习“推理（Inference）”，即：已知概率的情况下，根据输入 x 猜测输出 t。\n推理的中间过程是一个概率模型（probabilistic model x 和 t 的联合分布 p(x, t) ）来预测最可能的 t。\n模型的具体实现被称作预测器 predictor。\n推理问题主要分为两类，离散的 detection （比如晴天或者雨天）和连续的 estimation（比如温度）。\n而推理结果又分为两种：hard predictor 和 soft predictor，hard 就是只挑选某一个具体结果（比如预测 x = 0 时 t = 1，只确定一个固定结果）；soft 就是不确定的（当 x = 某个值时，t 为 0 的概率有 10%，为 1 的概率有 90%）。\n下面的公式示例中，第一行是 hard 的写法，代表：x = 0 时 t 的预测结果 = 1。\n第二行是条件概率的 soft 的写法，代表：x = 0 时 t = 1 的概率是 0.2。\n$$\n\\begin{aligned}\n\\hat t(0)= 1\\\nq(1|0)= 0.2\n\\end{aligned}\n$$\n贝叶斯推理\n贝叶斯定理（Optimal Soft Prediction / Bayesian Inference）比如我们求出，q(t|1)= Bern(t|0.8)，那么可以说：$\\hat t(1) = 1$ with associated probability of error of 0.2（误差 = 0.2 的硬推理）。当 x = 1 时 t = 1 的硬预测器是最优的。\n代价函数\n代价函数（Cost Function）用于计算预测器和正确值之间的偏差，进而后续决定如何修改预测器让代价更小。\n\n[!NOTE]\nloss 一般指的是单个预测值和正确值的差距，而 cost 指的是模型整体（所有预测值和变量值）的差距。\n\n对于硬推理，我们用代价函数记录预测的硬推理值与真实值之间的偏差来评估硬推理。\n$$\n\\mathcal{l} (t,\\hat t)=|t-\\hat t|^k\n$$\nk 一般 = 2，也就是平方损失（quadratic error loss）。\n一种损失函数：detection-error loss，也叫 0-1 loss。指实际值和预测值一致时损失=0，否则=1. 比如只有 0 和 1 两种结果的伯努利随机向量情况（猜猜明天是晴天还是雨天。猜对了损失 = 0，猜错了 = 1）。\n$\\mathbb{1}$ 是指示符函数，预测结果正确时 = 1，否则 = 0.\n$$\n\\begin{aligned}\n\\mathcal{l} (t, \\hat t) &amp;= \\mathbb{1}(t \\ne \\hat t) \\\\\n\\mathbb{1}(a) &amp;=\n\\begin{cases}\n1 &amp; \\text{if a = true} \\\n0 &amp; \\text{if a = false}\n\\end{cases}\n\\end{aligned}\n$$\n用什么损失评估硬推理的整体性能？一般用损失函数的平均值（population loss）计算。\n$$\nL_p(\\hat t(\\cdot))= E_{(x, t)\\sim p(x, t)}[l(t,\\hat t(x))]\n$$\n比如下题，预测器是令 t 永远 = 1，求 population loss。只需要计算算错部分的概率即可。\n\n最优硬预测\n最优硬预测（Optimal Hard Prediction）器的预测思路就是让 population loss 最小的预测函数。比如上图，很明显^t(1)= 0, ^t(0)= 1 的代价最小，= 0.15。\n对于硬预测，我们只需要挑出概率最大的条件概率点作为预测值即可。\n最优软预测\n最优软预测（Cross-Entropy Loss and Optimal Soft Prediction）的损失函数突然就上强度了，要算 log。cross-entropy loss：−log q(t|x)\n这是因为，对数损失的惩罚更高，迫使预测器做出更高概率更准确额预测：\n\n伯努利分布的 population 对数损失的计算公式如下（按 x 求期望)：\n$$\nLog\\  Loss =-\\frac{1}{N}\\sum^N_{i = 1}[y_i log(q(y_i|x))+(1-y_i)log(1-q(y_i|x))]\n$$\n即：每个预测结果 log 后与标准概率相乘，求平均值。\n最优软预测就是让 log loss 最小化的预测取值。\n监督学习\n监督学习简介\n推理和学习的主要区别在于 p(x, t) 是否已知。比如天气预测问题，没有人知道根据当前条件明天到底会是什么天气，只能通过以往样本学习统计出估计值作为训练参考。\n模型不可靠或者太复杂的时候，如果知道输入数据和期望输出我们可以用监督学习。\n监督学习（Supervised Learning）的步骤简单来说分为五步：\n\nInductive bias selection 归纳偏置。首先我们假设一下 目标模型 是什么样的，比如：一次函数？二次函数？做了这个假设之后再代入训练（比如 t = ax，代入训练数据后求出 a）。当然，我们的假设可能会有偏差，毕竟不一定所有问题都能找到完全合适的问题解决，这个偏差就叫 bias。以及还要定义 损失函数，损失函数用于计算预测值与训练数据之间的偏差以此调整模型；正交函数；训练方法（比如：让 loss 最小化）。\nTraining 训练。下面会讲到，我们把已知的数据分为训练集和测试集，训练集用于训练我们的模型，测试集用于检验模型效果不用于训练。\nValidation 验证，利用训练集数据计算 loss 损失判断模型的合理性，比如二次函数用一次函数的模型，偏差就会很大。\nRevise inductive bias 可能考虑是否修改归纳偏置模型。\ntest 测试集测试。\n\n监督学习解决的问题主要分为：\n\n回归问题（regression problem），连续\n分类问题（classification problem），离散\n\nmemoralizing 是记忆，记住训练数据中的 x, t 的键值对。learning 是学习，找规律。\n没有免费的午餐定理（no free lunch theorem）: 没有一种通用的学习算法可以在各种任务中都有很好的表现。我们需要对数据进行先验假设 inductive bias ，在归纳过程中再做修改。最终得到一个预测器 predictor，连续问题是软预测器 soft，离散问题是硬预测器 hard。\n比如下面这张图，我们觉得两条横线不同长度，就是因为我们大脑根据经验觉得在参考线的辅助下两条线不一样长。这个过程有点类似于计算机的归纳偏置。\n\n常见符号解释\n训练集：D，内含 N 个数据。training set D with N training data points\n$$\nD ={(x_n, t_n)^N_{n = 1}}\n$$\n硬预测器：^t\n$$\n\\hat t_D(x)\n$$\n软预测器：q\n$$\nq_D(t|x)\n$$\n硬预测模型类 model class：意为我们对预测器做一个大概的假设，这个预测器属于某一个模型类（比如一次函数的预测器类，二次函数的预测器类等）。θ 是模型的参数，属于一个特定范围，在训练过程中调整 θ 值。注意 θ 是一个向量代表一系列系数。\n$$\nH ={\\hat t(\\cdot|\\theta):\\theta\\in\\Theta}\n$$\n如果选择的模型类是多项式函数，一般用 degree M 表示其项数。\n$$\n\\hat t(x|\\theta)=\\theta_0+\\theta_1x+\\theta_2x^2+…+\\theta_Mx^M =\\theta^Tu(x)\n$$\n其中的 u(x) 可不是阶跃函数，而是 feature vector 表示 $[1, x, x^2, x^3…x^M]^T$ 这个列向量。\n这个模型类被称为线性预测器（不是因为 t 和 x 呈线性关系，很明显不是。而是因为 t 和 θ 呈线性关系）。\n总体损失 population loss：特指推理中的损失，因为我们知道概率 p(x, t) 的具体值：\n$$\nL_p(\\theta)= E_{(x, t)\\sim p(x, t)}[l(t,\\hat t(x|\\theta))]\n$$\n但是学习和推理不同，我们不知道具体概率值因此这个损失无法得到。我们可以评估训练损失：\n$$\nL_D(\\theta) = \\frac{1}{N} \\sum_{n = 1}^{N} \\ell(t_n, \\hat{t}(x_n \\mid \\theta)) = \\sum_{x, t} p_D(x, t) , \\ell(t, \\hat{t}(x \\mid \\theta))\n$$\n归纳偏差选择\n选择模型类 / 预测器的过程也是确定归纳偏差（Inductive Bias Selection）的过程。\n三种预测器\n总体最优无约束预测器（Population-optimal unconstrainded predictor）：最小化总体损失且无视模型，所以叫做无约束预测器，因为不受模型类的限制。但是我们不知道标准概率分布所以很难实现。\n$$\nt^*(\\cdot)= arg,\\mathop{min}\\limits_{t(\\cdot)}L_p(t(\\cdot))\n$$\n总体最优类内预测器（Population-optimal within-class predictor）：首先确定模型类，在这种模型类的前提下选择 θ 最小化损失。\n$$\n\\theta_M^* = \\arg\\min_{\\theta \\in \\mathbb{R}^{M+1}} L_p(\\theta)\n$$\n经验风险最小化训练预测器（Trained ERM predictor）：确定模型类，且使用有限的训练数据集来计算损失。\n$$\n\\theta_M^{ERM} = \\arg\\min_{\\theta \\in \\mathbb{R}^{M+1}} L_D(\\theta)\n$$\nERM 经验风险最小化预测\n针对这个损失函数，一种训练原则是 Empirical Risk Minimization 经验风险最小化（ERM），即找到使得 LD(θ) 最小的 θ 作为预测器参数。\n$$\n\\theta_D^{ERM}= arg,\\mathop{min}\\limits_{\\theta \\in \\Theta}L_D(\\theta)\n$$\n$$\nL_D(\\theta)=\\frac{1}{N}||t_D-X_D\\theta||^2\n$$\n和之前提到的一样，连续问题（如 Regression）的损失函数是求次方偏差，离散问题（如 Classification）的损失函数是求 0-1 偏差。\nt_D：一个列向量，依次存储了所有目标值.\nX_D：一个矩阵，每行存储了一个 u(x)，和 θ 向量相乘后就组成了每行一个预测器（第一行：输入 x1 得到的 t1 值；第二行：输入 x2 得到的 t2 值……）。\n意思就是所有预测值和训练值之间的代价损失的平均值。\n让这个代价函数最小的 θ 的解是：\n$$\n\\theta^{ERM}_D =(X_D^TX_D)^{-1}X_D^Tt_D\n$$\n如果第一部分的矩阵乘积是不可逆的，舍去这一部分即可。\nERM 相关的两个定理\n对于学习，有两个定理：\n\n魏尔斯特拉斯近似定理（Weierstrass approximation theorem）：任何连续函数，随着 M 的增加（M 是多项式模型的最高项数），精准度都会逐渐增大。（当然预测器复杂度也增加了，所以并不能只一味增加了事，计算难度也会大幅增加的）\n由于学习不知道准确概率只是根据训练数据估算的概率，所以这只能算是一种 估计 的损失。根据大数定理  law of large numbers，测试案例越多，估计损失越接近真正的 population loss.\n\n例题：\n\n给出的预测器形式很简单，就是 x = 0 时预测结果为 θ_0，x = 1 时预测结果为 θ_1。我们计算 2 个维度四种情况分别的 loss 选取损失最小的预测器。\n\n最优预测器和经验风险最小化预测器的对比\n例：\n\n当采用多项式函数模型，M = 1 时，两种预测器拟合出的预测结果分别如图：\n\n这种情况下，ERM underfits the data 欠拟合数据：\n\n模型不够复杂，the model is not rich enough\nestimation error 很小，ERM 和 population-optimal 的预测结果很像\n但是 bias 很大，因为用错公式了，一次方的函数怎么样也不可能和原函数很接近。\ntraining loss 和 population loss 都很大。\n\n如果 M = 9：\n\n这种情况下，ERM overfits the data 过拟合数据：\n\n模型太复杂了，为了匹配所有训练数据，训练数据外的数据不够精确。\n这是因为训练模型重点在于记住训练的数据集，而不是总结出没见过的数据的规律。\nestimation error 很大，ERM 和 population -optimal 差距很大；\nbias 很小，population -optimal 预测器和真正的数据规律很像。如果 bias 很大那两个模型的损失应该都很大，但是既然人家行你不行说明问题出在  ERM 本身上而不是归纳偏置上。\n当训练数据够多时，training 和 population -optimal 之间的差距会越来越小，training 会越来越准确。\n\nM = 3 时，模型预测如图，可以看出 ERM 在欠拟合和过拟合中间的 M 值会比较贴近正确预测结果：\n\n但是我们如何判断模型是否过拟合？我们不一定知道正确的模型公式。因为我们到目前为止只是用训练数据在测试，就算训练出了完全拟合训练数据的预测器（如上面第二个图，M = 9 的例子）我怎么知道这是适用于所有数据的预测器呢？\n软预测器的概率模型\n软预测器的概率模型（Probabilistic Models）用已知 t 和 θ 的条件概率表示。第三章的时候用 q 符号表示，这章用 p 符号，反正意思到位了。\n$$\n\\mathcal H =\\left{p(t|x,\\theta):\\theta \\in \\Theta \\right}\n$$\n概率模型的训练采用软预测，因为其中的概率不确定性。\n事实上很多确定性模型也可以用概率模型的特例来看待，也同样可以应用其公式。\n总体损失：\n$$\nL_p(\\theta)= E_{(x, t)~p(x, t)}[-log, p(t|x,\\theta)]\n$$\n训练损失（ERM）：\n$$\nL_D(\\theta)=\\frac{1}{N}\\sum^{N}_{n = 1}(-log, p(t_n|x_n,\\theta))\n$$\n也叫 Maximum Likehood Learning (ML Learning) 最大似然学习。最小化 log 损失，最大化概率。\n验证\n可以先拿出一部分已知数据作为验证集（validation set）不参与训练。预测器用训练集训练，验证集再计算损失。计算损失的方法仍然是整体损失：\n$$\n\\hat L_p(\\theta)= L_{D^v}(\\theta)=\\frac{1}{N^v}\\sum^{N^v}_{n = 1}l(t^v_n,\\hat t(x^v_n|\\theta))\n$$\n\n\n损失函数应该会小于真实值，因为 ERM 是基于整个训练集训练的。\n\n\n偏差问题：大数定理不再有效，因为大数定理是“训练集数量越多，整个训练集的损失越小”，而验证集的损失和训练集是分开的。所以验证集的损失是整体损失的有偏估计 biased estimate。\n\n\n比如我们可以利用验证选择更合适的模型：\n\n如何选择验证集？\nK-Fold Cross-Validation\n首先将模型划分为 K 个类。每次迭代从每个类中选取一个值作为验证集，比如第 3 次就把 3 类作为验证集，把剩下的类作为训练集。\n\n最后求所有迭代的损失平均值：\n$$\n\\hat{L}_p = \\frac{1}{K} \\sum_{k=1}^{K} L_{D_k} \\left( \\theta^{\\mathrm{ERM}}_{D_{-k}^{\\sim}} \\right)\n$$\n例题：如下，尝试计算只选取两个元素作为验证集（不用 K-Fold 验证方式）的损失。\n\n如果是总体最优预测模型：很简单，把所有数据都作为训练数据，并且如果只涉及到这四个数据，损失 = 0.\n\n学习（ERM）：现在假设我们先选择两个数据作为训练数据。假设我们选择了 x = 2 x = 3. 那就完蛋了，用这两个数据我们训练得到的预测器是 t(x)= 2，t 的值不受 x 的影响。\n$$\n\\hat t(x|\\theta) = \\theta _0 + \\theta _1x. \\theta _0 = 2, \\theta _1 = 0.\n$$\n总体损失就是(2^2^+1^2^+0+0)/4 = 5/4，过拟合。\nBias vs Estimation Error\n如何权衡偏差和估计错误？\n$$\n\\begin{aligned}\nL_p(\\theta_D) &amp;= L_p(\\hat{t}^{(\\cdot)})^{\\text{minimum unconstrained population loss}}\n+\\left(L_p(\\theta_H) -L_p(\\hat{t}^{(\\cdot)})\\right)^{\\text{bias}}\n+\\left(L_p(\\theta_D) -L_p(\\theta_H)\\right)^{\\text{estimation error}}\n\\end{aligned}\n$$\n第一部分：最优预测的损失。当然最优预测很难找到因为不知道概率。\n第二部分：bias。跟模型选择有关。\n第三部分：估计错误。跟训练数据集大小有关。\n在之前的例子中，我们知道：\nM 增加，也就是模型 class 复杂度增加，bias 会下降，但 estimation error 可能会增加，过度拟合。\nN 增加，也就是训练数据集增加，bias 不变，estimation error 会减少。\n\n再细化一点，对于每个输入 x，损失函数的表达方式是：\n$$\n\\begin{aligned}\nL_p(\\theta_D \\mid x) =\\ \n&amp;\\underset{\\mathrm{aleatoric\\ uncertainty}}{\\underbrace{L_p(\\hat{t}^*(x) \\mid x)}} \\\n&amp;+ \\underset{\\mathrm{bias}}{\\underbrace{\\left(L_p(\\theta_H^* \\mid x) - L_p(\\hat{t}^*(x) \\mid x)\\right)}} \\\n&amp;+ \\underset{\\mathrm{epistemic\\ uncertainty}}{\\underbrace{\\left(L_p(\\theta_D \\mid x) - L_p(\\theta_H^* \\mid x)\\right)}}\n\\end{aligned}\n$$\n其实这里对模型容量，数据量的介绍有些过于简化其作用了，训练效果和要解决的问题，模型选择，训练算法等等都有影响。比如深度神经网络一般是大容量模型，并不一定适用“模型容量越大，越容易过拟合”的定理。当模型容量增加的时候，测试误差会首先增加（过拟合）然后下降，直到一个插值点 interpolation point。这个特性被称为“双降 double descent”，意思是 training loss 随着模型容量增加而下降的同时，population loss 也没有如过拟合预期的那样增加。\n正交化\n正交化（Regularization）一种让 ERM 模型变得更加泛化的方法。\nθ 的参数过多会导致 overfitting，而正交化期望：降低 θ 的权重使得过拟合问题不那么明显。\n$$\n\\theta^{\\mathrm{R\\mbox{-}ERM}}_D = \\arg\\min_{\\theta \\in \\Theta} \\lbrace L_D(\\theta) + \\frac{\\lambda}{N} R(\\theta) \\rbrace\n$$\n括号内的部分是正交训练损失，Regularized training loss.\nλ：一个可以设定的参数，尽可能的在减小训练损失和准确度之间权衡。\nR：正交化 θ。比如一维范式就是所有 θ 的值求和 ||θ||，二维范式是其平方求和 $||θ||^2$。一维范式被称作 LASSO Least Absolute Shrinkage and Selection Operator 最小绝对收缩和选择算子回归。\nθ 数量越多，第二项也会使得整体的值增加，作用相当于 loss 增加。\n测试\n验证集多次迭代的过程是有偏估计，所以损失一般小于总体损失。\n建议提前拿出一组数据作为测试集（Test Set），不参与训练和验证，用测试集评估总体损失且训练者不应该知道测试集的内容。\n优化\n我们之前已经得出损失公式，以及训练的目标就是让损失最小化：\n$$\nmin_{\\theta}{g(\\theta)=\\frac{1}{N}\\sum^N_{n = 1}f(x_n, t_n|\\theta)+\\frac{\\lambda}{N}R(\\theta)}\n$$\n但是并不能一定取到最小值，比如类似 e^n 的函数，最小值无限接近 0 永远取不到。\n最小值点（global optimal point g(θ*)），对于所有 g(θ) 都有 g(θ)&gt;= g(θ*)，但大多数时候找不到。\n极小值点（local optimal point），对于 θ* 附近的 θ 值有 g(θ)&gt;= g(θ*)\n找极小值点的方法当然是求导，如果 d(g(θ)/θ)= 0 那就说明 0 处是一个极值点（stationary point）（但可能是极大值点或者暂时停止上升）。\n二阶导 = 0：在该点处局部线性。&gt; 0：说明是“U”形状。&lt; 0：说明是“倒 U”形状。\n如果二阶导一直 &gt;= 0，那么 g(θ) 的增长率（一阶导）就是一直增加或不变的（比如二次函数），那么我们可以称原函数 g 为凸函数 convex，并且 stationary point 一定是最小值点。\n\nθ 向量是从 1 到 D 维的所有 θ 系数，而 ∇g(θ) 是所有 θ 的导数的向量。\n首先如果一个点是极值点 ，这个点的一阶导一定 = 0，这是充分条件：一阶优化条件（first-order optimality condition）。\n多元函数的曲率由下公式定义 Hessian：\n\n这个矩阵是对称的，比如：\n\n其中的值全部 = 0 说明是凸函数。\n梯度下降优化\n梯度下降优化（Gradient Descent）是一种局部优化方法 Local optimization。\n简单来说，每次迭代的时候沿损失梯度下降最快的方向走一定的步长，让下次迭代的 θ 序列损失更小。\n\n公式如下，注意这里的 θ 不是指多项式中的每一个参数 θ，而是每次迭代产生的一组 θ。初始化第一组 θ 后，后面的每组 θ 都迭代计算。γ 是学习率，步长，决定每次迭代要迈多大的步子。\n$$\n\\theta^{(i+1)}=\\theta^{(i)}-\\gamma\\nabla g(\\theta^{(i)})\n$$\n如果 γ 设置的太大了，就容易迈过，再回头往反方向走。\n\n\n[!NOTE]\n图源：深度学习优化算法入门：一、梯度下降 - 知乎\n\n梯度下降\n\n如果 g(θ) 的二阶导全部 &lt;= L，可以说 g(θ) 是 L-smooth 的函数。\n\n$$\n\\frac{d^2g(\\theta)}{d\\theta^2}\\le L\n$$\n就是 g(θ) 一阶导的增长率不会过快，一定在 L 的范围内。\n\n\n当学习率 γ &lt;= 1/L 时，有如下性质：\n\nguaranteed reduction of the loss function:\n\n\n\n$$\ng(\\theta^{(i+1)})\\le g(\\theta^{(i)})-\\frac{\\gamma}{2}|\\nabla g(\\theta^{(i)})|^2\n$$\n​\t\t也就是说下一次迭代的 θ 一定能让损失下降这么多。\n\n\n\nconvergence to a stationary point：g(θ) 收敛，$\\nabla g(\\theta^{(i)})\\rightarrow0$\n\n\n\n不过问题在于 L 不一定知道。我们可以通过验证，以及其他方法获取（后续章节介绍）。\n随机梯度下降\n计算整个数据集的梯度，对于大模型来说计算成本还是太高了。\n每次迭代我们不挑出所有的训练集样本点计算 g(θ) ，只随机选取部分：随机梯度下降（Stochastic Gradient Descent）。\n$$\n\\theta^{(i+1)}\\leftarrow \\theta^{(i)}-\\frac{\\gamma^{(i)}}{S^{(i)}}\\sum_{n \\in S^{(i)}}\\nabla g_n(\\theta^{(i)})\n$$\nSGD 相比 GD 可能需要多走几步因为一开始的每一步不一定精准朝着 g(θ) 下降方向。但是计算成本还是下降了，因为 GD 每一步迈之前都要先考虑清楚所有可能的方向，再决定出让损失最小化的下一次迈步；如果数据量太大，这个功夫都够 SGD 走好多步了。\n所以选择合适的学习率也可以适当减少迭代次数。根据 Munro-Robbins conditions，SGD 的学习率设置：\n$$\n\\sum_{i = 1}^{\\infty} \\gamma^{(i)} = \\infty \\quad \\text{and} \\quad \\sum_{i = 1}^{\\infty} \\left( \\gamma^{(i)} \\right)^2 &lt; \\infty\n$$\n第一部分保证了学习率不会太小以至于原地踏步，永远无法到达 stationary point；第二部分确保学习率不会太大，SGD 的方差是逐渐减小直到消失的，保证逐渐逼近 stationary point 而不会在极点附近来回徘徊。\n比如 $\\gamma^{(i)}=1/i^{\\alpha},\\alpha \\in (0.5, 1]$ 这个学习率满足这一条件。\n多项式学习率常常用 $ \\gamma ^{(i)} = \\gamma ^{(0)}/(1 + \\beta i)^\\alpha, \\beta&gt;0,\\gamma^{(0)}&gt;0,\\alpha \\in (0.5,1]$\n除了对学习率范围设限，另一种避免到达不了极点的方法是 S 样本量每次迭代都会增加。这两种方式可以结合使用。\n计算梯度的方式\nSymbolic Differentiation：直接求导。\n\nNumerical Differentiation：利用导数定义近似求解。把 g(θ) 看作一个黑盒，不关心其内部结构，只考虑输入输出。\n\n\nAutomatic Differentiation：使用求导方法，但是只求出某个点的梯度值而不是先求出整体公式。\n三种方式的对比：\n\n计算图\n计算图（Computational Graph）便于计算梯度的图。\n比如：\n$$\ng(\\theta)=\\theta^2_1+\\theta^2_2+\\theta^2_3\n$$\n计算图表示为：\n\n当然也可能出现 θ1θ2 这样的形式：\n\n已知 θ 序列求 g(θ) 非常简单，把参数带进去就可以。forward pass\n反向传播（backward pass），假设 g(θ)= 1，反推回来。所有 f() 的部分要对相应的 θ 求导。\n\n例题： $g(\\theta)=\\theta^2_1+2\\theta^2_2-\\theta^2_3$ ，求 [1,-1,1] 点处的梯度。\n首先进行 forward pass，代入三点数值到计算图中求 g(θ) 在 [1,-1,1] 处的数值，这一步的主要作用是确定计算图：\n\n接着假设 g(θ)= 1，倒推回来：\n\n[2, -2, 2] 部分是对 forward pass 中三个函数求导再代入 [1,-1,1] 的值得到的。\n最终得到的 $\\nabla g(\\theta)=[2,-4,-2]^T$\n例题 2：如下图，f1-f3 都是 $(x_1+2x_2)^2$，f4 = logx。\n求 [1, -2, 1] 点处的梯度下降值。\n\n首先 forward pass 求出 g(θ)，并且在此过程中把每个函数对于 x1 x2 的求导也算出来（并带入输入 x1 x2 值）：\n\n然后假设 g(θ)= 1，反推回去得到 θ 的值。\n\n$\\nabla \\theta=[-4/3, -8/3,0]^T$\n\n上述方法在二元分类中的应用\n如下图，给了一个新点判断这个点可能是圈还是叉。\n\n目标 t 值：0 或者 1.\n$$\nt^{\\pm} = 2t - 1 =\n\\begin{cases}\n1, &amp; \\text{if } t = 1 \\\n-1, &amp; \\text{if } t = 0\n\\end{cases}\n$$\n整体流程还是和之前讲的差不多：\n\ninductive bias selection\ntraining\nvalidation\nrevise inductive bias\ntest\n\n模型主要分为线性模型和神经网络模型。\n线性模型\n预测器\n还是经典公式：\n$$\n\\theta^T u(x)= \\sum^{D’}_{d = 1}\\theta_du_d(x)\n$$\n特征向量 u(x) 也不一定只是 x 的多次幂列向量，比如可能是“一个句子中不同词的出现次数”。\n硬预测器的计算结果：如果公式值 &gt; 0 则 t 预测 = 1，如果 &lt; 0 则预测 = 0. 公式值 = 0 的情况不考虑也很难发生。\n$$\n\\hat t(x|\\theta)= step(\\theta^Tu(x))\n$$\n\n软预测用指数函数处理：\n$$\n\\begin{aligned}\np(t = 1|x,\\theta)&amp;=\\sigma (\\theta^T u(x))\\\np(t = 0|x,\\theta)= 1&amp;-p(t = 1|x,\\theta)\\\n\\sigma (x)=(&amp;1+e^{(-x)})^{-1}\n\\end{aligned}\n$$\n$\\sigma=\\frac{1}{1+e^{-x}}$ 或者 $=\\frac{e^2}{1+e^2}$ ，注意两种形式！\n\n多项式计算结果区间位于 0 到 5 时，概率 &gt; 0.5，说明更有可能发生。所以软预测器选择 &gt; 0.5 的那一项结果作为预测值。\n\n损失函数\n考虑下面这个式子，就是 classification margin：\n$$\ny = t^\\pm \\cdot \\theta^T u(x)\n$$\n这个式子为正值时预测结果为正确，为负值时预测结果为错误。\n所以硬预测的 Detection-Error Loss Function 损失函数（还是指示符函数，预测正确 = 0，预测错误 = 1）可以写作：\n$$\n\\begin{aligned}\nl(t,\\hat t(x|\\theta))&amp;=\\mathbb{1} (t\\neq \\hat t(x|\\theta))\\\n&amp;= step(-y)\n\\end{aligned}\n$$\n但是这个函数没法应用 GD 降维（损失函数图像类似矩阵函数，只有 0 和 1，没法降维）。所以我们可以应用其他的损失函数：\n\n\n\nExponential loss 指数损失：$l(y)=e^{-y}$\n\n\nHinge loss 铰链损失：$l(y)=max(0,1-y)$\n\n\nHinge-at-zero loss 零损失铰链函数：$l(y)=max(0,-y)$\n\n\nLogistic loss 对数损失：$l(y)=log(1+e^{-y})$\n\n\n这些函数都可以用，相比 detection-error loss 都可以应用 GD 降维。\n\n软预测损失：$l(t,\\hat t(x|\\theta))=log(1+e^{-y})$\n\n感知器算法\n应用了 ERM，hinge-at-zero loss，SGD 的算法（Perceptron Algorithm）。\n损失函数：$l(y)=max(0,-y)$\n梯度函数：\n$$\n\\begin{aligned}\n\\nabla \\ell\\left(t^{\\pm} \\cdot (\\theta^T u(x))\\right) &amp;=\n\\begin{cases}\n0, &amp; \\text{if prediction is correct} \\\\\nt^{\\pm} \\cdot u(x), &amp; \\text{if prediction is wrong}\n\\end{cases}\n\\end{aligned}\n$$\n每次梯度下降迭代后的新 θ 参数计算公式：\n$$\n\\begin{aligned}\n\\theta^{(i+1)} &amp;= \\theta^{(i)} + \\gamma^{(i)} \\cdot\n\\begin{cases}\n0, &amp; \\text{if prediction is correct} \\\\\nt^{\\pm} \\cdot u(x), &amp; \\text{if prediction is wrong}\n\\end{cases}\n\\end{aligned}\n$$\n例题：\n\n首先假设选取 (2.1, 1) 点计算梯度下降。\n$$\n\\begin{aligned}\nprediction; is; wrong,\\ &amp;\\theta_1\\cdot 2.1 =-2.1, hard\\ prediction = 0\\neq 1\\\\\n\\theta_2&amp;=\\theta_1-\\gamma x_1\\\\\n\\theta_2&amp;=-1+0.1\\cdot 2.1 =-0.79\n\\end{aligned}\n$$\n然后选取 (-1.5, 0) 点计算梯度下降。\n$$\n\\begin{aligned}\nprediction; is; wrong,\\ &amp;\\theta_2\\cdot -1.5 = 1.185,\\ hard\\ prediction = 1\\neq 0\\\\\n\\theta_3&amp;=\\theta_2-\\gamma x_2\\\\\n\\theta_3&amp;=-0.79-0.1\\cdot (-1.5)=-0.64\n\\end{aligned}\n$$\n计算每个步骤中的 classification margin 会发现值是逐渐接近于 0 的。\n对于 log loss 软预测器的梯度下降函数：\n$$\n\\nabla l(t^\\pm \\cdot (\\theta^T(u(x)))=(\\sigma(\\theta^T u(x))-t)\\cdot u(x)\n$$\n$\\sigma(\\theta^T u(x))-t$ 部分又用 $\\delta(x,t) $ 表示，表示 mean error，= 0 的时候说明预测完全准确。\n当 mean error = 0 时，如果 t = 1，则 $\\theta^T(u(x))\\rightarrow \\infty$ ；如果 t = 0，则 $\\theta^T(u(x))\\rightarrow -\\infty$\n软预测器梯度下降公式：\n$$\n\\theta^{i+1}\\leftarrow \\theta^{(i)}-\\gamma^{(i)}\\frac{1}{S^{(i)}}\\sum_{n\\in S^{(i)}}(\\sigma((\\theta^{(i)})^Tu(x_n))-t^n)\\cdot u(x_n)\n$$\n例题：还是上一道题的数据，初始预测器 $\\theta_1=-1, \\lambda=0, \\gamma=0.1$, minimum batch size S = 1\n\n神经网络模型\n神经网络模型（Neural Network Model）主要用于处理非线性情况。\nu(x) 并不像线性模型一样一开始是确定的，可能在模型训练过程中还有改动。对于难以建立先验的情况来说比较适用。\n之前线性模型中我们常用 u(x) 来描述特征向量(feature vector)，而神经网络模型中用 x 表示输入的特征向量，u(x) 是其一种表示形式。\n另外，神经网络模型专注于概率计算问题。\n\n中间的每一层都叫做特征提取层（feature extraction layers）。\n第一层输入 x 输出 D^1^ 维度的 h^1^ 向量。后面的每一层都用前一层的向量输入，输出一个 D^l-1^ 维度的 h^l-1^ 向量。最后一层叫做 classification layer 分类层，把 h 作为 u(x) 输入到预测器里计算概率。\n每一层的处理公式如下：\n$$\n\\begin{aligned}\na^l = W^l h^{l-1}\n\\end{aligned}\n$$\nW：权重向量，分配不同项之间的权重。\na：本层的 pre-activations 预激活向量。\nh：列向量，用本层的 a 向量通过一个激活函数激活后得到。\n\n典型的几种激活函数：\n\nsigmoid：$\\sigma (a)$\nhyperbolic tangent: $tanh(a)$\nRectified Linear Unit: $max(0,a)$\nLeaky ReLU: $max(\\alpha a,a),,\\alpha\\in[0,1]$\n\n下面是这四者的图像：\n\n梯度消失问题：见 Sigmoid 函数，其的导数特征在于：在 ±5 范围之外，导数全部 = 0；在中间导数先增长为 1 再下降。这就导致 a 必须落在 [-5,5] 的区间内，梯度值才会有效；在某些层传播中，梯度值很容易消失变为 0.\n梯度爆炸：tanh 中间的梯度值都快到 ∞ 了，梯度范围浮动非常大，不稳定。\n所以 ReLU 在这两点上优于 tanh 和 Sigmoid 函数，有效避免梯度下降和梯度消失问题。\n最后一层获取 u(x|θ) 的公式：\n\n每一层的作用都是提取一些信息化表示的特征，为最终通过 x 分类 t 做准备。\n其中，W 是权重矩阵向量。W^l^ 是一个 D^l^ * D^l-1^ 形状的向量，作用是和前一层传入的 D^l-1^ 长度的行向量相乘后输出 D^l^ * 1 长度的符合下一层形状的向量。注意矩阵乘法的时候，W 在前，h 在后。\n一个比较通俗易懂的图解如下：\n\n\n\n来源：神经网络——最易懂最清晰的一篇文章-CSDN 博客\n\n而 θ 也就是每一层的参数（权重）则这样表示：\n$$\n\\theta ={W^1, W^2, …, W^{L-1}, w^L}.\n$$\n如果 h 是线性函数，那么整个预测器就是一个线性预测器。\n\n例题：\n\n\n给定题目后，我们大概可知神经网络图像如下，两层（注意神经网络算出来的默认结果是预测值 = 1 的概率）：\n\n用输入向量逐层与权重相乘后激活计算得到：\n\np(0|x, θ) 就 1-0.12 = 0.88 即可。\nSGD\n又到了最喜欢的梯度下降优化环节。\n首先还是要找一个计算损失的方法：\n\n最后一层：\n$$\nl(\\theta)=-log,\\sigma (t^{\\pm}a^L)\n$$\n后向传播最后一层（第 L 层）所需梯度：只说结论的话：\n$$\n\\delta^l =\\sigma(a^L)-t\n$$\n最后一层后向传播的梯度 = 该层梯度的输入值代入 σ 函数再-目标值 t。比如最后一层输入-2，最终要计算 t = 0 时的梯度，计算结果就是 $\\frac{e^{-2}}{1+e^{-2}}-0\\approx0.12$\n推导也很简单，其实就是最后一层的损失函数求导罢了，$t^\\pm$ 视作一个常数。大家可以对 l(θ) 求导试试，对于 t = 1 和 0 的情况得到的分别是 $\\frac{1}{e^x+1}$ 和 $\\frac{e^x}{e^x+1}$ ，和下面的结论项是相等的。\n对于前面的 1 到 L-1 层，其导数还是对对应自变量求导代入求值，和之前的 GD 算法类似。\n比如：还是之前那道题，计算 t = 0 时的梯度。首先是前向传播：\n\nt = 0 时，t^±^=-1（$t^\\pm=2t-1$），a^2^ 是该层（第二层所以有个 2 的上标，不是平方）的输出 =-2，两者相乘 = 2，代入公式计算得到 0.13 为损失值。\n然后假设结尾 = 1，开始后向传播：\n\n首先根据 t 和 a^2^ 计算出 δ = 0.12，用 1*0.12 再*第二层权重回推。\n第一层的梯度公式是 h 对 a^1^求导，h 是一个 ReLU 函数，所以当 a &gt; 0 时求导结果 = 1，a &lt; 0 时求导结果 = 0. （参考 ReLU 公式）所以得到这一层的向量是 [1,0]，回推出反向传播误差。\n\n最终，我们给输入值*反向传播误差计算权重梯度，用原权重-权重梯度*学习率更新权重。这里貌似学习率视作 1 了吧？\n\n下图是不同层数，随着迭代次数增加训练损失下降情况图。可以看出 3 层反而是最有效进行二元分类的训练方法。\n\nTransformer\n一种常常用于自然语言处理的深度学习架构。\n输入可以被划分为 subset 子集或者 token：\n\n\n对于输入数据，创建 N 个 Tokens，每一个都有 D*1 的维度：\n\n自注意力\ntransformer 的一个重要机制在于自注意力（self-attention）。\n\nsoftmax 是形如下图的公式，这只是一种计算方法：\n\n在自注意力公式中，我们发现初始词嵌入出现了 3 次。前两次是作为句中词向量与其他词（包括它自己）点积得到权重；第三次再与权重相乘得到最终带上下文的词嵌入。这三个地方出现的词嵌入我们给他们三个术语：查询(Query), 键(Key), 值(Value)。\n\n\n【万字长文】深度解析 Transformer 和注意力机制（含完整代码实现）_transformer 架构注意力机制-CSDN 博客\n\nQuery 和 Key 不是对称的，一方对另一方的词注意力可能与反过来不同。比如“伦敦国王学院”和“大学”关联度很高，但”大学“和”伦敦国王学院“关联度不高，大学有那么多所呢。\n多头注意力\n多头注意力（MultiHead Attention）除了一个句子中不同词之间的关联，可能还有其他因素（如一词多义，语序问题等）。\n无监督学习\n无监督学习（Unsupervised Learning）相比监督学习没有一个“标准答案”，比如对于输入 x 我们没有期望 t 输出值。有很多问题是没有期望答案的，比如分类问题，或者异常检测（某个 x 的 p 值过小，很可能是异常）。\n\n一种常用的方法是自监督学习，把问题转化为监督学习。比如将预测所有 token 的问题转换为条件概率。\n\n密度估计\n压缩（Compression）：对于 x 向量中所有可能元素的表示，概率大的用简洁形式表示，概率小的用复杂形式表示更节省存储空间。比如摩斯电码。\n\n直方图\n很简单的无参密度估计方法，就是统计 x 出现次数除以总数据数。\n\n首先我们定义区间 quantizer，一定区间范围内 x 一起统计。\n公式：\n\n也就是说概率高度是 x 在这个区间内出现次数除以(区间长度*总区间数)。\n例题：\n\n区间范围是 -2.5 到-2 有一个，-1.5 到-1 有一个，1 到 1.5 有一个，1.5 到 2 有一个，2 到 2.5 有一个。\n区间密度单位 = 1/(5*0.5)= 0.4.\n\n可以看出区间的选取对直方图无监督学习影响很大。选太大了，bias 就很大，因为比较贴近正常值的异常值也可能被划进正常区间范围内；选太小了，估计误差可能又大了，因为每个区间的点数少了，就像上图，每个有样本的区间内都是一个样本数，怎么判断哪个是异常。\n核密度估计\n核密度估计（Kernel Density Estimation）：如果分布假设是平滑的而不是类似直方图的离散状，误差应该会小一些。比如假设每个样本点（相当于一个阶跃函数的图像）都变成一个高斯函数 k_h(x)= N(x|0, h)，概率密度函数如下：\n\n\nh 越小，高斯函数越窄，但是就像直方图中暴露出来的问题一样，bias 下降，estimation error 上升。\n例题：\n\n首先先用阶跃函数的形式画出样本点，然后延伸宽度为 0.1：\n\n如果设置 kernel width = 0.5，也就是每个点都变成 0.5 宽度的矩形函数:\n\n维度诅咒\n前两种方法缺陷在于 h 和 △ 选择必须合适，而且对于多维度数据误差可能很大（除非数据量够大）。这就是维度诅咒。\n由此引入了参数密度估计方法，相较于非参数密度方法不会受到维度诅咒（Curse of Dimensionality）。但是对概率模型有限制，必须是可以通过参数模型得到的概率模型。\n对比监督学习\n对比监督学习（Contrastive Density Learning）：目标是将相似样本拉近，不相似样本离远。\n生成噪声点：\n\n\n潜在变量模型\n潜在变量模型（Latent Variable Models）找到一些隐变量进行分类。\n主要有四种应用方式：\n\na：z 产生 x。\nb：x 产生 z。比如 x 是不同书籍，z 是其分类（历史，科幻……）\nc：从 x 中提取 z，比如混频信号分离。\nd：x 转换为 z 后再重建，比如图片 AI 高清化。\nz 需要通过无监督学习找寻。\n自动编码器\n自动编码器（Autoencoders）：一种 x-&gt; z-&gt; x 潜在变量模型。依赖于模型参数 θ：\n\n比如 z 是图片 x 的压缩形式，解压得到 x（可能会有损失）。\n自动编码器训练\n将无监督问题转化为监督问题的一种案例。选定期望输出 x 值或者原始 x 值作为预期结果，这样就可以计算损失了。\n比如：期望加密解密后的输出 x 值和原值相等：\n\n下面介绍一些自动编码器的案例：\n主成分分析（Principal Component Analysis (PCA)）：\n在 AI 课里学过：\nhttps://stellaris.graysea.cn/kcl/artificial-intelligence-and-decision-making-6ccs3ain-lv6/note#principle-component-analysis-zhu-cheng-fen-fen-xi\n对于 D 维度数据可以很好地提取出 M 个特征向量，M &lt; D.\n解码器：\n\n这里的 W 就是 θ。\n\n编码器：\n要去除 inductive bias，就需要从原数据中去掉平均值。\n计算损失的方法：\n\n例：USPS Data Set 手写识别数据集，一张图片的维度是 256 维（每个像素点的颜色可能性）。\n\n现在我们考虑这样两个 w 作为主成分，具体是什么主成分我不太理解，下图的灰度值只是便于理解的呈现（在 16*16 的矩阵方向上对应每个点的灰度值）：\n\n我们用这两个主成分和原 16*16 像素的图片相乘，得到对应两个主成分维度上的所有点的灰度值求和，作图后得到：\n\n可以比较明显的看出这两个主成分的选择还是蛮正确的，可以有效将数字 01 分开。\n这样这个例子就有效的把原来的 256 维度转换为 2 维度（当然这个例子 pick 的太简单了，手写识别里的只考虑 01 情况所以才会降维得这么厉害）。\nNeural Autoencoders 神经自动编码器：\n加密解密都是神经网络模型，使用前后向传播方法。\n\n直接生成模型\nDirected Generative Models 一种 z-&gt; x 模型。\nK 聚类算法\n把 n 个 x 数据分配给 k 个聚类（K-means）。z 是分配结果，$z_{k,n}=1$ 代表第 n 个数据分配给了第 k 簇，$z_{k,n}=0$  代表不在这个簇里。所有的 z_{k, n} 组成列向量 z。\n分法本质上是每个簇的中心点离该簇内所有 x 数据点的欧几里得距离和最小。\n\n但是我们并不知道怎么选质心点。\n所以最开始可以先选择几个 x 点作为质心点，先进行簇分类，然后计算每个簇中所有点的质心。\n再根据新质心，重新分类，直到质心不变为止。\n损失：\n\n例题：注意给定了初始 k 质心了。\n\n首先给这几个点就近分类：\n\n然后求平均找质心：\n\n","categories":["王道（KCL电子工程专业课内学习）","Lecture"],"tags":["Machine Learning"]},{"title":"北邮国院项目：Java Wordle","url":"/2022/07/20/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AJava%20Wordle/","content":"Wordle 游戏介绍\n\nWordle的游戏规则很简单，玩家需要猜出程序每天指定的一个5位英语单词谜底。\n玩家可以随意提交一个英语单词，但必须是字典里有的，不能胡乱拼写。\n如果字母在谜底中出现且位置对了就显示绿色，字母出现了但位置不对就显示黄色，字母在答案的单词中没出现就显示灰色。\n根据反馈信息再进行下一轮猜测，在6次尝试之内猜出就算赢。\n来源：数学大神攻克猜字游戏Wordle，求解算法成绩逼近理论极限，连信息论都用上了 -量子位\n\n\n玩法介绍\n点击HELP 查看帮助，点击 START 开始游戏。\n本游戏中没有虚拟键盘，输入框也不能获取鼠标焦点，只能通过键盘键入字母，回车检查答案。\n敲下回车后，字母就会呈现灰色、黄色、绿色三种状态，并换到下一行开始下一次猜单词机会。当猜中答案或六轮游戏结束时，弹出小窗，提示用户游戏胜利/失败。\n注意：\n\n检查用户输入。本游戏中用户只能输入字母，当用户试图键入数字或符号时会提示只能输入字母。当用户输入不足5位就尝试检查，或尝试输入超出5位时会提示输入必须为5位字母。当用户输入非单词尝试检查会提示输入必须为词库中存在的单词（词库：words.txt，可以自己更新）\n一些小的注意点。当用户输入中有两个e，都不在正确的位置上，那这两个e只有一个会显示黄色就够了，另一个显示灰色，否则会影响用户的判断。\n\n代码\nJava_Wordle_Game github下载地址\n\nREADME：帮助信息\njavadoc：生成的 javadoc\nTest：测试图片及说明\nwords.txt：词库\n运行方法：\njavac Main.javajava Main\n在此感谢老师同学对此项目的帮助指导！\n欢迎大家star支持[Doge]有问题也可以与博主交流~\n","categories":["邮途（北邮国院课内学习）","Project"],"tags":["Java"]},{"title":"北邮国院笔记：Software Engineering 软件工程","url":"/2024/12/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ASoftware%20Engineering%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","content":"Introduction\nsoftware types\ngeneral: developed for a general market. (ps, office)\ncustom: developed for a particular aim. (embeded system)\ngood software features\ndelivers required functionality\nusable\nefficient\ndependable\nmaintainable\nunderstandable\ncost-effective\nsecurity\nwhat is software engineering?\nusing proper theories, tools, methods(organized and systematic), constraints to develop high quantity software.\n4 layers\nTools, method, process, quality focus.\nWhy important?\nlarge scale projects are hard to finish in time properly because of time, budget, disaster, etc. guiding scientific principles and universally applicable methods can reduce practice and frequent failures.\nGeneral issues that affect software\nHeterogeneity (distributed systems, different type of devices), business and social change, security and trust, scale.\nSoftware process\na set of structured activities to produce software.\nincludes: required specification, development(analysis, design, implementation), validation (test), evolution.\n\nrequired specification: what should this system do? a complete desc of the problem and environment constraints. contains: system function, future extension, documentation amount, time and preformance response\nanalysis: create a conceptual model.\ndesign: implementable model (architecture, components of this system).\nimplementation: implementation of interfaces.\ntesting: unit, functional, integration, system, acceptance. test and implementation should run in parallel.\ndeployment: install, run and test on real environment.\nevolution: corrective, adaptive, perfective, preventive.\n\nprocess models\na abstraction of process. activities must be modelled to be managed.\nwaterfall\n\n易于管理 monitor，结构化很好。前面的模块必须完成才能跳到下一个，也就要求我们在最初设计的时候对需求很清楚，但是很难不遇到一些问题，很难按照正常流程正常走。\nevolutionary development\n\n交互性的活动，及时的反馈。核心需求能很好的满足，但是扩展性很差，结构性很差，缺少过程中的可见性。适合小型项目。\nrational unified process\n\ninception: 分析项目可行性。\nelaboration: 分析风险，架构。\nconstruction: iterative 迭代开发到 beta 版本为止。\ntransition: 交付到客户手中。\n通用的完整流程，动态。但是开销大了。\nAgile Software Development\n现代软件开发流程：敏捷开发。\nRapid software development 快速开发：争取每一版都交一个可以交付的东西给客户。\n敏捷开发：系统在一次一次迭代小增量过程中建立而成。specification, design, implementation, testing 并行。专注于代码，轻量级代码频繁发布，维护简单。\n\nIndividuals and interactions over processes and tools\nWorking software over comprehensive documentation\nCustomer collaboration over contract negotiation\nResponding to change over following a plan\n敏捷开发需要程序员之外的项目经理，运营，测试……\n敏捷开发重视价值，不要设计没价值的东西。实践一定要解决文分体，文档一定要有对应受众，不要过度设计系统。\n敏捷开发注重 steer而不是percise prediction。由customer priorities 和 programmer estimates of  feature difficulty 共同制定不断迭代的计划。\n开发原则：\n• Emphasis on simple design and refactoring.\n• Removing duplication.\n• Increasing cohesion.\n• Reducing coupling\n常见的敏捷开发方法：如极限开发 Extreme Programming.\n\n每天构建几次新版本\n每两周给用户提交一版增量\n需求由用户描述\n程序员Pair programming（两个人坐一起一起开发，效率差不多，而且对彼此代码更加了解）\n先开发测试单元，再写代码\n测试过了才算构建完成\n\nTest Driven Development (TDD):\n\nDefine both an interface and a specification.\n先写test后写code。\n基于增量设计测试 Incremental。\n每次构建后自动化测试 Automated。\n客户参与测试 User involvement，测试包括程序员单元测试（unit test），客户确认测试（acceptance test，看是否符合需求）。\n\n敏捷开发的问题：\n\n\n客户易失去积极性 customers interests.\n\n\n团队成员未必喜欢团队开发。\n\n\n多方利益相关，prioritising change is difficult.\n\n\n难维持简洁性，maintaining simplicity.\n\n\n频繁变化，合同设计困难 contract。\n\n\n适用于多变的，客户要求明确的中小型系统。\nrequirements\n确定需求是软工设计中最重要的部分。\n\n\nfeature to satisfy customer.\n\n\nindicates what should this sys do.\n\n\n可能是高层抽象的需求 high-level abstract 或者底层具体的 low-level specific.\n\n\nStakeholder 利益相关者：受系统影响的组织或个人（当然有的软件可能是针对市场需求开发，而不存在具体的用户）。这些人站在不同角度上有不同见解。\n客户不一定清晰描述其需求，也不一定清楚产品特性和功能，且其需求可能不断变化。\n在确定需求环节投入的额外时间长远角度来看会节省更多的时间和金钱。\n需求分为：functional 和 non functional.\nfunctional requirements\n定义系统的需求，要干什么。比如教务系统对于老师和学生端提供的不同的服务。\n这一部分要完整 completeness 清晰一致 consistency 的描述大需求，避免不必要的误解。\nnon-functional requirements\n这一部分比功能性更重要，相当于不满足这一部分系统错误，不满足功能需求系统有一些小bug。\nDefine system properties and constraints，比如时空复杂度，设备 capability。\nProcess requirements：比如质量标准，编程语言等。\nOrganisational requirements: 如系统要符合IT政策规定。\nexternal requirements: 比如“用户密码不能泄露”。\n\n非功能性需求需要定量描述指标。不然比如“希望程序跑的快一点”这就很模糊。要有measure的方法区测量quantitative定量指标。\nRequirement conflicts\n要trade-off权衡需求，让所有人都同意一个最优需求。\nRequirement document\nSoftware Requirements Specification (SRS) 软件需求规范，确认测试的参考规范，指明了应该实现的需求，但是不指明如何实现。\nRequirements Capture\nBackground Reading\nInterviewing\nObservation（观察用户使用系统的情况）\nDocument or Record Sampling（专业的observation）\nQuestionnaires\n敏捷开发中的需求\nusr stories\n用户需求被称作用户故事，一两句话写在卡片上。\ncustomer 给他们排序需求，development team分解实现任务。\nAs a user,  I want to backup my entire hard drive  so that I won’t lose any work.\n写在 stories cards 上，按顺序贴在墙上大家讨论，注意重点不是记录而是大家的讨论。\nProject glossary\n一些项目相关的专业术语，建议总结出来方便大家理解讨论。\n\nEpics\n大的 usr story。通常开始讨论前被拆分为小的块。\n\nAcceptance Criteria\n验收标准，通常写在故事卡背面，有助于理解需求和 invite negotiation with the team about the business  value that we are trying to create.\nNon-functional Requirements as User Stories\n比如用户表示：我希望电脑打cf fps高于100.\nusr stories注意事项\n\n谁都能写，最好让更多的成员写。\n整个 agile development 过程中都可以写。一开始开故事讨论会确定基本，后续随时可以添加。\n\nProduct backlog\n需求按优先级排列的需求表。综合考虑多方因素。\nMoSCoW：一种 dsdm 动态系统开发方法。\n\nmust have：最重要的。\nshould have：如果时间资源超限可以被取代。\ncould have：用户期望的需求，完成后用户满意度会高。但是不必要。\nwant to have: 当前阶段不重要的。\n\nEstimating\n估计项目用时。\n\nstory point：故事点，用于表示完成一个产品待办项或者其他任何某项工作所需的所有工作量的估算结果。\n当采用故事点估算时，我们为每个待办项分配一个点数。待办项估算结果的原生数据并不重要，我们只关注最后得到的相对估算结果。一个估算值为2的用户故事应该是估算值为1的用户故事的2倍。而它也应该是另一个估算值为3的用户故事的三分之二。\n团队不要采用100、200、300，或者1百万、2百万、3百万，而要使用1、2、3。估算结果是比值，而不是绝对值。\n敏捷开发中到底什么是故事点（Story Point）？ - 知乎 (zhihu.com)\n\n评判 good usr story\nINVEST原则。\n– Independent – Negotiable – Valuable – Estimatable – Small – Testable\nPrototyping\nphysical：比如画gui。\nlogical：元素，元素之间的关联……\nLow-fidelity 低保真：最简单，比如手绘图，纸板做的，快速验证产品概念的可行性。\nMedium-fidelity 中保真：数字模型。\nhigh-fidelity：如3d打印，最接近产品但是制作麻烦。\n\nanalysis\n仅仅从用户的需求来看得到的消息不全面，还需要分析。用户可能认为你明白了，或者他考虑不全面，觉得一些地方是不需要的。\n因此我们需要分析来 Refining requirements。\ngather requirements-analyse in real world context-develop the architecture\n分析包括：Textual analysis (针对文档分析)，Entities and concepts（应用层面分析），Experience（过往经验分析）\nconceptual model\n面向对象的UML图。\n\n边界类用于系统外部环境与内部交互进行建模的类。我的理解是不同系统之间的胶合层。能够减少系统之间的耦合。\n控制类用于对一个或几个用例所特有的控制行为进行建模。控制类源于对用例场景中行为的定义。\n实体类是对必须存储的信息和相关行为建模的类。\nUML-分析类_Iron_Sky的博客-CSDN博客\n\n\nattributes: 属性和相应数据类型。比如姓名，字符串。\nOperations：行为方法。一个operation一般只做一件事。\nrelationships: – Association – Inheritance.\n\nassociations 指两个类之间存在双向联系。比如一个老师教多个学生。有1对1,1对多等关系。\nInheritance 继承，父类泛化子类特化。\n\nActivities:\n\nIdentify Entity, Boundary and Control classes\nIdentify class relationships\nA conceptual class diagram\nIdentify attributes for each entity class\nAdd constraints\n\ndesign\ndesign 是把分析模型转换成设计模型，不是代码实现！implementation才是实现。\ndesign must have a purpose: how things works.\nA software design: enough information for a  development team to implement the solution.\nroles\n\nfinish non-functional requirements\nbreak down the overall task.\nCreate a ‘skeleton’ of the system 创建易于实现的骨架结构。\n\nFundamental Concepts\n\nAbstraction：抽象类和行为的功能。\nEncapsulation：information hiding。限制某些对象对内容的直接访问。\nModularity：封装成模块，提供接口给其他模块。\nCoupling：耦合，模块间关系紧密程度。最好是loose 松耦合，这样不容易牵一发而动全身。\nCohesion：内聚，模块内部自己元素的相关度。最好是high的。\nRefactoring：在代码正常完成要求的前提下修正代码减少重复。主要改进非功能属性。\n\n面向对象设计的好处：对象就是实体；对象可以重用，继承；有的系统对象是现实世界的明显映射。\nsteps\nconceptual class diagram\nClass Relationships\noperations\nDescribing methods\nCaptures implementation requirements\nProduce detailed design class diagram\nImplementation\n分析和设计阶段基本上把创意都列出来了。实现就是比较机械地按照前面的设计去敲代码。\n利用一些组件去实现。组件主要包括：excutable 可执行文件，file 源码和数据，document，table 数据库表。\nimplementing subsystem 实现部分功能，利用打包功能导出一个有接口的模块.\nIntegration Build Plan 迭代构建项目,每次构建指出构建实现的功能和构建需要的子系统、组件。\nOOP：有类，对象，方法。但是关联不是双向的，而是只能单向的，比如：\n\n\n一对多可以在一个类里包含另一个类的一个对象集合。\n类的实现要从最小耦合到最大耦合 least  coupled to most coupled。\nTesting\n在交付给用户前尽可能发现错误，验证每个阶段的结果。测试占据了40%。\n组件层面：开发者测试。\n集成测试：测试工程师，专注于质量。\n\nValidation testing：验证测试，测试系统正常需求已经满足。\nDefect testing：检测系统的缺陷。\n\nTesting policies\n我们不可能把所有可能情况都找到并且测试出来。因此只能选取有代表性的子集。\n好的测试：测试人员能预料到可能哪里出错；没有多余的测试用例；应选取“最可能出错”的用例；合适的复杂程度。\n\ntest case：输入的规范和预期的输出。\ntest data：输入。\n\ntesting strategy\nwhat 测试用例？when 测试？how to 测试？如何比对输出是否正确？\ntest cases 示例（正确的输入。错误的输入比如学号输入英文）：\n\nTest Procedures 测试程序，通常设置为可通用的，便于之后修改重用。这个程序不一定是代码，可能以流程指导的形式（比如按下login按钮，输入账号99001122登录……）\ntest matrix:\n\n发现缺陷：比如上例，错误的密码也能登录，于是测试工程师把错误信息返回给开发者：\n\nTesting: Techniques\n黑盒测试，black box/behavior test，即我们要测试的模块，对我们来说像一个内部结构不可见的黑盒子，我们重点关注他行为对不对，与外界的接口是否正确，访问外界数据库正不正确。\n\nPartition testing：典型的黑盒测试，把数据分成等效的几个区域，比如正数负数0.\nScenario-based testing：从用户角度触发，分析用户可能的正确和错误操作。\nRegression Testing：集成测试，随着添加增量也不断添加新测试，每次运行所有测试用例，确保系统更新的时候以前的功能没有受干扰。\n\n白盒测试，white/glass/clear box test，主要关注程序内部结构按规范运行，所有内部组件都正确。\n确保盒内的所有路径都被正确执行过；考虑正确和错误用例；在边界内外测试；尽量使用内部数据结构。\n\nBasis Path Testing：执行所有路径的最少用例数。\n\n\n总体测试流程：白盒测试，建立 test harness 测试装置，测试正确性，测试健壮性；然后黑盒测试。\nTDD\nassertEquals(20, student.getAge());//判断返回值是不是20岁\n在开发代码前编写测试。 simple, short-cycled mechanism。\n\nsmall cycle：编写测试，编写代码，测试失败，修改代码，测试通过。\nSoftware architecture\n功能需求和软件架构关系紧密，非功能需求是软件架构的选择结果（好的架构运行效率高之类的）。可以以表格或图的形式，比如UML图。\n设计难以更改。敏捷开发的早期阶段就是设计系统架构。\n好处：\n\nsystem analysis：利于分析系统是否满足非功能需求。\nlarge-scale reuse：架构可重用，更安全、更快。\nStakeholder communication：可以 成为一个讨论点。\n\nProject management\n让项目能在有限的时间和预算范围内按预期保质落地。\n软件工程比较灵活，没有标准的完全正确的方案，需要随机应变，敏锐的洞察力。\nProject planning\n最耗时的环节。\n计划只有在项目完成时才算完成，因为计划在项目开发阶段也不断变化。\n计划可能包括多种，如质量计划，员工开发计划……\nActivity organisation\n活动应该组织成切实的输出以及可以判断的进度。\nmilestone：标志阶段的结束，不一定是能输出给用户的成果。比如文档，或者逻辑阶段的结束。\nDeliverables：可以交付给用户的设计，规格等成果。\n\nProject scheduling\n估计项目时间预算的花费，并按顺序排布。\n比较难估计。通常根据过往项目经验估计。\n先把大项目分解为几个小项目，然后并发的组织任务——尽可能充分利用劳动力 workforce，以及 Minimise task dependencies 尽量减少因为前面的任务没完成对后面任务的延误。\n要对错误有预期，没错误是不可能的。约30%预料到的问题+20%未预料到的问题。\n通常用图表表示：\n任务表：\n\n活动网：最长的是关键路径，因为这条路径任务要是延期了，整个工期都要延期。\n\n甘特图：\n\nMonitoring/Reporting：定期周会周报监督进度。\nMetrics\n代码行数，代码中的缺陷，测试用例通过情况。\nPeople in the process\n选择成员，管理，激励他们，解决大家遇到的技术和非技术问题。\n\nConsistency：对大家态度一致。\nRespect：大家拥有技能不同，互相尊重。\nInclusion：让大家都参与进项目，聆听所有人的意见。\nHonesty：进度保持诚实。\n\nGroup working\n不仅仅是个人的集合。团队能力的组成，凝聚力，沟通，大型团队的层次结构。\n敏捷开发的团队合作方法：Scrum approcah，有一个Scrum master，日会，跟随进度，记录决策，和客户等沟通。\n项目被分解为易于管理和理解的小部分。不稳定的需求不影响项目进度。团队成员对项目把控更到位 visibility，客户能常常看到项目进度，双方交流更相信彼此。\nRisk management\n失败是常有的事。我们要做好备选方案，推迟时间或者放弃目标。\n风险管理是预测可能的失败，决定该在什么地方制定备选方案 alternative plans 。\nProject risks：项目开发或者资源的问题。比如项目员工走了；原材料没法及时收到了；项目要求时间提前了。\nProduct risks：产品质量和性能的问题。比如开发软件出bug了，开发出的软件质量不行，用户对gui不满意，有没考虑到的错误。\nBusiness risks：开发，采购组织的问题。比如上市了发现其他公司的技术，竞品比我们的好；负责该系统的组织因财务原因倒闭了。\nProject+Product：需求一直变；分析阶段太慢了；开发团队技能能力不行；项目比预想的要大。\nRisk Identification\n识别风险。\nRisk Analysis\n评估风险的影响。\nRisk Planning\n制定应对风险的计划。\nRisk Monitoring\n在项目开发过程中监控风险。\nAvoidance Strategies\n尽量使用熟悉的模式，但是也接受新技术，时刻关注市场动向；\n对员工合理培训，确保技术没被掌握在一个人手中；创造良好的工作环境；\n员工不要欺瞒进度，高管要时刻了解进度以及其对项目的重要性。\nContingencies 突发事件\n换人，换工具，换资源。\n改变，舍弃一部分目标。\n争取做的改动最小，但是损失也降到最小。\n我们知道敏捷开发持续提交小版本，因此经常进行测试修改当阶段错误。但是缺陷在于敏捷开发不注重长远眼光 long term planning，因此可能带来一些问题。\nQuality Management\n对质量的评估，最好从软件开发过程中抽离出来。因为开发的过程会错误影响开发者自己对质量的评估（我都这么努力了，做出来的东西肯定很好吧）。\n瀑布模型中在系统实现后单独测试软件质量。敏捷开发在每次发布新版本的时候测试。因为主要是在实际使用场合的测试，因此会比“为了达成测试而开发”的系统想的更多一些。\n好的软件符合目的 Fitness for purpose，标准好，易于使用，高效，代码写的好（当然从用户角度来说他看不到这一层。但是代码写得好是前提，比如时间复杂度运行得快）。开发者需要考虑用户的需求前提下，自己用专业知识思维去想：这个需求实现合理吗。然后多喝用户沟通表达看法。\n区分bug和特性：正常运行的是特性。有的时候哪怕系统除了意想不到的bug，但是功能意外的很合适，这也可以是特性。\n特性很难移除，当用户开始依赖特性功能的时候，移除用户可能不乐意不习惯；而且向后（版本）兼容变得很难。\n软件标准有很多好处，新员工快速入手，大家更熟悉项目等，但是标准可能对一些过去常常发生而现在不怎么出现的问题采取忽略的态度，从而兼容性上出现问题；而且可能浪费很多时间填文书。注重标准好的部分。\nDesign principle\n设计的软件不仅要正确，高效运行，还要在限定时间，人力，软件，经济条件下。差代码后期可能要花很多时间弥补隐患；而且不同模块的代码经常交互，差代码还会有安全隐患。\n我们仅仅想着怎么“正确”地编写代码是不够的，还要更省事省力地去开发。\nSoftware lifespan：软件生命周期，软件是一直在持续开发的，比如新技术，客户新需求。\nSoftware scale：项目大多数规格很大，很多人开发，代码多，多次修订。\nDecomposition：项目分解为小模块开发。有Locality（实现一个模块可以不用检查其他模块的实现）和Modifiability（修改一个模块也不用考虑用使用这个模块的模块）的特点。\nSpecification and implementation：规范连接了设计和实现，规定了模块应该提供哪些服务以及如何使用服务。模块之间的交互应该仅仅限于规范，以此实现分解后模块的locality和modifiability。\nClasses and Methods：面向对象思想中的模块为类。\nSeparation：分开考虑一个模块要实现的功能what和如何实现how。一个应用程序级别，一个实现级别。\nSplitting Methods and Classes：设计方法和类的时候好好考虑如何拆分方法和类。类太大了考虑一下要不要拆，几个变量模式比较常用考虑一下要不要抽象成类。\nHelper Methods and Classes：有一些方法和类只是为了抽象出来辅助拆分代码用的，这种一般是私有的helper method和嵌套的nested class，只在特定类里起作用，对其他类是private的。\nReuse：用以前的代码重复实现功能，节约代码，而且一改全改。重用代码可能厂商提供，编程语言提供，早期开发者开发。\nAbstraction and generalisation：抽象是提取一些概念，比如接口，类；泛化是提取一些重复元素，以便代码重用，比如父类。\nUML class diagrams：比代码更高的层次，是面向对象编程很重要的内容。\nStatic v. Dynamic：匹配静态内容和代码运行时产生的内容。对应UML中的类图 class diagram 和顺序图 sequence diagram。\n图源：UML类图与顺序图_顺序图和类图的关系_lingchen336的博客-CSDN博客\n\n\nclass and objects：类和对象。对象是类的实例 instance。两者关系很像static 中的method和动态中的method call。\nstatic：静态方法只能被类自己和其附加类调用。静态类实例化的对象是只有一个通用的对象，而不是实例化出无数个对象。\nVariables and referencing：java中变量是对对象的引用，比如var2=var1不是赋值而是改变var2指向var1的引用。包括一个变量的自带方法的\n\n\nScope and garbage collection：对象的作用域只要有变量还在引用这个对象，他就活着。没有人引用的时候就自动垃圾回收。\n基本设计原则：设计对象指代目标；对象方法指代其能做的操作；Locality和Modifiability；对象只能通过方法调用交互。\nClient-Contractor model：一种思想，一个对象调用其他对象的方法得到返回值来使用它，像客户和承包商一样。现代社会大进步的原因就是大家各专其职，因此项目中各个类各专其职也能在同样的量的前提下发挥更多的作用。\n\n\n客户给承包商的合同就类似定义类和方法的规范specification。代码编写者有义务Obligations拿了钱benefits，就确保软件正确执行，不做破坏的事等。\n\n\nDesign by Contract：一种思想。客户端代码应当满足承包商的先决需求pre-conditions；应当对异常做处理（exception）；后置条件post-conditions在测试中作为断言assertions合并到程序中。（前置条件：前提；后置条件：方法运行后的状态）\n\n\nSingle Responsibility Principle (SRP)\n单一责任原则：每个类有一个职责 responsibility，其所有对象都服务于这个职责。Leads to highly cohesive 内聚性高\nOpen-Closed Principle (OCP)\n开放闭合原则：模块（类和方法）open to extension，close to modification\n对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。\n对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。比如一个类以不同对象形式表现这就是扩展，因为需求改变或者有新需求。\nDo not Repeat Yourself principle (DRY)\n不要复读机原则（不要重复自己原则）。本模块中如果发现重复内容，建议再抽象为方法和类。\n**Liskov Substitution Principle (LSP) **\nLiskov替代原理：重写方法，不应该抱着”修改其方法“的想法。不能加强 strengthen 前置条件，不能削弱 weaken 后置条件。\n比如父类people方法AddPeople(String name, int age) 子类Student构造方法AddPeople(String name, int age)里先校验一下学生年龄，如果年龄大于25岁则不允许add，这就修改了原来方法。这就是前置条件加强了，要求年龄的限制多了。\n后置条件比如原来返回值大于0，现在返回值可以小于0了，那么返回值限制弱了，后置条件削弱了，不满足里氏原则。\n参考：设计模式六大原则(二)----里式替换原则 - 盛开的太阳 - 博客园 (cnblogs.com)\nAssociation, Aggregation and Composition：association是两个不同东西的对应，比如家长和孩子。另外两个是子集，aggregation是彼此可以独立存在，比如班级和学生。composition是可以彼此独立存在，比如house和room。\n\n有的时候继承满足不了LSP（比如令正方形为矩形的子类），可以使用聚类来防止破坏LSP。\nInterface-Segregation Principle (ISP)\n接口隔离原则：首先接口应该尽量分解为小接口。客户端每个类不应该依赖他不使用的方法。就是接口用啥实现啥，别多实现。\nDependency-Inversion Principle (DIP)\n依赖倒置原则：\n\n如果高层模块直接调用低层模块提供的服务，那么就是具体耦合关系，这样高层模块依赖于低层模块就不可避免。但是，如果我们使用抽象耦合关系，在高层模块和低层模块之间定义一个抽象接口，高层模块调用抽象接口定义的方法，低层模块实现该接口。这样，就消除了高层模块和低层模块之间的直接依赖关系。现在，高层模块就不依赖于低层模块了，二者都依赖于抽象。同时也实现了“抽象不应该依赖于细节，细节应该依赖于抽象”。\n面向对象基础设计原则：4.依赖倒转原则 - 知乎 (zhihu.com)\n\n依赖倒置原则（Dependency Inversion Principle） - sangmado - 博客园 (cnblogs.com)\n\nDesign Patterns\nDecorator Design pattern\n用于扩展系统功能的装饰模式。\n比如我们有一个鸭子类，可以调用其鸭子叫的方法。我们初始化了一个鸭子对象，如何统计这个对象叫了几次，也就是其鸭子叫方法被调用了几次？记住OCP原则不允许我们直接修改鸭子类。\n我们可以用一个计数类来把鸭子类包住。\n\n装饰模式实现一个接口，接口中的方法通过该变量的同一个参数去调用同一个方法，比如本例中是鸭子呱呱的计数，每次调用++。\nAdapter design patterns\n\n\n这个例子包括了几个原则：\n\n首先不同接口功能尽量分开，ISP，也就是说鸭子叫和计数不要写一个方法里。\n不能直接修改类，OCP。\n如果想鸭子叫同时计数，直接调用包装类即可，DRY。\nGooseAdapter 只访问了 Goose 的 honk 方法而不是对其完全访问，DIP。这里如果改成继承的子类，就有全部访问权了。\n\nWrapper design patterns\nWrapper 模式包括 decorator 和 adapter。decorator 主要是外面的包裹类和里面的类都实现一个接口，比如上例的鸭子嘎嘎。adapter 是内部类不需实现。\nImmutable View：前面提过java引用的问题，比如两个变量引用同一个对象，一改都改。这样就相当于有引用的时候，该目标对象完全暴露出来了。在wrapper里我们可以限制包装类：禁止修改对象，修改则抛出异常。\n\nComposite Design Pattern\n包装了一个集合。\n\nObserver Pattern\n比如看到绿灯汽车知道该走了，这种观察者一个变量改变影响其他变量的实现。\njava是提供了observable的api的，当对应变量值改变时触发函数。\n\n\n\n不过这种写法违反了OCP，因为我们修改了dogbot让他主动实现observer的update。我们可以采用decorator design 方法。\n\n如果dogbots是一个接口，dogwatcher 可以实现计数功能，还可以在文件，在gui中实现dogbots，实现集合的dogbots，两者代码几乎是分离的。\n我们先用一个ObservableDogBot类继承Observable，且实现未完成的dogbots，然后写一个dogreporter实现observer。最后rover.addObserver(reporter1);\nFactory Methods\n如果我们设定饥饿值大于6的狗要被构造为greedyDogBot是普通狗的子类，那么PlainDogBot和greedyDogBot都直接提供出来构造方法不太好。可以通过一个构造类来判断需要返回什么对象。\n\n这个构造方法可以返回接口类，但是实际方法里返回的都是实现了接口类的具体类，这样可以隐藏返回类类型：\n\n工厂类甚至自己可以包装好类然后送回来一个包装类：\n\n当然工厂方法除了静态的，也可以是非静态的工厂对象。我们可以利用不同的工厂对象包装不同的包装类，这样还能进一步隐藏返回对象的一些信息。\n比如下一个例子中，spy狗多一个watcher。我们用多态方法初始化两个 Dog Factory，但是一个是实际SpyDogFactory类型的，一个实际是PlainDogFactory类型的，因此两者调用makeDogBot的时候会返回不同的狗。\n\n像计数等额外包装功能，我们也可以不用“先用一个计数类包装普通类，再用工厂类包装计数类”，而是把计数内容包装在工厂类里。\n\n\nSingleton Design Pattern\n构造方法不一定返回必须是新创建的对象，工厂类里可以返回已有的对象。\n\n注意LSP原则。\nObject Pool Design Pattern\n对象池模式，保留一个对象列表，在需要的时候返回一个特定对象。\nStrategy Design Pattern\n选择要执行的策略。\n\n上图是狗执行几次action的函数。我们也可以利用重写的Comparator实现条件结构，比如比较ab两狗叫了几次，叫的少的补差。\nState Design Pattern\n可以改变对象的状态类型。\n下面改变的几个类型都是accountState抽象类的实现类，通过多态的方式初始化。\n\nBridge Design Pattern\n解耦思想。比如我们需要12种颜色的画笔，可以选择12根固定颜色的蜡笔，或者1根毛笔和12种颜料。毛笔的例子就很好地解耦了画笔和颜色。\n例子来源：处理多维度变化——桥接模式（一）_LoveLion的博客-CSDN博客\n下例：求父子交集。\n\nFlyweight Pattern\n将那些大量的，具有很多内部状态而外部状态很少的对象进行共享，可以以类似缓存的方式共享。\n概念来源：精读《设计模式 - Flyweight 享元模式》 - 知乎 (zhihu.com)\n\nOpen Source Software\nfree of charge, free of legal restrictions on usage.\n也需要敏捷开发，但是开发方式略有不同，毕竟不是利益相关的模式。强调个人之间的密切交互 close personal interaction，开发者也是自己的客户，因此有很多人做测试，而且修改后的小版本可以很快发布；通常分的小模块很多，世界各地的大家分别开发。\n世界各地大家通过电子方式互相交流 electronically。\n整体协调者 overall co-ordinator 通常由志愿者负责。\n商业软件和OSS就像大教堂和集市的区别，大教堂需要有一个整体的建造目标，大家一同努力。集市可能由城管那样的整体协调者管大家秩序，但是大家还是偏personal一点。\n如果自己公司自己开发项目，当然需要大量人力财力开发和后期维护；选择闭源软件，就绑定在供应商身上了（垄断技术），他们需要进一步收费咱也得交。开源软件就不用担心支付费用这类问题或者供应商倒闭问题，但是不是是开源软件就能拿来用的，注意版权问题。\n开源软件大多数有一小部分人在开发核心core以及新功能，大多数人在correcting  defects。大多数情况下开发者更愿意维护现有fork分支而不是一味开发新分支。\n开源软件也有一个control structure，通常由最初提出项目的人拥有软件的最终决议权，由一些商业公司管理而并非个人（这样能多保质一点），比如安卓开源软件由谷歌掌握控制权，对于提交的fork和patch有权最终决定下一个版本更新的内容。\n\ncontributor：OSS中做贡献的人。\ndeveloper：在软件平台上开发应用的人。\nverifier：测试 change request 是否正确的人。\napprover：决定这些修改是否要合并进大版本的人，和verifier都需要审核面试筛选。\nProject leads：监督单个项目的工程。\n\nsoftware freedom\n\n\n运行程序的自由 run the program\n\n\n学习程序运行原理和按自己意愿修改代码的自由 study how this program works, change it so it does your compute as you wish （当然前提是能访问到源码）\n\n\n分发软件副本的自由 redistribute copies\n\n\n发布自己的版本给他人的自由  distribute copies of your modified versions to others。\n\n\nCopyright\n只有制作者producer有权利制作副本和创建新内容 produce copies and create new work based on it，但是可以授权允许别人复制和改编该作品 make copies of the work and adapt it。制作者可以通过收费等方式赋予这些权力给他人，或者对改编的范围加限制，因为这算是加在producer身上的一种义务，有点回报也正常。\nCopyleft\n但是OSS的版权声明采用的是copyleft，一种 free software license，并不是限定他人复制改编的权力，而是赋予他人这种权力。许可证内容包括：声明源代码可用，以及改编允许的范围。\nvoting\n有权投票的人每人最多一票；没权投票的人不能投；有权投票且选择投票的人不能被阻止投票；其须拥有充足的选择 full choice；其投票结果必须被正确统计不能被别人篡改；总票数正确相加，不能篡改；大多数时候没有人能知道任何一个投票者的选择。\n电子投票有风险，比如数据容易被篡改，被伪造等。\nSoftware Development Tools\nSoftware Craftsmanship and Clean Code\n注意代码整洁，比如格式、注释等。\nSaying “No”\n不要一直盲目答应老板和客户的需求，程序员更熟悉代码，而且需要帮老板规避可能发生的错误。\nLearning from Mistakes\nMicrosoft’s Best Practices\nRevision Control System\n版本控制。\nroll-back：版本回滚。\ncheck-out：开发者拉下来代码。\ncheck-in：开发者提交自己的修订版。\nconflict：两个人的提交出冲突了。\nmerge：合并入主分支。\nDaily Build\n每日构建一次代码，编译链接源代码，进行一些测试，确保第二天大家能使用最新版本。\nContinuous Integration\n开发人员也建议每天check-in一次。\nBuild Verification Tests\n断言和单元测试。\nBug Database\n记录以前的bug记录，解决方法，严重程度，优先级等信息。\nWar Team and Bug Triage\n发布前，作战小组确认系统“好到可以发布”。检查运行是否正常，剩余的bug严重程度等。\nCode reviews and coding guidelines\n团队对彼此代码进行彻底审查。\nGlobalisation and Localisation\n针对不同语言、脚本的差异处理。\nDocumentation Generators\n文档生成。\n","categories":["邮途（北邮国院课内学习）","Lecture"],"tags":["Software"]},{"title":"北邮国院项目：Web 开发实践 小程序标点地图","url":"/2022/05/12/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%87%E7%82%B9%E5%9C%B0%E5%9B%BE/","content":"web 开发实践课的大作业。本次小程序设计主要围绕 map 组件展开。\n我们组设计了一款能够记录地图上的标点信息，并将自己的标点信息发布到帖子上的旅游类app。\ngithub 代码地址，希望对你有所帮助~\n\n小程序的主要功能就是记录地图上的标点信息，并上传到云数据库中；\n\n以及编辑文章，把文章信息上传到云数据库中；\n\n获取云数据库中的文章（最新发布的3篇）。\n数据库设计\n\n目前有两个数据库表。databasemarkers 存储本次记录中所有标点信息；databasearticles 存储该文章发布时间、文章标题、备注、内容以及对应的标点记录id（外键）。\n地图标点\n小程序自带的 map 组件中有一个属性 markers，是一个对象数组。只要把相应格式的对象数组传给 map 组件，就会自动在地图上标记出点的信息。\n\nwxml 文件：\n&lt;!-- subkey 用于调整地图样式经纬度 latitude longitude 信息是地图初始的中心点。本例中，要传递给 map 组件的对象数组也命名为 markers，在 js 文件中获取数据后传递给 map--&gt;&lt;map id=&quot;map&quot;      subkey=&quot;DKEBZ-LKBW4-B3KUP-DYSCI-IG7OS-SQBJH&quot;      longitude=&#x27;&#123;&#123;weidu&#125;&#125;&#x27;      latitude=&#x27;&#123;&#123;jingdu&#125;&#125;&#x27;      scale=&quot;10&quot;      layer-style=&quot;1&quot;      show-location=&quot;true&quot;      markers=&quot;&#123;&#123;markers&#125;&#125;&quot;&gt;&lt;/map&gt;&lt;!--每次点击添加标点按钮，就会获取当前位置信息，存入 markers 数组--&gt;&lt;button size=&quot;default&quot; bindtap=&quot;recstart&quot;&gt;    添加标点&lt;/button&gt;&lt;!--点击结束记录，将标点信息上传到数据库 databasemarkers 中，并跳转到文章编辑页面--&gt;&lt;button size=&quot;default&quot; bindtap=&quot;recstop&quot;&gt;    添加标点&lt;/button&gt;\njs 文件：\nlet cnt=cnt+1const db=wx.cloud.databasePage(&#123;    data: &#123;        jingdu: &quot;&quot;,        weidu: &quot;&quot;,        markers: [],    &#125;,\trecstart: function () &#123;        var that = this        cnt = cnt + 1        wx.getLocation(&#123;            altitude: &#x27;altitude&#x27;,            highAccuracyExpireTime: 0,            isHighAccuracy: true,            type: &#x27;gcj02&#x27;,            success: (result) =&gt; &#123;                console.log(result)                let marker = this.data.markers                marker.push(&#123;                    id: cnt-1,                    latitude: result.latitude,                    longitude: result.longitude,                    width: 20,                    height: 30                &#125;)                // let pointobj = this.data.polyline[0].points                // console.log(pointobj)                // pointobj.push(                //   &#123;                // \t  latitude: result.latitude,                //     longitude: result.longitude,                //   &#125;                // )                console.log(that.data.markers)                that.setData(&#123;                    jingdu: result.latitude,                    weidu: result.longitude,                    recmode: 1,                    markers: marker,                    // polyline:[&#123;                    //   points:pointobj                    // &#125;]                &#125;)            &#125;,            // fail: (res) =&gt; &#123;&#125;,            // complete: (res) =&gt; &#123;&#125;,        &#125;)    &#125;,    recstop:function() &#123;      var that = this      db.collection(&quot;databasemarkers&quot;).add(&#123;        data:&#123;          markers:this.data.markers        &#125;      &#125;).then(res=&gt;&#123;        console.log(&quot;数据添加成功！&quot;)        console.log(res)        var docstring=res._id        wx.navigateTo(&#123;        url: &#x27;/pages/addarticle/addarticle?docstring=&#x27;+docstring      &#125;)      &#125;)          &#125;,    /**     * 生命周期函数--监听页面加载     */    onLoad(options) &#123;        var that = this        wx.getLocation(&#123;            altitude: &#x27;altitude&#x27;,            highAccuracyExpireTime: 0,            isHighAccuracy: true,            type: &#x27;type&#x27;,            success: (result) =&gt; &#123;                console.log(result)                this.setData(&#123;                    jingdu: result.latitude,                    weidu: result.longitude                &#125;)            &#125;            // fail: (res) =&gt; &#123;&#125;,            // complete: (res) =&gt; &#123;&#125;,        &#125;)    &#125;,&#125;)\n发布文章\n\n添加完标点信息后，提示输入文章标题、备注、正文信息，点击提交，文章就会发布到 databasearticles 数据库中。\nwxml：\n&lt;view class=&quot;inputbox&quot;&gt;  &lt;view class=&quot;line&quot; style=&quot;border-top: 1px solid #e4e4e4;&quot;&gt;    &lt;label&gt;题目&lt;/label&gt;    &lt;input placeholder=&quot; 请输入题目&quot; bindinput=&quot;inputtitle&quot;/&gt;  &lt;/view&gt;  &lt;view class=&quot;line&quot;&gt;    &lt;label&gt;备注&lt;/label&gt;    &lt;input placeholder=&quot; 请输入备注信息&quot; bindinput=&quot;inputcomment&quot; /&gt;  &lt;/view&gt;  &lt;view class=&quot;line-content&quot;&gt;    &lt;label&gt;正文&lt;/label&gt;    &lt;input placeholder=&quot; 请输入正文&quot; class=&quot;content&quot; bindinput=&quot;inputcontent&quot; /&gt;  &lt;/view&gt;&lt;/view&gt;&lt;button bindtap=&quot;submit&quot; class=&quot;submit&quot;&gt;提交&lt;/button&gt;\njs：\nconst db=wx.cloud.database()Page(&#123;  /**   * 页面的初始数据   */  data: &#123;    dataobj:&#123;      comment:&quot;&quot;,      content:&quot;&quot;,      title:&quot;&quot;,      markersid:&quot;&quot;    &#125;  &#125;,  inputtitle:function(options)&#123;    var value=options.detail.value    console.log(value)    this.setData(&#123;      title:value    &#125;)  &#125;,  inputcomment:function(options)&#123;    var value=options.detail.value    console.log(value)    this.setData(&#123;      comment:value    &#125;)  &#125;,  inputcontent:function(options)&#123;    var value=options.detail.value    console.log(value)    this.setData(&#123;      content:value    &#125;)  &#125;,  submit()&#123;    var mydate=new Date()    db.collection(&quot;databasearticles&quot;).add(&#123;      data:&#123;        content:this.data.content,        markersid:this.data.markersid,        comment:this.data.comment,        title:this.data.title,        createdate:mydate      &#125;    &#125;).then(res=&gt;&#123;      console.log(&quot;数据添加成功！&quot;)        console.log(res)        wx.navigateTo(&#123;          url: &#x27;/pages/success/success&#x27;,        &#125;)    &#125;)  &#125;,  /**   * 生命周期函数--监听页面加载   */  onLoad(options) &#123;    var docstring=options.docstring    console.log(docstring)    this.setData(&#123;      markersid:docstring    &#125;)  &#125;,&#125;)\nwxss：\n.inputbox &#123;  margin-top:60rpx;  height: 450rpx;&#125;.inputbox .line &#123;  display: block;  min-height:100rpx;  line-height:100rpx;  padding: 0 30rpx;  border-bottom:1px solid #e4e4e4;&#125;.inputbox .line-content &#123;  display: block;  min-height:300rpx;  line-height:160rpx;  padding: 0 30rpx;  border-bottom:1px solid #e4e4e4;&#125;.inputbox .line label &#123;  float: left;&#125;.inputbox .line-content label &#123;  float:left;&#125;.inputbox .line input &#123;  height:100rpx;  line-height:100rpx;  float: left;  margin-left:40rpx;&#125;.inputbox .line-content input &#123;  width:80%;  height:140rpx;  line-height: 140rpx;  float: left;  margin-left:40rpx;&#125;.submit &#123;  position: absolute;\twidth: 80%;\tleft: 0;\tright: 0;\tmargin: 180rpx auto 0;  border-radius: 98rpx;  border: 3rpx solid rgb(0, 0, 167);  color:rgb(0, 0, 167);\tdisplay: flex;\tflex-direction: row;\talign-items: center;\tjustify-content: center;&#125;\n获取最新发布的三篇文章\n\n最新发布模块可以获取云数据库中最新发布的三篇文章，原理是根据时间戳倒叙排序后取前三条记录。\ndb.collection(&quot;databasearticles&quot;)      .orderBy(&#x27;createdate&#x27;,&#x27;desc&#x27;)      .limit(3)      .get(&#123;        success:res=&gt;&#123;          console.log(res)          this.setData(&#123;            new3obj:res.data//new3obj 是在 data 中定义的，用来接收最新发布的三篇文章对象集合的变量          &#125;)        &#125;      &#125;)\n以上就是本小程序核心功能啦！希望对你有帮助！\n","categories":["邮途（北邮国院课内学习）","Project"],"tags":["Wechat Miniprogram"]},{"title":"北邮国院项目：创新思维实践 C语言五子棋","url":"/2021/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E5%88%9B%E6%96%B0%E6%80%9D%E7%BB%B4%E5%AE%9E%E8%B7%B5%20C%E8%AF%AD%E8%A8%80%E4%BA%94%E5%AD%90%E6%A3%8B/","content":"这次看了几位大佬的做法，我们也做了很多修改尝试。算是第一次尝试合作完成项目。\n我认为学到的东西：\n\n第一次尝试写项目，把函数分到不同的.c文件中后更好看了一些。\n在研究过程中应该分清主次。代码正确运行才是基础要求，其他什么美化界面，调字体调颜色都并非重点。（8月4日更新：评价算法的五个特性，正确性，简明性，健壮性，效率，最优性）\n从代码中学到的，①是采用落子数来判断该轮到黑方下还是白方下（落子数为2的倍数时黑方下，否则白方下），这样也能判断出是哪一方胜利，而且落子数还可以判断棋盘是否下满（==16*16时棋盘落满，平局） ②是胜利条件的判断，以中间子为参考，看两边的四个子是否和他颜色相同。\n8月4日更新：在这次尝试中在文件中使用了全局变量，不同文件中用extern调用。但是在后来学习中意识到全局变量最好不要写在文件里，会增加耦合性。以后多人合作写不同函数的时候也要注意，尽量不要出现。\n\n规则\n在一个16*16的棋盘上，黑白双方交替落子，每次落下子后如果棋盘上出现了五个同色棋子横向/竖向/斜向连接，则该方胜利。如果在棋盘下满后（即下了16*16个子后）仍未分出胜负，则为平局。\n逻辑\n初始化棋盘，是一个16*16的二维数组（定义宏 N=16），一开始每一格都初始化为0。用一个不断++的落子数变量%2来判断本回合是黑方下还是白方下，；每次玩家输入横纵坐标，该处的变量值改变（黑子为1，白子为2）。每次落子判断全盘是否有五子连珠，如果有则结束游戏，如果没有则继续下。当落子数达到N*N即棋盘下满，还没有出现五子连珠时，则判断为平局，结束游戏。\n五子棋胜负条件判断\n判断原理:\n胜负的判断是在每颗棋子落下之后进行，所以用这一子的坐标为基准前后左右斜各个方向来看是否取胜。\n具体思想:\n按照五子棋规则，当一方的棋子，在横向，纵向或斜向连续五个均为同一用户的棋子时，代表胜利。\n另外，胜利判断只需要在一个新子落子时判断，且仅需要判断新子所在的四条线上(纵横加两个斜线)是否满足条件即可。\n所以，可以以新子坐标为基准点，判断四次。\n比如横向的，需要判断左侧和右侧连续的同类棋子个数，如果左侧+右侧+1（自身）总数&gt;=5，则为胜利。\n在判断胜利的时候,首先我们要排除空子的情况,然后当两个斜线的时候, 无胜情况下，判断直线,当为两斜线及直线无胜情况下，判断横线。\n参考代码如下：\nint win()&#123;\textern int arr[100][100];\tint k = 0,l = 0;\tint flag = 0; \tfor(k=2;k&lt;N-2;k++) \t\tfor(l=2;l&lt;N-2;l++)\t\t&#123;\t\t\tif(arr[k][l]!=0&amp;&amp;arr[k-2][l-2]==arr[k][l]&amp;&amp;arr[k-1][l-1]==arr[k][l]&amp;&amp;arr[k+1][l+1]==arr[k][l]&amp;&amp;arr[k+2][l+2]==arr[k][l])\t\t\t&#123;\t\t\t\tflag=1;\t\t\t\tbreak;\t\t\t&#125;\t\t\tif(arr[k][l]!=0&amp;&amp;arr[k+2][l-2]==arr[k][l]&amp;&amp;arr[k+1][l-1]==arr[k][l]&amp;&amp;arr[k-1][l+1]==arr[k][l]&amp;&amp;arr[k-2][l+2]==arr[k][l])\t\t\t&#123;\t\t\t\tflag=1;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\tif(flag==0) \t\tfor(k=0;k&lt;N;k++)\t\t\tfor(l=2;l&lt;N-2;l++)\t\t\t&#123;\t\t\t\tif(arr[k][l]!=0&amp;&amp;arr[k][l-2]==arr[k][l]&amp;&amp;arr[k][l-1]==arr[k][l]&amp;&amp;arr[k][l+1]==arr[k][l]&amp;&amp;arr[k][l+2]==arr[k][l])\t\t\t\t&#123;\t\t\t\t\tflag=1;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\tif(flag==0) \t\tfor(k=2;k&lt;N-2;k++)\t\t\tfor(l=0;l&lt;N;l++)\t\t\t&#123;\t\t\t\tif(arr[k][l]!=0&amp;&amp;arr[k+2][l]==arr[k][l]&amp;&amp;arr[k+1][l]==arr[k][l]&amp;&amp;arr[k-1][l]==arr[k][l]&amp;&amp;arr[k-2][l]==arr[k][l])\t\t\t\t&#123;\t\t\t\t\tflag=1;\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t&#125;\treturn flag; &#125;\n注:\n\n中的arr[k][l]!=0是排除空子的情况。\n最后返回判断结果时, 有胜为1,无为0,谁胜无必要判断，因为，谁尾手了的一定是胜的。\n\n演示\n开始\n\n输入坐标\n\n第二回合\n\n游戏结束\n\n","categories":["邮途（北邮国院课内学习）","Project"],"tags":["C"]},{"title":"北邮国院笔记：RFID","url":"/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ARFID/","content":"前言\n主要围绕考试提纲里的所有问题展开，没有拓展内容，Exam oriented Study。\n关注微信公众号：灰海宽松，回复 “RFID” 可获取本文pdf格式。\n1. Introduction\nComparison of different automatic identification technologies\n首先明确一下比较对象。human identification（cost too high）是人力识别就不用说了。\nfingerprint identification:\n\nstability 稳定，精确度高；\nhigh speed, 快速匹配；\nsecurity issues: 容易被复制。\n\nface recognition:\n\neasy to be influenced by surroundings, hair, age…\n\nspeech recognition:\n\neasy to use and accept by user;\nnot involve privacy;\ndue to international standards, is hard to promoting\n\n1d barcode:\n\nlimit storage capacity, 点线组合少;\nneed to combine with database;\nbarcode size is large;\npoor fault tolerance, 本来就需要摄像头可见，如果被污损遮挡很容易就无法识别;\n\n2d barcode recognition:\n\nlarger storage capacity;\nhigh information density;\npowerful fault tolerance;\nsupport for encryption 容量大了就支持更多编码解码等安全措施了。\n\nrfid：\n\nlow cost;\nlow power consumption;\nhigh accuracy;\nnon-contract, fast speed; 不用接触（哪怕是visual，薄纱条码）\ncertain computing and storage capabilities;\n\n主要考虑各个的缺点，人脸和声音特征点多速度慢，而且人脸容易被影响，声音由于国际标准技术难以提升；条码需要视觉可见；指纹容易被盗取。\nThe main features of RFID\n\n\nNon-contact automatic and rapid identification 快速薄纱复杂的人脸和声音，无接触薄纱条码和指纹\n\n\nPermanently store a certain amount of data 永久存储一定量数据\n\n\nSimple logical processing 其包含的简单逻辑电路允许做一定的逻辑处理，比如安全协议、算法\n\n\nReflection signal strength is affected by the distance  and other factors significantly 信号受到距离，读写器功率，其他信号，其他标签的干扰\n\n\nLow cost, can be deployed at a large scale\n\n\nConstraints of RFID technology\n\nCore technologies of RFID\nAnti-collision mechanism：rfid并不支持传统的cmsa/ca无线通信协议，需要采取一些措施防碰撞（reader-reader, tag-reader, tag-tag)\nEfficient information storage, retrieval and mining: 尽量节能的信息存储，检索，挖掘\nMake full use of the attenuation laws of backscatter signal to assist in positioning and mobile behavior sensing: 我们知道rfid信号会随着距离衰减。反之我们也可以利用这一点来定位物体位置和移动行为感知。\nSecurity certification and privacy protection: 如何利用逻辑门电路校验安全性。\nThe advantage of RFID in IoT, and the development trend\n充电方式：Backscatter, small node and indefinitely time of endurance. but rely on reader, one to many centralized communication 利用无线电 ratio signal 充电的方式\nptp communication: 建立 channel awareness technologies 使得支持被动点对点通信来建立分布式系统\nCombine with Sensors: 开发更多应用方式。\nRFID and IoT:\n\nembed intelligence in the physical object, so that simple physical objects can also “say”.\nallows a physical object to be uniquely identified in a way similar to the “IP address” of a computing node in the Internet.\nprovides a low-cost communication way to achieve effective communication between nodes.\nmakes the physical objects in a passive environment achieve “passive intelligence“, providing fundamental guarantee for the “thing-thing connection”\n\n2. Identification\n简单说RFID就是物体上贴tag，用reader上的antenna去读取，这三个是主要组成。\nReader’s function\nEnergy supply: 比如有的标签自身不带能量需要reader提供信号中蕴含的能量\nCommunication: 最基本的功能，和tag识别，通信\nSecurity Assurance: 比如加密解密\n扩展功能：比如自组网 ad-hoc, 管理天线 antenna management 中间件接口 interface of middle components 连接外设 connecting peripherals\nReader’s classification\n按频率：LF HF算低频，UHF和SHF算高频（ultra super)，高频数据传输速度快，距离远，但是衰减快 signal attenuation，收到障碍物影响大  sensitive to obstacles。\n按外观：\n\nFixed 固定有线的，高度集成，快速启动 set up\nportable 可移动的像手持手机一样，small, charging battery, easy to move\nIndustrial 为工厂目的而生，比如集成其他 sensor\n\nInfluencing factors of R&amp;W range\n许多东西都有说明书，规范，来提醒我们怎么不把东西玩坏比如手机提示不要放水里玩。\nRFID的R&amp;W range是其中一种。影响因素如下：\n\n\nThe way that antenna is coupled 天线耦合方式，比如把两个天线绑一起太近互相干扰。\n\n\nThe output power of the reader’s RF signal 功率，太低可能无法激发tags\n\n\nThe frequency of RF carrier signal 合适的频率\n\n\nAntenna direction 天线，读取器天线和标签天线极性方向 polarization 相匹配时识别范围最大\n\n\nOperation environment condition\n\n\nMovement speed of tags\n\n\nReader’s components and their functions\nSignal Processing and Control Module: 主要是控制功能，协调一些本地计算\n\nCommunicate with upper computer,  and execute command from it\nControl communication process with tags\nEncode and decode signal\nPerform anti-collision algorithm\nEncrypt and decrypt the data  transferred between reader and tag\nIdentity certification between reader and tag\n\nInductively Coupled RF Module: 主要是产生能量和调制发送信号功能\n\nGenerate high frequency send energy, activate RF tags and  provide energy (passive RF tags)\nModulate signal to sent,  transferring data to RF tags\nReceive and demodulate RF signal  from RF tags.\n\nTag’s functions\n\ndata storage\nenergy harvesting 吸收能量，与reader的 energy supply 对应\ncontactless with R&amp;W 不用接触就能通信，与 reader 的 communication with tags 对应\nSecurity Encryption 与 reader 的 Security Assurance 对应\nCollision Concessions 碰撞让步\n\nTag classification: by package form, by power source, by work frequency, by R&amp;W capability\nPackage form 也就是外观上的分类：\n\ncard-like\nlabel-like\nImplantable, 比如动物植物体内\nAccessories-like 附件类标签，比如纽扣型的，这一类主要是方便携带\n\nBy Power Source 按能源供应方式分类：\n\nactive 自己有电池供电\npassive 依靠 carrier signal 读取器发来的载波信号获取能量\nsemi-passive 有电池作为后备隐藏能源，平时主要是passive 方式\n\nBy Work Frequency\nLF HF UHF。UHF读写性能，距离最好，更多会使用 active 型。\nBy R&amp;W Capability\nread-only 和 R&amp;W 两种，结构复杂度也有所不同\nTwo work modes of RFID middleware\ninteractive, independent。\n\n交互模式大概就是一直接收主机的命令，你让我读我就读，读完把结果还给你。\n独立模式是可以不接收主机命令自行按预设的程序和读取到的结果信息循环执行指令，并将结果返回给主机。\n3. Wireless Communication Principle of RFID\nDifferent work principles of different carrier frequency\n不同频率载波也适用不同的工作原则。\n前面已经有所涉及，比如LF HF适用于近距离，UHF SHF适合远距离。\n前者适用 Inductively Coupled RF Module 电感耦合，通过感应方式获取能量。\n后者适用 Electromagnetic Backscatter Coupled RF Module 电磁反向散射耦合，持续不断发送射频信号来供给能量。backscatter 指的是接收机信号调制后通过发送机天线产生可被识别的信号。\n两者的能量消耗都和距离平方成正比 squared distance\nSignal voltage and energy: dB, dBm，重点：如何计算\n变化的电压通常用 $V(t)=v_0cos(\\omega t)$ 表示。\n功率P=VI=V^2/R这不用多说。平均功率 $=\\frac{v_0^2}{2R}$ 很简单推因为正余弦平均就是/根2.\n相对变化 The relative change，这是一个比较新鲜的而且信号变化中比较重要的指标。\n$G_{dB}=10log_{10}\\frac{P2}{P1}$\n参考功率 referenced power $dBm=10log_{10}\\frac{P}{10^{-3}}$\ndBm单位是功率的W，GdB单位是dB，代表一个比值。\nModulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0\n一些阅读器通过调制使得正弦电压信号携带信息的方法。\nOOK：on off keying，高功率1低功率0.\n\n问题在于，低功率0的部分标签没法被激活，也无法正常工作。也就是说0信号标签压根启动不了，没法接收0信号。\nPIE解决方法：长高功率是1，短高功率是0.\n\n然后涉及到tags对reader发来的信号进行解码。空间中的信号发过来是有方向的矢量叠加，tags如何通过编码机制识别信号？\nFM0编码方式：位窗起始处翻转信号表示1，中间翻转表示0.\n\nFM0属于 FSK frequent shift key 通过信号变化频率来识别的机制。\nLink budget (重点)\nLink budget: forward link budget  and backward link budget 发射过程中能量增减的总和\nreader transmit energy(+) path loss(-) tag activate energy(-)\n\npass loss: 读取器天线向360度的发送能量。其中只有一部分区域可以被tags antenna读取到，这一部分被称作 Effective  Aperture (Ae) of the tag antenna。能量=有效面积*密度 $P_t=\\rho A_e$ 。总共发送的能量比收到的能量就等于总表面积比有效面积 $\\frac{P_{TX}}{P_{RX}}=\\frac{A_e}{4\\pi r^2}$\n\n\n来看上例，发送方30dBm对应1W，tag接收到-10dBm对应10^-4W. 然后5dB的衰减到-15dBm。这个5dB衰减就是两个dBm做差得到的。\n所以，dBm相当于对功率P的另一种衡量方式，为什么这么麻烦的要用log来表示？因为两个dBm的差值就是分贝（放大系数），所以由一个dBm能量转到另一个只需要加减两者间差的分贝即可，很方便。\n从tags反射回来的信号 reflection link 和路径四次方成反比 inversely proportional. $P_{RX,back}:\\frac{1}{r^4}$\nAntenna gain and polarization, EIRP\nantenna gain: 输入条件相同情况下，实际情况某一点能量密度/理想条件下的密度单元。反应了天线 concentrates the input power 的能力。就比如把阅读器放中间，标签围一圈，360度去读取周围标签对能量消耗就大，可能因此传输距离也近；但是如果把标签集中放在一块区域，周围放置的 reader 利用定向天线 Directional antenna，固定读取某一个角度范围内的tags能量利用效率就高。\nPolarization：事物在一定条件下发生极化 polarization，使得其表现的和原有状态不一样  its properties deviate from the  original state。\nEIRP, Equivalent Isotropic Radiated Power: 天线在所指方向上获得最大增益效果 maximum gain effect 所需要的能量。\nFor example, FCC regulations in the United States, a non-irradiated  transmitter can transmit 1W of energy signals, and can use 6dBi antenna; antenna gain increased by 1dB, transmission energy needs to  be reduced by 1dB. In fact, FCC is not more than  36dBm(30dBm+6dBi).\nEffects of antenna gain，重点：分析 link budget，几个计算公式\ndirectional gain: radiation density of one direction d / average value in all direction\npower gain: radiation efficiency of that direction G\n平面角：单位rad，比如圆周180度单位角=2pi rad\n立体角：单位sr，比如球面立体角=4pi sr\n能量增益G的计算方法是4pi/立体角大小。比如波束宽度72°也就是2pi/5大概是1.25rad， $G=\\frac{4\\pi}{1.25^2}$\ndipole antenna: 垂直于轴沿各个方向发送信号，比全向天线 omnidirectional antenna 小2.2dB。\nEffective aperture $A=G\\frac{\\lambda ^2}{4\\pi}$\n$P_{RX}=P_{TX}G_{RX}G_{TX}(\\frac{\\lambda}{4\\pi r})^2$\n\n$R_{forward}=\\frac{\\lambda}{4\\pi}\\sqrt{\\frac{P_{TX,reader}T_bG_{reader}G_{tag}}{P_{min,tag}}}$\n$R_{reverse}=\\frac{\\lambda}{4\\pi}\\sqrt[4]{\\frac{P_{TX,reader}T_bG_{reader}^2G_{tag}^2}{P_{min,reader}}}$\n4. Tag Identification Protocol\nChecksum procedure: parity checks, LRC, CRC\n奇偶校验不多说，查1的个数，poor error recognition。电路通过所有位异或是偶校验，结果为1说明有错误；再取反是奇校验。\nLRC longitudinal redundancy check (LRC) procedure 循环冗余检测，所有字节进行异或运算，得到的结果是LRC校验码。也就是说数据发送到终点后，所有字节（数据和LRC）进行字节异或运算结果应该为0. 也有一些错误无法纠正，主要用于小的数据块校验。\nCRC (cyclic redundancy check) procedure\n\n接收方计算原数据+CRC数据拼接起来的CRC数据值，应该为0. 不能纠错，不过检错效率很高。\nASK, FSK, PSK\namplitude Shift Keying: 幅度调制，y轴上的调制。\n\n计算方法2：duty factor: $m=1-\\frac{u_1}{u_0}$\n$U_{ASK}(t) =(m·u_{code}(t)+1−m)·u_{HF}(t)$\nFrequency shift keying: 频率上的改变。\n\nPhase shift keying: 频率相位翻转180.\n\n\nDifficulty of traditional anti-collision algorithms for solving collision detection between RFID tags\nCompared with the reader, limited by hardware resources, tags have very limited storage capacity and computing.\n标签受制于硬件资源，存储容量和计算能力都不高。\nTDMA, FDMA, CSMA\n首先主要有两种方式，一个是reader broadcast 广播到诸多 tags，一个是多个 tags Multi-access 每个tags单独访问reader。\nTDMA FDMA是multi-access, CSMA是broadcast\nFDMA: 多个频率通道 several frequency channels 传输数据。\nTDMA:\n\nALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程\nPure ALOHA algorithm：收到成功确认 ack 后就不再发送。否则一直随机等待后继续发送。简单但是通道利用率 channel utilization 低，poor performance.\noffered load G：单位时间 tau 里同时发送的应答器数量\ns-aloha: 规定时间片 slot，一个时间片只能发一次，冲突就下一次时间片去发。channel utilization 几乎是 pure 的两倍。\n$S = G × e^{-G}$ G=1最大\nframe S-ALOHA: 规定一个周期 frame，包含若干个 slots，会更加有组织有秩序。reader 广播一个 frame length，tags 自己选择组织时间片（0~f-1），每个时间片开始 reader 轮询一下tag里sn信号是不是0，是0就发送，不是0就-1.\nconflict slot, single slot, idle slot（空）\n逻辑，电路设计，内存都比较简单，但是 frame length 长度不固定。tags 远远多于 frame length 冲突时间片就太多，tags 太少空时间片太多太浪费。负载 G=1 也就是 length=tags 利用率最好。\n\nDFSA：利用以前的 frame 冲突反馈结果，和一些机器学习算法推测合适的 frame length。\nEPC Global（第五章介绍）规范里使用了一种Q算法。简单说就是如果冲突太多了，当前 frame 就别继续了，中断，新开一个大容量 frame. 同理 空闲太多了就新开一个小 frame。\n\nQfp是指定的初始值。每次先取整，然后发起 query。\n没有回复：Qfp-C C是一个参数，比如0.1.\n有冲突&gt;1：+C。注意有上下限。\nALOHA 算法公平。但是可能发生饥饿 ，比如有一个 tag 每次都是有冲突的 slot，一直没有办法被处理。\nBinary tree based protocols: BT, QT, 重点：执行过程\n第二种算法，基于二进制数。就像二叉树不断拆分冲突的结点变为两个结点，直到节点里只有一个 tag。\nrandom binary tree BT：随机。\nbinary query tree QT：排序，查询。\n每一个 tag 需要有一个计数器来记录自己的状态。\n\n每一个tag都会被识别，不会饥饿，但是需要存储每个tag的状态。\n比如看下面的例子：\n\n首先 tag1234 随机选一个数，比如选了0010，SN分别加自己选的数。\n\n找SN=0的，发现有是有，但是他们几个都冲突了。那么继续分，比如1011，SN=1021\n\n2的SN=0而且不冲突，把2读取了之后2不再继续参与。然后当有tag读取后，所有其他SN-=1\n\n=0的是14，但是他俩冲突。然后再重新划分一下，比如011, SN=0021\n\n然后处理1，其他-=1，处理4，其他-=1，处理3.\nQT 不需要存储状态，如何实现？读取tag的序列号比较。\n\n不会饿死，也不需要一个可以读写的cnt，识别的时间和 tag id 有关。\n\nBinary search: Manchester code instead of NRZ code, 重点：执行过程\n具体分辨哪一位有冲突。1代表冲突。\n\nNRZ混合没法检测错误。\n\n曼彻斯特可以，一个上升一个下降，合起来是0或者1.\n\n查询的流程：\n\nrequest：发送一个序列号给tags的transponder，如果tags的序列号小于给定序列号返回。\nselect：给定一个特定序列号，返回等序列号的tag。\nread_data：返回所选tag的信息。\nunselect：读取完data了，这个tag退出选择流程。\n\n\n第一次迭代：返回uplink是所有transponder的id的共同信息（通过曼彻斯特编码找出没有冲突的位）。046位冲突了（从右往左），8个可能。\n第二次迭代：限定 bit6 为0的request。发现有3个还是冲突04位（最高位冲突位=0，其他冲突位=1，如果range是大于等于，则正好相反）。\n第三次迭代：限定bit4为0的request……\n\n长度 L(N)=log2(N)+1\nDynamic binary search, 重点：执行过程\nBinary Search 是每次都传输完整二进制字符串. 其实我们只需要动态改变的部分.\n比如我们查询1010 1111 1111, 那返回值前面一定是1010呀, 就不用传输了. 前缀叫 NVB, Number of Valid Bits\n每次请求发送的信息: Request+NVB=4+1010\nAdvantages and disadvantages of ALOHA based anti-collision algorithm\nsimple\ngood identification performance\nresults can be statistically analyzed 结果可以被统计化分析\n缺点就是可能 starvation 饥饿，delay trend to ∞\nAdvantages and disadvantages of binary tree based anti-collision algorithm\nsimple\nintermediate state variables 不需要存储中间状态变量（QT）\n缺点：查询时间受到 tags id 和 长度限制，比如二叉树沿着一个方向一直偏。\n5. EPCglobal Standard &amp; protocol\nConcept of EPC global network\nEPCglobal Network: a technology that\n\nallows trading partners to document and determine the location of individual goods\nif possible in real time\nadditional information: such as 生产使用日期，能否被贸易伙伴交换\n\nFive basic services of EPC global network, interaction of different components of EPCglobal network\nElectronic product code (EPC)\nThe identification system\nEPCglobal Middleware\nDiscovery Service (DS)\nEPC Information Services (EPCIS)\nEPC码是唯一标识对象的代码。识别系统包括对象上的可被读取的包含EPC码的transponder和读取器reader可以识别EPC，然后通过EPCglobal Middleware传到网上，通过DS在 EPCglobal network 查找EPC码的相关信息（包括object naming service）。可以通过EPCIS和其他贸易伙伴交换EPC相关信息。\n这其中的交互：\n\ntransponder and reader : data acquisition\nMiddleware\nDiscovery services\nEPC Information Services : access to EPC-related data\nEPC code 组成\nDomain Manager Number + Object Class Number + Serial Number\nBasic procedures of the EPC Network\nEPC码用于标识对应对象\nall information about the object 在EPCGlobal Network里注册 administer\neach company in the EPCglobal Network: 各个公司管理数据集和数据对象\naccess rights to object data: 包含在EPCIS里，指明了trading partners 之间访问权限\n\n\nthe manufacturer：把transponder和product绑定\n\n\nall data assigned to the product：在EPCIS里\n\n\nEPCIS registers the entries with EPC Discovery Services：注册了DS之后方能找得到EPCIS\n\n\nproduct：卖给零售商 retailer\n\n\nAt the retailer’s goods-in point 数据存储在零售商EPCIS中\n\n\nregistered by EPCIS with EPC Discovery Services\n\n\nThe company prefix send to root EPCIS\n\n\nroot -&gt; local -&gt; the EPCIS\n\n\nBinary tree based variant algorithm for EPCglobal Class 0\n这种tag是只读的，制造商赋值。\n\nEPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs\nEPC C1G1：查询tags EPC的一种标准。\n被动标签，支持kill和lock两种操作。\npingID：掩码，用于查询tag EPC\n\nEPC C1G2 有 OSI 的七层模型，两条数据链路（R-T）\n\n\n上电 ready\n发 query 命令，aribtrate 仲裁。选择随机数生成时间片。\nslot=0 的开始 reply\ntag 发 ack 给 reader，acknowledged 状态。\ntag 收到 reader 的命令后进入 open，校验后进入 secured，完成 killed。\n4个识别 tags 的命令：Select command, Query command, QueryRep command, QueryAdjust command\nselect 指明要查哪些 tags 的集合。\nquery 启动新的识别过程。\nRep 开启下一轮 slot 查询，标签 SN–，到0时读取。\nAdjust 调整时隙数，选择新的时隙计数器等。\n两大性能问题：\n\nBuild a set of tags involved in the recognition process，如何建立正确的tags集合来查询（select 和 query 负责）\nSelect the way of data encoding, for the readerto-tag, the tag-to-reader, the reader itself and the  tag itself 根据环境调整编码方式\n\n","categories":["邮途（北邮国院课内学习）","Lecture"],"tags":["RFID"]},{"title":"北邮国院项目：程序设计课程设计 C语言订餐系统","url":"/2021/09/11/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F/","content":"尽管快半年没有学c了，好在回顾起来还是蛮快的。而且也发现比去年的自己熟练了许多。\n小学期要求5人合作，用C语言做一个订餐系统，能够实现用户的登录、选择餐馆、订餐、按各种规则查询与排序、修改个人信息，管理员的登录、添加菜品、按各种规则查询与排序、修改个人信息。\n首先，我们调研了几个流行的订餐系统，并解决了午饭分析其页面逻辑顺序，借此设定了我们自己的订餐系统的逻辑顺序。\n感谢blue、peppa、214、Mar鼎力相助！\n\n至于写法，主要尝试了两个新知识点：文件操作与链表。\n想要实现这样的订餐系统，必须有地方可以存储其数据。不能说放在程序里吧，每次一关一开又恢复原状了。我们使用FILE文件操作，对存放在指定位置的txt进行读写操作，读取其中的数据。\n至于数据结构采用结构体数组还是链表，在之前学习翁恺老师的网课时我们认识到了结构体数组的一些弊端。数组大小固定，一旦初始化无法修改，少了可能越界，多了浪费内存空间，链表就可以想用一个结点开辟一个结点。而且对于插入、删除等操作还是链表香啊，数组中间插入或删除一个，后面的都要跟着动。\n至于如何实现多人合作，可参考翁恺老师网课12.3.1多个源代码文件用devc++创建项目的方法。我们每人负责了几个函数，最后对好接口和返回值合并。其实就像同学说的，在合并之前是最没底的，也没法测试知道自己写的什么样。好在最终完成的还算顺利。\n链表中嵌套链表，是这回我们做的一个非常有意思的尝试。我们发现每次订单中所点的菜品及其数量，和每次订单结束后推荐的菜品数量都是不固定的。对于数据结构还没开始学的我们来说有些困难。后来去问了老师，老师给出了“那你们只能在链表里套一个链表了吧”的解决方案。没想到这个方案真的能做，虽然这铁不是最佳方案。但是也非常有趣。\ntypedef struct list_dish //订单中的菜品链表&#123;\tint dish_id; //菜品号\tint number;\t //该菜品数量\tstruct list_dish *next;&#125; LISTDISH;typedef struct recommend_d&#123;\tchar dish_name[len]; //推荐的菜品名称\tstruct recommend_d *next;&#125; RECOMMEND;typedef struct list //订单链表&#123;\tint number;\t\t\t\t//订单号\tchar user_id[len];\t\t//用户id，据此可以找到用户地址\tint restaurant_id;\t\t//餐馆id\tint score;\t\t\t\t//本次订单对餐馆的打分\tint price;\t\t\t\t//本次订单的总价格\tTIME delivery_time_s;\t//起始配送时间。TIME是一个包含月、日、时、分成员的结构体\tTIME delivery_time_e;\t//结束配送时间\tRECOMMEND *recommend_d; //本次用户推荐菜品头结点指针 \tLISTDISH *head_ld;\t\t//本次订单的菜品链表头结点指针\tstruct list *next;&#125; LIST;\n如上，在订单链表的每个结点中，都包含着一个listdish（存储本次订单所选菜品及其数量）链表的头结点和一个recommend（存储本次订单推荐的菜品）链表的头结点。访问的时候可以通过list-&gt;recommend-&gt;dish_name这样的方法直接得到本次订单中推荐菜品的菜品名称。\n这样的结构，如何从文件中读取？\n其他的链表都还好办。至于这三个链表，我们建立了3个txt文件（虽然listdish和recommend有许多链表，但是最好还是都存在一个txt里，不然每次新点订单还要新建txt文件。）其中listdish和recommend文本文档是这样的：\n\n每一行代表第几个订单。每两个数字为一组，第一个数字为菜品号，第二个数字为该菜品所点数量。由于不固定长度，我们采用两个-1作为结尾，当读到-1时本订单结束。\nLIST *read_inf_l()&#123;\tLIST *head = (LIST *)malloc(sizeof(LIST))\t, *last = head, *p, *temp = (LIST *)malloc(sizeof(LIST));\thead-&gt;next = NULL;\tFILE *fp_l = fopen(&quot;D:\\\\小学期\\\\list.txt&quot;, &quot;r&quot;);\twhile (fscanf(fp_l, &quot;%d %s %d %d %d %d %d %d %d %d %d %d %d &quot;\t, &amp;temp-&gt;number, temp-&gt;user_id, &amp;temp-&gt;restaurant_id\t, &amp;temp-&gt;score, &amp;temp-&gt;price\t, &amp;temp-&gt;delivery_time_s.month, &amp;temp-&gt;delivery_time_s.day\t, &amp;temp-&gt;delivery_time_s.hour, &amp;temp-&gt;delivery_time_s.minute\t, &amp;temp-&gt;delivery_time_e.month, &amp;temp-&gt;delivery_time_e.day\t, &amp;temp-&gt;delivery_time_e.hour, &amp;temp-&gt;delivery_time_e.minute) != EOF)\t&#123;\t\tp = (LIST *)malloc(sizeof(LIST));\t\tp-&gt;next = NULL;\t\tp-&gt;head_ld = read_inf_ld(temp-&gt;number);//跳转到read_inf_ld(int number)函数中获得本次订单listdish链表的头结点，number是订单号\t\tp-&gt;recommend_d = read_inf_recommend(temp-&gt;number);//跳转到read_inf_recommend(int number)函数中获得本次订单recommend链表的头结点，number是订单号\t\tp-&gt;number = temp-&gt;number;\t\tstrcpy(p-&gt;user_id, temp-&gt;user_id);\t\tp-&gt;restaurant_id = temp-&gt;restaurant_id;\t\tp-&gt;score = temp-&gt;score;\t\tp-&gt;price = temp-&gt;price;\t\tp-&gt;delivery_time_s.month = temp-&gt;delivery_time_s.month;\t\tp-&gt;delivery_time_s.day = temp-&gt;delivery_time_s.day;\t\tp-&gt;delivery_time_s.hour = temp-&gt;delivery_time_s.hour;\t\tp-&gt;delivery_time_s.minute = temp-&gt;delivery_time_s.minute;\t\tp-&gt;delivery_time_e.month = temp-&gt;delivery_time_e.month;\t\tp-&gt;delivery_time_e.day = temp-&gt;delivery_time_e.day;\t\tp-&gt;delivery_time_e.hour = temp-&gt;delivery_time_e.hour;\t\tp-&gt;delivery_time_e.minute = temp-&gt;delivery_time_e.minute;\t\tlast-&gt;next = p;\t\tlast = last-&gt;next;\t\tlast-&gt;next = NULL;\t&#125;\tfclose(fp_l);\treturn head;&#125;\nLISTDISH *read_inf_ld(int id) //Read the Information of List-Dish linklist&#123;\tLISTDISH *head = (LISTDISH *)malloc(sizeof(LISTDISH))\t, *last = head, *p, *temp = (LISTDISH *)malloc(sizeof(LISTDISH));\thead-&gt;next = NULL;\tFILE *fp_ld;\tfp_ld = fopen(&quot;D:\\\\小学期\\\\listdish.txt&quot;, &quot;r&quot;);\tint cnt = 1;\tif (id != 0)\t\twhile (cnt != id)\t\t&#123;\t\t\ttemp-&gt;dish_id = 0;\t\t\twhile (temp-&gt;dish_id != -1)\t\t\t&#123;\t\t\t\tfscanf(fp_ld, &quot;%d %d &quot;, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);\t\t\t&#125;\t\t\tcnt++;\t\t&#125;\tfscanf(fp_ld, &quot;%d %d &quot;, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);\twhile (temp-&gt;dish_id != -1)\t&#123;\t\tp = (LISTDISH *)malloc(sizeof(LISTDISH));\t\tp-&gt;dish_id = temp-&gt;dish_id;\t\tp-&gt;number = temp-&gt;number;\t\tlast-&gt;next = p;\t\tlast = last-&gt;next;\t\tlast-&gt;next = NULL;\t\tfscanf(fp_ld, &quot;%d %d &quot;, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);\t&#125;\tfclose(fp_ld);\treturn head;&#125;\n比如要读取第三个订单所点菜品信息，传入read_inf_ld()的number订单号为3.int cnt = 1代表当前文件指针读取的订单号，从1开始计数，每次读到-1 -1证明又读完了一单，cnt++，直到cnt == number为止。然后读取接下来的这个链表，最后返回头结点，作为该订单中的一个成员。\n\nRECOMMEND *read_inf_recommend(int id)&#123;\tRECOMMEND *head = (RECOMMEND *)malloc(sizeof(RECOMMEND)),*last=head\t,*p,*temp = (RECOMMEND *)malloc(sizeof(RECOMMEND));\thead-&gt;next=NULL;\tFILE *fp_recommend = fopen(&quot;D:\\\\小学期\\\\recommend.txt&quot;, &quot;r&quot;); \tint cnt = 1;    if (id != 0)        while (cnt != id)        &#123;            strcpy(temp-&gt;dish_name,&quot;0&quot;);            while (strcmp(temp-&gt;dish_name , &quot;-1&quot;)!=0)            &#123;                fscanf(fp_recommend, &quot;%s &quot;, temp-&gt;dish_name);            &#125;            cnt++;        &#125;    fscanf(fp_recommend, &quot;%s &quot;, temp-&gt;dish_name);    while (strcmp(temp-&gt;dish_name ,&quot;-1&quot;)!=0)    &#123;        p = (RECOMMEND *)malloc(sizeof(RECOMMEND));        strcpy(p-&gt;dish_name, temp-&gt;dish_name);        last-&gt;next = p;        last = last-&gt;next;        last-&gt;next=NULL;        fscanf(fp_recommend, &quot;%s &quot;, temp-&gt;dish_name);    &#125;\tfclose(fp_recommend);\treturn head;&#125;\n读取推荐菜品链表也是类似。\n得到的链表全都包括头结点（里链表也是），不包含结尾的-1，只要通过-&gt;-&gt;就能访问hh。\n总之，结束了~\n","categories":["邮途（北邮国院课内学习）","Project"],"tags":["C"]},{"title":"北邮国院项目：计算导论与程序设计 C语言函数动画","url":"/2020/12/15/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E5%8A%A8%E7%94%BB/","content":"绘制一个函数动画。\n要求：1.碰到边界反弹；\n2.会像贪吃蛇一样消失。\n老师已给出提示代码：三个辅助函数\n#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;math.h&gt;// two functions to clear screen and set cursor position for printing.// one function to take a rest in 10 microseconds.// use this function to clear screenvoid clear()//清屏&#123;#if defined _WIN32    system(&quot;cls&quot;);#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)    system(&quot;clear&quot;);#elif defined (__APPLE__)    system(&quot;clear&quot;);#endif&#125;#if defined _WIN32    #include &lt;conio.h&gt;    #include &lt;windows.h&gt;    void setcursor(int x, int y)    &#123;        HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);        COORD setps;        setps.X = x; setps.Y = y;        SetConsoleCursorPosition(hCon, setps);    &#125;#endif// use this function to positioning before calling printf  void gotoxy(int x, int y)//光标移动到x,y处&#123;#if defined _WIN32    setcursor(y - 1, x - 1);#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)    printf(&quot;\\033[%d;%dH&quot;, x, y);#elif defined (__APPLE__)    printf(&quot;\\033[%d;%dH&quot;, x, y);#endif&#125;int factor = 10;// rest msec * 10 microsecondsvoid rest(int msec)//当前画面静止一定时间&#123;#if defined _WIN32    Sleep(msec * factor);#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)    usleep(msec * 1000 * factor);#elif defined (__APPLE__)    usleep(msec * 1000* factor);#endif&#125;\n其中clear()函数清屏；gotoxy()函数使光标移动到指定位置；rest()当前画面静止。\n思路\n1.动画绘制\n动画的原理是一帧帧的图片有短暂的时间间隔，连起来放映之后就产生了会动的感觉。我们可以每打印一个点之后rest()一小段时间来形成动画的效果。\n2.边界反弹\n即为碰到边界反向输出。我想的方法是纵坐标y1不变，只需要设计分段函数让x反向即可。\n3.延时消失\n要求的消失是像贪吃蛇一样，前面一边画着点，后面尾巴一边消失。但自己怎么想都只能做到全部绘制完成之后再让它开始消失。\n请教助教与Mc大佬之后得知他的思路是保留点数。屏幕中最多出现50个点，第51个点之后，打印第x个点时，x-50号点打印空格覆盖，让他消失。\n注意事项\n1.审题。给定的gotoxy()函数的横纵坐标是反着的，而且从左上角开始为(1,1)。\n2.rest()的用法非常灵活，比如高人指点：用户可以输入打印速度speed，rest(100-speed)。（妙啊）\n3.程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。所以比起重复一段好多遍，使用函数会更好。\n感谢Mc、fOrever_jAckY、olinr1222、–_–等人指点！\n我の代码\nint zong(int i)//纵坐标y1&#123;\tdouble x=(i-51);\tdouble y=12.0*sin(x/7);\tint y1=(int)(15-y);\treturn y1;&#125;int heng(int i)//横坐标j&#123;\tint j=i;\tif(i&gt;101&amp;&amp;i&lt;=202)j=203-i;\telse if(i&gt;202&amp;&amp;i&lt;=303)j=i-202;\telse if(i&gt;303&amp;&amp;i&lt;=404)j=405-i;\treturn j;&#125;void dayin(char ch,int j,int y1)//在(y1,j)处输出给定字符&#123;\t\tgotoxy(y1,j);\t\tif(ch==&#x27; &#x27;)\t\t&#123;\t\t\tif(y1==15)printf(&quot;-&quot;);\t\t\telse if(j==51)printf(&quot;|&quot;);\t\t\telse printf(&quot; &quot;);\t\t&#125;\t\telse printf(&quot;#&quot;);\t\tgotoxy(29-y1,102-j);\t\tif(ch==&#x27; &#x27;)//防止坐标点和坐标轴被空格覆盖\t\t&#123;\t\t\tif(29-y1==15)printf(&quot;-&quot;);\t\t\telse if(102-j==51)printf(&quot;|&quot;);\t\t\telse if(29-y1==26&amp;&amp;102-j==49)printf(&quot;-&quot;);\t\t\telse if((29-y1==26&amp;&amp;102-j==50)||(29-y1==3&amp;&amp;102-j==50))printf(&quot;1&quot;);\t\t\telse if(29-y1==16&amp;&amp;102-j==100)printf(&quot;X&quot;);\t\t\telse printf(&quot; &quot;);\t\t&#125;\t\telse printf(&quot;#&quot;);\t\tgotoxy(1,1);&#125;int main()&#123;\tfloat x,y;\tint tim=20;\tsystem(&quot;color F0&quot;);\tsystem(&quot;mode con cols=101 lines=30&quot;);\tclear();\t\tfor(int i=0;i&lt;=100;i++)//打印x轴 \t&#123;\t\tgotoxy(15,i+1);\t\tif(i!=50)printf(&quot;-&quot;);\t\telse printf(&quot;+&quot;);\t\tgotoxy(1,1);\t\trest(1);\t&#125;\t\tfor(int i=29;i&gt;=0;i--)//打印y轴 \t&#123;\t\tgotoxy(i+1,51);\t\tif(i!=14)printf(&quot;|&quot;);\t\tgotoxy(1,1); \t\trest(1);\t&#125;\t//打印轴上的点\tgotoxy(16,52); printf(&quot;O&quot;);\t\tgotoxy(16,100);printf(&quot;X&quot;);\t\tgotoxy(1,49);printf(&quot;Y&quot;);\t\tgotoxy(3,50);printf(&quot;1&quot;);\t\tgotoxy(26,49);printf(&quot;-1&quot;);\t\t\t\t\tint i=0,j,y1;\tfor(i=52;i&lt;=404;i++)//打印函数 \t&#123;\t\tj=heng(i),y1=zong(i);\t\tdayin(&#x27;#&#x27;,j,y1);\t\trest(4);\t\t\t\tif(i-51-tim&gt;0)\t\t&#123;\t\t\ty1=zong(i-tim);\t\t\tj=heng(i-tim);\t\t\tdayin(&#x27; &#x27;,j,y1);\t\t&#125;\t&#125;\t\tfor(int r=i-tim;r&lt;=i;r++)\t&#123;\t\tj=heng(r);\t\ty1=zong(r);\t\tdayin(&#x27; &#x27;,j,y1);\t\trest(4);\t&#125; \tgotoxy(1,1);\trest(1000);\treturn 0;&#125;","categories":["邮途（北邮国院课内学习）","Project"],"tags":["C"]},{"title":"技术学习：存算一体芯片的潜力与挑战","url":"/2024/01/29/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/","content":"前言\n本文学习自：存算一体芯片深度产业报告——作者：量子位\n报告链接：存算一体是啥新趋势？值得教授学者纷纷下海造芯 | 附报告下载 - 知乎 (zhihu.com)，侵删！\n存算一体技术概述\n“存算一体”技术的起因在于传统冯诺依曼架构芯片无法满足不断提升的算力与低功耗需求。随着晶体管的体积越来越小，摩尔定律逐渐失效（会引发量子隧穿等反应），导致存储器与处理器之间的数据传输成为 CPU 性能的瓶颈，相对较长时间的数据搬运导致算力受限。\n为了解决这个问题，我们需要新的芯片架构。主要有三种解决方式：\n\n近存计算：缩短处理器芯片与存储器芯片的距离，减少数据搬运损耗。\n内存储计算：处理器和存储器位于同一芯片的不同电路单元中。\n内存执行计算：通过在存储器颗粒上嵌入算法，由存储器芯片内部的存储单元完成计算操作。\n\n产业分析\n\n存算一体芯片落地的优势在于在算力提高的同时，芯片体积的减小和数据传输功耗的减少，使得芯片良率、成本、功耗等都有所改善。然而，实际应用的挑战主要在于评估市场需求和客户转换成本。重要的考量是，大规模采用新型芯片是否能够在成本和能耗方面带来足够的改进，以证明其经济效益；新架构芯片的先进生产工艺制造能力；客户对低功耗和高算力的需求；以及封装、测试、工具链、EDA 等相辅相成的产业链生态仍缺乏相应的研发公司。\n当下大多数初创公司的思路是先聚焦特定场景，在垂直领域内站稳脚跟后技术外溢到更丰富的应用场景。主要的应用场景包括小算力低功耗场景（知存科技、九天睿芯和闪易半导体等）和大算力场景（千芯科技，后摩智能等）。\n目前已知的商业模式主要分为三种：IP授权，定制/联合开发以及自主SoC芯片。\n当前国内外存算一体技术发展特征如下：\n\n成立时间不同会影响技术路线选择，国内外实现产品化的公司数量不多，离规模化还有一定距离\n技术路线：大公司选择最容易落地的，初创公司在确保技术先进性基础上选择最容易落地的\n国外已形成完整的自研技术链，大规模量产上国内外均未实现突破\n不同的业务场景均已呈现出各自的优势，在商业模式上国内外都处在探索阶段\n虽然业内尚未形成完整的生态，产业链部分环节已经出现针对存算一体进行技术研发的公司\n\n未来展望\n为了推动存算一体技术的未来发展，重点应放在解决关键技术难题上，并且寻找适合快速应用推广的场景。随着新型存储器技术，尤其是RRAM和MRAM的不断进步，预计将大幅推进存算一体架构的发展。这些技术的应用，尤其是在终端推理和物联网领域，预示着存算一体技术将在这些领域发挥重要作用。为了实现从初步商业化到大规模商业化的转变，技术创新与产业发展必须紧密协同，共同推动这一技术的成熟和应用普及。\n个人感悟\n作为一名物联网工程专业的大学生，深入了解存算一体技术让我领略了科技创新的魅力及其在未来应用的广阔前景。虽然我尚缺乏商业模式和产品上市的实践经验，但这次学习经历让我认识到理论与实践结合的重要性，以及跨学科知识对于技术创新的贡献。\n通过研究这一技术，我明白了在物联网设备设计中，如何有效融合硬件和软件来提高性能同时降低能耗的重要性。这一认识不仅提升了我的专业技能，也激发了我对如何将技术创新转化为实际应用的深入思考。\n此外，我也看到了自己在商业知识和市场分析方面的不足，这提示我在未来的学习中需更多关注这些领域。我期待将这次学习的感悟转化为动力，在未来的学习和工作中不断探索、学习和创新，为智能化世界贡献我的力量。\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["Chip"]},{"title":"技术学习：STM32 F407 霸天虎开发板","url":"/2023/11/26/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9ASTM32%20F407%20%E9%9C%B8%E5%A4%A9%E8%99%8E%E5%BC%80%E5%8F%91%E6%9D%BF/","content":"前言\n博主开始探索嵌入式以来，其实很早就开始玩 stm32 了。但是学了一段时间之后总是感觉还是很没有头绪，不知道在学什么。前前后后分别尝试了江协科技、正点原子、野火霸天虎三次 stm32 的课程学习。江协科技的 stm32f103c8t6 课程看了一段时间，感觉对一些外设的调用方法有一个基础的认知了，但是没有很明白到底在学什么；正点原子则是有点听不懂，半字也借给同学了就有一段时间没学，感觉自认为 stm32 学的有两把刷子了。后来听前辈说江协科技的 stm32 课程不如 51 单片机的质量好，其实课程讲的一般，我就想：是不是应该重新好好学一下 stm32 课程了。\n这次选择的是野火的  F407 霸天虎课程，第一是听大家说，入门选野火或者正点最好。第二是野火的大师进阶篇的一些内容，涉及到一些原理等的学习讲解，我觉得对我会非常有帮助，因此正好就买了这款开发板从入门到中级到大师原理一起学习了。\n本系列博文笔记主要基于野火相应课程，b站地址：野火F407开发板-霸天虎视频-【入门篇】_哔哩哔哩_bilibili ，仅供学习参考不做任何商业用途使用，侵删！\n调试器介绍\n我选择的是高速版，支持 SW 和 JTAG 两种连接方式。SW 模式则只需要连接 VREF（3V3）, TMS（数据）, TCK, RESET, GND 五个引脚。\n程序烧录配置\n芯片型号：STM32F407ZGTX。\nDAP 仿真烧录自然非常简单。\n串口一键下载 ISP 下载速度慢，不能调试，但是成本很低。可以使用 FlyMcu 等软件。\n2023.11.2 补充。\n警告，建议如果 flymcu 不能烧录，就不要尝试这种玩法了，看看课学学得了。因为我自己乱捣鼓一通后把开发板锁了。\n下面的内容我不太清楚具体是哪一步出现了锁死 flash 的问题，总之不要尝试！学习一下理论得啦。\n如果和我一样锁死了，请见野火大师篇程序，里面有一个解除写保护的代码，运行一下。\nISP 下载方式：允许我们不拆下芯片来下载。对于上个世纪嵌入式学习来说这是一个很大的突破，因为当时是要把芯片拆下来烧录编程的。\nISP 厂商出产的时候就选定了一种串行外设对芯片内部 FLASH 进行编程，我们不能修改。常用串口下载方式，成本低，但是不能调试仿真。\n普通 ISP 需要手动配置 boot loader，一键 ISP 不用，硬件电路和上位机配合达到一键下载的效果（手动配置：00是用户闪存启动，10是系统 SRAM/ISP 启动，普通 ISP 要手动改跳线帽）。\n一键下载电路的具体原理流程如下：\n\nRTS 低电平，Q1 是一个 PNP 三极管，导通，BOOT0 拉高。\nDTS 高电平，Q2 NPN 导通，U18 是一个由 EN 控制开关的模拟开关，2 脚被导通为低电平，连接1脚拉低 NRST 复位。程序下载执行。\nU18 模拟开关的作用是稳定电路。开发板复位的时候 DTR RTS 是不稳定的状态，如果没有这个模拟开关，DTR RTS 可能进入 ISP 状态，复位，进入 ISP 状态，复位，进入……一直运行不起来了。模拟开关右侧电容使得 VCC 需要花一点时间充电给 EN，而不是立刻激活 EN（EN 1.8V 左右）。这时候 DTR RTS 已经稳定了，可以导通 U18 12 引脚来给 NRST 复位了。\n\n\n不过 FlyMcu 实际配置方式是反过来的，因为他的协议是 232（+3~+15 是 0，-3~-15 是 1），和 TTL（3.3v 是1,0v 是0）正相反。\n但是实际操作的时候可能遇到一种状况：部分开发板无法使用 FlyMcu 写入。我就碰到了。解决办法是使用 stm32 cube programmer 烧录程序。\n配置如下：开发板上 boot 连接 3v3，RTS DTR=0，选中 read unprotect，建立连接后再烧录程序。\n但是不知道是波特率或者校验位的问题，我每次能成功烧录进去，然后过一会就显示断开找不到设备了。可能是因为波特率没有76800的选项。\nSTM32 介绍\n\n正点原子网课：单片机和电脑的类比：内存是 SRAM，硬盘是 FLASH，主板是外设。\n\nst：意法半导体公司，SoC 厂商。\nm：微控制器。微控制器和微处理器相比性能比较拉一点，主频低，微处理器能跑一些大 os（linux）。\n32：32位微控制器。\n\n正点原子网课：8051，X86 属于 CISC；ARM, MIPS, RISC-V 属于 RISC.\n\n冯诺依曼和哈佛结构的主要区别：程序存储器和数据存储器是否分开存储。不分开是冯诺依曼，分开是哈佛。哈佛执行效率更高，冯诺伊曼资源占据更少。\nCORTEX-M 系列介绍\nARM 公司（做精简指令集计算机的）只设计内核架构和授权知识产权，不参与设计芯片，给其他合作公司授权设计芯片。半导体厂商再根据架构完善周边电路并制作芯片。现在95%手机、平板都是 ARM 架构的， ARM 公司是真的牛。\n\n其优点在于低功耗低成本高性能，且支持16/32位双指令集。\nARM 有9个版本，从 v6 开始出现 cortex 的命名。\n\n\n随着需求不断发展，stm32 在一众 8/16位 MCU 中脱颖而出。\nstm32 自带许多通信接口，如 spi i2c uart 等；扫地机，无人机，手环等都可以是 stm32 的作品。\n如何选型？以下是几大类 stm32 的特点。\n\n本课程学习使用的开发板命名方式：\n\n选型：满足项目需求的前提下，尽可能选便宜的，比如主频低，功耗低，引脚少，flash 少。\n引脚分配：\n\n看手册的重点：\n\n外设资源，芯片功能，引脚，引脚大致分类，内存，封装……\n哎想起前两天面试被问，如果选型 MCU 我应该看哪些因素。我只想到了外设和内存hhh。属于是只会写代码的笨比了。这也是我开始重新看野火课程的原因之一。\n寄存器\n虽然正式编程没有必要用寄存器编程，通常都是库函数或者 hal 库。但是还是有必要学一下原理的。\n寄存器映射\n芯片视图如下。\n丝印：芯片上印的信息。型号，内核，生产批次等。\n引脚：左上角是有小圆点的，从左上-左下-右下-右上逆时针看。或者如果没有小圆点，把丝印方向摆正，从左上角开始看。\n\n芯片内部组成：\n\n寄存器映射：32位，2^32^=4GB，因此所有程序都需要通过内存 4GB 去映射访问。\n\nblock7：M4 芯片内外设，比如一些通信总线这些都算外设。\nblock1：内存。\nblock0：代码。不过实际上由于设计工艺的问题，block0 block1 都只用了很少的一部分来存代码或者作为内存。\n外设寄存器放在 block2 中。根据不同块速度不一样，又具体分为不同速度的外设（AHB APB）。\n总线速度：AHB&gt;APB2&gt;APB1. APB1 是较低速的外设，包括 I2C UART SPI 看门狗等。\n我们想要操作特定的外设，其实就是控制他的寄存器。控制寄存器就要找到寄存器相应的地址往里面写入数据，寄存器地址就是内存中的地址映射。\n比如 GPIOF 我们想让其端口全部输出高电平。我们查找 stm32f407 手册，发现 GPIOF 的地址是 0x40021400，GPIOF 的 ODR（output data register）相对起始地址的偏移地址是14，则我们需要给 0x40021414 的地址写入数据 0xFFFF.\n\n51 单片机库函数中封装的 reg51.h 中，利用 sfr 定义寄存器地址；而 stm32 库函数中使用宏定义，这些就是寄存器映射操作。对芯片里一个特殊功能的内存单元起别名的过程就是寄存器映射。 给这个地址再分配一个地址交重映射，stm32 中不咋常用。\nC语言对寄存器的封装\n这样逐个地址，哪怕已经进行了寄存器映射，还是很复杂。\nc 语言库函数实际进行的封装操作是使用结构体批量定义。\n/* GPIO 外设基地址 */#define GPIOA_BASE (AHB1PERIPH_BASE + 0x0000)#define GPIOB_BASE (AHB1PERIPH_BASE + 0x0400)#define GPIOC_BASE (AHB1PERIPH_BASE + 0x0800)#define GPIOD_BASE (AHB1PERIPH_BASE + 0x0C00)#define GPIOE_BASE (AHB1PERIPH_BASE + 0x1000)#define GPIOF_BASE (AHB1PERIPH_BASE + 0x1400)#define GPIOG_BASE (AHB1PERIPH_BASE + 0x1800)#define GPIOH_BASE (AHB1PERIPH_BASE + 0x1C00)/* GPIO 寄存器列表 */typedef struct &#123;    uint32_t MODER; /*GPIO 模式寄存器 地址偏移: 0x00 */    uint32_t OTYPER; /*GPIO 输出类型寄存器 地址偏移: 0x04 */    uint32_t OSPEEDR; /*GPIO 输出速度寄存器 地址偏移: 0x08 */    uint32_t PUPDR; /*GPIO 上拉/下拉寄存器 地址偏移: 0x0C */    uint32_t IDR; /*GPIO 输入数据寄存器 地址偏移: 0x10 */    uint32_t ODR; /*GPIO 输出数据寄存器 地址偏移: 0x14 */    uint16_t BSRRL; /*GPIO 置位/复位寄存器低 16 位部分 地址偏移: 0x18 */    uint16_t BSRRH; /*GPIO 置位/复位寄存器高 16 位部分 地址偏移: 0x1A */    uint32_t LCKR; /*GPIO 配置锁定寄存器 地址偏移: 0x1C */\tuint32_t AFR[2]; /*GPIO 复用功能配置寄存器 地址偏移: 0x20-0x24 */&#125; GPIO_TypeDef;/* 使用 GPIO_TypeDef 把地址强制转换成指针 */#define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)#define GPIOB ((GPIO_TypeDef *) GPIOB_BASE)#define GPIOC ((GPIO_TypeDef *) GPIOC_BASE)#define GPIOD ((GPIO_TypeDef *) GPIOD_BASE)#define GPIOE ((GPIO_TypeDef *) GPIOE_BASE)#define GPIOF ((GPIO_TypeDef *) GPIOF_BASE)#define GPIOG ((GPIO_TypeDef *) GPIOG_BASE)#define GPIOH ((GPIO_TypeDef *) GPIOH_BASE)\n所有外设都是如此，首先定义总线 APB AHB 地址，然后每个外设在其基础上进行偏移，每个外设的不同部分再在该外设基址上进行偏移。\n新建工程\n寄存器方式\n要命啊，一看名字我就不想试。寄存器新建不得麻烦死。\n哎算了为了学习原理，干了。\n我们尝试自己写一个寄存器的库函数来引用。\n首先我们需要引用 st 官方启动文件 stmf4xx.s，具体用途后面章节再展开讲解。然后我们自己新建一个 stm32f4xx.h 文件来映射寄存器。不过只是把这个文件包含进项目，编译会报错：\n.\\Objects\\led_reg.axf: Error: L6218E: Undefined symbol SystemInit (referred from startup_stm32f40xx.o).\n进入启动文件后，可以看到这么一个函数：\n; Reset handlerReset_Handler    PROC                 EXPORT  Reset_Handler             [WEAK]        IMPORT  SystemInit        IMPORT  __main                 LDR     R0, =SystemInit                 BLX     R0                 LDR     R0, =__main                 BX      R0                 ENDP\nimport 的作用相当于 extern，所以没有找到这个函数的定义，需要我们自己去定义。这就是为什么简单引入了启动文件会报错。\n而 __main 是当我们定义了 main() 函数后，编译器会自动链接一些c语言库定义好的函数，用于初始化堆栈并且调用我们的 main().\n注意，如果想要生成 __main 函数，必须勾选下面这一项。\n\n野火你讲的是真好啊。我之前草草学了学 stm32 单片机用法，比赛的时候自己想移植代码，改了启动文件也不好使，就是报错。原来是这个原因。\n那么我们只需要定义这么一个函数，哪怕内容是空都无所谓。\n最终我们定义的初步项目框架如下：\n\nstm32f4xx.h：内容为空，有这么个东西就行。\nmain.c：\n#include &quot;stm32f4xx.h&quot;int main()&#123;\twhile(1)&#123;\t\t\t&#125;&#125;void SystemInit()&#123;\t&#125;\n好了，这个程序可以烧录到板子上的。烧录成功之后没有任何反应（因为本来程序也没做什么哈哈），但是这就是一个大进步了。\n点灯——51单片机版\n51单片机版就是引用 reg51.h 头文件，在其中声明了各个引脚的地址。我们只需要直接给引脚赋值即可。\n调用代码：\n#include &quot;reg51.h&quot;#ifdef 0 void main()&#123;\tPA0=0xFE;\twhile(1)&#123;&#125;&#125;#endif\n接下来我们需要定义 LED 灯的寄存器位置。阅读原理图如下：\n\n大致可以看出，板子上的这个 RGB LED 通过三个引脚来控制 RGB 亮度。输出低电平则导通点亮。\n具体输出方式是通过 ODR 进行输出。查找 stm32f4xx 中文参考手册可见：\n\n\n那么我们就要给 0x4002 1400 +14 的地址赋值，让 1&lt;&lt;6 1&lt;&lt;7 1&lt;&lt;8 的位分别赋值为低电平.\nint main()&#123;\t *(unsigned int *)(0x40021400+14)&amp;=~(1&lt;&lt;6); \twhile(1)&#123;\t\t\t&#125;&#125;\n然而这样也不亮。亮就怪了，stm32 寄存器是需要先做初始化配置的。\n点灯——stm32 版\n首先我们要设置 GPIO 模式。\n\n想点灯 输出高低电平，是 01 通用输出模式。\n*(unsigned int *)(0x40021400+0)&amp;=~(3&lt;&lt;(6*2)); *(unsigned int *)(0x40021400+0)|=(1&lt;&lt;(6*2)); \n意思是先把 PF6 模式位置为00，然后赋值为01通用输出。\n配置完模式之后，还需要配置时钟，stm32 每个外设都需要配置时钟。\n前面提到过 GPIO 是在 AHB1.\n\n\n全部代码如下：\n#include &quot;stm32f4xx.h&quot;int main()&#123;    //RCC    *(unsigned int *)(0x40023800+0x30)|=(1&lt;&lt;5);         //Mode    *(unsigned int *)(0x40021400+0)&amp;=~(3&lt;&lt;(6*2));     *(unsigned int *)(0x40021400+0)|=(1&lt;&lt;(6*2));             *(unsigned int *)(0x40021400+0x14)&amp;=~(1&lt;&lt;6);     while(1)&#123;\t\t\t&#125;&#125;void SystemInit()&#123;\t&#125;\n接下来，我们把这几个地址值提取出来，宏定义映射寄存器。\n//stm32f4xx.h/* 用来存放寄存器映射相关的代码 */#define RCC_AHB1_ENR    *(unsigned int *)(0x40023800+0x30)#define GPIOF_MODER     *(unsigned int *)(0x40021400+0)#define GPIOF_ODR       *(unsigned int *)(0x40021400+0x14)//main.c#include &quot;stm32f4xx.h&quot;int main()&#123;    //RCC    RCC_AHB1_ENR|=(1&lt;&lt;5);         //Mode    GPIOF_MODER&amp;=~(3&lt;&lt;(6*2));     GPIOF_MODER|=(1&lt;&lt;(6*2));             GPIOF_ODR&amp;=~(1&lt;&lt;6);     while(1)&#123;\t\t\t&#125;&#125;void SystemInit()&#123;\t&#125;\n点灯——流水灯闪烁\n利用软件延时实现 RGB 流水灯闪烁。很简单，前面已经看了3个 LED 通道 PF678 了。\n#include &quot;stm32f4xx.h&quot;void delay_ms(int time);int main()&#123;    //RCC    RCC_AHB1_ENR|=(1&lt;&lt;5);         //Mode    GPIOF_MODER&amp;=~(3&lt;&lt;(6*2));     GPIOF_MODER|=(1&lt;&lt;(6*2));     GPIOF_MODER&amp;=~(3&lt;&lt;(7*2));     GPIOF_MODER|=(1&lt;&lt;(7*2));     GPIOF_MODER&amp;=~(3&lt;&lt;(8*2));       GPIOF_MODER|=(1&lt;&lt;(8*2));         while(1)&#123;        GPIOF_ODR|=(7&lt;&lt;6);        GPIOF_ODR&amp;=~(1&lt;&lt;6);        delay_ms(1000);        GPIOF_ODR|=(7&lt;&lt;6);        GPIOF_ODR&amp;=~(1&lt;&lt;7);         delay_ms(1000);        GPIOF_ODR|=(7&lt;&lt;6);        GPIOF_ODR&amp;=~(1&lt;&lt;8);        delay_ms(1000);\t&#125;&#125;void SystemInit()&#123;\t&#125;//毫秒级的延时void delay_ms(int time)&#123;       int i=0;     while(time--)   &#123;      i=4000;      while(i--) ;       &#125;&#125;\n点灯——GPIO 具体功能框图对应\nGPIO：通用输入输出引脚。我们可以通过编程来输出或者读取数据。大部分 GPIO 是已经连接、定义好了一些功能（比如上面尝试过的 PF6 LED），有的引脚有多个功能支持重新映射。\nSTM32 GPIO 除了 adc 是 3.3v，其他 GPIO 都是 5v 容忍。\nGPIO 框图（重点）如下：\n\n先从输出开始看。最右侧的 IO 引脚是连接在芯片周围一圈的144个引脚之一。除了 IO 引脚，此图中其他所有部分都是封装在芯片内部我们看不到的。\n往左有两个保护二极管。当电压大于 5V，电流会往上 VDD_FT 走。当电压为负电压，电流会由 VSS 往 IO 引脚走。\n上下拉电阻：比武外接一个低电平工作的设备，但是我们不希望一上电外设就工作，可以设置上拉电阻，稳定一段时间。\nGPIO 输出的数据来源：复位寄存器 BSRR，或者 ODR 设置（图中的3下路部分）。复位寄存器高16位复位（写1置0）低16位置位（写1置1），置位优先级更高。\n配置 GPIO 模式（输入/输出，选择哪一路）通过前面用过的 MODER 配置。\n输出模式（图中输出控制部分）配置端口输出类型寄存器 OTYPER，比如推挽输出，开漏输出。\n推挽输出：有直接驱动能力，输出0就是低电平，输出1就输出可以工作的高电平。原理是采用了一个放大的电路？\n\n输入（INT）为高电平时，反向后 PMOS 导通，输出高电平。输入为低电平时，反向后 NMOS 导通，输出低电平。我们可以用一个小电流去驱动出来一个大电流。\n开漏输出：自己本身没有输出高电平的手段。低电平可以接地，高电平没有 PMOS 管，是浮空状态。需要外接一个电阻。\n\nstm32 输出 5V 电压的方法就是开漏输出外接电阻。通过接两个三极管的方式反向。\n\n框图中的模拟部分输入输出则不用配置这些模式信息，直接由外设接到保护二极管再接到输出引脚。\n框图中的输入部分经过保护电压后，还需要施密特触发器调整一下。比如原来电压的数值并非精确的0或 3.3V，施密特触发器将高于 1.8V 的全部视作1，低于的全部视作0后输入芯片。模拟部分则不需要经过施密特触发器。\n因此配置 GPIO 输出的步骤如下：\n\nGPIO 功能，通用输出、复用功能、模拟输入等 MODER；\n输出推挽 or 开漏 OTYPER；\n输出速度 OSPEEDR；\n上下拉电阻是否需要开启 PUPDR；\n具体输出内容 BSRR or ODR.\n\n输入部分后面输入实验介绍~\n按整个流程重新串一遍代码，如下：（其实和前面差不多，就是重新按照流程串了一遍）\n/* 用来存放寄存器映射相关的代码 */#define RCC_BASE    (unsigned int *)    0x40023800#define GPIOF_BASE  (unsigned int *)    0x40021400    #define RCC_AHB1ENR         *(RCC_BASE+0x30)    #define GPIOF_MODER         *(GPIOF_BASE+0x00)#define GPIOF_OSPEEDR       *(GPIOF_BASE+0x08)#define GPIOF_PUPDR         *(GPIOF_BASE+0x0C)#define GPIOF_ODR           *(GPIOF_BASE+0x14)#define GPIOF_BSRR          *(GPIOF_BASE+0x18)//main.c#include &quot;stm32f4xx.h&quot;int main()&#123;    RCC_AHB1ENR |= (1&lt;&lt;5);    GPIOF_MODER &amp;= ~(3&lt;&lt;(6*2));    GPIOF_MODER |= (1&lt;&lt;(6*2));    while (1)    &#123;    &#125;&#125;void SystemInit()&#123;&#125;\n烧录前记得勾选：use MicroLib.\n构建库方式\n点灯——自己尝试构建库函数版\n寄存器方法了解到这里就好，野火课程主要是库函数写代码。首先我们自己尝试构建一下库函数。\n还是基于上次实验代码修改即可。首先对 .h 文件做一些修改：\n#ifndef __STM32F4XX_H__#define __STM32F4XX_H__#endif\n这个是防止多次引用头文件重复定义。\n然后，像之前一条条定义太麻烦了。其实我们注意到每个寄存器都是4字节，我们可以用固定大小的结构体定义。比如 GPIO ABCDEF 结构都一样，我们只需要统一定义结构体和各自的基址即可。\n#include&lt;stdint.h&gt;\t// 包含了 uint32_t uint16_t/* GPIO寄存器列表 */typedef struct&#123;    uint32_t MODER;    /*GPIO模式寄存器\t\t\t\t\t\t地址偏移: 0x00      */    uint32_t OTYPER;   /*GPIO输出类型寄存器\t\t\t\t地址偏移: 0x04      */    uint32_t OSPEEDR;  /*GPIO输出速度寄存器\t\t\t\t地址偏移: 0x08      */    uint32_t PUPDR;    /*GPIO上拉/下拉寄存器\t\t\t地址偏移: 0x0C      \t\t*/    uint32_t IDR;      /*GPIO输入数据寄存器\t\t\t\t地址偏移: 0x10      \t\t*/    uint32_t ODR;      /*GPIO输出数据寄存器\t\t\t\t地址偏移: 0x14      \t\t*/    uint16_t BSRRL;    /*GPIO置位/复位寄存器 低16位部分\t地址偏移: 0x18 \t*/    uint16_t BSRRH;    /*GPIO置位/复位寄存器 高16位部分\t地址偏移: 0x1A  */    uint32_t LCKR;     /*GPIO配置锁定寄存器\t\t\t\t地址偏移: 0x1C      */    uint32_t AFR[2];   /*GPIO复用功能配置寄存器\t\t地址偏移: 0x20-0x24 \t\t*/&#125; GPIO_TypeDef;# define GPIOF ((GPIO_TypeDef *)GPIOF_BASE)\nmain.c 中可以把对应寄存器替换为 GPIOF-&gt;寄存器名了。\n然后我们直接对寄存器做操作，还是有点直接了，最好是我们不需要关注寄存器有哪些，直接调用一个 GPIO 设置函数即可使用，封装性可移植性都会好很多。\n//stm32f4xx_gpio.cvoid GPIO_SetBits(GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin)&#123;    GPIOx-&gt;BSRRL=GPIO_Pin;&#125;void GPIO_ResetBits(GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin)&#123;    GPIOx-&gt;BSRRH=GPIO_Pin;&#125;//stm32f4xx_gpio.h#include &quot;stm32f4xx.h&quot;#ifndef __STM32F4XX_GPIO_H__#define __STM32F4XX_GPIO_H__void GPIO_SetBits(GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin);void GPIO_ResetBits(GPIO_TypeDef * GPIOx, uint16_t GPIO_Pin);#endif\n比如首先我们简单写了这样一个置位函数，使用方法为 GPIO_SetBits(GPIOF_Base,1&lt;&lt;6) .\n以及我们可以在 stm32f4xx_gpio.h 里批量定义：\n#define GPIO_Pin_6          (uint16_t)(1&lt;&lt;6)#define GPIO_Pin_7          (uint16_t)(1&lt;&lt;7)#define GPIO_Pin_8          (uint16_t)(1&lt;&lt;8)\n这样 GPIO 使用用 Set Reset 函数已经非常规范了。那么初始化操作我们也可以封装成一个函数。\n初始化需要设置 MODER PUPDR OSPEEDR OTYPER，我们可以定义一个结构体用于存储这些初始化变量，初始化的时候新建一个这样的结构体并赋值，传入初始化函数。\n//stm32f4xx_gpio.h//每个模块具体的值可以定义一个枚举类型。typedef enum&#123;    GPIO_Mode_IN=0x00;    GPIO_Mode_OUT=0x01;    GPIO_Mode_AF=0x02;    GPIO_Mode_AN=0x03;&#125;GPIOMode_TypeDef;typedef struct&#123;    uint16_t GPIO_Pin;    GPIOMode_TypeDef MODER;    GPIOPuPd_TypeDef PUPDR;    GPIOOType_TypeDef OTYPER;    GPIOOSpeed_TypeDef OSPEEDR;&#125;GPIO_InitTypeDef;\n具体使用的时候首先我们初始化一个 GPIO_InitTypeDef 变量，并且给其中的每一个子元素都赋值。然后传入 GPIO_Init 函数中，里面就是一系列根据手册而来的位操作，这里我感觉前面原理懂差不多就不用非跟着敲了。\n分析 stm32 固件库函数\n前面基本上都是了解固件库编程，从51过渡到 stm32. 后面所有固件编程固件库的使用方法都和前面的 GPIO 类似。\n固件是什么？其实就是程序，固化到 EEPROM 或 FLASH 中，操作最底层的设备。不是具体的应用，而是只操作最底层的设备。比如点灯算应用，给应用工程师提供库函数的工作是固件工程师的。\nstm32 官方 stmf4 固件库下载地址：\nSTM32标准外设软件库: 相关产品\n\n$ lsMode                 LastWriteTime         Length Name----                 -------------         ------ ----d-----         2023/11/8     22:16                Librariesd-----         2023/11/8     22:16                Projectd-----         2023/11/8     22:17                Utilitiesd-----         2023/11/8     22:17                _htmresc-ar---         2023/11/8     22:15          88007 Package_license.html-ar---         2023/11/8     22:15          19611 Package_license.md-ar---         2023/11/8     22:15         152599 Release_Notes.html-ar---         2023/11/8     22:15       37185187 stm32f4xx_dsp_stdperiph_lib_um.chm\n.chm：使用帮助文档。\n.html .md：一些版本更新，包许可证相关信息。\nUtilities：一些第三方其他软件。\nProject：样例，模板。\nLibraries：库，CMSIS 是一些 ARM 公司的标准，Driver 是固件。inc 是头文件，src 是c文件。\n我们根据上节课写的项目来进行库函数文件功能分析。\n\n\n\n文件名\n所属类别\n功能\n\n\n\n\nstartup_stm32f40xx.s\n片上外设\n汇编启动文件\n\n\nstm32f4xx.h\n片上外设\n外设寄存器映射\n\n\nsystem_stm32f4xx.c / system_stm32f4xx.h\n片上外设\n初始化系统时钟\n\n\nstm32f4xx_xxxx.c / stm32f4xx_xxxx.h\n内核\n内核寄存器映射\n\n\ncore_cm4.h\n内核\n内核寄存器映射\n\n\ncore_cmFunc.h / core_cmSimd.h\n内核\n内核外设的一些操作函数\n\n\nmisc.c / misc.h\n内核\n中断相关函数（优先级分组，系统中断）\n\n\nstm32f4xx_it.c / stm32f4xx_it.h\n内核\n中断服务函数（所有中断入口）\n\n\nmain.c\n\nmain 函数\n\n\n\n\nstartupxxxx.s：启动文件。\nstm32f4xx.h：外设寄存器映射。\n跳到 system_Init 函数，这个函数当时我们为了执行只写了一个空函数，而 stm32 官方固件库模板里面是有的，在 system_stm32f4xx.c 里，初始化系统时钟。\nstm32f4xx.c：具体外设驱动，比如上节课写的 gpio。\ncore_cm4.h：内核寄存器映射。\nmisc：中断。\n\n构建库函数\n创建一个通用的模板，后面写程序直接使用这个模板。\n$ lsMode                 LastWriteTime         Length Name----                 -------------         ------ ----d-----         2023/11/8     23:27                Librariesd-----         2023/11/8     23:27                Listingd-----         2023/11/8     23:27                Outputd-----         2023/11/8     23:27                Projectd-----         2023/11/8     23:27                User-a----         2020/2/27     13:45            401 keilkill.bat\n前面都是新建的文件夹，keilkill.bat 是从 keil 编译程序中复制出来的一个脚本，可以删掉中间文件。\n把固件库 Lib 里的 CMSIS 和 Driver 文件拷贝到 Libraries 文件夹中。CMSIS 中只保留 Device Include 文件夹。Device 中包含外设相关（比如 stm32f4xx.h system_stm32f4xx），Include 中只包含内核相关。\n把 main.c stm32f4xx_it.c / stm32f4xx_it.h stm32f4xx_conf.h 拷贝到 User 文件夹中。\n在 Project 文件夹里可以包含多给项目文件，不光只有 Keil 的。比如 IAR 的我们新建一个 IAR 文件夹，Keil 我们新建一个 RVMDK(uv5) 文件夹。RealView 是包含不止 MDK 的开发工具集合的称呼，MDK 是 MCU 开发工具集成包，uVersion 是 IDE，Keil 是公司名字。\nuVision 里新建工程，新建在 RVMDK(uv5) 文件夹下。\n新建组、添加文件如下：\n\nSTM32F4xx_StdPeriph_Driver 添加 STM32F4xx_StdPeriph_Driver/src 下的所有文件，屏蔽掉 dma2d fmc ltdc，后两个是 sd 和 lcd 屏幕组件。\n头文件如下：\n\n宏定义如下：\nUSE_STDPERIPH_DRIVER,STM32F40_41xxx\n我现在好想明白为什么宏定义在这里了，这样后面换单片机型号的时候可以直接修改这个宏定义。\nPS：我下载的是 1.8.1 版本 stm32f4xx.h 库函数，里面出现了一段重复定义导致编译产生了200多个 warning。我把下面那一段删掉了就好了。\n\nOutput 里设置 Output 文件夹，不然都在 Proj 里太乱。\n记得勾选 MicroLib。\n点灯——官方库函数版\n在 User 文件夹中新建 LED 文件夹，里面新建 bsp_led.c，代表板级支持包 LED 代码，也就是只针对我们当前这一款开发板的点灯程序。\n\n\n设置时钟：rcc 时钟，在 stm32f4xx_rcc.c 中：\n\n\n/**\n  * @brief  Enables or disables the AHB1 peripheral clock.\n  * @note   After reset, the peripheral clock (used for registers read/write access)\n  *         is disabled and the application software has to enable this clock before \n  *         using it.   \n  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.\n  *          This parameter can be any combination of the following values:\n  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock\n  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock \n  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock\n  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock\n  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock\n  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock\n  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock\n  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock\n  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock\n  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) \n  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  \n  *            @arg RCC_AHB1Periph_CRC:         CRC clock\n  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock\n  *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock\n  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock\n  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock\n  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  \n  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock\n  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock\n  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock\n  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock\n  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock\n  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock\n  * @param  NewState: new state of the specified peripheral clock.\n  *          This parameter can be: ENABLE or DISABLE.\n  * @retval None\n  */\nvoid RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)\n其他部分基本也是参照库函数（主要是 stm32f4xx_gpio.h）最终呈现如下：```c#include &quot;bsp_led.h&quot;void LED_GPIO_Config(void)&#123;    //RCC set function in stm32f4xx_rcc.h    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);    &#123;        //Init structure        GPIO_InitTypeDef GPIO_InitStructure;        GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;        GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;        GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;        GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;        GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;        //init function        GPIO_Init(GPIOF,&amp;GPIO_InitStructure);    &#125;    &#125;\n\n置位可以使用 `GPIO_SetBits` 或 `GPIO_ResetBits`。\n\nint main()&#123;    int i;    LED_GPIO_Config();            *(unsigned int *)(0x40021400+0x14)&amp;=~(1&lt;&lt;6);   while (1)  &#123;      GPIO_ResetBits(GPIOF,GPIO_Pin_6);      i=12000000;      while(i--);      GPIO_SetBits(GPIOF,GPIO_Pin_6);      i=12000000;      while(i--);  &#125;&#125;\n\n没有上下拉的时候推挽输出会直接被 ODR 值所影响，哪怕没有赋值其中本来的值也会影响。所以推挽输出无上下拉，不置位 LED 也会被点亮，因为 ODR 默认值0.\n\n\n\n\n输入——按键点灯\n开发板按键电路如下：\n\n按键未按下接地，按下后为高电平。电容起到消抖作用，软件处理就不需要手动延时消抖了。\n编程没啥难度，就是改了一下输入模式。使用 ReadInputDataBits 读取。\n//bsp_button.c#include &quot;bsp_button.h&quot;void Button_GPIO_Config(void)&#123;    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);    &#123;        GPIO_InitTypeDef GPIOInitStruct;        GPIOInitStruct.GPIO_Mode=GPIO_Mode_IN;        GPIOInitStruct.GPIO_Pin=GPIO_Pin_0;        GPIOInitStruct.GPIO_OType=GPIO_OType_PP;        GPIOInitStruct.GPIO_Speed=GPIO_Speed_50MHz;        GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;                GPIO_Init(GPIOA,&amp;GPIOInitStruct);    &#125;&#125;//main.c#include &quot;stm32f4xx.h&quot;#include &quot;bsp_led.h&quot;#include &quot;bsp_button.h&quot;int main()&#123;    //RCC    LED_GPIO_Config();    Button_GPIO_Config();    while (1)    &#123;        if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0))GPIO_SetBits(GPIOF, GPIO_Pin_6);        else GPIO_ResetBits(GPIOF, GPIO_Pin_6);    &#125;&#125;\n实现按键按下后翻转：\nint main()&#123;    //RCC    LED_GPIO_Config();    Button_GPIO_Config();    while (1)    &#123;        if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET)&#123;            while(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET);            GPIO_ToggleBits(GPIOF, GPIO_Pin_6);        &#125;    &#125;&#125;\n要等到按键松开的时候再翻转，轮询直到松开。\n位带操作\n之前51单片机常见位定义。比如 PA 引脚有8个 IO 口，我们可以定义 sbit LED1=PA^0 这样单独操作某一位。\nstm32 里没有直接的位定义方式。一种解决办法是我们利用与或操作不影响其他位的同时操作特定位；另一种就是位带操作。\nstm32 里有一部分别名区域，用于映射外设、SRAM 中特定的位带区，我们操作这一部分别名区域时就可以实现对外设、SRAM 位带区与的位操作。\n片上外设位带区：0X4000 0000~0X400F 0000，别名区：0X4200 0000~0X43FF FFFF，包含 APB12，AHB1 外设。\nSRAM 位带区：0X2000 0000~0X200F 0000，别名区：0X2200 0000~0X23FF FFFF\n\n外设地址 A 别名地址为：AliasAddr= =0x42000000+ (A-0x40000000)84 +n*4  （n是位序号）\nSRAM 地址 A 别名地址为：AliasAddr= =0x22000000+ (A-0x20000000)84 +n*4\n扩大了32倍，可以对32位寄存器中的每一位进行操作。\n统一公式：\\#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))\n使用：比如我们操作一个 GPIO 的位操作。\n#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))// 把一个地址转换成一个指针#define MEM_ADDR(addr) *((volatile unsigned long *)(addr))// 把位带别名区地址转换成指针#define BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))// GPIO ODR 和 IDR 寄存器地址映射#define GPIOF_ODR_Addr (GPIOF_BASE+20)#define GPIOF_IDR_Addr (GPIOF_BASE+16)// 单独操作 GPIO 的某一个 IO 口，n(0,1,2...15),// n 表示具体是哪一个 IO 口#define PFout(n) BIT_ADDR(GPIOF_ODR_Addr,n) //输出#define PFin(n) BIT_ADDR(GPIOF_IDR_Addr,n) //输入//使用示例PFout(6)= 0;\n这个概念学学就好，好像实际应用没啥意义。我们微处理器考试也考过hh。\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["C"]},{"title":"技术学习：吴恩达机器学习","url":"/2025/05/31/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%90%B4%E6%81%A9%E8%BE%BE%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"前言\n学习自 Coursera 的吴恩达老师机器学习系列。https://www.coursera.org/specializations/machine-learning-introduction\n机器学习定义\n计算机不经过明确编程的情况下进行学习的研究领域。比如相比直接编程告诉计算机怎么下棋更容易取胜，让计算机自己经过多次尝试总结形成一个具有较高胜率的下棋模型，每一步自行预测下一步棋怎么走让最终胜率更大。\n\n[!NOTE]\n在 KCL 机器学习笔记中我们学习过：推理（Inference）和学习（Learning）的区别。推理是已知模型和对应的概率（现实生活中很少），而学习是不知道对应的模型和概率需要统计数据训练得到一个近似值。比如投硬币，我们统计了 100 次投硬币概率，30 次正面 70 次反面，那么学习结果就是 0.3 概率正面。\n\n监督学习\n给定输入 x 和有标签标注的输出 y，如对于天气预报机器学习案例：（昨天有鱼鳞状云，今天下雨）这样一条数据，昨天的云是输入数据 x，今天下雨是输出 y（知道确切的结果），让计算机由输入到输出的映射训练模型。再比如：输入是一栋房子的基本信息（几室几厅，面积……）输出是其价格。\n监督学习主要分为两种：\n\n回归问题（Regression）：从无限多的数字中预测一个数字，如房价推测。\n分类问题（Classification）：如判断这张图片里的动物是猫还是狗，明天是否下雨，预测结果有限可确定。比如可能 0 代表照片里动物是猫，1 代表是狗，2 代表是老鼠……\n\n无监督学习\n没有对应的有标注的输出 y。比如找到一些潜在的分类（把现有用户分为几种，分类之前我们并不知道有哪些最终的用户类，是计算机帮我们划分的）。这叫做聚类（Clustering）。除此之外的应用还有异常情况检测，新闻关键词组合提取等。\n线性回归模型\n\n[!NOTE]\n模型，就是机器学习算法所需要的最终产物。通过数据和算法得到。比如 DeepSeek 模型，GPT 模型。使用模型很简单其实，我们不需要关心模型内部原理，就像一个黑盒子，我们只要输入数据进去得到输出数据就好。不过这门课程我们主要学习“训练模型的过程”，了解学习原理。\n\n线性回归模型是一种非常基础的回归模型。比如根据输入数据（房子面积）预测输出数据（房价）公式：y = 20000x+100000（我瞎写的）这就是一个简单的线性回归模型。\n简化版训练过程\n线性回归模型训练过程（无敌简化版）：\n\n首先我们有一个训练数据集，里面只有两条数据（0,100000）和（2,140000）。训练数据集数据总数一般用 m 表示。\n线性回归模型我们设置成 y=wx+b，w 一般用于表示模型参数，b 表示线性回归模型后面加的常量。\n带入数据，得到 w = 20000，b = 100000. 完成训练。得到的模型用 f_wb 表示。\n\n代价函数\n不过，一般真实数据都不是那么有规律的，我们的模型并非可以完美拟合（fit）所有数据点。比如下面这个情况。\n\n这些红叉数据点就不在一条直线上，我们怎么可能找到一个完美拟合的线性回归模型经过他们全部呢，做不到。只能尽可能找到一个线性回归模型让这些点离我们模型的偏差尽量小一些。\n这就引入了一个机器学习重要概念：代价（cost）也就是我们的模型预测值和真实值的偏差。对于单个数据点偏差一般用损失（loss）表示，比如我预测这栋有 100m^2 的房子房价是 100 万元，实际价格是 110 万元。而代价一般是形容模型整体，所有预测数据和所有训练数据的偏差。\n一种成本函数计算公式（成本函数有很多很多选择，就像模型一样，我们也可以不选线性回归模型学习问题）：\n$$\nJ(w, b)=\\frac{1}{2m}\\sum^{m}_{i = 1}(f_{w, b}(x^{(i)})-y^{(i)})^2\n$$\n$y^{(i)}$ 是第 i 个训练数据的输出（110 万真实房价），$f_{w,b}(x^{(i)})$ 是将第 i 个训练数据输入带入我们的模型得到的预测输出（100 万预测房价）。我们的模型预测目标就是找到合适的模型参数 w，b 让代价函数最小化。\n\n[!NOTE]\n这里前面的参数为什么是 1/2m，因为后续我们要求导来找到让代价函数下降最快的方式，求导的时候就会把 2 约掉，计算更简洁。\n\n下图是一个代价函数可视化案例：\n\n对于这个例子我们要找到的代价函数最小值点就是中间那个凹进去的地方对吧。\n另一种绘制方式是这样的等高线图：\n\n梯度下降\n根据当前训练数据，通过求偏导更新 w，b 让代价函数下降最快（Gradient Descent）。\n计算公式：\n$$\nw = w-\\alpha \\frac{d}{dw}J(w, b)=\\frac{1}{m}\\sum^{m}_{i = 1}(f_{w, b}(x^{(i)})-y^{(i)})x^{(i)}\\\\\nb = b-\\alpha \\frac{d}{db}J(w, b)=\\frac{1}{m}\\sum^{m}_{i = 1}(f_{w, b}(x^{(i)})-y^{(i)})\n$$\nα 是学习率，α 越大每一轮学习的时候我们根据上一轮的代价函数所做的调整就越大。\nα 太小的话，会导致需要很多轮才能找到一个比较靠近极小值的模型：\n\nα 太大有可能总是“迈步迈过头”到达不了极小值点。\n\n另外，一个学习问题可能会有多个局部极小值点。选择不恰当大小的学习率也会导致无法到达最小值。\n\n下图是一个梯度下降参数可视化：\n\n\n[!NOTE]\n另外，每轮学习的时候我们可能会只选取部分训练数据进行迭代更新或者全部数据。如果每次都用全部数据计算代价函数，叫做批梯度下降（Batch Gradient Descent BGD）.\n卷积神经网络（CNN）训练不会每次都看整个图像数据，每次只会取出一部分。这样可以加快计算速度而且更不容易出现过拟合。\n\n\n[!TIP]\n老师提出的一种寻找学习率的方式：\n如 0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1, 3, …\n此外，还可以使用 Adam 算法寻找合适的学习率。原理上和自己试应该差不多，从小到大试，loss 快速下降时停止增加学习率。\n\n多维度特征\n特征（features）指的就是输入数据多维度的参数，比如：如果只根据房屋面积计算房屋价格，特征就只有一个就是面积。如果根据房屋面积，几室几厅，楼层数，房屋年龄等作为输入数据，就是多特征学习。\n我们用 n 表示特征总数，那么输入数据其实就是一个 m*n 的矩阵，m 表示有 m 条数据，n 表示每条数据里面有 n 个特征。$x_j^{(i)}$ 表示第 i 条数据的第 j 个属性。\n同时模型参数也会改变，$w=[w_1, w_2, … w_n]$ 和 $x^{(i)}$ 进行向量乘法得到一个标量数据，再和标量 b 求和得到预测结果。\n$$\nf_{w, b}(\\mathbf{x}) = \\mathbf{w}\\cdot \\mathbf{x} +b = w_1 x_1 + w_2 x_2 + \\cdots + w_n x_n + b\n$$\n在 python 代码实现中，不需要手动循环相乘求和，可以使用 numpy 库：\nw = np.array([1, 2.5, -3.3])b = 4x = np.array([10, 20, 30])f = np.dot(w,x)+b\n而且计算机底层会使用带有矢量化的计算机硬件实现，并行加速计算。\n同长度向量可以直接做减法。\nw = w - 0.1 * b\n\n[!NOTE]\n如果特征量太大，使用正态方程法可以快速求解 w，b。但是这种方法几乎只适用于线性回归学习方法。\n\n\n[!NOTE]\n有的时候可能还需要我们自行设计特征，比如根据房子长宽推导房子面积，如果使用二维度线性回归模型效果就不会太好，但是如果将长*宽作为一个新维度特征输入的一维线性回归模型训练就会好一些。\n\n特征缩放\n多维度特征尽可能采取范围近似的值，让彼此参数差距不大，否则可能导致梯度下降缓慢。\n\n简单的特征缩放方法就是（每个数据-平均值）/（最大值-最小值）。但是分母可能是 0，而且对异常值敏感。\nz-score normalization 方法是（数据-平均值）/标准差 σ。转换为均值 0，方差 1 的标准正态分布区间。\n梯度下降收敛\n当每轮迭代的梯度下降小于等于收敛值 ε（如 0.001）时，可以称之为收敛。这个时候就可以不用再学习了，再学习的成本与对模型精确度的提升相比不那么合适了。\n扩展到多项式回归\n$$\nf_{\\vec{w}, b}({x}) =\n{w_1} {x} +\n{w_2} {x^2} +\n{w_3}{x^3} +\n{b}\n$$\n分类\n比如：预测一个邮件是否为垃圾邮件，0 false 1 true。\n预测方法：比如线性回归模型得到的结果是 0 到 1 范围内，我们将 0-0.5 视作 0,0.5-1 视作 1.\n不过相比线性回归模型，下面这个回归模型更适合分类问题：\n逻辑回归\n\n首先还是得到一个线性回归模型 $z=wx+b$。\n然后不直接把这个模型作为预测输出，而是将其传入 sigmoid 函数：$g(z)=\\frac{1}{1+e^{-z}}$\n\n为什么用这个函数？因为其范围 0-1，符合我们的分类需求，而且在 0.5 附近斜率比较大，所以更难预测到 0.5 的不确定概率情况。\n\n逻辑回归的损失函数\n不能再使用之前的平方代价函数了，因为转换得到的代价函数并不是一个凸函数（convex，比如 y = x^2 这样的），而可能是一个波浪线状的有多个极小值点的丑陋函数。\n所以要使用下面这个损失函数。\n$$\nL\\left( f_{\\vec{w}, b}(\\vec{x}^{(i)}),\\ y^{(i)} \\right) =\n\\begin{cases}\n-\\log\\left( f_{\\vec{w}, b}(\\vec{x}^{(i)}) \\right), &amp; \\text{if } y^{(i)} = 1 \\\\\n-\\log\\left( 1 - f_{\\vec{w}, b}(\\vec{x}^{(i)}) \\right), &amp; \\text{if } y^{(i)} = 0\n\\end{cases}\\\\\nL\\left( f_{\\vec{w}, b}(\\vec{x}^{(i)}),\\ y^{(i)} \\right) =\n\ny^{(i)} \\log\\left( f_{\\vec{w}, b}(\\vec{x}^{(i)}) \\right)\n(1 - y^{(i)}) \\log\\left( 1 - f_{\\vec{w}, b}(\\vec{x}^{(i)}) \\right)\n$$\n逻辑回归损失函数图像如下：\n\n\ny = 1 预测值 = 0 的时候导数非常大，y = 0 预测值 = 1 的时候导数非常大，促使预测值向另一端靠近。\n相应的代价函数公式：\n$$\n\\begin{aligned}\nJ(\\vec{w}, b) &amp;= \\frac{1}{m} \\sum_{i = 1}^{m}\nL\\left( f_{\\vec{w}, b}(\\vec{x}^{(i)}),\\ y^{(i)} \\right)\\\\\n&amp;= -\\frac{1}{m} \\sum_{i = 1}^{m} \\left[\ny^{(i)} \\log\\left( f_{\\vec{w}, b}(\\vec{x}^{(i)}) \\right)\n\n(1 - y^{(i)}) \\log\\left( 1 - f_{\\vec{w}, b}(\\vec{x}^{(i)}) \\right)\n\\right]\n\\end{aligned}\n$$\n至于梯度下降，公式和之前一样。不过别忘记现在 f 函数的定义不一样了。\n$$\nw = w-\\alpha \\frac{d}{dw}J(w, b)=\\frac{1}{m}\\sum^{m}_{i = 1}(f_{w, b}(x^{(i)})-y^{(i)})x^{(i)}\\\\\nb = b-\\alpha \\frac{d}{db}J(w, b)=\\frac{1}{m}\\sum^{m}_{i = 1}(f_{w, b}(x^{(i)})-y^{(i)})\n$$\n\n过拟合及解决方法\n如下图，左边的模型欠拟合（underfit）因为模型复杂度不够；而右边的模型过拟合（overfit）因为参数太多模型过于复杂了，导致模型能非常好地拟合训练数据，但是对于训练数据之外的数据预测效果不好。\n\n过拟合的解决方式：\n\n增加训练数据量；\n只选择部分对输出数据影响更大的特征作为训练模型的特征，减小模型复杂度；\n模型正交化（Regularization），将模型复杂度也列入代价函数公式中，这样模型过于复杂的时候虽然可以很好地拟合训练数据，代价函数仍然很大。比如加上 $\\frac{\\lambda}{2m}\\sum^{n}_{j=1}w_j^2$ ，λ 是正交化参数。\n\n$$\nJ(w, b)=\\frac{1}{2m}\\sum^{m}_{i = 1}(f_{w, b}(x^{(i)})-y^{(i)})^2+\\frac{\\lambda}{2m}\\sum^{n}_{j = 1}w_j^2\\\\\nw_j = w_j - \\alpha\n\\frac{\\lambda}{m} w_j - \\alpha\n\\frac{1}{m} \\sum_{i = 1}^{m}\n\\left( f_{w, b}(\\vec{x}^{(i)}) - y^{(i)} \\right) x_j^{(i)}\\\\\nb =\\frac{1}{m}\\sum^{m}_{i = 1}(f_{w, b}(x^{(i)})-y^{(i)})\n$$\n对梯度下降的影响其实就是 w 更新的时候前面一项由 wj 变成 (1-αλ/m)wj 了。这个东西 &lt; 1 ，作用是每次迭代都让 wj 尽可能小一些。\n神经网络\n模拟人脑，分为多层对输入数据进行处理，每层有多个神经元，处理完输出给下一层，最后汇总输出。\n在更大数据量或者更复杂的问题上表现更好。\n\n比如人脸识别学习案例：如下图，第一层神经网络可能着重识别边缘部分，第二层神经网络可能着重识别人脸的某一部分比如眼睛鼻子嘴巴，第三层则是匹配对应的整张人脸。\n\n输入数据被称为输入层（input layer），一般不计入总层数。中间的层都叫隐藏层（hidden layer），最后一层叫输出层（output layer）计入总层数，比如上面这个例子是一个 4 层神经网络。\n每个神经元的输入 -&gt; 输出处理函数叫做激活函数（activation function），比如我们可能第一层选用线性回归函数，第二层选用 sigmoid 函数……\n比如假设第三层是 sigmoid 激活函数，第三层有三个神经元，那么第三层就会输出三个特征，第三层输出向量计算公式为：\n$$\na_1^{[3]}= g(\\vec(w)_1^{[3]}\\cdot \\vec{a}^{[2]}+b_1^{[3]})\\\\\na_2^{[3]}= g(\\vec(w)_2^{[3]}\\cdot \\vec{a}^{[2]}+b_2^{[3]})\\\\\na_3^{[3]}= g(\\vec(w)_3^{[3]}\\cdot \\vec{a}^{[2]}+b_3^{[3]})\\\\\n$$\n这里会涉及到一些矩阵乘法的知识。\n例学习问题：输入数据是烘焙咖啡豆温度和时间，输出数据是咖啡豆烘焙结果（刚好或糊了）。\n\n比如在 TensorFlow 中配置模型的步骤如下：\n# 定义模型model = Sequential(    [        tf.keras.Input(shape=(2,)),        Dense(3, activation=&#x27;sigmoid&#x27;, name = &#x27;layer1&#x27;),        Dense(1, activation=&#x27;sigmoid&#x27;, name = &#x27;layer2&#x27;)     ])# 查看每层参数W1, b1 = model.get_layer(&quot;layer1&quot;).get_weights()W2, b2 = model.get_layer(&quot;layer2&quot;).get_weights()# 配置损失函数model.compile(    loss = tf.keras.losses.BinaryCrossentropy(),    optimizer = tf.keras.optimizers.Adam(learning_rate=0.01),)# 自动训练model.fit(    Xt,Yt,                epochs=10, # 用输入数据重复训练10次)# 预测predictions = model.predict(X_testn)\n使用起来非常简单，调库有啥难的？不过重点还是在于原理理解。\n这个例子中，输入数据是 2 维特征的，第一层隐藏层是 3 维的，第二层输出层是 1 维的，我们最终会得到一个预测结果值。\n对于第一层的模型参数：\nW = np.array([    [1, -3,  5],    [2,  4, -6]])b = np.array([-1, 1, 2])     # 偏置项，形状为 (3,)a_in = np.array([-2, 4])     # 输入向量（也记作 a^[0] 或 x），形状为 (2,)\n这样计算完得到的是一个 1*3 形状的矩阵，供第二层输入。\n在 python 中利用 numpy 做向量矩阵快速乘法的实现公式：\ndef g(z):    # 示例激活函数    return 1 / (1 + np.exp(-z))  # Sigmoiddef dense(A_in, W, B):    Z = np.matmul(A_in, W) + B    A_out = g(Z)    return A_out\nReLU 激活函数\n如下图，ReLU 函数公式很简单，输入 &lt;0 时输出=0，输入 &gt; 0 时输出和输入成正比。\n\nsigmoid 函数只有在 0 附近的输入值才能取得比较好的梯度结果，如果输入数据太大了，那么梯度下降特征不明显，可能会造成梯度消失的情况，而且计算复杂；\n以及，ReLU 会使一部分神经元的输出为 0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生。\n最常见的四种激活函数就是：线性激活函数，sigmoid，ReLU，softmax 后面介绍。\n激活函数的选择\n二元分类问题推荐使用 sigmoid，因为最终推导结果介于 0~1 之间。\n回归问题建议使用线性回归激活函数。\n回归问题且输出 &gt; 0 推荐使用 ReLU。\n比如一个二元神经网络问题，采用的激活函数可能是：前两层是 ReLU，最后一层是 Sigmoid。\n此外，隐藏层尽量不要使用线性函数（ReLU 可以用），因为根据公式推导，隐藏层放多个线性回归最后得到的输出也是一个线性回归函数，使得这个神经网络解决不了更加复杂的问题。\n多分类问题\n比如手写数字识别，我们预测的结果介于 0~9 之间。\nsoftmax 常用于解决多分类问题，可以得到多个特征的输出结果。比如对于手写数字识别问题，可能得到的结果是：预测是数字 0 的概率为 0.09,1 的概率是 0.11,2 的概率是……最后选择一个最有可能的结果。\n算法公式：\n$$\nz_j = \\vec{w}_j \\cdot \\vec{x} + b_j, \\quad j = 1, \\dots, N\\\\\na_j = \\frac{e^{z_j}}{\\sum\\limits_{k = 1}^{N} e^{z_k}} = \\mathbb{P}(y = j \\mid \\vec{x})\n$$\n\n所有预测概率加起来 = 1.\n损失函数：\n$$\n\\text{loss}(a_1, \\dots, a_N, y) =\n\\begin{cases}\n-\\log a_1 &amp; \\text{if } y = 1 \\\\\n-\\log a_2 &amp; \\text{if } y = 2 \\\\\n\\quad \\vdots &amp; \\\\\n-\\log a_N &amp; \\text{if } y = N \\\\\n\\end{cases}\n$$\n损失函数只有对应真实值的预测概率 = 1 时 = 0，否则预测正确结果的概率越小，损失值越大。\n在多分类预测问题中，通常使用 softmax 来作为输出层的激活函数。\n改进 softmax 函数\n根据 python 的一些精度特性，如果不是先计算出概率 a 再带入损失函数，而是直接把 z 带入损失函数计算公式，精度更高。\n不要：\n$$\n\\text{Loss} = L(\\vec{a}, y) =\n\\begin{cases}\n-\\log a_1 &amp; \\text{if } y = 1 \\\\\n\\vdots \\\\\n-\\log a_{10} &amp; \\text{if } y = 10 \\\\\n\\end{cases}\n$$\n而是：\n$$\nL(\\vec{z}, y) =\n\\begin{cases}\n-\\log \\left( \\frac{e^{z_1}}{e^{z_1} + \\cdots + e^{z_{10}}} \\right) &amp; \\text{if } y = 1 \\\\\n\\vdots \\\\\n-\\log \\left( \\frac{e^{z_{10}}}{e^{z_1} + \\cdots + e^{z_{10}}} \\right) &amp; \\text{if } y = 10 \\\\\n\\end{cases}\n$$\n在 TensorFlow 中的实现方法应该是：最后一层不再声明为 softmax 层，而是 linear 层，取而代之的是在模型参数设置的时候声明计算逻辑损失。\npreferred_model = Sequential(    [         tf.keras.Input(shape=(2,)),        Dense(25, activation = &#x27;relu&#x27;),        Dense(15, activation = &#x27;relu&#x27;),        Dense(4, activation = &#x27;linear&#x27;)   #&lt;-- Note    ])preferred_model.compile(    loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),  #&lt;-- Note    optimizer=tf.keras.optimizers.Adam(0.001),)\n多标签分类问题\n比如：判断下面这张图片里面有没有汽车？有没有行人？有没有树？\n和多分类问题的区别在于，多分类的结果是互斥的，比如预测出数字应该是 5 就不会是 7 了。\n而多标签分类问题的多个结果可以共存，比如既有树，也有人。\n多标签分类也会得到多个维度的特征，不过类似 sigmoid 单维度处理方式，每个维度的预测值在 0-1 之间，如果 &gt; 0.5 视作 true。比如对有汽车的概率预测为 0.6，有人的概率预测为 0.7，那么就判断这张图片里有人有车。\n反向传播\n说实话有点太难描述，但是这部分十分重要。读者如果感兴趣一定要去学习一下，其实不难，就是求导反推。\n可以快速推导出 w 的变化对最终代价函数 j 的影响。\n机器学习应用问题\nDebug\n如果模型误差很大，下一步怎么做？\n\n获取更多数据。\n减少或者增加特征。\n增加多项式参数。\n调整正则化参数 λ。\n\n评估模型\n如何评估模型性能？通常我们会将输入数据拿出30%作为测试集，其余70%作为训练集。先用训练集训练，然后用测试集和训练集评估误差。\n注意：测试集和训练集评估误差的时候不要加上正交参数，这个时候最小化参数不是我们想要的结果，我们是在评估模型性能。\n如果模型对训练数据表现良好，对测试数据表现差，说明过拟合。\n但其实，测试集仅仅是我们对模型误差的一种“乐观估计”。因为测试集通常来自与训练集相似的分布，而且在整个建模过程中，它是提前准备好的。如果我们在调参过程中频繁查看测试集的表现，实际上已经“间接使用”了测试集的信息。这会导致模型过拟合到测试集本身，最终得出的泛化能力评估并不可靠。\n取而代之的方案是60%数据作为训练集，20%数据作为交叉验证集（Cross Validation），20%数据作为测试集。对于不同模型（如一次线性，二次线性，三次线性……）我们统一用训练集训练，然后用交叉验证集计算代价，注意这里也不要考虑参数正交化项。然后选出交叉验证误差最小的模型。最终我们用测试集评估模型泛化性能。以多项式拟合为例：我们可以用训练集分别训练一次线性、二次多项式、三次多项式等模型，然后在验证集上评估它们的预测误差（此时评估用的 cost 函数不需要包含正则化项），选出在验证集上表现最好的模型。最后，再用测试集来评估这个最终模型在未见数据上的表现。\n比如下面这个学习案例：\n\ndegree = 4 的时候训练集和交叉验证集误差都最小，5变化不大，6开始回升了。所以最佳选择4.\n分类问题和神经网络学习问题同样。\nBias and Variance\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["Machine Learning"]},{"title":"技术学习：瑞萨开发板","url":"/2023/06/24/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%91%9E%E8%90%A8%E5%BC%80%E5%8F%91%E6%9D%BF/","content":"前言\n这回参加的是 csdn 李肯老师的攻城狮计划，简单说就是我白嫖板子，输出学习笔记。\n\n板子是瑞萨的CPK_RA2E1，还有触摸元件，看起来很有意思hh。\n环境搭建\n一开始决定采取vscode搭建的方式。后期进行到最后一步——cmake build的时候一直显示语法错误，肯哥表示是环境配置不全，但是我反反复复根据官网和其他博主的文章检查了不下10遍都不知道问题何在。最终决定还是老老实实用keil。\n\n\nkeil导入瑞萨包。官网下载地址：Arm Keil | Renesas\n\n\n下载rasc软件。对于这个东西我的理解是类似stm32cubemx，可以快速初始化项目的软件。该软件可以在瑞萨官网下载：https://www2.renesas.cn/kr/en/software-tool/ra-smart-configurator\n\n\n接下来我们尝试新建编译一个项目。这是我第一次没有跟着一块有完整开发流程的板子的视频课，而几乎完全是自己检索资料探索尝试的项目构建，因此碰到了很多弯路。首先rasc软件我们新建一个项目。\n\n板子型号这里是根据我的学习板设置的。IDE一定记得改为keil。\n\n\n\n后两页选择 no rtos 和 minimal 即可，因为我们现在的目的只是尝试编译通过一个项目。\n\n\n添加完成后，点击generate code 生成相关的项目代码。然后用keil打开，尝试编译。\n\n\n我第一次遇到的问题是报了19个错。我还以为是pack导入的不对，但是后来搜了一下发现不是那么回事，是编译方式选错了。参考文章：keil出现大量未知语法错误（系统移植）_portforce_inline_IT小生lkc的博客-CSDN博客\n\n\n\n于是我把编译器改为version5，编译到一半，再次报错：error: A3903U: Argument ‘Cortex-M7.fp.sp’ not permitted for option  cpu’.。这个问题原因是因为编译器版本太低，于是我又去下载了新的keil5.\n\n\n再次编译的时候提示我，不能用version5，新版本已经不支持了。于是我又改为version6进行编译。这次非常顺利！\n\n\n\n下载\n终于考完试了，然而攻城狮的截止期限也快到了QAQ，得尽快水（划掉）写几篇文章了！\n先争取可以成功下载一个空的程序。\n先对上一篇文章下载 DFP 也就是 keil MDK Software Packs 做一个补充。我们要下载的是 RA_DFP，下载地址为：Arm Keil | Renesas RA_DFP\n至于版本我看到有前辈使用 3.5.0 的版本可以成功运行，而我下载的是4+的版本也可以。只不过在选择 device 的时候会有一点不同：\n\n可以看到 4.1.0 的版本无法细化选择到 R7FA2E1A92DFM，只能选择大类 A9. 不过经过下面的烧录尝试，是没有问题的。\n流程：基于上次的空项目，用keil打开，编译，下载成功。\n一直到编译的步骤前面都做完了。下载主要需要以下几个步骤：\n\n引入项目的 src 文件夹。在 options for target - c/c++ 里引入即可很简单。\ndebug 模式设置为 jlink 模式。设置完之后插上板子设置配置，这里因为我的jlink版本太低出现了一个报错：unkown to this version of the jlink software。解决办法就是在官网上下载了一个新版本的jlink（官网链接：https://www.segger.com/downloads/jlink，我选择的是 windows 版本），下载好后直接会提示“检测到你电脑里的 keil 环境，请问是否更新其 jlink 调试器”，更新后重新启动就没有问题了。\n上一步参考文章: keil识别不到芯片，提示unkown to this version of the jlink software_keil识别不到单片机_王小琪0712的博客-CSDN博客 里面也有如果没有提示自动更新 jlink 调试器的选项如何手动进行更新的步骤，建议多多支持原作者。\n只是选择了 jlink 调试器也并不算设置完成。如果这个时候点击下载，会提示“找不到 flash”，也就是还没有配置完成，需要设置闪存。首先确保插上了板子，然后打开 jlink 的setting：\n如果显示下图说明板子被正常识别。如果没有显示这些数据，可能是 jlink 的版本还是过低，或者线坏了，或者还未下载对应 rcsa 包。\n接下来我们配置 flash download. 打开这个页面后点击 add，添加图中所示的这款型号芯片，然后 start 和 size 应该就会自动配置成和图中一样的情形，这样就算成功了。\n点击 load，如果显示如下信息说明成功下载程序。\n\n刚插上板子的时候板子上是有白色的 power 指示灯和一个红蓝交替闪烁灯。下载空程序之后，应该只有电源指示灯还在亮。\n\n点亮LED\n本文主要参考文章：【致敬未来的攻城狮计划】— 连续打卡第十一天：FSP固件库开发点亮第一个灯。_嵌入式up的博客-CSDN博客\n在32阶段我们已经接触过类似做法了。初始化引脚模式（可以手动库函数，或者在工具包图形化界面里配置），设置引脚输出值。\n设置 FSP Smart Configurator\n像上次一样创建一个项目。\n首先我们翻一下RA2E1的数据手册看看led在哪。\n\n如图所示，一红一蓝，502 501，输出高电平亮。\n因此 configurator 里的pin如图所示设置501 502为output initial high\n\n配置完成后点击右上角 generate project content，输出更新配置到该项目中。\nKeil代码编写\n接下来就是编写keil里，驱动两个led灯输出高电平的部分了。\n\nhal_entry.c 是相当于 main.c 的入口函数。其他都是 configurator 提供的配置函数。\n引脚设置已经设置好了。我们打开 pin_data.c 可以看到：\n\n这就代表确实初始化配置加进代码里了。\n然后在 hal_entry.c 里是通过这个 open 函数在 warm_start 里初始化了。\n\n接下来我们需要一个写入位函数。在 r_ioport.c 里。\n\n参数1：固定参数，传入 &amp;p_ctrl。\n参数2：引脚，老方法 goto the definition\n\n参数3：电平。\n\n然后就简单了，只需要在主函数里调用write函数写亮led。\nvoid hal_entry(void)&#123;    /* TODO: add your own code here */\t\twhile(1)&#123;\t\t\t\t R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);\t\t\t\t R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);\t\t&#125;#if BSP_TZ_SECURE_BUILD    /* Enter non-secure code */    R_BSP_NonSecureEnter();#endif&#125;\n实验结果\n\n按键模块\n后台轮询\n按键也是一个比较简单的模块，主要是为了学习IO输入模式。\n查看RA2E1电路图可见：\n\n按键相关引脚是004引脚，默认上拉高电平，按下接地为低电平。\n首先第一步还是设置对应引脚。类似上一期设置LED的方式，只不过Mode改为Input mode。\n\n设置好之后仍然是记得generate。\n然后就是程序编写。首先还是明确一下开发流程。首先我们尝试后台轮询的按键检测。在while里不断检测按键电平，如果为高点亮蓝灯，如果为低点亮红灯。\n点亮好写，上一次已经尝试过write函数。那么我们接下来再去看类似的read函数。\n\n第一个参数还是传入固定的&amp;g_ioport_ctrl。第二个是引脚。第三个是存放我们要存储的读取按键的值。比如传入变量state的地址 &amp;state，函数执行结束后state的值就是读取的按键电平。\n主函数编写：\nvoid hal_entry(void)&#123;\tbsp_io_level_t state;    /* TODO: add your own code here */\t\twhile(1)&#123;\t\t\tR_IOPORT_PinRead(&amp;g_ioport_ctrl, BSP_IO_PORT_00_PIN_04,&amp;state);\t\t\tif(state==BSP_IO_LEVEL_HIGH)&#123;\t\t\t\tR_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);\t\t\t\tR_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_LOW);\t\t\t&#125;\t\t\telse&#123;\t\t\t\tR_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_LOW);\t\t\t\tR_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);\t\t\t&#125;\t\t&#125;#if BSP_TZ_SECURE_BUILD    /* Enter non-secure code */    R_BSP_NonSecureEnter();#endif&#125;\n实现效果：\n\n\n活动总结\n一转眼攻城狮计划就已经到了最后一天了。\n5月我还处在一个迷茫期，那时候刚刚入坑嵌入式，只学了几款电子积木，对整个体系也不是很清楚，也不知道应该学些什么。因为刚刚转到硬件领域，也缺少相关经历和能力证明，科研实习面试都失败了。\n一开始得到的少许鼓励来源于C站推荐的一系列交流会活动。我去参加了RTThread的学习营，第一次尝试在单片机开发中加入RTOS系统，也算是跳脱出自己当时缓慢的按部就班学习路线，如井底之蛙般弹出脑袋窥探了一眼外面的风景。\n后来偶然收到李肯老师的攻城狮活动邀请。虽然因为选在了期末周，自己又比较懒，基本没更几篇文章hh。但是借助李肯老师的交流活动认识了很多嵌入式领域的前辈，同伴，从每天的交流话题中也能学到很多。\n\n现如今，虽然学到的知识相比之前可能没有太多，但是整个系统的框架，从硬件到ISA，操作系统解释器等系统软件，汇编语言和机器语言的转化等……确实见识到了很多。\n再聊到本次活动。虽然自己没有做过多的尝试，但是因为之前我也只尝试过51和32的库函数开发，rcsa的configurator配置本身对我来说就是一种新奇的开发模式。与32的hal库对比更能让我体会到这些driver的便捷之处，也开始适应这种开发方式。\n非常感谢给予这次机会的李肯老大！也期望自己能保持这股热情继续学下去~\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["C"]},{"title":"技术学习：王道操作系统","url":"/2022/11/27/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"介绍\n操作系统是什么？\n计算机结构大概分为四层：\n\n用户\n应用程序\n操作系统\n硬件\n\n操作系统是一类系统软件，调度硬件资源，合理分配管理软件（因此操作系统又被称作资源管理器（resource manager））。\n\n程序要运行首先要被放到内存中，然后才能被 CPU 处理；运行中的程序叫进程。\n双击打开 QQ.exe，对应进程就会被放到内存中；\nQQ 正常运行过程中，对应进程被 CPU 处理。\nQQ 若想调用摄像头等，操作系统会把相应硬件分配给他。\n计算机还会提供用户和硬件之间的接口。主要分为三种：GUI 接口，命令接口，程序接口。\n联机/交互式命令接口：用户说一句，系统做一句。（cmd）\n脱机/批处理命令接口：用户说一堆，系统做一堆。（.bat）\n程序接口：通过程序才能调用。（.dll）\n只有硬件的计算机叫裸机；操作系统将硬件资源转换为通用的、强大的虚拟形式，有时操作系统也被称为虚拟机。操作系统提供几百个系统调用（system call）供其他应用程序使用，实现运行程序、访问内存和设备等操作，也可以说操作系统为其他应用程序提供了一个标准库（standard library）。\n操作系统几大特征\n操作系统围绕以下几大主题展开：\n\n虚拟化（virtualize）：尽管一般只有一个 CPU，但是能同时进行多个进程，造成多个 CPU 的假象。多个程序实例同时用到一片内存地址时，却能各运行各的，值互不干扰。实际上每个进程是在访问自己的私有虚拟内存空间（virtual address space)，虚拟内存通过一定的规则映射到物理内存上，运行中的程序的物理内存是完全独立的。\n并发（concurrency）**不是并行！并行是同时发生，并发是交替发生。**单核计算机就会采用并发的程序运行方式。现在尽管都有四核计算机，可以进行4个程序的并行操作，但是并发仍然很重要。\n共享：系统中的某些资源供多个进程使用。\n\n​\t\t互斥型共享就是一次只能一个程序用，如摄像头；\n​\t\t同时型共享就是两个进程交替使用，如 QQ 微信 同时发送文件。\n\n异步性：并发执行的程序有时候会卡住。比如 AB 程序都要用同一个地址，A先用了，B用的时候就要等A用完释放才能用。\n\n操作系统历史\n手工操作阶段：用户手工打点，给机器。人机协调不均衡，资源分配不均匀。\n批处理阶段——单道批处理系统：用户打好的点交给磁带，磁带读入计算机速度快得多（监督程序，早期的操作系统）。但是利用率仍然很低。\n批处理阶段——多道批处理系统：每次内存中同时读入多个程序。多个程序并发执行，有了”中断“的概念。但是用户在程序执行的时候没法干涉，人机交互很差。\n\n分时操作系统：计算机以时间片为单位轮流给所有用户提供服务。用户的请求可以被及时响应，解决了人机交互问题；各个用户之间也感受不到其他用户的存在。但是众生平等，没有优先级。\n实时操作系统：优先度高的任务可以先被处理，并且必须在给定的时限内完成任务。\n\nOS 运行机制和体系结构\n计算机中的指令有的安全（加减乘除运算），有的危险一点（清空内存）。因此需要通过权限控制限制用户能执行的指令。\n具体实现方法为：CPU 处于核心态（管态）时可以执行所有指令；处于用户态（目态）时只能执行非特权指令。\n内核程序是系统的管理者，可以执行所有指令，运行在核心态；\n应用程序只能执行非特权指令，运行在用户态。\n\n操作系统的内核包含橙黄两部分：大内核。\n只包含黄色部分：微内核。\n各自的缺点：大内核组织结构混乱，难以维护；微内核频发切换，性能低。\n中断\n一开始的计算机只是简单的串行执行程序。\n现在的操作系统不仅可以并发执行程序，而且收到中断指令时，CPU 会切换到内核模式，中断当前程序的执行，按中断指令调整程序执行顺序，然后恢复到用户态继续执行。\n中断分内中断、外中断。区别在于中断指令来自于 CPU 内部还是外部。\n\n系统调用\n我们知道计算机硬件为了供用户使用，向上层提供了一些接口。用户直接使用的接口叫命令接口；用户通过应用程序间接使用的接口叫程序接口。系统调用是操作系统提供给应用程序的接口。\n系统调用可以增加安全性，不让用户可以直接随意访问所有功能。如两个人去打印店用打印机，第一个人打到一半第二个人发送了他的打印任务请求，可打印机最终还是有序地把两个人的任务分别打印好了。如果用户能直接让打印机打印自己的任务，不加协调，无法实现这样的结果。\n哪些操作要通过系统调用的方式进行？凡是和资源相关的。这样可以保证系统的安全性和稳定性。\n\n编程语言提供的一些库函数也是从下往上提供的一些封装的功能。但库函数不一定是系统调用。如求绝对值的库函数，这个库函数就不是系统调用，用户直接就能访问。\n现在大多数系统调用都是高级语言中封装的部分库函数。\n\n陷入指令核心态不能执行，可以理解为：核心态只能执行系统调用，不能发起系统调用给自己。\n进程\n进程（process）是操作系统中最基本的抽象。\n进程就是运行中的程序，程序本身只是存放在磁盘上的一些静态指令，是操作系统让其运行起来。\n现在我们的计算机可以同时运行上百个进程，是通过虚拟化 CPU 而实现。每个进程只运行一个时间片段，然后跳转到其他进程，造成多个进程同时运行的假象。\n内存中存放每个进程的程序段和数据段，但内存怎么知道哪个是哪个进程的？通过一种数据结构叫进程控制块（PCB）找到对应进程的额程序段和数据段。程序段、数据段、PCB 组成了进程实体。\n\n\n操作系统需要一些低级机制（mechanism）切换程序运行，如上下文切换（context switch，停止当前程序，并运行另一个程序）；还需要一些智能决定要切换到哪个程序，如策略（poliicy，根据一些算法判断要运行哪个程序，如“哪个程序在上一分钟运行的时间更长？”）\n进程的几种状态\n\n\n就绪态就是除了处理机其他资源都准备就绪了。阻塞态还需要准备资源才能进入就绪态。\n\n进程控制\n就是这几种进程状态之间的切换。\n通过两个指针实现：就绪队列指针和阻塞队列指针，用于存放就绪和阻塞的进程（阻塞队列可能还有好几个，按阻塞原因分组）。\n状态切换使用原语，因为原语执行过程中不会受到中断的干扰。\n\n原语做的操作无非是：1. 修改 PCB；2. 把 PCB 放到对应队列中；3. 分配/释放资源。\n\n进程通信\n进程之间互相通信，安全起见不能直接进行。\n\n\n共享存储，共用一块存储空间。有基于数据结构的分享（给定数据结构存储方式）和基于存储区的分享（内存中划定一块存储区，进程自己决定怎么存储）。\n共享的缓冲区叫做管道，如果只采用一个管道只能使用半双工型，全双工型需要两根管道。两个进程访问该管道要互斥的访问。\n管道写满才能读，读空了才能写。\n读出来的数据就直接被丢弃了。所以安全起见只能有一个读的进程。\n\n\n消息传递。类似计网的数据报，消息封装好之后发给另一个进程的消息队列。\n\n\n线程\n让一个进程可以并发执行多个任务。比如 qq 聊天的同时可以发文件收消息发消息。\n一个进程包含多个线程。线程是调度， CPU 的程序执行单元，进程是资源分配的单元，比如把显示器资源分配给 QQ。\n\n线程有两种实现方式：\n\n用户级线程 （ULT），进程的切换由应用程序实现，而不需要操作系统管理，因此用户态下就能实现线程的切换，且线程的存在对用户透明，对操作系统不透明。\n内核级线程（KLT），线程管理靠操作系统在核心态下实现、\n两者组合的形式，n 个用户级线程映射到 m 个内核级线程上。\n\n操作系统分配 CPU 处理机只能分配给内核级线程（因为用户级线程对操作系统来说不透明）。所以如果有三个用户级线程，但这个应用程序只有两个内核级线程，最多也只能被分配到两个处理机，最多也只能有两个用户线程并发执行（哪怕这个操作系统是三核的，四核的，有很多核空闲出来）。\n几个用户级进程映射到几个内核级进程上？这就是多线程模型问题。\n\n\n多个用户级进程映射到一个内核级进程上。\n\n线程切换不用在核心态下进行，切换效率高，但是并发度不高。\n\n\n一对一。\n\n优缺点正好和1相反。\n\n\nn 对 m，用户级线程多于内核级线程，较为折中。\n\n\n\n进程调度和切换\n线程数往往多于处理机数，因此要考虑按怎样的算法分配处理机。\n进程调度和切换的区别是什么？\n进程调度先选再切换。\n进程切换包括：\n\n保存原来运行的数据\n恢复新进程的数据。\n\n切换会影响效率。\n调度层次1：高级调度（→就绪态）\n首先先不说处理机够不够处理内存中的线程，有时候线程多到内存中放不下。高级调度需要按一定的原则从外存中挑选一些作业放到内存中并建立进程（PCB），让他们有进一步竞争处理机的机会。主要解决的是调入问题。\n调度层次2：中级调度（挂起态→就绪态）\n引入虚拟存储技术之后，暂时不能运行的进程可以先调至外存等待（挂起）。等可以运行再拿回来，这样能提高内存利用率和系统吞吐量。\n其对应的 PCB 并不会一起移出内存，而是存储了被挂起的进程的信息，被放到内存中的挂起队列里。\n中级调度就是挑选挂起的进程调入内存。\n引入挂起的进程实际上可以说是有七种状态。不能运行的进程都会先放到就绪挂起态或阻塞挂起态，能运行再回到内存（有的操作系统阻塞挂起态直接回到就绪挂起态）。注意挂起和阻塞的区别！\n\n调度层次3：初级调度（就绪态→运行态）\n就是从就绪队列中按一定算法挑一个进程来执行。\n调度时机\n当前运行的进程主动（运行完了，或者异常终止）或被动放弃处理机，就会发生调度。\n有以下几种情况不能调度：\n\n进程在处理中断时。\n进程在操作系统内核程序临界区中。（临界资源及临界区（内核/普通）以及三种进程不能切换的情况_Unstoppable~~~的博客-CSDN博客_内核临界区 在此感谢这位博主！调度区和调度资源是两回事，调度区又分普通调度区和内核调度区。）\n原语执行时.\n\n调度方式\n非剥夺/非抢占调度方式：只允许进程主动放弃处理机。哪怕有更紧急的进程到达，也不会把当前正在使用处理机的进程挤开。开销小，但没法处理紧急情况。\n剥夺/抢占调度方式：允许进程主动或被动放弃处理机。\n调度算法评价指标\nCPU 利用率：CPU 有活干的时间/总时间。\n系统吞吐量：完成了的作业道数/总用时。\n周转时间：提交作业到作业完成用时。包括在外存等待高级调度→在内存就绪队列等待低级调度→在 CPU 上执行→等待 I/O 操作完成的时间。\n注意概念问题，进程是运行中的程序，所以作业在外存的时候不可以被称为进程。进入内存才创建了进程。\n带权周转时间：周转时间/实际运行时间。越小越好（排队用时少吧）。\n等待时间：作业等待处理机状态的时间之和。（不包括 IO）\n响应时间：用户提交请求到首次产生响应的时间。\n调度算法\n早期批处理调度算法：只根据等待时间和预估处理时间调度，不考虑是否紧急。\n\n\n\n算法名\n思想\n规则\n用于何种调度\n是否可抢占\n优缺点\n是否会导致饥饿（某个作业长期得不到服务）\n\n\n\n\n先来先服务 FCFS\n公平\n先来后到\n都用\n非抢占式\n公平；但排在后面的短作业体验差\n不会\n\n\n短作业优先 SJF\n让平均等待、周转、带权周转时间最短\n最短的作业优先服务\n都用\n非抢占式（最短剩余优先算法是抢占式的，当有进程入队的时候立刻调度。平均时间抢占式的更少）\n平均时间少，但对长作业不公平，可能“饥饿\n会\n\n\n高响应比优先 HRRN\n综合考虑等待时间和处理时间\n$\\frac{等待时间+服务时间}{服务时间}$，优先执行响应比大的\n都用\n非抢占式（当前进程主动结束时才进行调度）\n综合考虑了等待时间和服务时间，长作业等久了也会执行\n不会\n\n\n\n后期交互式系统算法：\n\n\n\n算法名\n思想\n规则\n用于何种调度\n是否可抢占\n优缺点\n是否会导致饥饿\n\n\n\n\n时间片轮转 RR\n公平轮流地为所有进程服务\n按先来后到，轮流给各个进程一个时间片执行。如果没执行完就交给下一个进程，然后重新到队尾排队（时间片大小要合适。太大就是 FCFS 算法了，太小效率低）\n进程调度\n是\n公平；响应快；但是频繁切换效率低，不区分紧急程度\n不会\n\n\n优先级调度\n按紧急程度处理\n优先度高的先执行\n都用\n是\n可以优先处理紧急任务；但总是高优先级任务到来可能饥饿\n会\n\n\n多级反馈队列调度算法\n根据时间片计算优先级\n进程刚到达放入1队列，一个时间片内没完成放入2队列，还没完成一直往后放，如果已经在最后一个队列了就重新放到该队列结尾。1队列优先级最高\n进程调度\n是\n综合了各个调度算法优点\n会\n\n\n\n\n进程同步和互斥\n虽然之前提过进程是异步的，各个进程相互独立，但是有的工作是有顺序的，比如先读入再写。\n同步，即相互制约，指部分工作的次序需要协调。\n互斥：一些共享资源不允许多个进程同时访问。比如一次只允许一个进程访问的资源叫临界资源。\n\n进程互斥遵循以下原则：\n\n空闲让进\n忙则等待\n有限等待，防止饥饿，不让进程等太久\n让权等待，如果该进程进不去，那就不给他了，赶紧给别人。\n\n进程互斥软件实现方法\n\n单标志法\t\n\n​\t一开始只允许 P1 访问。一直到P1把 turn 变为0，然后切时间片的时候才能交给 P0. 两者交替访问。\n​\t但是违背了空闲让进。如果只有 P0 想访问临界区，就一直进不去。\n\n\n双标志先检查法\n\n判断对方有没有在访问。\n但是如果按照①⑤③②⑥⑦的顺序，两者会同时访问临界资源，违反了忙则等待。\n\n\n双标志后检查法\n先上锁再检查。但是两个进程要是都先锁住了，就都执行不了了，可能出现死锁问题。\n\n\nPeterson 算法\n\n可惜没有遵守让权等待。\n\n\n进程互斥硬件实现方法\n\n\n中断屏蔽方法\n访问临界资源的时候把中断关上；访问完了打开，再允许调度。但是用户态不适用（用户态不应该搞中断的问题），而且对多处理机不适用。\n\n\nTestAndSet 指令\n是硬件实现方法，下图为软件实现方式。\n\n如果 lock 原来是 true，那么其他进程访问的时候一直卡在 while 处。知道访问临界区的进程退出并解锁，其他进程访问的时候 lock 才是 false，才能跳出循环。\n但是无法解决让权等待问题，如果有一个进程把 lock 变成 true 之后又进不去临界区，其他进程就永远无法访问，一直忙等。\n\n\nSwap 指令\n\n逻辑上等同于 TS，也无法解决让权等待问题。\n\n\n信号量\n信号量用于表示系统中某种资源的数量。我们用一对原语（等待 P，信号 V）对信号量做操作.信号量涉及到的三个操作就是初始化、P、V。\n\n然而这样的信号量也没能解决让权等待问题。不过一个记录型信号量可以解决。\n\n释放完资源，S.value≤0 说明还有进程在阻塞队列中，直接把当前刚释放的处理机给阻塞队列的进程执行。\n这样如果该进程进不去自己的处理机，就会把自己调整到堵塞态，把处理机让出来给别人，解决了让权等待问题。\n\n\n信号量实现进程同步和互斥\n互斥：\n\n同步：如怎样保证2一定在4之前执行\n\n\n进程种类\n生产者和消费者\n生产者把产品放入未满的缓冲区，消费者从未空的缓冲区取出。两者要互斥地对缓冲区访问；同时如果生产者要放入满缓冲区要先等消费者取出，消费者要从空缓冲区取要先等生产者放，这两件事是同步关系。\n\n注意 决定互斥的 mutex 顺序不能和决定同步的 empty full 颠倒！！！\n\n如上图，如果先进行①②，则互斥锁打开，生产者因为仓库已满无法放入，阻塞。消费者又因为互斥锁打开无法取东西，阻塞，就死锁了。\n多生产者 多消费者\n\n缓冲区大小（盘子）如果为1，那么不用互斥变量也能解决。\n\n因为苹果、橘子、盘子变量同时只能有一个=1，每次最多也只能有一个变量访问。如果缓冲区变为2就需要 mutex 了，父母同时放入水果可能覆盖对方的值。\n吸烟者问题\n\n\n因为只有一个缓冲区，所以不需要 mutex 就能实现互斥。\n吸烟者问题其实是实现了一个生产者生产多种产品的问题。此例中生产者生产的产品顺序固定，还可以修改生产顺序逻辑。\n读者-写者问题\n允许多人同时读，但是有人在写的时候其他人不能读写。\n读进程有限的解决办法：mutex 用于所有读进程互斥访问 count 变量，当 count 变量=0时才可写入。但是写进程有饿死的风险。\n\n如果再加一个写的互斥信号量，就能让写操作优先于读操作了。\n\n哲学家进餐问题\n一个进程同时持有多个临界资源的情况。\n\n如果只是简单地用两个信号量判断左右两根筷子是否空闲，可能所有进程并发拿起了左手的筷子，并发地卡住了右手的筷子，造成死锁。\n有几种解决方案：①拿两只筷子的行为添加一个互斥信号量。这样一个哲学家拿不起来被阻塞的时候，其他哲学家也不会尝试拿。\n\n②奇数先拿左手，偶数先拿右手，这样相邻的人拿筷子就会互斥。\n管程\n信号量挺琐碎的，而且容易出错，顺序错了都会影响结果。\n\n管程内的数据只有在管程内的过程（函数）才能访问；一次只允许一个进程进入管程。\n\nmonitor 是 java 语法的管程，每次只允许一个进程访问（互斥），进程只能通过管程提供的特定入口进入。我们可以自己定义逻辑判断，让进程等待或释放（同步）。\n关键字 synchronized 修饰的函数同一时间段内只能被一个进程访问。\n死锁\nA等B，B等C，C等A，都在等对方手里的资源。\n和饥饿不一样，饥饿是如果一直来新进程自己可能一直无法继续。\n死锁的四个条件：\n\n互斥，对某一资源互斥使用。\n不剥夺，不能抢资源。\n请求和保持，在新资源还在请求时可以保持自己手里已有的资源。\n循环等待，存在资源的循环等待链。比如有12两个资源，进程一申请顺序：12，进程二申请顺序：21，两者正好互相锁住。\n\n可能发生死锁的情况：\n\n竞争不能共用的系统资源时；\n进程推进顺序不当；（哲学家拿筷子，都先拿左手的）\n信号量使用不当（如生产者消费者一例，先互斥锁再信号量锁。生产者先进入满仓库，因为当前只有自己进程进入仓库所以互斥锁不干扰；但是仓库已满，无法放入导致阻塞；消费者又因为生产者正在访问，互斥锁限制导致阻塞）。\n\n预防死锁\n破坏四个条件之一。\n\n\n把资源改为可以共享使用的；不过不是所有设备都能强行改的。\n\n\n剥夺：要么如果当前进程资源不足时立刻全部释放资源，等一会再重新运行；要么根据优先级，高优先级抢低优先级的资源使用。但是比较复杂而且会影响前一个进程，常用于易于保存和恢复状态的进程（如 CPU）；效率低；方案一还可能导致饥饿。\n\n\n请求保持：采用静态分配方法，进程开始运行时就把所有需要的资源都给他，全程让他运行。但是可能有的资源这个进程就用一两下，一直占着会比较浪费；可能导致饥饿。\n\n\n\n比如上例，两个进程申请资源顺序都从小到大，先1后2，就不会死锁了。但是实际资源使用顺序可能并不是从小到大，效率低；而且增添设备要修改编号，不方便；而且用户编程要注意顺序，比较费事。\n\n\n避免死锁\n\n安全序列就是按某种顺序分配资源，所有进程都能顺利得到，不会死锁。存在一种安全序列的情况，那么当前系统就是处于安全状态。\n银行家算法：\n\n如图，剩余资源 (3, 3, 2)，视作一个一维数组。P0 全分配也不够，不行；P1可以，全分配给P1后P1归还资源，剩余资源数变成 (5, 3, 2)；然后P2不够，P3可以，变成 (7, 4, 3)；p4 变成 (7, 4, 5); P1 变成 (7, 5, 5)，最后 P2 P4，五轮循环全部分配。\n最大需求：Max\n已分配：Allocation\n最多还需要：Need\n当次发起申请的请求量：Request\nRequest≥Need：出错了\nRequest≤Available：说明有多余空闲。系统先尝试分配一下，成功后证明安全，正式分配。\n检测、消除死锁\n点表示进程，方框表示资源，箭头表示分配。如果所有箭头都能被顺利消除，证明不会发生死锁。\n\nP1向R2要一个。R2给了P2一个自己还剩下一个，所以可以要到。（P1释放后，就能把P1的所有边去掉了）\nP2向R1要一个。但是R1三个都给出去了，所以P2要不到，阻塞了。\nP1运行完释放，R1里就有两个空闲的了，P2就能要到了。\n下例就没法全部消除，死锁了。只有P3能正常运行并释放。\n\n解决办法：可以挂起或终止死锁的部分节点，或者回退到没有发生死锁的断点。\n内存\n存放数据的硬件，程序要先被放到内存中才能被处理.\n代码被编译成指令，通常还会涉及到几个地址。比如一个加法指令涉及的三部分（A，B，C）A代表：这是一个加法指令；B C代表：把B中的数据加到C中。\n指令中采取的是相对的逻辑地址，因为还不能确定物理存到了哪里。\n\n装入有三种：\n\n绝对装入，编译时就知道要放到哪个物理地址里，编译时直接采用物理地址；适用于单道程序环境。\n静态重定位装入，编译时采用相对地址，装入时根据相对地址存入到物理地址。但是如果内存中容量不够，就不能装入。用于早期操作系统。\n动态重定位装入，刚进内存不会装入，等到程序运行时再装入。允许程序运行中在内存里移动。现代操作系统。\n\n链接也有三种，装入前链接成一块，边装入边链接，运行时再链接。\n内存管理\n内存中存了多少？空闲多少？进程分配到哪里？怎么释放？内存扩充（游戏60G，内存4G，采用虚拟内存的方式扩充）、地址转换（就是装入。逻辑地址和物理地址之间的链接 是操作系统解决，程序员不用管）、内存保护。\n覆盖与交换技术\n覆盖技术：解决内存太小的问题。内存中分固定区和覆盖区。\n\n缺点在于固定区覆盖区要程序员自己规定，不透明。\n交换技术：把内存中某些进程拿出来，再把某些进程换进去。磁盘中专门有一块交换区，追求交换的速度，采用连续存储方式，IO 比文件区要快得多。缺页率高时换出得多。优先换出阻塞和优先级低的进程。\n覆盖是同一个进程中的，交换是多个进程中的。\n内存保护限制每个进程只能访问自己范围内的数据。可以设置上下限寄存器；或者重定向寄存器决定上限，界地址寄存器代表最大长度。\n内存分配\n连续分配：内存分为系统区和用户区。系统区存放操作系统相关数据；用户区存进程，只能存一个。实现简单，没有外部碎片（内存空闲区域太小，没法分配给进程的情况），可以通过覆盖技术扩大内存，不一定要保护；但是利用率低，而且有内部碎片（分配给某个进程的内存区域，有些部分没有用到）。\n固定分区分配：内存分成很多个分区，每个分区只装一道作业。\n（分区大小相等，缺乏灵活性，但是适用于一台计算机控制多个相同对象的场合；\n也可以设置不同大小的分区，适用于各种作业）\n操作系统需要叫分区说明表的数据结构，让内核程序知道哪些分区可用不可用，起始位置，大小等。没有外部碎片，但是有内部碎片；而且可能有过大的用户程序，所有分区都满足不了，就只能覆盖，降低效率。\n动态分区分配：根据进程大小动态建立分区。系统区大小都是不固定的。可以采取空闲表或空闲链的数据结构存储信息。\n动态分配的算法：\n\n要插入的进程比空闲区小：更新空闲区起始位置和大小。\n要插入的进程和空闲区一样大：直接在空闲分区表中删掉这一条空闲区的记录。\n\n动态分区回收算法\n\n要回收的分区前面或后面有一块空闲：更新那块空闲的起始位置和大小。\n前后没有空闲：新增一条空闲记录。\n前后都有空闲：空闲表中两条记录 更新成一整条。\n\n动态分配算法 没有内部碎片，但有外部碎片。可以通过“拼凑”来解决。\n具体怎么选择空闲分区分配？\n动态分区分配算法\n首次适应算法：从小地址到大逐渐找。空闲区按地址从小到大存储在空闲链中。\n最佳适应算法：优先找能容得下的最小的空闲区，大的留着给大的进程预备着。空闲分区从小到大存储在空闲链中。小碎片会越来越多，导致外部碎片。\n最坏适应算法：优先使用最大的空闲分区，避免外部碎片。但是大进程到来的时候可能插入不进来了。\n临近适应算法：因为首次适应算法每次都从头找，头部可能有很多小碎片，每次又要遍历。临近适应算法每次从上次结束的地方开始查找。也是优先使用最大分区，类似最坏适应算法。\n基本分页存储算法\n是一种非连续分配。\n每个分区10MB，A进程23MB，可以拆成10+10+3MB存储。\n但是这样导致第三个分区内部碎片达到7MB。如果分区大小为2MB，那么只有最后一个分区有1MB内部碎片。\n每个分区是一个页框，有页框号，从0开始。把进程分配成页框的大小，叫做一个个页，有页号。\n分的页并不是连续存储在分区中的，可以不连续存储，根据逻辑地址找页与页之间的关系。\n页号：逻辑地址/页面长度。\n偏移量：逻辑地址%页面长度。\n如第80个内存单元，页面长度50，那么页号=1，偏移量=30.\n如果页面大小是2的整数次幂，那么页面范围就是00000……0001000……0000到00000……00010111……11111，末尾的部分就是页面偏移量。\n页表存储页面信息，页表项包含页号和块号信息，每个页表项应该能表示出所有块数的信息。比如有2^20个块，则每个页表项要有20种状态，20位即至少三个字节。(但是通常采用4个字节 这样让总内存数可以等于证书个页表项)\n基本地址变换机构\n用于实现分页管理逻辑地址转变为物理地址的操作。\n\n基本地址变换结构 每次要访问两次内存。\n查页表，知道要访问的数据的位置：一次；\n去访问数据：二次。\n具有快表的地址变换机构\n\n让最近访问过的页表项存到快表中。\n\n如果快表中有该页表项，直接取出该项计算出物理地址，就不用到慢表中查表了。\n访问快表命中了，就只需要一次访存。\n\n两级页表\n\n单极页表必须连续存储；\n并不是整张页表都会被频繁访问到。\n\n可以把长长的页表再分成离散的几块，即第二级页表。又叫顶级页表。这样就解决了问题1.\n然后对于没有进内存的目标页，访问的时候产生缺页中断，然后调入页。\n\n但是没有快表的话，两级页表要访存3次。\n基本分段存储管理方式\n按逻辑把程序分为一个个段（如 主函数，sum 函数……）分段离散的存储到内存中。可读性更高。\n段号规定了可以有多少个段，段内地址规定了段的大小。\n当然啦，为了查找到哪个段放在哪里，也需要段表。段表每一条包含段号、基址（起始位置）、段长。\n\n\n段表寄存器存储在系统区的 PCB 中，即段表的位置。\n相比分页，分段是有意义的，是二维的，用户既要给出段名（如 main 函数的段），又要给出地址。\n分段也更容易实现信息共享和保护。首先什么代码可以共享？不能修改的代码可以共享，如常量，防止多个进程并发访问会出问题。\n然后分段是按逻辑分的。比如每个函数分一个段。分页是按大小直接截断的。所以分段可能提取出可以共享的代码片段，分页会更难一些。\n\n分段也是两次访存，也可以尝试快表。\n段页式管理方式\n分段和分页的缺点是什么？\n分页划分固定分区，但不便于信息共享和保护。\n分段根据程序分配大小不确定的分区，可能有外部碎片（紧凑还是付出代价很大的）。而且进程太大的话也难以找到一大块连续区域。\n那，把大的段分页就好了。\n分页的页表包含：页号 页内偏移量信息。分段的段表包含：段号 段长 基址信息（段号可以隐含）。\n段页式系统的逻辑地址结构 段包含：段号 页表长 页存放块号（起始地址）。页包含：页号 页面存放的内存块号。\n\n虚拟内存\n归根结底，以上的内存分配方法需要把整个程序都装入内存运行。而且由于内存的驻留性，程序运行完之前整个都一直留在内存中。\n第一，没必要，程序的某些部分不常使用，不用一直占在内存里，内存利用率低。第二，太大的程序装不进来。第三，很多程序排队时，这样一次只能运行很少的几个，并发性差。\n根据之前快存学到的局部性原理，可以把常用的部分留到内存中，不常用的拿出去。要用到的不在内存里，就拿进来；内存太满，就把不常用的再拿出去。\n\n虚拟内存有多次性（分多次装入）、对换性（可以换出来）、虚拟性。\n存储方式：采用连续型并不合适，因为要分多次装入。改用请求式管理。\n请求分页管理\n和基本分页管理的区别在于：1. 要访问的信息可能在内存中，也可能不在。不在的话要调入进来。要存储该页是否在内存中的信息。\n\n暂时不用的可以换出去。如果在内存中做过修改，那么不用拿回到外存；如果做过修改了就要了。\n\n\n先根据状态位判断要访问的页在不在内存中，不在里面，就先产生缺页中断，调入内存。如果有空闲块就插到空闲块里，没有就根据页面置换算法换出来一个不常用的。调出内存的页面如果发生改变就要写入外存，没有就直接丢掉。最后还要修改请求页表中的状态信息。\n\n缺页中断是自行产生的内中断。\n\n几个值得注意的点：\n\n我们知道，如果内存中的内容被修改（发生了”写“操作），状态位中的修改位变为1，移出内存时要再写入外存。实际上修改位的改变不一定用在内存中修改，可能只修改快表中的修改位即可，这样少访存。\n换入换出页面太频繁，开销会很大。\n页面调入内存后，直接就放到快表里，之后访问就访问快表就行。\n\n页面置换算法\n追求更小的缺页率，这样换入换出更少。\n最佳置换算法 OPT：选择不再使用，或者最长时间内不再被访问的页面淘汰。\n\n插入701之后满了，再想插入2就要顶掉一个。看看后面要访问的页面，7是最不着急的，先把7顶掉。后面以此类推。\n注意缺页不一定就会发生页面置换。如果还有块空闲就不用。\n但最大问题就是操作系统无法提前预判后面的页面访问序列。\n先进先出置换算法 FIFO：最早进来的页面最早被淘汰。就是队列的数据结构。\n\n但是这就是再猜啊。怎么能因为用的早就觉得下一秒他不会用了呢？买彩票呢。可能会引发 Belady 异常（为进程分配的物理块变大时，缺页次数反而变多）。\n最近最久未使用置换算法 LRU：\n哪个最久没用过，就先替换掉哪个。\n\n性能确实好，但是开销大，实现困难。\n时钟置换算法 CLOCK：每个页面添加一个访问位，初值都是0，访问过了改为1.每次优先替换掉0的页面。如果全为1，则全置0后再次扫描。\n改进的时钟置换算法：同时考虑访问位和修改位。\n替换：第一轮扫描找0，0的替换。这种不仅最近没用过，而且不用写入外存。\n第二轮找0，1的替换。这种最近没用过，但是之前修改过，要写入外存。\n如果这两轮都没找到，说明所有的第一位都是1.全部置0，再进行扫描。\n第三轮找0，0，类似第一轮。\n第四轮找0，1，类似第二轮。\n页面分配策略\n驻留集：请求分页存储管理中分给内存的物理块的集合。虚拟存储中，驻留集大小一般小于进程总大小。太小，频繁缺页出入内存效率低；太大，并发性降低。\n固定分配：一开始给定每个进程固定大小的驻留集。\n动态分配：根据运行过程中的情况动态分配大小。\n局部置换：缺页时只能当前进程自己的物理块置换需要的页进来。\n全局置换：可以用空闲的物理块，或其他进程的物理块置换。全局置换大小肯定不固定，肯定是动态分配。\n\n调入哪些页？\n首次调入时，根据局部性原理，某个页相邻的页也会容易用到。因此一调调一小片。\n运行中缺页调入时，只调缺少的页。\n从何处调入页面？\n\n抖动/颠簸现象：刚换出去的页面又换进来。主要原因是驻留集太少了，少于要频繁使用的块。\n工作集：运行时进程实际访问的页面集合。驻留集不应小于工作集。\n文件\n有信息的数据集合。\n文件包含的信息：文件名、标识符（操作系统要看）、类型、大小、创建修改时间、所有者、安全信息。\n文件管理\n文件分为无结构的流式文件和有结构的记录式文件。记录式文件由一条条记录组成。\n文件存放在根目录里的目录里。\n操作系统应该向上提供给用户的功能：CRUD，打开和关闭文件。\n文件存放在外存类似进程在内存中，是分块存放的（救命啊，我刚把那块学过去）。\n初次子海外，操作系统还应该提供文件共享和保护功能。\n文件的逻辑结构\n无结构文件（如txt）很简单。\n有结构文件一般有关键字区分各个记录；记录存储长度不同又分为定长和可变长。\n有结构文件逻辑结构：\n\n\n顺序/链式存储。顺序定长存储可以实现随机存取，想找第i位直接起始位置+i*单位长度即可。顺序可变长无法计算，链式存储不连续也无法实现随机存取。顺序定长存储如果物理上也采用顺序存储，则可实现快速检索。\n\n\n索引文件。对于可变长记录文件，可以建立一个定长的索引表，包含索引号、长度、起始位置指针的信息。检索速度很高。但是索引表和记录数一样，占的空间不小。\n\n\n索引顺序文件，一条索引代表一组记录。可能查找速度还是很慢，那就建立多级索引。\n类似数据结构中学到的中间表，如果索引中只存储必要的少部分信息（文件名，指针），索引占的小，能放更多的索引，用更少的磁盘块存储，就平均需要访问更少的磁盘块就能找到文件。\n\n\n\n​\t外存中的索引节点叫磁盘索引节点，内存中的叫索引节点，可能包含更多信息，如文件是否被修改、同时有几个进程在访问等。\n文件目录\n文件控制块 FCB 中存储文件名、类型（是否是目录）、权限、地址等信息。\n目录支持的功能有：搜索、创建、删除、显示、修改文件。\n早期操作系统只支持单文件目录，那就不能重名了。\n早期多用户操作系统支持双文件目录，一个主文件目录，其中包含多个用户目录。不同用户目录各自文件可以重名。但是用户自己没办法创建多级目录。\n后来的多级目录结构支持多级目录了。\n引入当前目录概念：如果没有此概念，我们要找根目录下 /目录1/目录2/照片.jpg，需要三次访存。根目录找目录1，目录1找目录2，目录2找jpg。要是有当前目录的相对路径就会方便得多。\n树形目录结构缺点在于不能共享文件。\n无环图目录结构\n\n不同用户不同目录下可以访问到相同的共享文件。\n共享文件要设置共享计数器。当有用户取消共享后，要删除共享信息，共享计数器–。减为0时删除共享节点。\n文件的物理结构\n很多操作系统中，磁盘块和内存块、页大小相同，成块成块拿进来。\n类似内存，文件存储的逻辑地址分为逻辑块号和块内地址两部分。\n连续分配\n自不必多说~物理块号=起始块号+逻辑块号。支持顺序访问和随机访问。但是不方便拓展，比如1~3块的A文件想扩展，但是4~6是B文件，不是空闲文件，A文件想拓展只能整体挪到空闲区域；而且还可能产生大量磁盘碎片。\n链接分配\n隐式链接：FCB存储起始块号和结束块号。像链表一样从第一个找到结尾（每个磁盘块中包含指向下一个盘块的指针，但是这对用户来说是透明的），没法随机存取，但是拓展方便。\n显示链接：FCB 中包含起始块号，此外还有一张文件分配表 FAT，其中包含所有块号的下一块指针。隐式链接想找一个块，要先在 FCB 中找到起始位置，再读磁盘，找磁盘里的下一块。显示连接可以先不用读磁盘，根据分配表推测出要找的逻辑块的物理地址再去读磁盘，访问速度更快。\n链接分配都不会有外部碎片。\n索引分配\n每个文件建立一个索引表。索引表存放的磁盘块叫索引块，文件数据存放的磁盘块叫数据块。FAT是一个磁盘对应一张，索引表是一个文件对应一张。\n\n也支持随机存取，也方便拓展，但是索引表占空间。\n要是文件太大，索引表一个索引块存不下，需要多个。\n可以让索引块之间链接起来。但是不支持顺序存储，要找最后一块就要从头便历。\n可以建立多级索引。每级大小不超过一个数据块。k级表访问数据，要访问k+1次磁盘块（k次查找位置，1次查找数据）。\n混合索引：\n\n小文件层级小一点。因小文件访问可能频繁一些，就少访问几次。\n文件存储空间管理\n操作系统的盘有什么用？又叫文件卷，每个文件卷都包含目录区和文件区。\n空闲表法\n分配磁盘块给用户：类似动态分区分配，可采用首次适应、最佳适应、最坏适应等。\n回收磁盘块：也类似动态分区分配，考虑前后有无空闲块。\n空闲链表法\n\n空闲盘块链分配：空闲链从链头摘下来k个空闲块，并修改链头位置。\n空闲盘块链回收：回收的空闲块挂到空闲链结尾，并修改链尾位置。\n空闲盘区链分配：先按算法找到合适的空闲盘区。如果没有合适的，也可以把不同盘区的盘块同时给一个文件。\n空闲盘区链回收：如果和空闲盘区挨着，直接合并。否则变成一个单独的空闲盘区挂到队尾。\n位示图法\n一定注意从0还是1开始！\n\n分配：扫描位图，找到连续的k个0，修改为1.\n回收：算出回收盘块的位图字号、位号，置为0.\n成组链接法\n大文件不适用空闲块法。\n超级块存放在内存中，其中包含下一组空闲块块数和块号。\n如果没有下一级了，下一组空闲盘块数可以用特殊标识符如-1表示。\n\n空闲分配：如果&lt;100个，从超级块分配就够。\n如果=100个，不能直接分配超级块因为这样超级块对后面的链接就消失了。要先把300的内容提到超级块作为新的超级块，再分配。\n\n回收：直接加到超级块上。如果超级块最大大小为100，已经满了，还要回收，就要让新回收的块作为新的超级块，并指向原来的超级块。\n\n文件基本操作\n文件创建\n需要关注：文件名；文件路径；需要的外存空间。\n\n在外存中找到合适大小的内存空间；\n在目录表中更新新文件的信息。\n\n文件删除\n\n根据目录表找到该目录项；\n外存中回收内存；\n目录表中删除该文件信息。\n\n打开文件\n需要用户提供的信息：文件名；文件目录；打开方式（读；写；……）\n操作系统先去目录表找到对应的文件，复制到内存中。并且把目录项复制到内存系统的“打开文件表”中。\n\n关闭文件\n删除用户打开文件表的对应项；回收空间；系统打开文件表的打开计数器-1，减到0则删除打开文件表的对应项。\n读文件\n指明要读的文件，要读入多少数据，读入的数据在内存中的位置。读入指定大小放入内存中。\n写文件\n和read很像。最后再通过write系统调用写回外存。\n文件共享\n基于索引节点的共享方式（硬链接）：\n\ncount说明还有几个进程在共享该文件。\n要删除时，count–，若&gt;0则不能删除，=0才能删除。\n基于符号链的共享方式（软链接）：\n\n删掉文件1，软链接仍然存在，只是无法通过软链接去访问文件1了。\n因为访问共享文件要查询多级目录，进行多次 IO，因此采用软链接。\n文件保护\n口令保护：规定一个口令，用户要说对应口令才能访问。但是口令保存在系统内部，不安全。\n加密保护：用密码对文件加密。如异或加密。有点费时。\n访问控制：文件的 FCB 中增加一个访问控制列表 ACL，记录用户可以有哪些权限（读写运行ls）。以组为单位，如：管理员，文件主，文件主的伙伴，陌生人。\n文件系统的层次结构\n\n\n磁盘\n\n\n\n\n磁盘调度算法\n\n先来先服务算法 FCFS：就是单纯的先处理先来的进程。\n\n最短寻找时间优先 SSTF：先找离当前磁道近的。\n\n扫描算法 SCAN：只有磁道移到最外侧之后才允许往回移动，避免 SSTF 的左右横跳。\n\nLOOK 调度算法：改进 SCAN 算法，观察到当前磁道已经是访问请求最右边的磁道后，就可以立即改变磁道移动方向往回。\n\n循环扫描算法 C-SCAN：\n\nC-LOOK 算法：\n\n减少延迟时间\n磁盘一直旋转的。如果要读几个相邻的扇区，读了第一个处理的过程中磁盘还在转，处理好了的时候可能又转到不知道哪里去了。可能就会产生很长的延迟时间。\n解决办法：交替编号。逻辑上相邻的扇区物理上分开。\n\n为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？因为更改柱面号需要移动磁头臂，更改盘面号不用移动臂，只需要激活相邻盘面的磁头即可。可以减少磁头移动消耗的时间。\n磁盘管理\n初始化：\n​\t物理格式化：把磁盘划分为扇区。扇区包含头、尾、中间数据部分。头尾会存放一些扇区校验码之类的信息。\n​\t磁盘分区：分为几个文件卷。\n​\t逻辑格式化：创建文件系统（根目录、管理空间的数据结构如位示图、空闲分区表等）。\n​\t磁盘的初始化程序：放在哪里？\n​\tROM 只读存储器中的数据出厂时就写好了且不能更改，集成在主板上。但是磁盘的初始化程序说不定以后会更新换代，ROM 中的内容又不能更新，因此初始化程序不放在 ROM 中，而是放在磁盘（C）里。初始化程序的装入程序写在 ROM 中。\n坏块的管理：坏掉的扇区。简单的磁盘直接在 FAT 中标记出来防止被使用到（对操作系统不透明）。复杂的磁盘交给磁盘控制器维护坏块链表，而且保留一些备用分区（对操作系统透明）。\nI/O 设备\nI/O 设备分类\n按使用特性分类\n人机交互类外设：如鼠标打印机键盘等。数据传输慢。\n存储设备：移动硬盘、光盘等，数据传输速率快。\n网络通信设备：调制解调器等用于网络通信，速度中等。\n按速率分类\n低速设备：鼠标键盘。\n中速：激光打印机。\n高速：移动硬盘等。\n按信息交换的单位分类\n块为单位：磁盘。\n字符为单位：鼠标键盘等。\nI/O 控制器\nIO设备包括：\n\n\n机械部件：用于执行具体 IO 操作的，如鼠标按钮、显示器屏、磁盘盘面。\n\n\n电子部件：插入主板扩充槽的印刷电路板。\n\n\nCPU 要通过 IO 控制器作为中介才能控制机械部件。\n\n\n一个 IO 控制器可能控制多个设备；而且可能有多个寄存器。有的操作系统让这些寄存器存到内存里，叫做内存映像 IO；有的采用专门的地址，即寄存器独立编址。独立编址不在内存里，因此还要设置专门的指令来实现对其的操作，还要指明具体对哪个控制器操作。\nIO 控制方式\n关注：一次读写操作的流程；CPU 干预的频率；数据传送单位；数据流向；优缺点。\n程序直接控制\n读：\n\n重点在轮询。CPU要不断轮询。\n数据传送单位：每次一个字。\n数据流向：内存和 IO 设备经由 CPU 读写。每个字读写都需要 CPU 帮助。\n简单，但是 CPU 和 IO 只能串行工作，CPU 一直轮询检查效率也很低。\n中断驱动方式\nCPU 发出读写命令后，等待 IO 的进程暂时阻塞，先运行其他程序。IO 完成后控制器会向 CPU 发一个中断信号，CPU 收到后继续执行。\n\nCPU 执行完每个指令的周期末尾检查中断。中断处理过程需要保存、恢复进程的运行环境，也需要一定时间开销。\nCPU 只有 IO 开始时干预一下，等待 IO 过程中就运行其他进程了。\n数据传送单位：每次一个字。\n数据流向：内存和 IO 设备经由 CPU 读写。每个字读写都需要 CPU 帮助。\n相比程序直接控制，CPU 利用率高一点了。但是一个字一个字的传，速度还是慢。\nDMA 方式\n数据传输单位是块；设备和内存之间数据传输不用每次都经过 CPU ，只有开始传输或结束时才需要干预。\n\n缺点：CPU 每发一条 IO 指令，只能读写几次连续的数据块。离散的数据块就要多次中断。\n通道控制方式\n通道相当于简化版的 CPU。CPU向通道发出指令，指明通道程序在内存中的位置，并指明要操作的是哪个 IO 设备，然后 CPU 就去运行其他程序了。\n\n通道能执行的指令很单一，而且放在内存中。\nCPU 干预次数极少，效率也高，就是需要专门的通道程序支持。\nI/O 软件层次\n\n设备独立性软件：向上提供接口（入库函数）。校验用户是否有权限使用当前设备。差错处理。分配和回收设备。管理数据缓冲区。建立逻辑设备名到物理设备名的映射，并根据实际的物理设备选择合适的驱动程序。\n\n可以只设立一个系统 LUT，但是所有用户的逻辑设备名不能重复；也可以给每个用户设计一个。\n为什么不同设备驱动程序也不同？因为不同设备内部结构也不一样。比如不同打印机内部寄存器数量可能不一样。驱动程序一般作为单独的进程。\n设备驱动程序：主要负责具体控制硬件设备。\n中断处理程序：IO 顺利完成后，进行中断处理。并从设备读入一个字长的数据。\nI/O 核心子系统\n假脱机技术\n脱机技术是什么？我们记得最早期的计算机是人手动打孔纸带放入计算机中的，因为人打孔太慢，CPU 运行再快也得等着。\n批处理几段引入了脱机输入，先通过外围控制机把数据输入到更快速的磁带上再让主机读入。脱机指的是脱离主机控制的 IO 操作。\n不仅 IO 快了，而且 CPU 忙的时候用户也可以先处理数据到磁带上。\n假脱机技术 SPOOLing 用软件模拟脱机技术。\n\n输入输出进程模拟外围控制机。\n借助 SPOOLing 技术，可以让打印机实现共享。收到用户的打印请求时，在输出井里申请空闲缓冲区（在磁盘上），并放入要打印的数据；且给用户进程申请一张空白的打印请求表，里面存储打印的相关信息，并把该表挂到假脱机文件队列上。打印机空闲时从队列中取出打印请求表，根据表取出打印的数据到输出缓冲区，再到打印机打印。\n设备的分配和回收\n分配设备要考虑：设备属性（独占？共享？虚拟？虚拟就是假脱机技术等独占改成共享）。设备分配算法（FCFS 优先级高的优先 短任务优先）。安全性。\n\n分配分为静态分配和动态分配。\n设备分配管理中的数据结构\n\n设备控制表 DCT\n\n控制器控制表 COCT\n\n通道控制表 CHCT\n\n系统设备表 SDT\n\n设备分配步骤\n\n根据进程的物理设备名，去 SDT 找设备。\n根据 SDT 找 DCT，空闲就直接把设备分给这个进程，忙碌就把这个进程的 PCB 挂到设备等待队列中。\n根据 DCT 找到 COCT，空闲就分配，不空闲就等待。\n根据 COCT 找到 CHCT，空闲就分配，不空闲就等待。\n\n以上方法缺点在于用户要知道物理设备名，不透明；而且只指定这一个设备，如果该设备坏了或者堵塞哪怕其他设备能用也无法切换。\n可以建立逻辑设备，用逻辑设备找物理设备。\nSDT 中设备类型就是逻辑设备名。\n通过逻辑设备表 LUT 建立逻辑设备名和物理设备名之间的映射关系。\n缓冲区\n缓冲区是一个存储区域，可以用专门的硬件寄存器，也可以用内存做。速度快，成本高，容量小，比如快表。本节中介绍的主要是内存缓冲区。\n可以缓冲 CPU 和 IO 之间速度不匹配的矛盾，进而 CPU 中断次数也会减少；解决数据颗粒度不匹配的问题；提高 CPU 与 IO 的并行性。\n单缓冲区\n某用户进程请求设备读入若干个块的数据。。如果采用单缓冲策略，主存中会被分配一个缓冲区（一般是一个块大小）。缓冲区中只有空的时候才能冲入数据，只有非空的时候才能传出数据。\n\n\n双缓冲区\n一满一空，可以空的边读，满的边往工作区写。\n\n\n用时=Max(C+M, T)\n如果两台机器各配置2个缓冲区，就能同时收发了。\n循环缓冲区\n多个大小相同的缓冲区链接成一个循环队列。\n\n缓冲池\n放满了各种各样缓冲区的池子。\n\n输入：取出一个空缓冲区挂到收容输入队列中，输入放到收容输入队列中，装好了挂到输入队列中。\n提取输入：从输入队列取下来，放到提取输入队列中提取到用户进程，再挂回空缓冲区。\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["OS"]},{"title":"效率提升：Win11磁贴配置","url":"/2023/10/09/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%EF%BC%9AWin11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/","content":"前言\n最近电脑还是升级到 win11 了。我之前采用的美化方案是桌面上的图标全部移到 win10 开始菜单里的全屏菜单上，用磁贴贴一排。每次要访问文件的时候都去开始菜单里找，而不是放在桌面上，这样桌面也可以空出来欣赏壁纸。参考配置链接：如何让Windows 10系统桌面变得更好看？ - 知乎 (zhihu.com)\n但是升级到 win11 对我而言影响最大的就是压根没有全屏桌面和磁贴功能了。因此我搜了很多解决方案，加上一些自己的改进，最终把桌面磁贴恢复成如上图所示。一个自己喜欢看的桌面还是会对生产力的提高有很大帮助的。\n\n软件安装：start11\n首先，恢复开始菜单这一操作最离不开的就是 start11 这款软件。他让 win11 的开始菜单又有了全屏菜单选项，也支持了自定义磁贴在上面。虽然调整磁贴位置的时候偶尔会花几秒重启，但大多数时候还是没问题的。\n\n正版软件是免费试用的，欢迎付费支持原作者。或采用博主的同款方案：\n链接：https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru\n提取码：1fru\n–来自百度网盘超级会员V2的分享\n首先如果是按博主的磁贴方法配置，就要选“win10配置”。或者你觉得其他风格也还不错都可以选。并且 ENABLE start11.\n\n点击“配置菜单”，进行如下配置：\n\n在“自定义菜单视觉外观”里，可以设置全屏菜单的颜色、透明度等，比如我使用的是有一定透明度的毛玻璃的样式。\n\n然后在“控制”栏里设定如何打开 start11，确保可以打开：\n\n接着，点击 win 图标就可以打开全屏菜单了。\n磁贴配置\n对于大部分软件，只要右键-固定到开始屏幕/固定到 start11，就可以在全屏菜单里看到刚刚贴上的磁贴了。\n如果贴失败，可以尝试以下的方法：\n\n右键快捷方式，点击“打开文件所在位置”，再尝试把该文件的 .exe 文件固定到开始屏幕。\n反复尝试，因为可能有一定的延迟。可以取消固定再次固定，等待一会看开始菜单是否出现。\n\n然后可以手动分组磁贴（把他们移到临近的位置），调整磁贴背景色，调整磁贴大小（有小正方形，中正方形，长方形，大正方形四种可以选择），调整磁贴布局位置。\n\n图片磁贴配置\n这里是最自由发挥的部分。高情商：自由发挥。低情商：都要自己做很麻烦。\n之前 win10 是有一款快捷工具可以输入自定义图片，按自己想要的格式裁剪并自动在全屏菜单中输出的，叫 Tile Genie.\n\n但是它好像并不能在 start11 中使用。我尝试了一下导出的都是不能显示的图片块，所以只能放弃这种方法。如果读者的 Tile Genie 是没有问题可以正常显示图片那再好不过了，后面的内容都可以不用看了。\n如果导出失败……我采用的方法是手动裁剪固定图片。很笨，但是有结果。\n\n首先，自行裁剪图片，计算公式为：中正方形 150*150，长方形 306*150，大正方形 306*306，边界线是6（像素）.\n我采用的图像裁剪方法是：免费在线裁剪图像文件 (iloveimg.com)\n\n然后把导出图片找一个合适的地方存储起来，注意贴上磁贴之后就不能再移动修改这些图片了。\n在全屏菜单中右键-固定文件，选定文件路径添加。\n\n刚固定上是这种形式：\n\n然后右键-调整大小，调整为想要的大小。\n\n\n最后一步，右键-图标-选择自定义磁贴图像，再次选择此文件，然后他就被当做图标全屏显示了。\n\n","categories":["踏星逐路（创新探索）","Efficiency"],"tags":["Windows"]},{"title":"技术学习：江协科技51单片机","url":"/2023/03/31/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%B1%9F%E5%8D%8F%E7%A7%91%E6%8A%8051%E5%8D%95%E7%89%87%E6%9C%BA/","content":"软件下载\n开发：Keil。如果想要没乱码的中文注释，那么设置编码方式为 UTF8 或 GB2312。\n程序文件下载到单片机：STC/普中（STC需要冷启动，先点击下载再开启单片机电源）\n介绍\nMicro Controller Unit, MCU 单片机，其中包含了CPU RAM ROM 输入输出设备 等一系列电脑硬件常用功能。\n功能：通过传感器采集数据，通过CPU处理数据，控制硬件。\n可以说是一个性能低的小电脑，是了解计算机原理的很好的学习方法。\n右上角的跳线帽使用数码管时跳到VCC，使用点阵时跳到GND。\nSTC89C52RC 命名规则\nSTC：芯片为 STC 公司生产的产品。\n8：该芯片为 8051 内核芯片。\n9：表示内部含有 Flash EEPROM 存储器，还有如 80C51 中 0 表内部含有 MaskROM（掩模 ROM）存储器；如 87C51 中 7 表示内部含有 EPROM（紫外线可擦除 ROM）存储器。\nC–表示该器件为 CMOS 产品。还有如 89LV52 和 89LE58 中的 LV 和 LE 都表示 该芯片为低电压产品（通常为 3.3V 电压供电）；而 89S52 中 S 表示该芯片含有 可串行下载功能的 Flash 存储器，即具有 ISP 可在线编程功能。\n5–固定不变。\n2：表示该芯片内部程序存储（FLASH）空间大小，1 为 4KB，2 为 8KB，3 为  12KB，即该数乘以 4KB 就是芯片内部的程序存储空间大小。程序空间大小决定了 一个芯片所能装入执行代码的多少。一般来说，程序存储空间越大，芯片价格也 越高，所以我们再选择芯片的时候要根据自己需求选择合适芯片。 RC–STC 单片机内部 RAM（随机读写存储器）为 512B。还有如 RD+表示内部 RAM 为 1280B。还有芯片会省略此部分\n\n芯片介绍\n芯片在 PDIP 里。黑色的部分 PDIP 是一种封装方式，可能还有 LQFP 等（一个正方形的形状）封装方式。\n8051 内核基本上都是中间绿色块的样子，只是外设、封装等方式不同。\n\n管脚图：\nVcc 是电源，XTAL 管时钟，RST 是复位，等等。\n\n\n整个是一个总线结构，所有外设都挂在上面。如最下面一行左边是晶振，右边是外部引脚。\n只有这一个单片机是不能运行的，看我们的开发板上面还外接了好多好多外设呢。能让单片机运行的最小应用系统如下：\n\n三角是正极，三线符号是负极。\n首先需要 Vcc 接正，GND 接负。\n然后需要接晶振。没有晶振单片机程序无法一条条往下执行，有了晶振按照固定的周期才能一条条往下执行。晶振就是板子上银色的椭圆形的一个东西，频率写在上面，一般是有12MHz和11.多MHz的两种（有的芯片自带晶振。不过很明显我们的芯片并不自带）。\n然后还有复位电路，让程序回到第一条的位置。\n开发板介绍\n\n中间黑色的是刚刚介绍的单片机。拉起拉杆，可以取下单片机，但放回时一定不能放反。单片机有缺口的一端左侧从01开始，逆时针逐渐增大到40。\n右侧中间有8个 LED 灯，我是点灯大师！\n下面是一个矩阵按键，用户可以通过按按键输入。\n最下面一行右侧有个红外接收传感器，接收红外线的。\n左边无线模块，8个插孔的，做无线模块（如2.4G）用的。\n再左边四个独立按键。\n最左下是 USB 自动下载模块，插上 USB 线后按开关就会自动下载程序，不用了解。\nDS1302 时钟芯片，可以做一个小时钟，读取时间。\n红色按钮是 RST 按钮。\nAD/DA 模数转换器，使单片机在数字与模拟领域之间转化。\n74H595 可以扩展出更多的 IO 口。\n步进电机可以精确控制脚步（转一圈、转半圈）。比如空调会用。\n超声波模块可以测距。\n蜂鸣器模块可以放歌。但我（）（）（）（）。\n138译码器控制数码管，也可以扩展 IO 口。\n24c02 也是一种 ROM，还是 EEP ROM（掉电不丢失）。其实单片机自带的 Flash ROM 更先进，但是只能用来存储程序。\n温度传感器可以用来检测温度。\n74HC245 可以驱动数码管（我的单片机是 HC138）。\n左上角的电位器和排座用于接显示屏。电位器可以调整显示屏的亮度。\n最大的黑色方阵是一个 LED 点阵。可以点亮8*8的方阵，甚至用来做动画。\n之后的课程中还会详细介绍每一个模块，以及对应的电路图。\n逻辑运算\n&amp;与，|或，!非，⊙同或（相同结果才=1），异或⊕（不同结果才为1）\nC语言语法\nint 16位，char 8位。\n\n\n基本语法其他的都好说，再复习一下位运算。\n\n左右移补0.\n位运算符也可以参与成为复合赋值运算符，如^=, &lt;&lt;=\n逗号运算符=最后一个表达式的值\n\n函数在C语言基础上做的拓展\n重入函数\n在函数形参括号后加修饰符 reentrant，代表这个函数是重入函数，可以被递归调用，但这样就不能有bit变量，也不能进行位运算。\n中断函数\n在函数形参括号后加修饰符 interrupt m，系统编译时把对应函数转化为中断函数，自动加上程序头段和尾段，并按 51 系 统中断的处理方式自动把它安排在程序存储器中的相应位置。\n在该修饰符中，m 的取值为 0~31，对应的中断情况如下：\n0——外部中断 0\n1——定时/计数器 T0\n2——外部中断 1\n3——定时/计数器 T1\n4——串行口中断\n5——定时/计数器 T2\n其它值预留。\n外部函数\n如果要调用的函数不在本文件内，在其他文件内，定义函数时函数开头要加 extern 修饰符。\nsfr sbit\n用于定义特殊功能寄存器或特殊位。\nsfr P0=0x80;//把地址 0x80 处的寄存器定义为 P0sbit P0_1=P0^1;//取第一位定义为 P0_1\n其实头文件 regx52.h 中都有。\n能不能给位单独赋值要看是不是可位寻址。因为物理地址有限，每8个寄存器只能有一个可位寻址。\n51单片机最小系统组成\n\n晶振电路，提供时钟，相当于心脏\n复位电路，系统运行不正常时可以重启\n电源电路，注意单片机的供电电压要求\n下载电路，烧入程序\n\n另外注意，单片机的P0口是漏级开路，输出高电平会导致高阻态，因此输出高电平时要接上拉电阻，通常选择 4.7K~10K 阻值。\n程序编写前言\n新建项目 new μversion project\n选择 CPU 型号：Keil 中没有完全对应的 STC89C52 版本，用Atmel 中的 AT89C52 即可，不用把8051启动文件添加到工程中。\n\nAT 和 STC 是两种型号的单片机。有的 STC 单片机上面还有 AT 接口，AT 使用那个接口烧录程序。STC 就用 USB 下载。\n\n新建好后有一个文件夹：source group，代码文件都在其中。\n选中该文件夹，右键新建new item，新建c语言文件。可以选c/cpp/asm\n在魔术棒 Output 选项中添加 “ create HEX file&quot;.\n程序框架\n#include &quot;reg52.h&quot;void main()&#123;    while(1)    &#123;    &#125;&#125;\n编译：translate按钮\n建立：build按钮，也有编译的作用，只编译发生变动的文件。\n重新建立：rebuild，编译所有文件（速度慢不建议）。\n报错如果显示：缺少root segment根段，即没有找到主函数。\n头文件作用\n#include&lt;reg52.h&gt;和`#include “reg52.h&quot;都可以。区别在于&lt;&gt;直接去软件安装处搜索头文件，而”&quot;先在该项目下查找头文件，找不到再去软件安装处，再找不到就报错。\n查看头文件可以在左侧的结构树对应的c文件目录下打开，或者右键“reg52.h&quot; open 打开。\n该头文件中定义了52单片机内部所有功能寄存器，把地址值如0x80赋值给P0等端口。\n程序烧录\n程序编译建立没有错误，也开启了魔术棒创建 HEX 文件选项，那么 build 后就会在对应路径中找到生成的 HEX 文件。\n在 STC-ISP 中选定单片机型号、串口、晶振频率（可以直接看开发板上的晶振上面有写），选择对应的 HEX 文件，先断电开发板，再点击下载，再开机，就可以查看呈现在开发板上的效果。\nHELLO WORLD——LED部分\nLED 发光二极管。\n\n\n下面两个黑色的方块就是8个电阻。电阻是限流作用，防止电流过大烧毁 LED。\n电阻上面写着小小的“102”，代表10*10^2，即1kΩ。\n每个 LED 正极是一定通电流的，如果负极接地，那么这个 LED 被点亮。否则两头都是高电平点不亮（这里的电平是 TTL 电平，高5低0）。\n单片机如何驱动高低电平？在 MCU 内，CPU 接到指令（如P2^0口赋1，即高电平）CPU 把数据写入寄存器，寄存器数据通过驱动器放大后变为5V/0V 电平输出。\n点亮 LED\nGPIO（general purpose input output) 即通用输入输出端口，可以通过软件控制其输入和输出.\n\n\n电源引脚： Vcc， GND\n晶振引脚：XTAL1 2\n复位引脚：RST VPD，不做其他功能。\n下载引脚：TXD RXD\nGPIO引脚：Px.x的都是 GPIO 引脚，大致分为P0 P1 P2 P3，每组8个IO，P3还有附加功能，比如串口、外部中 断、计数器等。每个引脚每次只能使用一个功能。\n\n#include &quot;reg52.h&quot;sbit LED1=P2^0; //将 P2.0 管脚定义为 LED1//我们也可以直接给P2整个赋值。比如P2=0xFE，即1111 1110，就只会点亮最后一个 LED 灯，和 P2^0=0 效果是一样的。//另，我们的这种做法只是寻找特殊寄存器P2的第几位。而头文件 REGX52.H 中是真正包含所有引脚信息的，如P2_0 就是2.0引脚，也能起到一样的效果。void main()&#123;    LED1=0; //LED1 端口设置为低电平，就会被点亮    while(1)//单片机默认不断执行主程序。如果没有这个死循环，单片机就会不断点亮点亮点亮点亮……不如点亮一次之后无限延时。    &#123;    &#125;&#125;\n编译结果里面的几个数据的意义：\ncode：表示程序所占用 FLASH 的大小。\ndata：数据储存器内部 RAM 占用大小。\nxdata：数据储存器外部 RAM 占用大小。\nLED 闪烁\n只需要点亮——延时——熄灭——延时循环即可。\n单片机频率单位是 MHz 兆赫兹，所以只是单纯的亮灭亮灭肉眼看不出亮灭的效果。所以需要延时。\n延时可以写一个这样的函数：\ntypedef unsigned int u16void delay(u16 ten_us)&#123;    while(ten_us--);&#125;\nu16 代表16位的无符号整型数据。这是一个比较常用的定义，unsigned char 定义为 u8, unsigned int 定义为 u16。当 ten_us 超出 u16 的范围后，跳出 while 循环。\n然后就LED1=0;delay(50000);LED1=1;delay(50000);循环即可.\n但是，STC-ISP 可以根据晶振频率和要延时的时间生成延时函数，真的牛！不过注意软件上标明的适用系列版本。\n\n其中 _nop_() 函数包括在 INTRINS.H 头文件中，是一个空语句，就只会产生延时的效果。\n不过 STC-ISP 只能生成固定时长的延时函数。如果想要像自己写的那个 delay() 函数一样传入参数，延时对应长度的毫秒/微秒呢？\n很简单，我们先生成延时1毫秒/微秒的函数，然后把函数中的内容重复执行传入参数遍。\nvoid Delay1ms(unsigned int xms)\t\t//@11.0592MHz&#123;\tunsigned char i, j; \twhile(xms--)&#123;//这里是修改过的        _nop_();        _nop_();        _nop_();        i = 11;        j = 190;        do        &#123;            while (--j);        &#125; while (--i);     &#125;&#125;\nKeil 软件仿真\n使用仿真功能查看 LED 闪烁案例中的实际延时时间。\n\n点击魔术棒，选择 Target 选项卡，设置 Xtal 为12M或11.0592M，根据开发板晶振修改对应值。\n点击黑色放大镜中有红色d的仿真按钮，进入仿真页面\n\n\n我们要关注的参数是sec。\n\n点击RST按钮重新复位系统参数，sec 变为0。然后在要调试的行前双击，就会出现红色块的断点，点击8运行时就会直接运行到断点处。再次点击就会运行到下一处断点处。\n点击红色标记8运行，运行到36行时显示用时：0.00039s，再次点击运行到37行，用时：0.45s\n可见delay花费时间约为0.45s\n\nLED 流水灯\n学会了点亮和延时，流水灯的原理就很好懂了。就是给P2的所有端口赋值为：1111 1110，每次只有一个为0即点亮，这个点亮的0从最高位逐渐降到最低位。\n取反后即为：\n1000 0000\n0100 0000\n0010 0000\n0001 0000\n0000 1000\n0000 0100\n0000 0010\n0000 0001\n也就是一个移位运算，0x01&lt;&lt;i的循环。\n#include &quot;reg52.h&quot;# define LED P2void delay(unsigned int i)&#123;\twhile(i--)&#123;&#125;&#125;void main()&#123;    while(1)    &#123;\t\t\tint i=0;\t\t\tfor(i;i&lt;8;i++)&#123;\t\t\t\tLED=~(0x01&lt;&lt;i);\t\t\t\tdelay(50000);\t\t\t&#125;    &#125;&#125;\n移位函数\n位运算的移位操作只能补0，但是 Keil C51 软件内有对应的移位库函数，左移_crol_()，右移_cror_()，包含在 intrins.h 库中。\n移位函数会把移出去的位补到空位，一个循环。\n#include &quot;reg52.h&quot;#include &quot;intrins.h&quot;# define LED P2void delay(unsigned int i)&#123;\twhile(i--)&#123;&#125;&#125;void main()&#123;    LED=~(0x01);\tdelay(50000);    while(1)    &#123;\t\t\tLED=_crol_(LED,1);\t\t\tdelay(50000);    &#125;&#125;\n蜂鸣器实验\n蜂鸣器简单地说，就是电磁线圈和磁铁对振动膜的作用。\n单片机的是无源蜂鸣器，不能一直充电，需要外部控制器发送震荡信号，可以改变频率产生不同的音色、音调。\n大多数有源蜂鸣器则没有这个效果，有源蜂鸣器外观与之相同，内部自带震荡源，接上电就能响，但不能改变频率。\n\n我们知道三极管的作用是不用单片机自己直接驱动单片机。\n另一种方法是步进电机。\n\nULN 2003，高电压 高电流驱动器，给信号就被驱动。IN 取反输出 OUT。\n简谱\n\n首先整个谱大概分为几个区。大字组、小字组、小字1组、小字2组。每个组之间差8度，每相邻的两个键（如黑白）差半音，相邻的两个同色键差一个全音。\n几个白键的表示方法就是下面的简谱，差半音的黑键用左上角的#表示升半音，b表示降半音。\n演奏两大要素：音高和时值。\n\n谱上一个数字是1/4 音符，二分是其两倍，数字加个横线 - 。全音符就是（2 - - -）。这个线叫增时线。\n八分是其1/2，数字下加一条线（2）.再/2就再加一条，叫减时线。\n试着识一个完整的谱：\n\n4/4：以四分音符为一拍，每小节有四拍。\n第二节 $\\dot{1}$ · 上面的点我们知道代表高音，后面的点代表：前一位音符延长1/2长度，即四分音符+1/2的四分音符。也就是3/8哈哈哈。\n看第一节，一般连着两个八分音符就把 underline 连起来。但是这种哪怕是一个音，中间也要先断开再重响。比如右上角的3 3。\n升音和降音在本小节中有效。如第三行的 7 #4 4 7 ，两个4都是升音。\n不过如果顶端画了延音线，就是连起来的不用断开。如中间的 $\\widehat{7 7}$，拆开写是为了好读谱。\n接下来就是如何把谱转化为单片机代码。左上角 1=c 说明是c调的。d大调会出现黑键，c调只有白键。\n\n音具体是怎么定义的？首先以中音a为基准，高音a是其2倍，低音a是其1/2。\n中间每次升音都是等比数列递增的，即*2的1/12次方\n使用蜂鸣器\n响起来很简单：不断反转 P1^5 口（是不是这个口得看自己的板子型号）。\nvoid main()&#123;\tu16 i=2000;//决定时值\twhile(1)&#123;\t\twhile(i--)\t\t&#123;\t\t\tBEEP=!BEEP;\t\t\tdelay10Us(100);//决定音高\t\t&#125;        i=2000;        BEEP=0;\t&#125;&#125;\n时值还好确认，音高怎么说？\n首先我们有上图的音符与频率对照表。我们把频率转化为周期，即1/频率。这里周期单位是us。\n\n然后周期时长转化为机器周期，即记一个数需要的时间。我们看看需要多少机器周期。\n1机器周期=12时钟周期，时钟周期=1/单片机晶振。比如对于我的11.0592MHZ 晶振，机器周期=12/11.0592MHZ （单位：us）。\n据此把“需要切换的周期时长”转化为“需要切换的周期需要执行几次指令”。即周期/机器周期。如果是12MHZ 晶振这一步相当于没有。\n\n然后电平从低到高，从高到低才是一个周期。所以实际电平反转一次的周期是周期的一半。\n\n我们知道定时器原理是 TH TL 加至65536触发中断。因此重装载值（定时器初值）=65536-取整值。\n\n\n\n音符\n频率\n周期\n需要的机器周期数\n需要的机器周期数/2\n取整\n重装载值\n\n\n\n\n1\n262\n3816.794\n3517.557252\n1758.778626\n1759\n63777\n\n\n1#\n277\n3610.108\n3327.075812\n1663.537906\n1664\n63872\n\n\n2\n294\n3401.361\n3134.693878\n1567.346939\n1567\n63969\n\n\n2#\n311\n3215.434\n2963.344051\n1481.672026\n1482\n64054\n\n\n3\n330\n3030.303\n2792.727273\n1396.363636\n1396\n64140\n\n\n4\n349\n2865.33\n2640.687679\n1320.34384\n1320\n64216\n\n\n4#\n370\n2702.703\n2490.810811\n1245.405405\n1245\n64291\n\n\n5\n392\n2551.02\n2351.020408\n1175.510204\n1176\n64360\n\n\n5#\n415\n2409.639\n2220.722892\n1110.361446\n1110\n64426\n\n\n6\n440\n2272.727\n2094.545455\n1047.272727\n1047\n64489\n\n\n6#\n466\n2145.923\n1977.682403\n988.8412017\n989\n64547\n\n\n7\n494\n2024.291\n1865.587045\n932.7935223\n933\n64603\n\n\n1\n523\n1912.046\n1762.141491\n881.0707457\n881\n64655\n\n\n1#\n554\n1805.054\n1663.537906\n831.7689531\n832\n64704\n\n\n2\n587\n1703.578\n1570.017036\n785.0085179\n785\n64751\n\n\n2#\n622\n1607.717\n1481.672026\n740.8360129\n741\n64795\n\n\n3\n659\n1517.451\n1398.482549\n699.2412747\n699\n64837\n\n\n4\n698\n1432.665\n1320.34384\n660.1719198\n660\n64876\n\n\n4#\n740\n1351.351\n1245.405405\n622.7027027\n623\n64913\n\n\n5\n784\n1275.51\n1175.510204\n587.755102\n588\n64948\n\n\n5#\n831\n1203.369\n1109.025271\n554.5126354\n555\n64981\n\n\n6\n880\n1136.364\n1047.272727\n523.6363636\n524\n65012\n\n\n6#\n932\n1072.961\n988.8412017\n494.4206009\n494\n65042\n\n\n7\n988\n1012.146\n932.7935223\n466.3967611\n466\n65070\n\n\n1\n1046\n956.0229\n881.0707457\n440.5353728\n441\n65095\n\n\n1#\n1109\n901.7133\n831.018936\n415.509468\n416\n65120\n\n\n2\n1175\n851.0638\n784.3404255\n392.1702128\n392\n65144\n\n\n2#\n1245\n803.2129\n740.2409639\n370.1204819\n370\n65166\n\n\n3\n1318\n758.7253\n699.2412747\n349.6206373\n350\n65186\n\n\n4\n1397\n715.8196\n659.6993558\n329.8496779\n330\n65206\n\n\n4#\n1480\n675.6757\n622.7027027\n311.3513514\n311\n65225\n\n\n5\n1568\n637.7551\n587.755102\n293.877551\n294\n65242\n\n\n5#\n1661\n602.047\n554.846478\n277.423239\n277\n65259\n\n\n6\n1760\n568.1818\n523.6363636\n261.8181818\n262\n65274\n\n\n6#\n1865\n536.193\n494.155496\n247.077748\n247\n65289\n\n\n7\n1976\n506.0729\n466.3967611\n233.1983806\n233\n65303\n\n\n\n使用方法：TH=重装载值/256，TL=重装载值%256.\n音高从低到高逐位响起代码：\n#include &quot;reg52.h&quot;#include &quot;Delay.h&quot;#include &quot;Timer0.h&quot;sbit beep=P1^5;unsigned int beep_table[]=&#123;//可以加个0代表不响的0\t63777,63872,63969,64054,64140,64216,64291,64360,64426,64489,64547,64603,\t64655,64704,64751,64795,64837,64876,64913,64948,64981,65012,65042,65070,\t65095,65120,65144,65166,65186,65206,65225,65242,65259,65274,65289,65303\t&#125;;unsigned char beep_select=0;void main()&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \tunsigned char i;\ttimer0Init();\twhile(1)&#123;\t\tbeep_select++;\t\tdelayMs(50);//时值\t\t\t&#125;&#125;void timer0Interrupt() interrupt 1&#123;    TH0 = beep_table[beep_select]/256; // 因为触发中断时，TH TL 归零，所以记得赋初值！    TL0 = beep_table[beep_select]%256;\tbeep=!beep;&#125;\n编曲：\n\n根据乐谱写一个数组。\nunsigned int little_star[]=&#123;12, 12, 19, 19,                            21, 21, 19,    //增时线                            17, 17, 16, 16,                            14, 14, 12,                            19, 19, 17, 17,                            16, 16, 14,                            19, 19, 17, 17,                            16, 16, 14,                            12, 12, 19, 19,                            21, 21, 19,                             17, 17, 16, 16,                            14, 14, 12                           &#125;;\n遍历数组，得到的音高再去 beep_table 中获取重装载值。\nTH0 = beep_table[little_star[beep_select]]/256; // 因为触发中断时，TH TL 归零，所以记得赋初值！TL0 = beep_table[little_star[beep_select]]%256;\n但是播放起来都是连着的，听起来效果并不好。可以每次播完一个音先关闭中断并延时一段时间，再继续播放。\nwhile(1)&#123;\t\tbeep_select++;\t\tdelayMs(50);\t\tTR0=0;\t\tdelayUs(1);\t\tTR0=1;\t\t\t&#125;\n増时线如何处理？中间是不断开一直想的，因此需要几个特定的音符delay时间更长一些。怎么区分哪些音符加长哪些不加呢？\n最好还是存储乐谱时搞一个二维数组（逻辑上物理上都可以），既能存储音高，也能存储时值。\nunsigned int little_star[]=&#123;12, 4,                            12, 4,                            19, 4,                            19, 4,                            21, 4,                            21, 4,                            19, 8,  //增时线                            17, 4,                            17, 4,                            16, 4,                            16, 4,                            14, 4,                            14, 4,                            12, 8,                            19, 4,                            19, 4,                            17, 4,                            17, 4,                            16, 4,                            16, 4,                            14, 8,                            19, 4,                            19, 4,                            17, 4,                            17, 4,                            16, 4,                            16, 4,                            14, 8,                            12, 4,                            12, 4,                            19, 4,                            19, 4,                            21, 4,                            21, 4,                            19, 8,                            17, 4,                            17, 4,                            16, 4,                            16, 4,                            14, 4,                            14, 4,                            12, 8,                            0xFF,4//终止标志防越界                           &#125;;\n如果数组大小超限，在魔术棒-Target-Memory Model 中选择第三个。不过这只是治标不治本，因为 RAM 只有512字节所以存不下太长。可以在定义数组时加上关键词 code 来存在 ROM 8K 的闪存中。不过这样的数组是只读的。\n当然这样找索引比较麻烦。最好是索引全部重新宏定义。\n//音符与索引对应表，P：休止符，L：低音，M：中音，H：高音，下划线：升半音符号##define P\t0#define L1\t1#define L1_\t2#define L2\t3#define L2_\t4#define L3\t5#define L4\t6#define L4_\t7#define L5\t8#define L5_\t9#define L6\t10#define L6_\t11#define L7\t12#define M1\t13#define M1_\t14#define M2\t15#define M2_\t16#define M3\t17#define M4\t18#define M4_\t19#define M5\t20#define M5_\t21#define M6\t22#define M6_\t23#define M7\t24#define H1\t25#define H1_\t26#define H2\t27#define H2_\t28#define H3\t29#define H4\t30#define H4_\t31#define H5\t32#define H5_\t33#define H6\t34#define H6_\t35#define H7\t36\n数码管\n动态数码管原理是什么？首先我们知道每个数码管都有 abcdefg 七个段。\n8个数码管那我们按理来说是需要8*7个引脚，很浪费。\n于是设计了动态数码管。首先所有数码管是共阴极的。然后我们选中哪一个数码管阴极赋0，就会启动哪一个数码管，传入的 abcdefg 就会点亮该数码管的对应段。\n然后8个数码管像流水灯一样，以极高频率依次点亮，肉眼看到的就是8个数码管都被点亮且呈现出不同的图案。\n\n开发板上的数码管是共阴极数码管，所有位共接一个阴极，给对应ABCDEF输入高电平点亮。\n直接引脚：\n\n\n74译码器使用3位 bit 输入表示8种状态，调整 LED1~8 哪一个输出低电平，代表要启动8个数码管的哪一个的公共端。\n输入的三位从最低位到最高位分别是P2^2, P2^3, P2^4，代表数码管从左到右的第几位是输入取反。\n比如P2^4=1, P2^3=1, P2^2=0, 输入就是110，取反后就是001，就是从左到右第1位数码管（从第0位开始）。\nVCC 和 GND 是使能，接到译码器上一上电就工作。\n\nP00~P07 代表控制当前数码管的 a~g 显示形式，接到 74HC245 缓冲器上而不是直接接到数码管上，使得单片机不用直接驱动数码管，Ai 连到 Bi 上。\nOE 是使能，接地工作不接地不工作的原理。\nDIR 是规定方向，高电平从左边读取数据传输到右边。低电平从右边读数据到左边。开发板上有个 J21 跳线帽，可以调整是 GND 与 LE 相连还是 VCC 与 LE 相连，也就是高电平输入 DIR 还是低电平输入 DIR。\n数码管上面的 COM 是公共端，选中哪一个公共端（使得其=0，因为是共阴极）就是调整哪一个数码管的点亮方式。\n点亮一位数码管代码：\n#include &quot;reg52.h&quot;#define Display P0 unsigned char display_code[17]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71&#125;;/*具体显示什么图案是怎么推算出来的呢？首先 abcdefg 和 dp 小数点段一共有8个要控制的段。比如我们要呈现数字6，就是 acdefg 亮，b和小数点不亮。因为数码管是共阴极，所以我们想让哪个段亮哪个段就输入高电平，和 LED 相反。所以P00~P07 的输入应该是 1011 1110然后我们直接给 P0 赋值的话，是 P0_7 在最高位，P0_0 在最低位，所以输入应该正好反过来，0111 1101，即0x7d。*/void main()&#123;    Display=display_code[0];    while(1)    &#123;&#125;&#125;\n#define SMG_A_DP_PORT P0 //使用宏定义数码管段码口sbit LSA=P2^2;sbit LSB=P2^3;sbit LSC=P2^4;for(i=0;i&lt;8;i++)&#123;    //这个程序是从左到右显示12345678.当然完全也可以把确定哪一位数码管和确定要显示的数字封装成一个函数，点亮会更方便。\t\tswitch(i)&#123;\t\t\tcase 0: LSC=1;LSB=1;LSA=1;break;//从左往右第0个数码管\t\t\tcase 1: LSC=1;LSB=1;LSA=0;break;\t\t\tcase 2: LSC=1;LSB=0;LSA=1;break;\t\t\tcase 3: LSC=1;LSB=0;LSA=0;break;\t\t\tcase 4: LSC=0;LSB=1;LSA=1;break;\t\t\tcase 5: LSC=0;LSB=1;LSA=0;break;\t\t\tcase 6: LSC=0;LSB=0;LSA=1;break;\t\t\tcase 7: LSC=0;LSB=0;LSA=0;break;\t\t\tbreak;\t\t&#125;\t\tSMG_A_DP_PORT=gsmg_code[i];\t\tdelay_10us(100);\t\tSMG_A_DP_PORT=0x00;//消影    //为什么要消影？ 不延时的话动态数码管会反复重复 位选 段选 位选 段选……位选之后不一定及时段选，可能前一位的位选就会赋给后一位。因此需要消影。&#125;\n我们这种动态数码管扫描方式是单片机直接扫描，硬件会简单很多，但是会占据大量的 CPU 时间。有的动态数码管自带显存和扫描电路，只要告诉他要显示什么他会自动扫描显示。\n按键\n内部有一个金属片，按下后电路接通。\n\n和学习 LED 时类似，所有 IO 口一开始都是高电平，我们给其接地就变成低电平了。\n按下按键后一段时间内电平会高低抖动。\n\n1，先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻，所以默认 IO 为高 电平）。\n2，读取 IO 口电平确认是否有按键按下。\n3，如有 IO 电平为低电平后，延时几个毫秒。\n4，再读取该 IO 电平，如果仍然为低电平，说明按键按下。\n5，执行按键控制程序。\n#include &quot;reg52.h&quot;typedef unsigned int u16; //对系统默认数据类型进行重定义typedef unsigned char u8;//定义独立按键控制脚sbit KEY1=P3^1;sbit KEY2=P3^0;sbit KEY3=P3^2;sbit KEY4=P3^3;//定义 LED1 控制脚sbit LED1=P2^0;sbit LED2=P2^1;sbit LED3=P2^2;sbit LED4=P2^3;//使用宏定义独立按键按下的键值#define KEY1_PRESS 1#define KEY2_PRESS 2#define KEY3_PRESS 3#define KEY4_PRESS 4#define KEY_UNPRESS 0void delay_10us(u16 ten_us)&#123;while(ten_us--);&#125;u8 key_scan(u8 mode)&#123;\tstatic u8 key=1;\tif(mode)key=1;//连续扫描按键\tif(key==1&amp;&amp;(KEY1==0||KEY2==0||KEY3==0||KEY4==0))//任意按键按下\t&#123;\t\tdelay_10us(1000);//10ms 消抖        /*另一种消抖的方法：        if(KEY==0)&#123;        \tdelay_ms(20);        \twhile(KEY==0);        \tdelay(20ms);        &#125;        这个是针对按下按钮又抬起按钮之后的执行。*/\t\tkey=0;\t\tif(KEY1==0)\t\treturn KEY1_PRESS;\t\telse if(KEY2==0)\t\treturn KEY2_PRESS;\t\telse if(KEY3==0)\t\treturn KEY3_PRESS;\t\telse if(KEY4==0)\t\treturn KEY4_PRESS;\t&#125;\telse if(KEY1==1&amp;&amp;KEY2==1&amp;&amp;KEY3==1&amp;&amp;KEY4==1) //无按键按下\t&#123;\t\tkey=1;\t&#125;\treturn KEY_UNPRESS;&#125;void main()&#123;\tu8 key=0;\twhile(1)\t&#123;\t\tkey=key_scan(0);\t\tif(key==KEY1_PRESS)//检测按键 K1 是否按下\t\tLED1=!LED1;//LED1 状态翻转\t\tif(key==KEY2_PRESS)//检测按键 K2 是否按下\t\tLED2=!LED2;//LED1 状态翻转\t\tif(key==KEY3_PRESS)//检测按键 K3 是否按下\t\tLED3=!LED3;//LED1 状态翻转\t\tif(key==KEY4_PRESS)//检测按键 K4 是否按下\t\tLED4=!LED4;//LED1 状态翻转\t&#125;&#125;\n矩阵按键\n为了减少 IO 口的占用，用4个 IO 口代表行，4个 IO 口代表列。\n类似动态数码管快速扫描实现几乎同时点亮的效果，矩阵键盘也是快速扫描。\n\n主要有两种扫描方法\n行列式扫描法：每次给某一列赋值为0，然后检测这一列有无按钮按下。\n​\t按行扫描：通过设置 P17 16 15 14 中的一个为低电平来选择扫描哪一行。根据 P10 P11 P12 P13 的输入判断是哪一列。但是 \tP15 口是蜂鸣器，不断反转会响。所以最好还是用按列扫描。\n线翻转扫描方法：给所有列赋1，给所有行赋0，先判断在哪一行；然后用同样的方法判断在哪一列。\n这里有一点问题就是：本单片机是准双向口输出，每个口既能做输入也能做输出而不用重新配置口线输出状态。其实这样相当于单片机一个引脚输出高电平，直接与另一个为低电平的引脚相连接。不会短路吗？\n单片机的处理方法是这样的：内部 VCC 电源还附带一个下拉电阻。低电平的驱动力比高电平强，高电平直接接低电平就会被变为低电平，而不会短路。\n#include &quot;reg52.h&quot;typedef unsigned int u16; //对系统默认数据类型进行重定义typedef unsigned char u8;#define KEY_MATRIX_PORT P1 //使用宏定义矩阵按键控制口#define SMG_A_DP_PORT P0 //使用宏定义数码管段码口//共阴极数码管显示 0~F 的段码数据u8 gsmg_code[17]=&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x71&#125;;void delay_10us(u16 ten_us)&#123;    while(ten_us--);&#125;u8 key_matrix_ranks_scan(void)&#123;    u8 key_value=0;    KEY_MATRIX_PORT=0xf7;//1111 0111 给第一列也就是 P1_3 赋值 0，其余全为 1    if(KEY_MATRIX_PORT!=0xf7)//判断第一列按键是否按下    &#123;        delay_10us(1000);//消抖。因为这里用了类似动态数码管的循环扫描的方法。        switch(KEY_MATRIX_PORT)//保存第一列按键按下后的键值        &#123;            case 0x77: key_value=1;break;//0111 0111            case 0xb7: key_value=5;break;//1011 0111            case 0xd7: key_value=9;break;//1101 0111            case 0xe7: key_value=13;break;//1110 0111        &#125;    &#125;    while(KEY_MATRIX_PORT!=0xf7);//等待按键松开    KEY_MATRIX_PORT=0xfb;//给第二列赋值 0，其余全为 1    if(KEY_MATRIX_PORT!=0xfb)//判断第二列按键是否按下    &#123;        delay_10us(1000);//消抖        switch(KEY_MATRIX_PORT)//保存第二列按键按下后的键值        &#123;            case 0x7b: key_value=2;break;            case 0xbb: key_value=6;break;            case 0xdb: key_value=10;break;            case 0xeb: key_value=14;break;        &#125;    &#125;    while(KEY_MATRIX_PORT!=0xfb);//等待按键松开    KEY_MATRIX_PORT=0xfd;//给第三列赋值 0，其余全为 1    if(KEY_MATRIX_PORT!=0xfd)//判断第三列按键是否按下    &#123;        delay_10us(1000);//消抖        switch(KEY_MATRIX_PORT)//保存第三列按键按下后的键值        &#123;            case 0x7d: key_value=3;break;            case 0xbd: key_value=7;break;            case 0xdd: key_value=11;break;            case 0xed: key_value=15;break;        &#125;    &#125;    while(KEY_MATRIX_PORT!=0xfd);//等待按键松开    KEY_MATRIX_PORT=0xfe;//给第四列赋值 0，其余全为 1    if(KEY_MATRIX_PORT!=0xfe)//判断第四列按键是否按下    &#123;        delay_10us(1000);//消抖        switch(KEY_MATRIX_PORT)//保存第四列按键按下后的键值        &#123;            case 0x7e: key_value=4;break;            case 0xbe: key_value=8;break;            case 0xde: key_value=12;break;            case 0xee: key_value=16;break;        &#125;    &#125;    while(KEY_MATRIX_PORT!=0xfe);//等待按键松开    return key_value;&#125;u8 key_matrix_flip_scan(void)//另一种扫描方式，这个函数暂时没有投入使用&#123;    static u8 key_value=0;    KEY_MATRIX_PORT=0x0f;//给所有行赋值 0，列全为 1    if(KEY_MATRIX_PORT!=0x0f)//判断按键是否按下    &#123;        delay_10us(1000);//消抖        if(KEY_MATRIX_PORT!=0x0f)        &#123;            //测试列            KEY_MATRIX_PORT=0x0f;            switch(KEY_MATRIX_PORT)//保存行为 0，按键按下后的列值            &#123;                case 0x07: key_value=1;break;                case 0x0b: key_value=2;break;                case 0x0d: key_value=3;break;                case 0x0e: key_value=4;break;            &#125;            //测试行            KEY_MATRIX_PORT=0xf0;            switch(KEY_MATRIX_PORT)//保存列为 0，按键按下后的键值            &#123;                case 0x70: key_value=key_value;break;                case 0xb0: key_value=key_value+4;break;                case 0xd0: key_value=key_value+8;break;                case 0xe0: key_value=key_value+12;break;            &#125;            while(KEY_MATRIX_PORT!=0xf0);//等待按键松开        &#125;    &#125;    else    key_value=0;\treturn key_value;&#125;void main()&#123;    u8 key=0;    while(1)    &#123;        key=key_matrix_ranks_scan();        if(key!=0)        SMG_A_DP_PORT=gsmg_code[key-1];//得到的按键值减 1 换算成数组下标    &#125;&#125;\nIO 扩展(串转并)-74HC595\n前面接的一些输入输出设备都是直接连接的单片机 IO 口，单片机仅有的 IO 口非常有限。而使用 IO 扩展可以大量增加可使用的端口。比如后面要使用的 LED 点阵，8*8个格子，使用扩展 IO 输入就更为合适。如果多级联一个，就又有了8位输出，能实现16*16的点阵。\n\n由图可知，OE 低电平有效，因此 LED 点阵旁的跳线帽一定要接到 OE-GND 一端。\n74HC595 是一个位移缓存器，有8位串行输入、并行输出，并行输出是三态输出（高电平、低电平、高阻抗）。比如一次输入一个比特，输入八次，并行输出可以输出一个8位的字 1010 1010.\n输出是由 VCC 驱动的，原理有那么一点像三极管。因为单片机内部是弱上拉，输出不足以点亮 LED 点阵，所以抛开 IO 口不够的问题，也不能直接接到 LED 点阵上，至少要有三极管。\n点亮 LED 点阵\n\n\n传入数据如列是0100 0000，行是0000 0001，则代表最后一行第二列的点会被点亮。\nSRCLK：移位寄存器，数据先传输到移位寄存器中。移位寄存器上升沿时移位，再接收下一次数据。\nRCLK：存储寄存器。存储寄存器上升沿时把寄存器中所有数据都通过端口输出。\n相当于手枪，每次 SRCLK 上升时我们填入一枚子弹，RCLK 上升时把弹夹塞入。\nQH 是级联用的。\n列数据直接输入引脚，行数据输入 IO 拓展。\n#include &quot;reg52.h&quot;//编写程序先定义管脚和端口。管脚用sbit，端口宏定义#define LED_MATRIX P0sbit SRCLK=P3^6;//因为 RCLK 是关键字不能被复用了sbit rCLK=P3^5;sbit SER=P3^4;unsigned char hc_led_arr[8]=&#123;0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80&#125;;void delay(int i)&#123;while(i--);&#125;void hc_write_data(unsigned char c)&#123;\t//要传入8个输入，需要循环\tint i=0;\tfor(i;i&lt;8;i++)&#123;\t\t//注意 芯片传数据先传高位 再传低位，所以要反着写。这个问题在write函数内部解决，传入的数据和想要的形式一样就好。\t\t//通过移位获取\t\tSER=c&gt;&gt;7;\t\t//想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿\t\tSRCLK=0;\t\t//芯片一般给定一个延时时间，经过这个时间之后才能处理完毕\t\tdelay(1);\t\tSRCLK=1;\t\tdelay(1);\t\t//让传入数据的次高位变为下次循环的高位\t\tc&lt;&lt;=1;\t&#125;\t//最后通过存储寄存器的上升沿，传输全部数据\trCLK=0;\tdelay(1);\trCLK=1;&#125;void main()&#123;\tLED_MATRIX=0x00;\twhile(1)&#123;\t\t int i=0;\t\t for(i;i&lt;8;i++)&#123;\t\t \thc_write_data(0x00);//消隐\t\t \thc_write_data(hc_led_arr[i]);\t\t\tdelay(500000);\t\t &#125;\t&#125;&#125;\n比如0000 0001，传入LED阵列的数据是：每轮循环传入最高位的值，并且所有数据向左移动一位。因此前7轮 SER 传入都是0，最后一轮 SER 传入1，最下面一行全亮。\nLED 点阵实验\n上面的方法只能确定某一具体的行被点亮。可不可以具体确定哪些点点亮的方法？\n我们让想被点亮的点列为低电平，行为高电平，就会被点亮。如果我们只想点亮第一行第一列的点，只需行脚只有第一行接高电平，列脚只有第一列接低电平即可。\n所以只要先让第一列为低电平，其他列为高天平来只读取第一列，遍历所有行检查第一列哪些点应该被点亮；然后第二列，第三列……一次类推，每轮循环不用消除上次的结果即可。\n#include &quot;reg52.h&quot;//编写程序先定义管脚和端口。管脚用sbit，端口宏定义#define LED_MATRIX P0sbit SRCLK=P3^6;sbit rCLK=P3^5;sbit SER=P3^4;unsigned char hc_led_arr[8]=&#123;0x38,0x7C,0x7E,0x3F,0x3F,0x7E,0x7C,0x38&#125;;unsigned char col[8]=&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;;void delay(int i)&#123;while(i--);&#125;void hc_write_data(unsigned char c)&#123;\t//要传入8个输入，需要循环\tint i=0;\tfor(i;i&lt;8;i++)&#123;\t\t//注意 芯片传数据先传高位 再传低位，所以要反着写\t\t//通过移位获取\t\tSER=c&gt;&gt;7;\t\t//想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿\t\tSRCLK=0;\t\t//芯片一般给定一个延时时间，经过这个时间之后才能处理完毕\t\tdelay(1);\t\tSRCLK=1;\t\tdelay(1);\t\t//让传入数据的次高位变为下次循环的高位\t\tc&lt;&lt;=1;\t&#125;\t//最后通过存储寄存器的上升沿，传输全部数据\trCLK=0;\tdelay(1);\trCLK=1;&#125;void main()&#123;\tLED_MATRIX=0x00;\twhile(1)&#123;\t\t int i=0;\t\t for(i;i&lt;8;i++)&#123;\t\t \tLED_MATRIX=col[i];\t\t \thc_write_data(hc_led_arr[i]);             //不知道为什么，下面两部分不写图形会偏移。不知道会不会有大佬解答一下\t\t\tdelay(100);\t\t\thc_write_data(0x00);\t\t &#125;\t&#125;&#125;\n点阵的具体图案生成方法：字模提取软件。\n\n步进电机\n电脉冲信号转化为角位移。\n**注意步进电机红色线接到5V的地方。**以下程序意为：启动步进电机后，按按钮1旋转方向改变，按按钮2加速，按按钮3减速。\n#include &quot;reg52.h&quot;typedef unsigned int u16;typedef unsigned char u8;sbit IN1_A=P1^0;sbit IN2_B=P1^1;sbit IN3_C=P1^2;sbit IN4_D=P1^3;//定义独立按键控制脚sbit KEY1=P3^1;sbit KEY2=P3^0;sbit KEY3=P3^2;sbit KEY4=P3^3;//使用宏定义独立按键按下的键值#define KEY1_PRESS 1#define KEY2_PRESS 2#define KEY3_PRESS 3#define KEY4_PRESS 4#define KEY_UNPRESS 0#define STEPMOTOR_MINSPEED 1#define STEPMOTOR_MAXSPEED 5void delay(u16 ten_us)&#123;\twhile(ten_us--);&#125;void step_motor_28BYJ48_send_pulse(u8 step,u8 dir)&#123;\tu8 temp=step;\tif(dir==0)temp=7-step;//逆时针旋转\tswitch(temp)//8 个节拍控制：A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA\t&#123;\t\tcase 0: IN1_A=1;IN2_B=0;IN3_C=0;IN4_D=0;break;\t\tcase 1: IN1_A=1;IN2_B=1;IN3_C=0;IN4_D=0;break;\t\tcase 2: IN1_A=0;IN2_B=1;IN3_C=0;IN4_D=0;break;\t\tcase 3: IN1_A=0;IN2_B=1;IN3_C=1;IN4_D=0;break;\t\tcase 4: IN1_A=0;IN2_B=0;IN3_C=1;IN4_D=0;break;\t\tcase 5: IN1_A=0;IN2_B=0;IN3_C=1;IN4_D=1;break;\t\tcase 6: IN1_A=0;IN2_B=0;IN3_C=0;IN4_D=1;break;\t\tcase 7: IN1_A=1;IN2_B=0;IN3_C=0;IN4_D=1;break;\t\tdefault:break;\t&#125;&#125;u8 key_scan(u8 mode)&#123;\tstatic u8 key=1;\tif(mode)key=1;//连续扫描按键\tif(key==1&amp;&amp;(KEY1==0||KEY2==0||KEY3==0||KEY4==0))//任意按键按下\t&#123;\tdelay(1000);//消抖\tkey=0;\tif(KEY1==0)\treturn KEY1_PRESS;\telse if(KEY2==0)\treturn KEY2_PRESS;\telse if(KEY3==0)\treturn KEY3_PRESS;\telse if(KEY4==0)\treturn KEY4_PRESS;\t&#125;\telse if(KEY1==1&amp;&amp;KEY2==1&amp;&amp;KEY3==1&amp;&amp;KEY4==1) //无按键按下\t&#123;\tkey=1;\t&#125;\treturn KEY_UNPRESS;&#125;void main()&#123;\tu8 key=0;\tu8 dir=0;\tu8 speed=STEPMOTOR_MAXSPEED;\tu8 step=0;\twhile(1)&#123;\t\tkey=key_scan(0);\t\tswitch(key)\t\t&#123;\t\t\tcase KEY1_PRESS:dir=!dir;break;\t\t\tcase KEY2_PRESS:if(speed&gt;STEPMOTOR_MINSPEED)speed-=1;break;\t\t\tcase KEY3_PRESS:if(speed&lt;STEPMOTOR_MAXSPEED)speed+=1;break;\t\t\tdefault:break;\t\t&#125;\t\tstep_motor_28BYJ48_send_pulse(step++,dir);\t\tstep%=8;\t\tdelay(speed*1000);\t&#125;&#125;\n中断\n使单片机能对外部或者内部随机发生的事件实时处理。\n分时操作，实时响应，可靠性高。\n中断相应条件：首先我们要确保相关配置都准备好了，CPU 允许中断，中断源允许中断，然后发生中断事件时才会正确触发中断。\n中断可能还会被优先级更高的中断打断，支持这种操作的系统叫多级中断系统。\nSTC89C52 有8个中断，4外部，3定时器，1串口。\n\n这是传统51单片机定时器中断结构，原理与 STC89C52 相近。\n\n通过配置寄存器控制线路连接。比如上图中的开关就是由寄存器控制。\nEA ENABLE ALL：即使能所有中断。\nET：中断允许位。\nPT：中断优先级。只有一个 PT 只能决定是高或低两种优先级。更多的中断优先级寄存器可以决定更多中断优先级。\nTCON 部分： time controller，不属于 CPU 部分，等到定时器部分展开叙述。\n代码编写：主程序中需要包含：\nEA=1;//总中断开关：打开EX0=1;//外部中断0开关：打开。IT0=0/1;//外部中断触发方式的选择。如下降沿触发，或低电平触发。//如果要配置外部中断1，则改为EX1和IT1//中断服务函数void int0() interrupt 0 using 1//using 1 可省略&#123;    &#125;\n定时器中断实验\n本章利用单片机自带的定时器来实现之前做过的操作：LED灯间歇闪烁。一直以来实现的方法都是借助while循环来拖延时间。定时器不仅更加准确，还可以节省下 CPU 的资源。\nSTC89C52 有3个定时器。\nCPU时序的相关知识\n振荡周期：为单片机提供信号的振荡源的周期（晶振周期）。12MHZ 的晶振振荡周期就是1/12us, 求倒数。\n状态周期：两个振荡周期=1状态周期s（时钟周期）。\n机器周期：6状态周期=1机器周期。\n指令周期：完成一条指令所用的全部时间，以机器周期为单位。\n定时器的相关知识\n定时器又可以计数，也叫计数器。不需要CPU参与自己就能完成任务，根据脉冲信号对寄存器中数据+1。来一个脉冲定时器+1，加到全为1后输出一个脉冲并归0.同时，向CPU发出计时器中断信息。\n一般有四种工作模式：\n13位定时器，16位定时器，8位自动重装模式，双8位计数器。\n我们的工作模式用的是16位。\n\n串口通信中为了精度考虑要使用自动重装模式。因为我们要自己设置每次溢出产生中断后 TH TL 的初值，这样吧比较容易出错且有点慢。8位自动重装模式就是舍弃了16位存储数据（到65535），只采用后八位 TL 计数（到255），初始值TH TL 赋一样的初值。TL 每次溢出，TH 把自己的值赋给 TL，这样就不用我们自己手动重新赋初值了，初值一直保存在 TH 中。\n而且，在本例中我们使用定时器中断就是为了产生中断时给定时器赋初值并让灯切换状态。使用8位自动重装模式后，不用手动给定时器赋初值了；如果没有其他的需要定时器溢出时必须做的操作，定时器可以不用设置中断，起到一个可以看时间但是不会响的闹钟的功能，即 ET=0。\n\n\n左上角支路是时钟功能，左下角支路是计数功能，最终实现中断功能。\nTH TL 寄存器最大能存储到65535.每来一次脉冲+1，加到最大值时 flag 申请中断。\nSYSCLK 是晶振周期。另一个时钟是 T0 引脚，如果启用 T0 引脚定时器就变成计数器了，每来一个脉冲+1。\n默认使用12T 的分频，把 12MHZ 分成12份，每一份就是1us。这个单片机上是没有对应调整的寄存器的，如果想使用 6T 的分频需要在 STC-ISP 中选择使能 6T 模式。\nCT 是一位寄存器，赋1为C，即计数器；赋0为T，即时钟（T上面的横线就代表0时）。\n每个定时器主要有两种寄存器：TCON TMOD。\nTCON 包括：TF, TR, IE, IT。\n\n​\tTF 可见上图主路，TH TL 被允许计数后周期性+1计数，加到最大值时 TF=1，并发起中断。处理完中断后恢复为0.\n​\tTR 可见上图支路，是开启中断的条件之一。\n​\tIE 是外部中断。\n​\tIT 是设置中断触发模式，比如设置为0是低电平触发，设置为1是下降沿触发。\nTMOD 是不可寻址的寄存器，也就是只能整体赋值，不能像 P2 一样分开给每个变量赋值。包含：GATE, CT, M0, M1.\n\n​\tGATE 用于开启定时器。当 GATE 打开, TR=1（timer reset）且$\\overline{INT1/INT0}$ 为高（即打开中断引脚）时定时器开始工作。这一部分内容对应上图电路中的左下角。\n​\tM0M1 用于选定时钟的4个模式。比如16 位就是01. 两者包含一个叫做 TMOD 的不可位寻址的变量里，\n​\tCT就是打开定时器的计时还是时钟功能。\n开启定时器计数功能及总中断：\nvoid time0_init(void)&#123;    TMOD&amp;=0xF0;//设置定时器模式    TMOD|=0X01;//我们知道 TMOD 是不可位寻址，也就是里面虽然既包含了定时器1和0的寄存器，但是我们赋值只能一整个赋值。    //如果直接给 TMOD=0x01，就会影响定时器1的值。因此我们用这两部先清空后四位，再单独给后四位赋值为0x01。        //TCON 中的 IE IT 对应就是支路图中的 INT0，因为我们开启了 GATE，或电路，因此 IE IT 不用设置也行。    //我们知道 TH TL 合起来达到65535，也就是过了 65535个机器周期 后会触发中断。    //比如我们现在想1ms触发一次中断，怎么处理呢？    //12MHZ 下1us一个周期，1ms 1000个周期，因此我们每次设置初始值为64535，变为65535正好需要1ms。    //11.0592MHz除12为921600Hz，就是1us 0.9216 个机器周期，因此初值为65535-922=64613.    //我们可以给 TH TL 赋初始值，64535，这样只要过 1000us 就会触发中断。    //然后因为 TH 和 TL 拼接变为一整个16位的寄存器，所以 TH 是高8位，TL 是低8位，分别用计算出的初值/256 %256得到最终结果。    TH0=0XFC; //64613/256=252=0xFC，我的单片机是 11.0592 MHZ    TL0=0X65;//64613%256=0x65        TF0=0;//归零，防止刚配置好就产生中断。可有可无    TR0=1;//打开定时器，开启中断条件之一    ET0=1;//打开定时器 0 中断允许    EA=1;//打开总中断    PT0=0;//设置中断优先级为低。默认也是低，不写也没关系。&#125;\nSTC-ISP 上也有生成定时器函数。不过 AUXR 设置定时器时钟那一步是针对最新版本可以调整单片机定时器使能而添加的，我们的单片机加上会报错，需要删掉。\n另外需要手动添加 ET EA PT。\n\nLED灯间隔1s闪烁代码：\n#include &quot;reg52.h&quot;sbit LED=P2^0;void time0_init(void);//不再重写了~void  time0() interrupt 1&#123;\tstatic int i;\tTH0=0XFC; //因为触发中断时，TH TL 归零，所以记得赋初值！\tTL0=0X65;\ti++;\tif(i==1000)\t&#123;\t\ti=0;\t\tLED=!LED;//闪烁\t&#125;&#125;void main()&#123;\ttime0_init();\twhile(1)&#123;&#125;&#125;\n外部中断实验\n运行程序前，请摘下红外接收传感器。因为共用P3^2引脚，会干扰实验结果。\n51单片机都有2个外部中断。STC89C5X系列有INT0~INT3四个。\n对于三个参数的初始化，一般用一个init函数执行，在main的最开头。\n本例中，我们用按键3作为外部中断源。按下按键3就会产生中断。中断执行的指令就是点亮或熄灭LED灯。\n#include &quot;reg52.h&quot;sbit LED=P2^0;sbit KEY3=P3^2;void delay(int ten_us)&#123;while(ten_us--);&#125;void interrupt_init()&#123;\tEA=1;//总中断开关：打开\tEX0=1;//外部中断0开关：打开。\tIT0=1;//外部中断触发方式的选择。如下降沿触发，或低电平触发。\t&#125;void int0() interrupt 0&#123;\tdelay(1000);\tif(KEY3==0)&#123;\t\tLED=!LED;\t&#125;&#125;void main()&#123;\tinterrupt_init();\twhile(1)&#123;\t\t\t&#125;&#125;\n通信\n通信基础知识\n单片机还可以通过IO口实现多种通信。\n串行通信：一条数据线，一次发1bit，发很久。\n并行通信：多条数据线，同时发送，发的速度快多了但是费用高、接收困难、抗干扰性差。\n异步通信：发送和接收方时钟可以不用完全一致。\n同步通信 ：发送和接收方时钟要完全一致。\n单工、半双工、全双工通信：数据的传输方式，略。\n比特率：位/s。\n波特率：码元/s。\n溢出率：比如13us溢出一次。溢出率就是1/13us。\n校验位：如奇偶校验位。\n停止位：分隔数据帧。\n（有那么一点点感谢通原了~）\n串口\n串口通信，指外设和计算机之间通过数据线等传输数据的一种通信方式。比如RS-系列，大多数计算机应该都有对应的梯形接口。51单片机内自带UART（Universal Asynchronous Receiver Transmitter，通用异步收发器），可实现与计算机之间的串口通信！\n单片机串口通信的管脚：VCC TXD（发送数据，串行输出）RXD（接收数据，串行输入）SGND（信号接地）。\n电脑的串口还有很多管脚，如 RTS CTS，单片机的相对简单很多。\nTXD和RXD用正负电压表示逻辑1和0，51单片机采用TTL 晶体管-晶体管逻辑集成电路，用高低电平表示逻辑状态（+5V：1；0V：0），所以需要转换型时候才能与计算机串口通信。\n还有两种电平状态：RS232，3~15V 表示低（注意），-15~-3V 表示高。RS485，两线压差（差分信号）2~6V 表示高，-6~-2V 表示低。\n\nSTC89C52系列有一个通用异步收发器（UART P30 P31端口），有四种工作模式。\n\n模式0：同步移位寄存器；\n模式1：8位UART，波特率可变（常用）；\n模式2：9位UART，波特率固定；\n模式3：9位UART，波特率可变.\n\n\nTXD RXD 直接接到单片机 P30 P31 上. 另一端是单片机上自带的，我们把数据线连到电脑上就接上了。\n\n溢出率到波特率的计算见图。\n串口助手和单片机要规定好发送数据的形式。\n\n串口数据缓存寄存器：SBUF。物理上是接收和发送两个寄存器，实际上共用相同的地址，只是使用时有不同的意义。我们只需要把数据放入其中就行，发送原理暂不用弄明白。\nSCON：串口控制寄存器。控制电路。包含：\n​\tSM0，SM1：设置工作方式。比如我们采用8位 UART，就赋值01.\n​\tSM2：与工作方式1无关。\n​\tREN：是否允许串行接收状态。1允许接收。\n​\tTB8 RB8：接收到的第9位数据，与工作方式1无关。\n​\tTI RI：发送接收中断请求标志位。代表发送完了。硬件赋1，需要用软件复位。\n赋值的话只有 SM0 SM1=01，和 REN 需要注意，其他的初始值都=0。\nPCON：电源管理。包含：\n​\tSMOD：可见支路图，用于设置波特率是否加倍。\n​\tSMOD1：纠错或协助 SM0 设置工作方式。\nIE：打开中断。\n移位寄存器会触发对应中断。在中断图中的 TI RI，触发的是同一个中断。\n实施串口通信\nSTC-ISP自带一个串口调试助手。\n\n串口选择左侧和串口号一致的选项。\nSTC89C52串口初始化函数：\nvoid uart_init(void)&#123;    TMOD|=0X20; //设置计数器工作方式 2    SCON=0X50; //设置为工作方式 1。40是 REN 关闭，50是打开，代表单片机是否可以接收数据    PCON=0X80; //波特率加倍，0就是不加倍    TH1=0XFA; //计数器初始值设置，根据波特率为9600    TL1=0XFA;    ES=1; //打开接收中断    EA=1; //打开总中断    TR1=1; //打开计数器1&#125;\n初始化函数也可以在 STC-ISP 中生成。这里会发现 12MHZ 的晶振相较 11.0592 MHZ 的晶振误差较大，要通过波特率加倍才能减少一些。这就是 11.0592 MHZ 晶振的设计原因。\n单片机向电脑发送数据：给SBUF赋值即可。\n在程序中发送可以直接SBUF=0X11;单片机就会收到11的信息，点击复位按钮后可以在串口助手的接收缓冲区中看到。\n赋值后需要一段时间才能发送完成，发送完成后TI不再是0.\nvoid main()&#123;    uart_init();    SBUF=0x11;    while(TI==0);TI=0;//=1说明发送完成，然后手动复位    while(1)&#123;&#125;&#125;\n这样就在程序中发送了11信息。\n电脑给单片机发送数据：通过串口助手发信息可以通过串口中断interrupt 4实现。\nvoid uart() interrupt 4 //串口通信中断函数&#123;        u8 rec_data;    P2=0x00;//这一句使得函数成功触发时LED灯全亮，便于调试    if(RI==1)&#123;P2=~SBUF;RI=0;&#125;//因为发送和接收中断共用4中断，这句用于区分具体是发送还是接收中断    //如果是接收中断，RI=1，那么只简单执行这两句即可。    SBUF=rec_data; //将接收到的数据放入到发送寄存器    while(!TI); //等待发送数据完成    TI=0; //清除发送完成标志位&#125;\n以上程序可以将发送缓冲区中输入的数据发给单片机，单片机再在接收缓冲区中原封不动地呈现出来。\n文本模式和 HEX 模式就是文本和 ASCII 码的转换。\n封装头文件；绘制LED动画\n类似C语言的语法，部分函数等内容可以封装到头文件里，需要的时候引入到source file 中，再在 include 中指明即可正常使用。\n编写.h文件：如：\n\n引入.h文件：右键左侧的.c文件→options for file→C51→include path→找到.h文件所在的文件夹并选中，注意一定不能有中文路径。然后就可以使用.h文件中定义的变量和函数了，注意不能重复定义。\n什么内容封装到函数里呢？静态的方法待调用的封装进去。逻辑判断后决定使用哪个方法这类的就不用放进函数里了，因为逻辑判断很可能经常改。\n接下来就自己试着先把delay函数和矩阵LED绘制函数写入头文件，然后制作矩阵动画，这样动起来也会更方便一些。\n//h file#include &quot;reg52.h&quot;typedef unsigned char u8;typedef unsigned int u16;\tsbit SRCLK = P3 ^ 6;\tsbit rCLK = P3 ^ 5;\tsbit SER = P3 ^ 4;\t/** * Function name: time0_init * Function paremeter: void * Function performance: 初始化定时器。只有执行此函数后才能使用单片机的定时器功能 */void time0_init(void)&#123;\tTMOD |= 0X01; // 选择为定时器 0 模式，工作方式 1\tTH0 = 0XFC;\t  // 给定时器赋初值，定时 1ms\tTL0 = 0X18;\tET0 = 1; // 打开定时器 0 中断允许\tEA = 1;\t // 打开总中断\tTR0 = 1; // 打开定时器&#125;/** * Function name:time0 * Function paremeter: void * Function performance: 启动定时器。定时器计数器time_counter在0~10000之间循环。 *//*void time0() interrupt 1&#123;\tTH0=0XFC; //给定时器赋初值，定时 1ms\tTL0=0X18;\ttime_counter++;\tbit pass_1s=0;\tif(time_counter==1000)\t&#123;\t\ttime_counter=0;\t\tpass_1s=~pass_1s;\t&#125;&#125;*/void delay(u16 delay_10us)&#123;\twhile(delay_10us--);&#125;void hc_write_data(unsigned char c)&#123;\t// 要传入8个输入，需要循环\tint i = 0;\tfor (i; i &lt; 8; i++)\t&#123;\t\t// 注意 芯片传数据先传高位 再传低位，所以要反着写\t\t// 通过移位获取\t\tSER = c &gt;&gt; 7;\t\t// 想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿\t\tSRCLK = 0;\t\t// 芯片一般给定一个延时时间，经过这个时间之后才能处理完毕\t\tdelay(1);\t\tSRCLK = 1;\t\tdelay(1);\t\t// 让传入数据的次高位变为下次循环的高位\t\tc &lt;&lt;= 1;\t&#125;\t// 最后通过存储寄存器的上升沿，传输全部数据\trCLK = 0;\tdelay(1);\trCLK = 1;&#125;void matrix_led_animation(u8 hc_led_arr[])&#123;\tunsigned char col[8]=&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;;\tint i=0;\tP0=0x00;\t\tfor(i;i&lt;8;i++)&#123;\t\tP0=col[i];\t\thc_write_data(hc_led_arr[i]);        //不知道为什么，下面两部分不写图形会偏移。不知道会不会有大佬解答一下\t\tdelay(1);\t\thc_write_data(0x00);\t&#125;\t&#125;\n然后就是利用取模软件得到要绘制的图案的字模。这里我选定的图案是之前圣诞节临摹过的像素画中”Merry Christmas“的字体。参照来源：圣诞节 像素画 圣诞树🎄_哔哩哔哩_bilibili\n\n绘制部分代码：\n#include &quot;reg52.h&quot;#include &lt;MyHFile.H&gt;u8 anime_row[]=&#123; 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x40, 0x7C, 0x40, 0x7C, 0x00, 0x1C, 0x14, 0x18, 0x00, 0x1C, 0x10, 0x00, 0x1C, 0x10, 0x00, 0x1D, 0x05, 0x1F, 0x00, 0x7C, 0x44, 0x44, 0x44, 0x00, 0x7C, 0x10, 0x1C, 0x00, 0x1C, 0x10, 0x00, 0x5C, 0x00, 0x04, 0x1C, 0x10, 0x00, 0x7C, 0x14, 0x00, 0x1C, 0x10, 0x1C, 0x10, 0x1C, 0x00, 0x0C, 0x14, 0x1C, 0x00, 0x04, 0x1C, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 &#125;;void main()&#123;\tint cnt = 0;\twhile (1)\t&#123;\tfor(cnt;cnt&lt;62;cnt++)&#123;\t\tu8 row[8]=&#123;0,0,0,0,0,0,0,0&#125;;\t\trow[0]=anime_row[cnt];\t\trow[1]=anime_row[cnt+1];\t\trow[2]=anime_row[cnt+2];\t\trow[3]=anime_row[cnt+3];\t\trow[4]=anime_row[cnt+4];\t\trow[5]=anime_row[cnt+5];\t\trow[6]=anime_row[cnt+6];\t\trow[7]=anime_row[cnt+7];\t\tmatrix_led_animation(row);\t\tdelay(5000);\t&#125;\tcnt=0;\t&#125;&#125;\n虽然因为每次绘制完成必须擦除再重新绘制，导致看起来一闪一闪的。\n不过最终的动画效果还是不错的~\nIIC, AT24C02\n掉电不丢失的存储器。存储结构是 E2PROM，通讯方式是 I2C。\nEEPROM\n存储器主要分为 RAM 易失性存储器和 ROM 非易失性存储器，RAM 存取快但掉电丢失，ROM 正相反。\n\nSRAM：锁存器，速度最快。\nDRAM：电容，充电1放电0. 但是电容漏电比较严重，需要扫描器每隔一段时间检查一下是否漏电，漏电再充。\nROM 名字来源于 read-only，但是后期的非易失性存储器都可以写入，只是沿用了名字。\nMASK ROM：不可写入。\nPROM：只能写入一次。\nEPROM：可擦除，但是形式比较麻烦，要用紫外线照射很久。\nE2PROM：电擦除更加方便，我们现在的单片机所用。但是容量小。\nFLASH：应用广泛。\n\n这只是一个有助理解的简化模型~\n选定一些结点导通，比如我们读取第一行地址1处的数据，发现第1/2/3个结点导通，其他节点都未导通，则从最下端读到的该处地址的数据为：1110 0000。\nMASK ROM 中，两条线中没有二极管，则两条线都通电流就会导通。有二极管后，数据总线无法流下来，为低电平。\nPROM 中如何实现可编程写入一次？蓝色的二极管容易被击穿。被击穿后二极管的通路变为断路，导通；否则和 MASK ROM 低电平原理一样。\nEPROM 是二极管可以恢复。\n选中哪条总线可以通过三位138译码器的输入决定。\n\nVCC 范围：1.8~5.5v\nWE/WR：写保护，WR 高电平保护，不能写入。可以看到 WE 标明低电平启用，而且单片机上的 EEPROM 直接 WE 接地了。\nSCL SDA：I2C 接口。\nE1 E2：I2C 地址。\n\n大概是能看懂的。SCL SDA 传入数据后，看是 R/W 哪个地址里的数据，通过 DEC 译码器找到地址 R/W，通过串行多路复用器 serial MUX 把并行数据转化为串行并输出。\nI2C\nI2C（Inter－Integrated Circuit BUS）总线是由 PHILIPS 公司开发的两线式 串行总线，用于连接微控制器及其外围设备。因为各家自己开发的数据总线可能不通用，PHILIPS 公司开发了这款统一通信标准。这样不仅方便了芯片开发，也便于大家学习。\nI2C 结构\nI2C 只有两根双向信号线，一根是 SDA 数据线，一根是 SCL 时钟线。是同步、半双工的通信线，带数据应答。\n所有设备的 SCL 和 SDA 都连在总线上。设备的 SCL SDA 是开漏输出的（高电平直接接地），SCL 和 SDA 又要添加弱上拉电阻。这两共同作用实现了“线与”的功能，避免各个设备通信相互干扰。\n如下图所示，设备上的 SCLK SDA 是开漏输出。如果给高电平导通开关， IN 也是接地，该设备就无法读取输入数据不会被干扰。否则如果是低电平关闭开关，数据会流出 DATA IN。\n\n主机：启动数据传送并产生时钟信号的设备；\n从机：被主机寻址的器件；\n多主机：同时有多于一个主机尝试控制总线但不破坏传输；\n主模式：用 I2CNDAT 支持自动字节计数的模式； 位 I2CRM,I2CSTT,I2CSTP 控制数据的接收和发送；\n从模式：发送和接收操作都是由 I2C 模块自动控制的；\n仲裁：是一个在有多个主机同时尝试控制总线但只允许其中一个控制总线并 使传输不被破坏的过程；\n同步：两个或多个器件同步时钟信号的过程；\n发送器：发送数据到总线的器件；\n接收器：从总线接收数据的器件。\nI2C 协议\n①时钟信号周期性的高电平低电平。只有时钟信号为低电平时，数据信号才能变化。\n②起始和停止信号：SCLK 高电平时，SDA 由高→低为开始，低→高为结束。\n④发送数据：\n\n先发 start 标识，后跟一个字节，第一个字节是地址+读写位。前四位固定，比如 24C02 是1010. 后三位是地址。收到接收应答后就开始发送数据。读写位 $R/\\overline{W}$ .\nSCLK 低电平时，SDA 先设置好要传的数据。然后 SCLK 变为高电平后 SDA 不允许再数据变化，SCLK 先读取数据。这样发送一位，SCLK 再变为低电平，如此循环。\n发送器件传输完一个字节8位数据后，后面必须紧跟一个ACK/NACK校验位，判断接受是否完成，数据传送是否可以继续。接收方会让主机在发完的下一个时钟信号收到接收应答。\n\n\n复合数据帧格式：先发再收。\n\n字节写：规定一个字节数据地址，写入和读取都去那里。\n\n随机读：\n\n③总线寻址方式\n从机有自己的地址，总线寻址采用7或10位的寻址位数。如7位：位定义D0表示数据传送方向位（是主机从从机读取数据？还是主机向从机写数据？代表这个从机是接收器还是发送器），D7~D1是从机地址位。\n主机发送一个地址后，所有从机前7位地址和主机比较，如果相同再判断从机是接收还是发送器。\n从机地址包含固定位和可编程位，可编程位决定了这个部件可以最多有多少个接入总线。如4位固定位，3位可编程位，说明2^3=8个最多可以接入总线。\n④数据传输\n起始信号 S+7位从机地址+数据方向位+ACK+数据+NACK+终止信号。如果主机还想要新的数据传送，可以不终止，继续发出起始信号向另一从机寻址。\n数据方向位=0：主机向从机发送数据。主机一直发到从机返回 NACK 为止。\n数据方向位=1：从机向主机发送数据，发送到主机返回 NACK 为止。\nAT24C02\n是一个2k位串行CMOS，主板上的主板上的一块可读写的并行或串行FLASH芯片。该芯片有 I2C 接口，是个从机。而且有写保护功能，其中写入的数据断电不丢失。\n我们可以通过单片机的模拟 IIO 功能，将数据写入该芯片永久存储，下次断电时也能访问。\n创建多文件工程\n下面编写的程序要求：\n设计一个系统，可以写入、读取 AT24C02 中的数据，并将其中的数据用数码管显示出来。\n这个系统涉及之前学过的按键、数码管信息，还涉及新的 AT24C02 的使用，三部分代码。由于内容太多，所以这次我们创建一个多文件系统，以后也会用这个系统模板更好的管理文件。\n本项目主要包含：\nApp 文件夹：存储各类函数\nObj 文件夹：存放编译产生的 hex 文件、列表清单等。\nPublic 文件：存放公共文件，如延时、变量重定义。\nUser：存放 main.c 等主函数文件。\n创建步骤：\n①新建一个项目文件夹，在该项目文件夹中新建以上四个文件夹。\n②在 Keil 中新建项目，选中这个项目文件夹。选择不复制 StartUp 代码。\n③点击魔术棒右边的三色方块，创建三个分组 Group。这里创建的分组是一个逻辑上的分组，并不是指选中这三个具体的文件夹。与三个文件夹起名相同是为了方便管理.\n\n④编写程序.\n清楚了我们的需求，我们想一下要写那些代码，放在什么地方。\n公共内容：public 中。\n使用按钮代码：App中。\n使用数码管代码：App中。\n使用 AT24C02 代码：App 中。\n调用以上几部分内容代码：main 中。\n\n把普中部分代码复制到单片机中，大意：按键1将当前数据写入芯片，按键2读取芯片中存储的数据，按键3将当前数据+1，按键4将当前数据清零。\niic：定义i2c总线的一些方法。如开始等待接收数据、结束关闭、ack、nack、wait ack、读取写入数据等方法。\n/////////iic.h#ifndef _iic_H#define _iic_H#include &quot;public.h&quot;//定义EEPROM控制脚sbit IIC_SCL=P2^1;//SCL时钟线sbit IIC_SDA=P2^0;//SDA数据线//IIC所有操作函数\t\t\t\t void iic_start(void);\t\t\t//发送IIC开始信号void iic_stop(void);\t  \t\t//发送IIC停止信号void iic_write_byte(u8 txd);\t//IIC发送一个字节u8 iic_read_byte(u8 ack);\t\t//IIC读取一个字节u8 iic_wait_ack(void); \t\t\t//IIC等待ACK信号void iic_ack(void);\t\t\t\t//IIC发送ACK信号void iic_nack(void);\t\t\t//IIC不发送ACK信号#endif///////////iic.c#include &quot;public.h&quot;#include &quot;iic.h&quot;void iic_start()&#123;    IIC_SCL = 1; // SCL为高电平时，SDA的数据才有效    IIC_SDA = 1;    delay(10);    IIC_SDA = 0; // SCL SDA 都由高变低，是起始标志    \tdelay(10);    IIC_SCL = 0;&#125;void iic_stop()&#123;    IIC_SCL = 1;    IIC_SDA = 0;    delay(10);    IIC_SDA = 1;    delay(10);&#125;void iic_ack()&#123;    IIC_SCL = 0;    IIC_SDA = 0;    delay(10);    IIC_SCL = 1;    delay(10);    IIC_SCL = 0;&#125;void iic_nack()&#123;    IIC_SCL = 0;    IIC_SDA = 1;    delay(10);    IIC_SCL = 1;    delay(10);    IIC_SCL = 0;&#125;u8 iic_wait_ack()&#123;    u16 time_temp = 0;    IIC_SCL = 1;    while (IIC_SDA)    &#123; // 等待数据变成0        if (++time_temp &gt; 100)        &#123;            iic_stop();            return 1;        &#125;    &#125;    IIC_SCL = 0;    return 0;&#125;u8 iic_read_byte(u8 ack)&#123;    u8 i = 0, receive = 0;    for (i; i &lt; 8; i++)    &#123;        IIC_SCL = 0;        delay(1);        IIC_SCL = 1;        receive &lt;&lt;= 1;        if (IIC_SDA)            receive += 1;        delay(1);    &#125;    if (!ack)        iic_nack();    else        iic_ack();    return receive;&#125;void iic_write_byte(u8 dat)&#123;    u8 i = 0;    IIC_SCL = 0;    for (i; i &lt; 8; i++)    &#123;        if ((dat &amp; 0x80) &gt; 0)            IIC_SDA = 1;        else            IIC_SDA = 0;        dat &lt;&lt;= 1;        delay(1);        IIC_SCL = 1;        delay(1);        IIC_SCL = 0;        delay(1);    &#125;&#125;\n24c02：主要就是芯片调用iic来写入或取出数据的函数。看上去倒没有多少自己的东西。\n/////////24c02.h#ifndef _24c02_H#define _24c02_H#include &quot;public.h&quot;void at24c02_write_one_byte(u8 addr, u8 dat);u8 at24c02_read_one_byte(u8 addr);#endif/////////24c02.c#include &quot;public.h&quot;#include &quot;24c02.h&quot;#include &quot;iic.h&quot;void at24c02_write_one_byte(u8 addr, u8 dat)&#123;    iic_start();    iic_write_byte(0xA0);//写命令    iic_wait_ack();    iic_write_byte(addr);//发送写地址    iic_wait_ack();    iic_write_byte(dat);    iic_wait_ack();    iic_stop();//停止条件    delay(1);&#125;u8 at24c02_read_one_byte(u8 addr)&#123;\tu8 temp;    iic_start();    iic_write_byte(0xA0);//写命令    iic_wait_ack();    iic_write_byte(addr);//发送写地址    iic_wait_ack();    iic_write_byte(0xA1);//进入接收模式    iic_wait_ack();    temp=iic_read_byte(0);//读取条件    iic_stop();//停止条件    return temp;&#125;\npublic.h和.c里面就是装了u8 u16 和 delay 函数的定义。不用多说。\nmain.c：\n#include &lt;reg52.h&gt;#include &lt;public.h&gt;#include &lt;key.h&gt;#include &lt;display.h&gt;#include &lt;24c02.h&gt;#define EEPROM_ADDRESS 0//数据存入EEPROM 的起始地址void main()&#123;    u8 key_temp=0;    u8 save_value=0;//每次刚打开单片机时，起始值都=0    u8 save_buf[3];    while(1)&#123;        key_temp=key_scan(0);//单词扫描按键获取当前按键        switch(key_temp)&#123;//按键1：写入            \t\t\tcase KEY1_PRESS:                at24c02_write_one_byte(EEPROM_ADDRESS,save_value);                break;            case KEY2_PRESS:                save_value=at24c02_read_one_byte(EEPROM_ADDRESS);                break;            case KEY3_PRESS:                if(save_value&lt;255)save_value++;                break;            case KEY4_PRESS:                save_value=0;                break;            default:                break;        &#125;        save_buf[0]=save_value/100;        save_buf[1]=save_value/10%10;        save_buf[2]=save_value%10;        smg_display(save_buf,5);    &#125;&#125;\nmain.c：\nvoid main()&#123;\tunsigned char dat=0,KeyNum;\tLCD_Init();\t//LCD_ShowString(1,1,&quot;Hello!&quot;);\t//AT24C02_WriteByte(1,66);//256 位字节，存入数据不 &gt;256\t//delayMs(50);//两次写之间需要的时间间隔\t//AT24C02_WriteByte(2,34);//256 位字节\t//delayMs(50);\t//dat=AT24C02_ReadByte(1);\t//delayMs(50);\t//dat1=AT24C02_ReadByte(2);\tLCD_ShowNum(2,1,dat,3);\twhile(1)&#123;\t\tKeyNum=key_scan(0);\t\tswitch(KeyNum)&#123;\t\t\tcase KEY1_PRESS:\t\t\t\tif(dat&lt;255)dat+=1;\t\t\t\tLCD_ShowString(1,1,&quot;++&quot;);\t\t\t\tLCD_ShowNum(2,1,dat,3);\t\t\t\t\tbreak;\t\t\tcase KEY2_PRESS:\t\t\t\tif(dat&gt;0)dat-=1;\t\t\t\tLCD_ShowString(1,1,&quot;--&quot;);\t\t\t\tLCD_ShowNum(2,1,dat,3);\t\t\t\t\tbreak;\t\t\tcase KEY3_PRESS:\t\t\t\tAT24C02_WriteByte(1,dat);\t\t\t\tLCD_ShowString(1,1,&quot;Write Complete!&quot;);\t\t\t\tdelayMs(50);\t\t\t\tLCD_ShowNum(2,1,dat,3);\t\t\t\t\tbreak;\t\t\tcase KEY4_PRESS:\t\t\t\tdat=AT24C02_ReadByte(1);\t\t\t\tLCD_ShowString(1,1,&quot;Read Complete!&quot;);\t\t\t\tLCD_ShowNum(2,1,dat,3);\t\t\t\t\tbreak;\t\t&#125;\t\t&#125;&#125;\n运行效果：\n一开始运行，显示当前数字000.\n按下按钮1，数字++。\n按下按钮2，数字–。\n按下按钮3，当前数字会写入。\n按下按钮4，会读取 AT24C02 中存储的数字显示出来。断电也能保存。\n一个字节确实只能存到 255. 我们可以拿 12 两个存储地址合起来存储一个数据，一个存储高八位 /256，一个存储低八位 %256. 取数据的时候 datl|=dath&lt;&lt;8;\n写入多位时，延时间隔应该&gt;5ms！因为 at24c02 的写入还是很慢的。\n温度传感器 DS18B20\n单片机上自带的温度传感器模块：DS18B20。是一种常见的数字温度传感器。不用 ADC，自己处理好数据后放到 RAM 中，我们取出来就能用。\n总线结构，可以把很多设备挂到总线上，省 IO 口；有温度报警装置；寄生供电（总线高电平可以供电）.\n寄生供电需要添加强上拉电阻。\n传感器很简单，只有三个引脚：\n\nDQ 是 P37。\n\n具体结构如上图。寄生供电使得 DQ 也可以供电。\nROM 是寻址用，可以跳过。\nSCRATCHPAD：暂存器，读取的数据在其中。\nEEPROM：存储一些配置信息，比如报警阈值，精度。\n\nDS18B20 采用异步半双工的单总线，加上寄生供电，使得只要两根线就能驱动。不过这种结构并不常见。\n我们将检测到的温度通过数码管显示出来。数码管的传入函数和IIC的一样，将外部dat数组传给数码管。\ninit\n主机输出低电平拉低总线 480~960 us，释放总线；外部上拉电阻把总线拉高，延时 15~60 us 进入接收模式。接着 DS18B20 拉低总线 60~240 us。\n我们要在主机释放总线后，检测一下一定时间内总线是否被拉低了，拉低了说明有从机。然后再检测一定时间内从机是否把总线又释放了。\n发送一位数据\n主机拉低总线 60~120 us 后释放：0.\n主机拉低总线 1~15 us ：1.\n一般发送间隔 1ms。\n从机拉低 30us 读取数据。\n读取一位数据\n主机拉低总线 15us，接近结束时释放，看一下总线是否释放。\n如果释放了，说明从机在发送数据1，在 15us 内就释放了。\n如果没释放，说明从机还在拉着总线，是打算拉 60us 以上的0.\n至于发送读取是否会混淆，无需担心，因为总线发送给主机指令来决定其作用。\n发送 接收字节\n连续读或发1个字节 8次。低位在前。\n整体流程\n从机复位，主机检测从机是否响应；\nROM 指令+本指令是 R/W；\n功能指令+本指令是 R/W。\n\n因为只有一个从机，所以这里用 skip rom 指令 跳过地址校验。\n功能指令：\n\n转换温度：该指令一发出，立刻转换温度后放在暂存器中。\n写入寄存器：只写3个字节。TH TL configuration register。\n读寄存器：读出寄存器数据。我们知道温度值只是前2个字节，所以简单处理只读2个字节即可。\ncopy：寄存器指令写入 EEPROM。RECALL 相反。\nread power supply：检测是否寄生供电，这里我们也不需要。\n\n温度变换：init-跳过 ROM-转换温度。\n温度读取：init-跳过 ROM-读取温度-持续读取。\n温度&gt;0：*0.625\n温度&lt;0：取反+1，再*0.625\n具体代码解释在下文的注释中。\n#include &quot;intrins.h&quot;sbit DS18B20_PORT=P3^7;//初始化序列：首先拉低总线至少480us，以产生复位脉冲。接着主机释放总线，延时至少15us，进入接收模式void ds18b20_reset()&#123;\tDS18B20_PORT=0;//拉低DQ\tdelay(75);//拉低750us\tDS18B20_PORT=1;//DQ=1\tdelay(2);&#125;u8 ds18b20_check()&#123;\tu8 time_temp=0;\twhile(DS18B20_PORT&amp;&amp;time_temp&lt;20)&#123;\t\ttime_temp++;\t\tdelay(1);\t&#125;\tif(time_temp&gt;=20)return 1;//超时跳出，而不是因为DQ变低跳出\telse time_temp=0;\twhile((!DS18B20_PORT)&amp;&amp;time_temp&lt;20)&#123;\t\ttime_temp++;\t\tdelay(1);\t&#125;\tif(time_temp&gt;=20)return 1;\treturn 0;&#125;u8 ds18b20_init()&#123;\tds18b20_reset();\treturn ds18b20_check();&#125;/*写时序：写1时序：拉低后延时2us，释放后延时60us.写0时序：拉低后延时60us，释放后延时2us。*/void ds18b20_write_byte(u8 dat)&#123;\tu8 i=0;\tu8 temp=0;\tfor(i;i&lt;8;i++)&#123;\t\ttemp=dat&amp;0x01;dat&gt;&gt;=1;\t\tif(temp)&#123;\t\t\tDS18B20_PORT=0;\t\t\t_nop_();_nop_();\t\t\tDS18B20_PORT=1;\t\t\t\tdelay(6);\t\t&#125;\t\telse&#123;\t\t\tDS18B20_PORT=0;\t\t\tdelay(6);\t\t\tDS18B20_PORT=1;\t\t\t_nop_();_nop_();\t\t\t&#125;\t&#125;&#125;//读时序：至少需要60us。时序起始后15us内读数据（采样总线）。//典型的读时序过程为：主机输出低电平延时 2us，然后主机转入输入模式延时12us，然后读取单总线当前的电平，然后延时 50us。u8 ds18b20_read_bit()&#123;\tu8 dat=0;\tDS18B20_PORT=0;\t_nop_();_nop_();\tDS18B20_PORT=1;\t\t_nop_();_nop_(); //该段时间不能过长，必须在15us内读取数据\tif(DS18B20_PORT)dat=1;\t//如果总线上为1则数据dat为1，否则为0\telse dat=0;\tdelay(5);\treturn dat;\t&#125;u8 ds18b20_read_byte()&#123;\tu8 i=0;\tu8 dat=0;\tu8 temp=0;\tfor(i;i&lt;8;i++)&#123;\t\t//先低位后高位\t\ttemp=ds18b20_read_bit();\t\tdat=(temp&lt;&lt;7)|(dat&gt;&gt;1);//读取到的先放到最高位，然后逐渐向低位移动\t&#125;\treturn dat;&#125;void ds18b20_start()&#123;\tds18b20_init();\tds18b20_write_byte(0xcc);//跳过ROM命令，此命令通过允许总线主机不提供64位ROM编码而访问存储器操作来节省时间。\tds18b20_write_byte(0x44);//转换命令&#125;float ds18b20_read_temperature()&#123;\tu8 datl=0,dath=0;\tu16 val=0;\tfloat temp;\tds18b20_start();\tds18b20_init();\tds18b20_write_byte(0xcc);\tds18b20_write_byte(0xbe);//读存储器命令，读出温度\tdatl=ds18b20_read_byte();//低字节\tdath=ds18b20_read_byte();//高字节\tval=(dath&lt;&lt;8)+datl;\tif((val&amp;0xf800)==0xf800)//负温度\t&#123;\t\tval=(~val)+1;//取反+1\t\ttemp=val*(-0.0625);//计算方法如此。*0.0625，如果是负数要先取反+1。\t&#125;\telse temp=(0.0625*val);\treturn temp;&#125;void main()&#123;\tint cnt=0;//每50次循环读取一次温度\tint temp_value;\tu8 temp_buf[5];\tds18b20_init();\twhile(1)&#123;\t\tcnt++;\t\tif(cnt%50==0)&#123;\t\t\tcnt%=50;\t\t\ttemp_value=ds18b20_read_temperature()*10;\t\t\tif(temp_value&lt;0)&#123;\t\t\t\ttemp_value=-temp_value;\t\t\t\ttemp_buf[0]=0x40;//负号\t\t\t&#125;\t\t\telse temp_buf[0]=0x00;//不显示负号\t\t\ttemp_buf[1]=gsmg_code[temp_value/1000];\t\t\ttemp_buf[2]=gsmg_code[temp_value%1000/100];\t\t\ttemp_buf[3]=gsmg_code[temp_value%100/10]|0x80; //加小数点\t\t\ttemp_buf[4]=gsmg_code[temp_value%10];\t\t\tsmg_display(temp_buf,3);\t\t&#125;\t&#125;&#125;\n时钟\nDS1302 时钟芯片。开发板上已经集成的芯片，本次实验目的是用数码管显示出当前时间，以hh-mm-ss的格式。\n\nVCC2：电源\nVCC1：备用电源，即单片机断电后维持时钟继续运行的。STC89C52 是没有的，即断电就停止运行。\nX1X2：晶振。\nCE：使能。\nIO：输入输出。\nSCLK：时钟。\n操作流程就是将数据写入 DS1302 的寄存器来设置当前时间格式，然后 DS1302 时钟运作后我们再将寄存器中数据读出。\nDS1302 中存储顺序是秒分时日月周年，存储格式是 BCD 码。\n\n首先，CE/RST在整个读写过程中要保持是高电平，一次字节读写完毕后要返回低电平。\n然后，控制指令字输入后的下一个 SCLK 上升沿数据写入，下降沿数据读出，在图中可以看得出来，都是从低位0先读，最后出高位7. 第一位代表读或写，后四位代表地址（年、月、日、时、分、秒有着不同的地址），R/C 代表存取 RAM 数据还是读取时钟数据。最高位只有=1才能启用时钟。后面八位是读或写的数据。\n读时序注意：因此写命令的第八个上升沿结束后，紧接着第八个下降沿就开始读数据了。\n写时序注意：先关闭写保护 WP，1是只读，0才可以写。\n\n我们先试着写入一个秒初值，然后读取时钟里的秒数值，应该是1s一加。\n记得 BCD 码和十进制的转换。\n\n#include&quot;REG52.H&quot;#include&quot;LCD1602.h&quot;sbit DS1302_CLK=P3^6;//时钟管脚sbit DS1302_CE=P3^5;//复位管脚sbit DS1302_IO=P3^4;//数据管脚typedef unsigned char u8;void ds1302Init()&#123;    DS1302_CE=0;    DS1302_CLK=0;&#125;void ds1302WriteByte(u8 command,u8 dat)&#123;u8 i;    DS1302_CE=1;        for(i=0;i&lt;8;i++)    &#123;        DS1302_IO=command&amp;(0x01&lt;&lt;i);//从低到高写入数据        DS1302_CLK=1;        DS1302_CLK=0;    //需要查询最小执行时间。不过这里执行时间都大于最小时间了。    &#125;    for(i=0;i&lt;8;i++)    &#123;        DS1302_IO=dat&amp;(0x01&lt;&lt;i);//从低到高写入数据        DS1302_CLK=1;        DS1302_CLK=0;    //需要查询最小执行时间。不过这里执行时间都大于最小时间了。    &#125;    DS1302_CE=0;&#125;u8 ds1302ReadByte(u8 command)&#123;\tu8 i;\tu8 dat=0x00;//全局变量会有初值0，局部变量不会。data 是要写入的数据    DS1302_CE=1;    for(i=0;i&lt;8;i++)    &#123;        DS1302_IO=command&amp;(0x01&lt;&lt;i);//从低到高写入数据        DS1302_CLK=0;        DS1302_CLK=1;//这里为什么和 write 是相反的？因为我们注意到 read 是先上升沿读入8位，再切换为下降沿读入8位。、        //如果还是先1后0，读入第8位时不仅会把上升沿读掉，下降沿也会读掉，导致错过第九位。    //需要查询最小执行时间。不过这里执行时间都大于最小时间了。    &#125;    for(i=0;i&lt;8;i++)    &#123;                DS1302_CLK=1;        DS1302_CLK=0;    //需要查询最小执行时间。不过这里执行时间都大于最小时间了。\t\tif(DS1302_IO)dat|=(0x01&lt;&lt;i);//从低到高写入数据    &#125;    DS1302_CE=0;\tDS1302_IO=0;//读取前要归0，因为内部是以 BCD 码格式存储。\treturn dat;&#125;void main()&#123;    u8 second;\tLCD_Init();\tds1302Init();\t//ds1302WriteByte(0x8E,0x00);//如果读出数据&gt;59，可能是处于 wp 写保护，需要通过这句关闭\tds1302WriteByte(0x80,0x01);//写入55s，就是0x55，与内部BCD码对应\tLCD_ShowString(1,1,&quot;DS1302&quot;);\tsecond=ds1302ReadByte(0x81);\twhile(1)&#123;LCD_ShowNum(2,1,second/16*10+second%16,3);&#125;&#125;\n写入其他变量时分秒都一样。就是更换不同的地址。\n不过全部定义变量明显太麻烦。可以先 define 定义了所有地址，再定义一个数组存所有值。\nu8 ds1302_address[7]=&#123;0x80, 0x82, 0x84, 0x86, 0x88, 0x8c&#125;;// second, minute, hour, date, month, yearu8 ds1302_time[7]=&#123;0x55, 0x59, 0x11, 0x07, 0x02, 0x23&#125;;void main()&#123;\tu8 i;    u8 time_temp[6];\tu8 temp;\tLCD_Init();\tds1302Init();\t//ds1302WriteByte(0x8E,0x00);//如果读出数据&gt;59，可能是处于 wp 写保护，需要通过这句关闭\tds1302WriteByte(0x80,0x01);\tds1302WriteByte(0x82,0x37);\tfor(i=0;i&lt;6;i++)&#123;\t\tds1302WriteByte(ds1302_address[i], ds1302_time[i]);\t&#125;\tLCD_ShowString(1,1,&quot;  -  -  &quot;);\tLCD_ShowString(2,1,&quot;  :  :  &quot;);\twhile(1)&#123;\t\tfor(i=0;i&lt;6;i++)&#123;\t\t\ttemp=ds1302ReadByte(ds1302_address[i]+1);\t\t\ttime_temp[i]=temp/16*10+temp%16;\t\t&#125;\t\tfor(i=0;i&lt;6;i++)&#123;\t\t\tLCD_ShowNum(1+i/3,1+3*(i%3), time_temp[5-i],2);\t\t&#125;\t\t//LCD_ShowNum(2,1,minute/16*10+minute%16,2);\t\t//LCD_ShowNum(2,3,second/16*10+second%16,2);\t&#125;&#125;\n然后我们让按键可以修改时钟值，这样用户可以手动更改时钟。\n按键1切换切换要调整的位，按键2切换回第0位，按键3+1，按键4-1.\n难点主要在于+ -的溢出情况。这里我们不考虑秒+1进位对分钟或小时等影响，大多数闹钟也是这样设计的。59+1就归零，0-1就变59.\nif(key)&#123;\t\t\tswitch(key)&#123;\t\t\t\tcase KEY1_PRESS: time_set_select=0;break;\t\t\t\tcase KEY2_PRESS: time_set_select=(time_set_select+1)%6;break;\t\t\t\tcase KEY3_PRESS:\t\t\t\t\tif(time_set_select&lt;=1&amp;&amp;ds1302_time[time_set_select]==59)&#123;//second, minute 59-00\t\t\t\t\t\tds1302_time[time_set_select]=0;\t\t\t\t\t&#125;\t\t\t\t\telse if(time_set_select==2&amp;&amp;ds1302_time[time_set_select]==23)ds1302_time[time_set_select]=0;//hour 23-00\t\t\t\t\telse if(time_set_select==3&amp;&amp;ds1302_time[time_set_select]==maxDate(ds1302_time[3],ds1302_time[4],ds1302_time[5]))ds1302_time[time_set_select]=1;//date 超过最大日期 -01\t\t\t\t\telse if(time_set_select==4&amp;&amp;ds1302_time[time_set_select]==12)ds1302_time[time_set_select]=1;//month 12-00\t\t\t\t\telse if(time_set_select==5&amp;&amp;ds1302_time[time_set_select]==99)ds1302_time[time_set_select]=0;//year 99-00\t\t\t\t\telse ds1302_time[time_set_select]++;break;\t\t\t\tcase KEY4_PRESS: \t\t\t\t\tif((ds1302_time[time_set_select]&amp;&amp;time_set_select!=3&amp;&amp;time_set_select!=4)\t\t\t\t\t||ds1302_time[time_set_select]&gt;1)ds1302_time[time_set_select]--;//date month!=0\t\t\t\t\telse if(time_set_select&lt;=1)ds1302_time[time_set_select]=59;\t\t\t\t\telse if(time_set_select==2)ds1302_time[time_set_select]=23;\t\t\t\t\telse if(time_set_select==3)ds1302_time[time_set_select]=maxDate(ds1302_time[3],ds1302_time[4],ds1302_time[5]);\t\t\t\t\telse if(time_set_select==4)ds1302_time[time_set_select]=12;\t\t\t\t\telse if(time_set_select==5)ds1302_time[time_set_select]=99;\t\t\t\t\tbreak;\t\t\t&#125;\t\t\tif(key&gt;=3)timeSet();\n计算日期最大值函数：\nu8 maxDate(u8 date, u8 month,u8 year)&#123;\tif(month==1||month==3||month==5||month==7||month==8||month==10||month==12)return 31;\telse if((month==4||month==6||month==9||month==11)&amp;&amp;date==31)return 30;\telse if(year%4)return 28;\telse if(year%4==0&amp;&amp;year%100)return 28;\telse return 29;&#125;\n有个弊端就是不知道现在在操作哪一位（只能自己记住）。可以利用定时器的定时闪烁，让在被操作的位不停闪烁。（重复写入空格或数值。）\n还有就是按下按键，时钟会停走，不松开就一直停着。可以改按键触发条件为按下或弹起的上升沿或下降沿，避免按键处理函数死循环。\n红外传感器\n遥控器通过红外 LED 发送调制后的信号，开发板上的红外接收模块接收遥控器的红外线。\n单工异步，940nm 波长（还有一种 250nm 的N，可见光），EC 通信标准。\n\n38KHz：红外线频率。\nIN：发送的方波。\n\n红外接收模块中会自动帮我们滤出 In 部分。\n\n空闲状态：OUT 输出高电平。\n发送高电平：OUT 输出高电平。\n发送低电平：OUT输出低电平，代表有数据。\n\n38kHz 属于是底层信息，所以协议层不给予展示，类似类的封装。\n9ms 低+4.5ms 高：start。\n后面跟四个字节数据。反码用于数据验证。\n560us 低+560us 高表示0，560us 低+1690us 高表示1. 结束的最后一个高电平后面要跟一个下降沿表示终止。\n一直扫描是效率很低的做法，所以 out 是接在外部中断上的。\n外部中断\n\nvoid main()&#123;    LCD_Init();    LCD_ShowString(1,1,&quot;A&quot;);    IT0=1;    IE0=0;    EX0=1;    EA=1;    PX0=1;    while(1)&#123;        LCD_ShowNum(2,1,num,2);    &#125;&#125;void Int0_Routine() interrupt 0 &#123;    num++;&#125;\n中断和第三个按键 P3^2 接在一起，因此按下按键3时就会下降沿触发中断。\n如果改为低电平触发，即 IT0=0，按下按键就一直触发。\n接收到的数据会以2位的二进制位展现在数码管上，这里遥控器上的按钮并不是按几数码管就会显示几的注意一下。重点只是在于看遥控器不同的信号单片机能否区分和识别。\n\n//ired.h#ifndef _ired_H#define _ired_H#include &quot;public.h&quot;//管脚定义sbit IRED=P3^2;//声明变量extern u8 gired_data[4];//函数声明void ired_init(void);#endif//ired.c#include &quot;ired.h&quot;u8 gired_data[4];//存储4个字节接收码（地址码+地址反码+控制码+控制反码）/******************************************************************************** 函 数 名         : ired_init* 函数功能\t\t   : 红外端口初始化函数，外部中断0配置 * 输    入         : 无* 输    出         : 无*******************************************************************************/void ired_init(void)&#123;\tIT0=1;\t//下降沿触发\tEX0=1;\t//打开中断0允许\tEA=1;\t//打开总中断\tIRED=1;\t//初始化端口&#125;void ired() interrupt 0\t//外部中断0服务函数&#123;\tu8 ired_high_time=0;\tu16 time_cnt=0;\tu8 i=0,j=0;\t//引导信号有9ms的低电平和4.5ms的高电平，先把这两部分读掉，并且如果太长时间引导信号没有发生相应的变化就先跳出，省的系统死机。我们给引导信号10ms和5ms的机会。\tif(IRED==0)\t&#123;\t\ttime_cnt=1000;\t\twhile((!IRED)&amp;&amp;(time_cnt))//等待引导信号9ms低电平结束，若超过10ms强制退出\t\t&#123;\t\t\tdelay_10us(1);//延时约10us\t\t\ttime_cnt--;\t\t\tif(time_cnt==0)return;\t\t\t\t&#125;\t\tif(IRED)//引导信号9ms低电平已过，进入4.5ms高电平\t\t&#123;\t\t\ttime_cnt=500;\t\t\twhile(IRED&amp;&amp;time_cnt)//等待引导信号4.5ms高电平结束，若超过5ms强制退出\t\t\t&#123;\t\t\t\tdelay_10us(1);\t\t\t\ttime_cnt--;\t\t\t\tif(time_cnt==0)return;\t\t\t\t&#125;            //接下来是读取地址、地址反码、控制、控制反码。\t\t\tfor(i=0;i&lt;4;i++)//循环4次，读取4个字节数据\t\t\t&#123;\t\t\t\tfor(j=0;j&lt;8;j++)//循环8次读取每位数据即一个字节\t\t\t\t&#123;\t\t\t\t\ttime_cnt=600;\t\t\t\t\twhile((IRED==0)&amp;&amp;time_cnt)//等待数据1或0前面的0.56ms结束，若超过6ms强制退出\t\t\t\t\t&#123;\t\t\t\t\t\tdelay_10us(1);\t\t\t\t\t\ttime_cnt--;\t\t\t\t\t\tif(time_cnt==0)return;\t\t\t\t\t\t&#125;\t\t\t\t\ttime_cnt=20;\t\t\t\t\twhile(IRED)//等待数据1或0后面的高电平结束，若超过2ms强制退出\t\t\t\t\t&#123;\t\t\t\t\t\tdelay_10us(10);//约0.1ms\t\t\t\t\t\tired_high_time++;\t\t\t\t\t\tif(ired_high_time&gt;20)return;\t\t\t\t\t\t&#125;\t\t\t\t\tgired_data[i]&gt;&gt;=1;//先读取的为低位，然后是高位\t\t\t\t\tif(ired_high_time&gt;=8)//如果高电平时间大于0.8ms，数据则为1，否则为0\t\t\t\t\t\tgired_data[i]|=0x80;//最高位赋1\t\t\t\t\tired_high_time=0;//重新清零，等待下一次计算时间\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tif(gired_data[2]!=~gired_data[3])//校验控制码与反码，错误则清空后返回\t\t&#123;\t\t\tfor(i=0;i&lt;4;i++)\t\t\t\tgired_data[i]=0;\t\t\treturn;\t\t\t&#125;\t&#125;\t\t&#125;\nmain.c:\nvoid main()&#123;\t\tu8 ired_buf[3];\tired_init();//红外初始化\twhile(1)\t&#123;\t\t\t\t\t\tired_buf[0]=gsmg_code[gired_data[2]/16];//将控制码高4位转换为数码管段码\t\tired_buf[1]=gsmg_code[gired_data[2]%16];//将控制码低4位转换为数码管段码\t\tired_buf[2]=0X76;//显示H的段码\t\tsmg_display(ired_buf,6);\t\t&#125;\t\t&#125;\nLCD1602\nliquid crystal display 液晶显示屏，一种字符型液晶显示模块，可以显示 16*2 个字符，每个字符是 5*7 点阵。\n\nP0 P2 会和数码管、LED 一定程度上冲突。\n\n\n地。\n\n\nVcc。\n\n\n调对比度的。\n\n\nRS：数据指令端。1代表 DB 是数据，0代表是指令。\n\n\nRW：1读0写。\n\n\nE：类似时钟的使能。高电平有效，下降沿执行。\n\n\nDB：并行输入。一个字节长。\n\n\nBG：背光灯电源。\n\n\n内部结构图\n\n类似 SMG，想显示1并不是直接输入1，而是操纵数码管右侧一竖被点亮。字模库起的就是这个作用，里面有固定的 ROM 和用户课自定义的 RAM。\nDDRAM 长于屏幕，可以通过移平实现滚动效果。\nAC address controller，可以自动移位写入数据。\n字模库中的数据大多数和 ASCII 码是一样的。\n指令\n\n\n\n\n\n\n\n\n\n\n初始化指令\n初始化要做哪些操作？\n规定显示区域（如8位数据接口，2行显示，5*7点阵，即为0011 10xx，如果取0即为 0x38.）。\n显示的模式设置（如开启显示，关闭光标，关闭光标闪烁：0000 1101，即 0x0D）。\n进入模式设置（如读写后光标++，屏幕不动：0000 0110,0x06。如果是滚动屏幕则为）。\n清屏（0x01）。\n显示指令\n先设置 DDRAM 初始地址，0x80|AC（开头的8是 DDRAM 固定指令信息不能改。后面的全是0，与 AC 光标位置做与，AC 不同位置的值见 DDRAM 地址表）.\n然后发送数据。\n时序\n\n\n\n模块化\n第一阶段我们先编写 LCD1602 模块化编程代码，这一部分主要显示静态内容，用于程序编写过程中显示变量进行调试。\n目标模块化函数：\n\n//LCD1602.h#ifndef __LCD1602_H__#define __LCD1602_H__#include &quot;reg52.h&quot;#include &quot;intrins.h&quot;sbit LCD_RS=P2^6;sbit LCD_RW=P2^5;sbit LCD_E=P2^7;#define LCD_DATAPORT P0void LCD_Delay1ms();\t\t//@11.0592MHzvoid LCD_WriteCommand(unsigned char Command);void LCD_WriteData(unsigned char Data);void LCD_Init();void LCD_SetCursor(unsigned char line, unsigned char column);unsigned int LCD_Pow(unsigned char x, unsigned char y);void LCD_ShowChar(unsigned char line, unsigned char column, unsigned char c);void LCD_ShowString(unsigned char line, unsigned char column, unsigned char str[]);void LCD_ShowNum(unsigned char line, unsigned char column, unsigned int num, unsigned char length);void LCD_ShowSignedNum(unsigned char line, unsigned char column, int num, unsigned char length);void LCD_ShowHexNum(unsigned char line, unsigned char column, unsigned int num, unsigned char length);void LCD_ShowBinNum(unsigned char line, unsigned char column, unsigned int num, unsigned char length);#endif\n//LCD1602.c#include &quot;LCD1602.H&quot;void LCD_Delay1ms()\t\t//@11.0592MHz&#123;\tunsigned char i, j;\t_nop_();\t_nop_();\t_nop_();\ti = 11;\tj = 190;\tdo\t&#123;\t\twhile (--j);\t&#125; while (--i);&#125;void LCD_WriteCommand(unsigned char Command)&#123;\tLCD_RS=0;\tLCD_RW=0;\tLCD_E=0;\tLCD_DATAPORT=Command;\tLCD_Delay1ms();\tLCD_E=1;\tLCD_Delay1ms();\tLCD_E=0;&#125;void LCD_WriteData(unsigned char Data)&#123;\tLCD_RS=1;\tLCD_RW=0;\tLCD_E=0;\tLCD_DATAPORT=Data;\tLCD_Delay1ms();\tLCD_E=1;\tLCD_Delay1ms();\tLCD_E=0;&#125;void LCD_Init()&#123;\tLCD_WriteCommand(0x38);\tLCD_WriteCommand(0x0C);\tLCD_WriteCommand(0x06);\tLCD_WriteCommand(0x01);&#125;void LCD_SetCursor(unsigned char line, unsigned char column)&#123;\tif(line==1)&#123;\t\tLCD_WriteCommand(0x80|(column-1));\t&#125;\telse&#123;\t\tLCD_WriteCommand(0x80|(column-1)+0x40);\t&#125;&#125;unsigned int LCD_Pow(unsigned char x, unsigned char y)&#123;\tunsigned char i=y;\tunsigned int res=1;\tfor(;i&gt;0;i--)res*=x;\treturn res;&#125;void LCD_ShowChar(unsigned char line, unsigned char column, unsigned char c)&#123;\tLCD_SetCursor(line, column);\tLCD_WriteData(c);&#125;void LCD_ShowString(unsigned char line, unsigned char column, unsigned char str[])&#123;\tunsigned int i=0;\tLCD_SetCursor(line, column);\twhile(str[i]!=&#x27;\\0&#x27;)&#123;\t\tLCD_WriteData(str[i]);\t\ti++;\t&#125;&#125;void LCD_ShowNum(unsigned char line, unsigned char column, unsigned int num, unsigned char length)&#123;\tunsigned char i;\tunsigned base;\tLCD_SetCursor(line, column);\tfor(i=length;i&gt;0;i--)&#123;\t\tbase=LCD_Pow(10, i-1);\t\tLCD_WriteData(num/base%10+&#x27;0&#x27;);\t\t&#125;&#125;void LCD_ShowBinNum(unsigned char line, unsigned char column, unsigned int num, unsigned char length)&#123;\tunsigned char i;\tunsigned char base;\tunsigned char single_num;\tLCD_SetCursor(line, column);\tfor(i=length;i&gt;0;i--)&#123;\t\tbase=LCD_Pow(2, i-1);\t\tsingle_num=num/base%2+&#x27;0&#x27;;\t\tLCD_WriteData(single_num);\t\t&#125;&#125;void LCD_ShowHexNum(unsigned char line, unsigned char column, unsigned int num, unsigned char length)&#123;\tunsigned char i;\tunsigned char base;\tunsigned char single_num;\tLCD_SetCursor(line, column);\tfor(i=length;i&gt;0;i--)&#123;\t\tbase=LCD_Pow(16, i-1);\t\tsingle_num=num/base%16;\t\tif(single_num&lt;=9)single_num+=&#x27;0&#x27;;\t\telse single_num+=&#x27;A&#x27;-10;\t\tLCD_WriteData(single_num);\t\t&#125;&#125;void LCD_ShowSignedNum(unsigned char line, unsigned char column, int num, unsigned char length)&#123;\tunsigned char i;\tunsigned base;\tLCD_SetCursor(line, column);\tif(num&gt;0)LCD_WriteData(&#x27;+&#x27;);\telse &#123;LCD_WriteData(&#x27;-&#x27;);num=-num;&#125;\tfor(i=length;i&gt;0;i--)&#123;\t\tbase=LCD_Pow(10, i-1);\t\tLCD_WriteData(num/base%10+&#x27;0&#x27;);\t\t&#125;&#125;\n如果希望屏幕滚动，一定时间执行一次LCD_WriteCommand(0x18); 屏幕左移指令。\n直流电机\n电能转机械能。\n\n第二种驱动方式可以双向，电机可以双向驱动，转向不同。\n直接驱动电机还起到电感的作用，断开电源后电机产生电压，可以形成一个回路慢慢消耗掉。\nPWM：脉冲信号调制。\n\n比如调 LED 灯，我们可以加一个有电位器的电阻（滑动变阻器）。\n电机可能这种方式有局限性，比如电阻太大直接不转，驱动不起来，太小烧毁。\n脉冲调制比如：“转2s”“停1s”“转2s”“停1s”……因为电机有惯性，所以可行。\n示例：LED 流水灯：\nsbit LED=P2^0;void delay(unsigned char i)\t\t//@11.0592MHz&#123;\twhile (--i);&#125;void main()&#123; \tunsigned char period=100;\tunsigned char ti;\tunsigned char i;\twhile(1)&#123;\t\tfor(ti=0;ti&lt;100;ti++)&#123;\t\t\tfor(i=0;i&lt;20;i++)&#123;\t\t\t\tLED=0;\t\t\t\tdelay(ti);\t\t\t\tLED=1;\t\t\t\tdelay(period-ti);\t\t\t&#125;\t\t&#125;\t\tfor(ti=100;ti&gt;0;ti--)&#123;\t\t\tfor(i=0;i&lt;20;i++)&#123;\t\t\t\tLED=0;\t\t\t\tdelay(ti);\t\t\t\tLED=1;\t\t\t\tdelay(period-ti);\t\t&#125;\t\t&#125;\t\t&#125;&#125;\n可以利用 timer 来计数，我们知道 timer 是一直增加的，我们可以设置一个比较值，当 timer 大于比较值时输出1，小于时输出0类似这样。\n#include &quot;regx52.h&quot;#include &quot;delay.h&quot;#include &quot;nixie.h&quot;#include &quot;timer0.h&quot;#include &quot;key.h&quot;sbit LED=P1^0 ;unsigned char compare;unsigned int T0Count;void main()&#123;\tunsigned char key;\tunsigned char level=1;\ttime0Init();\tcompare=5;\twhile(1)&#123;\t\tkey=key_scan(0);\t\tif(key==KEY1_PRESS)level++;\t\telse if(key==KEY2_PRESS)if(level&gt;1)level--;\t\tlevel%=5;\t\tif(level==0)level++;\t\tif(level==1)compare=0;\t\telse if(level==2)compare=50;\t\telse if(level==3)compare=75;\t\telse if(level==4)compare=100;\t\tNixie_Scan(1,level);\t\t&#125;&#125;void Timer0_Routine() interrupt 1&#123;  TL0 = 0xAE;  TH0 = 0xFB;  T0Count++;  if(T0Count&gt;=100)  &#123;    T0Count=0;  &#125;  if(T0Count&lt;compare)&#123;  \t LED=1;  &#125;  else if(T0Count&gt;compare)LED=0;&#125;\nADC\n使得调节开发板上的电位器时，数码管上能够显示 AD 模块 采集电位器的电压值且随之变化。\n开发板上有三个应用：光敏电阻，热敏电阻，电位器。\n一般 AD 转换有多个输入，提高使用效率。\n\nADC 通过地址锁存与译码判断采用哪个输入。\n\n运算放大器，可以作为电压比较器、同相反相放大器、电压跟随器\nT 型电阻网络 DA 转换器：\n\n低通滤波器：输入是有直交流两个分量的，可以通过低通滤波器提取出直流。电压跟随器让驱动能力增加。\n\nda 简单些，因为d值是固定的，根据d调整a即可。\nad 怎么判断电压大小？我们用一个电压值和给定电压作比较，看大于还是小于，逐渐逼近来找近似值。\n分辨率：精细程度。比如8位的 ad 可以把 5v 转换到 0~255 范围。\n转换速度：最大采样/建立频率。\nXPT2046 采用 SPI，的时序在上升沿输入，下降沿输出，可实现输入再输出。\n\n采用单端模式（触摸屏查分会更好一些）。\nPD1=1 采用内部参考电压，内部电压为 2.5v，我们知道adc 映射范围是 0~5v，所以1采用内部电压不如0采用5v的外部电压。\nA 地址配置：\n\nVBAT：电池电压。\nAUX：辅助电压。\nXP YP：XY 正极。\n读取指令并 ad 转化：\n#define XPT2046_XP_8 0x9C    // 1001 1100#define XPT2046_YP_8 0xDC    // 1101 1100#define XPT2046_VBAT_8 0xAC  // 1010 1100#define XPT2046_AUX_8 0xEC   // 1110 1100#define XPT2046_XP_12 0x94   // 1001 0100#define XPT2046_YP_12 0xD4   // 1101 0100#define XPT2046_VBAT_12 0xA4 // 1010 0100#define XPT2046_AUX_12 0xE4  // 1110 0100unsigned int XPT2046_ReadAD(unsigned char command)&#123;    unsigned char i;    unsigned char temp=command;    unsigned int ADValue = 0;    XPT2046_DCLK = 0;    XPT2046_CS = 0;    for (i = 0; i &lt; 8; i++)    &#123;        XPT2046_DIN = temp &gt;&gt; 7;        temp &lt;&lt;= 1;        XPT2046_DCLK = 1;        XPT2046_DCLK = 0;    &#125;    for (i = 0; i &lt; 12; i++)    &#123;        XPT2046_DCLK = 1;        XPT2046_DCLK = 0;        if (XPT2046_DOUT)            ADValue |= (0x0800 &gt;&gt; i);    &#125;    XPT2046_CS = 1;    //for 12 bit:    if(command&amp;0x08)return ADValue&gt;&gt;4;    else return ADValue;&#125;\nvoid main()&#123;\tunsigned int ADValue = 0;\tLCD_Init();\tLCD_ShowString(1, 1, &quot;ADC NTC RG&quot;);\twhile (1)\t&#123;\t\tADValue = XPT2046_ReadAD(XPT2046_XP_8);//电位器\t\tLCD_ShowNum(2, 1, ADValue, 3);\t\tADValue = XPT2046_ReadAD(XPT2046_YP_8);//热敏电阻\t\tLCD_ShowNum(2, 5, ADValue, 3);\t\tADValue = XPT2046_ReadAD(XPT2046_VBAT_8);//光敏电阻\t\tLCD_ShowNum(2, 9, ADValue, 3);\t\tdelayMs(10);\t&#125;&#125;\ndac 也是采用 pwm 的原理，改变01 叫错频率来模拟灯的亮度（输出口：P2^1）。所以 dac 用处不广泛，因为可以被代替。\n完结：库函数封装说明\n从12月开始决定入嵌入式开始，经历了5个月的学习，终于把入门模块基本弄懂并且跟着代码敲了一遍。\n在这期间跟随普中课程老师学习到的封装习惯让我主键开始留意每做完一个模块后就进行调试并把该模块封装起来，供下次使用该模块时可以快捷导入。\n后来浅了解了一些 git 的项目管理后，我又把封装好的函数发布到 github repository 上。\n单片机版本：STC89C52RC\ngithub 仓库地址：Jingqing3948/MySTC89C52RCFunction: 学习 STC89C52RC 单片机时的一些封装好的库函数。 (github.com)\n函数包含：\n\nAT24C02：掉电不丢失存储器。\nDS18B20：温度传感器。\ndelay：stc-isp 生成的基于 11.0592MHz 晶振的延时函数。\nIIC：IIC 总线的使用，配合 AT24C02 模块使用。\nIR：红外遥控模块，包括外部中断、定时器等内容。\nKey：四个独立按键。\nLCD1602：LCD1602 显示屏。\nNiXie：数码管。\nTimer：定时器中断函数。\npublic.h：无用，定义了 u8 u16 两个变量。\n有问题欢迎随时与博主沟通。如侵犯他人权益会尽快删除！\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["C"]},{"title":"问题解决：ubuntu 安装 emscripten 时 install latest 报错","url":"/2023/10/09/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E6%8A%A5%E9%94%99/","content":"学习官网参考：Compiling a New C/C++ Module to WebAssembly - WebAssembly | MDN (mozilla.org)\n报错信息\n形如：\nError: Downloading URL &#x27;https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2&#x27;: &lt;urlopen error [Errno 104] Connection reset by peer&gt;error: installation failed!\nOS：\n$ uname -aLinux jingqing 5.19.0-35-generic #36~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 17 15:17:25 UTC 2 x86_64 x86_64 x86_64 GNU/Linux\n产生错误原因分析\n\nemsdk install latest报错（因为从谷歌中下载，cmd中命令形式访问不到google）\n版权声明：本文为CSDN博主「小白啥时候能进阶成功」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/qq_34754747/article/details/103815349\n\n非常感谢博主的答疑解惑，不过我没有看得太懂原文中的解决方案，网上搜到的大多数方案也是 windows 环境下的解决方案，因此我决定自己写一个 ubuntu 系统下的补安装。\n解决方案\n说白了就是我自己复制链接到浏览器里，下载安装这几个包，放到 emsdk 的指定位置。\n这里有两个要注意的点，这一部分主要是分析，不想看的同学可以直接跳到具体步骤处：\n\n\nemsdk install 的默认安装规则是：不管你有没有安装过这些包，我 install latest 都是重新安装，保证最新版本。但是现在问题是 install latest 有问题，我要手动安装包放进去。\n我们打开 emsdk.py 通过搜索关键词可以找到报错信息的位置：\n# ./emsdk.py:675# On success, returns the filename on the disk pointing to the destination file that was produced# On failure, returns None.def download_file(url, dstpath, download_even_if_exists=False, filename_prefix=&#x27;&#x27;):  debug_print(&#x27;download_file(url=&#x27; + url + &#x27;, dstpath=&#x27; + dstpath + &#x27;)&#x27;)  file_name = get_download_target(url, dstpath, filename_prefix)  if os.path.exists(file_name) and not download_even_if_exists:    print(&quot;File &#x27;&quot; + file_name + &quot;&#x27; already downloaded, skipping.&quot;)    return file_name  try:    u = urlopen(url)    mkdir_p(os.path.dirname(file_name))    with open(file_name, &#x27;wb&#x27;) as f:      file_size = get_content_length(u)      if file_size &gt; 0:        print(&quot;Downloading: %s from %s, %s Bytes&quot; % (file_name, url, file_size))      else:        print(&quot;Downloading: %s from %s&quot; % (file_name, url))      file_size_dl = 0      # Draw a progress bar 80 chars wide (in non-TTY mode)      progress_max = 80 - 4      progress_shown = 0      block_sz = 256 * 1024      if not TTY_OUTPUT:          print(&#x27; [&#x27;, end=&#x27;&#x27;)      while True:          buffer = u.read(block_sz)          if not buffer:              break          file_size_dl += len(buffer)          f.write(buffer)          if file_size:              percent = file_size_dl * 100.0 / file_size              if TTY_OUTPUT:                  status = r&quot; %10d  [%3.02f%%]&quot; % (file_size_dl, percent)                  print(status, end=&#x27;\\r&#x27;)              else:                  while progress_shown &lt; progress_max * percent / 100:                      print(&#x27;-&#x27;, end=&#x27;&#x27;)                      sys.stdout.flush()                      progress_shown += 1      if not TTY_OUTPUT:        print(&#x27;]&#x27;)        sys.stdout.flush()  except Exception as e:    errlog(&quot;Error: Downloading URL &#x27;&quot; + url + &quot;&#x27;: &quot; + str(e))    if &quot;SSL: CERTIFICATE_VERIFY_FAILED&quot; in str(e) or &quot;urlopen error unknown url type: https&quot; in str(e):      errlog(&quot;Warning: Possibly SSL/TLS issue. Update or install Python SSL root certificates (2048-bit or greater) supplied in Python folder or https://pypi.org/project/certifi/ and try again.&quot;)    rmfile(file_name)    return None  except KeyboardInterrupt:    rmfile(file_name)    exit_with_error(&quot;aborted by user, exiting&quot;)  return file_name\n大致一看能看明白逻辑，如果 download_even_if_exists = True 那么无论包是否已经存在都要安装，否则为 False 就只安装不存在的包，我们需要为 False。\n搜索函数名查看在哪里使用了这个函数：\n# ./emsdk.py:1411received_download_target = download_file(url, download_dir, not KEEP_DOWNLOADS, filename_prefix)\n这个 KEEP_DOWNLOADS 是一个环境变量，默认为0，我们需要他为1，传入函数的参数则为0（False），即已存在文件不再重复下载。\n在终端输入 ./emsdk --help 可以看到提示信息如下：\nEnvironment:      EMSDK_KEEP_DOWNLOADS=1     - if you want to keep the downloaded archives.      EMSDK_NOTTY=1              - override isatty() result (mainly to log progress).      EMSDK_NUM_CORES=n          - limit parallelism to n cores.      EMSDK_VERBOSE=1            - very verbose output, useful for debugging.\n也就是说只要安装时单独指定此变量值为1即可。\n\n\n第二步就是如何下载文件了。下载什么文件？放到哪个目录下？\n这里大家可以通过 download_file 的 print debug 调试来查看他校验文件是否存在是去哪里校验的，我就不再具体展开讲调试步骤了，结论就是：他在 emsdk/downloads/ 目录下先查找一下待下载的压缩包是否存在，那么我们复制报错信息中的 url 下载文件到这个 downloads 文件夹下即可（没有就新建）。\n\n\n具体步骤\n\n\n首先要安装所缺的所有包，一个个安装，报错信息里提示什么安装什么。比如文章开头的报错信息中下载链接是：https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2，就先安装这个。\nnode: https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2\nwasm-binaries: https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2\n安装完成后要重命名 b90507fcf011da61bacfca613569d882f7749552-wasm-binaries.tbz2。\n\n\n移入 emsdk/downloads 文件夹下，不用解压。\n\n\n执行 EMSDK_KEEP_DOWNLOADS=1 变量赋值。\n\n\n执行 ./emsdk install latest  。\n\n\njingqing3948@jingqing:~/Webassembly/emsdk$ ./emsdk install latestResolving SDK alias &#x27;latest&#x27; to &#x27;3.1.44&#x27;Resolving SDK version &#x27;3.1.44&#x27; to &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;Installing SDK &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;..Skipped installing node-16.20.0-64bit, already installed.Skipped installing releases-b90507fcf011da61bacfca613569d882f7749552-64bit, already installed.All SDK components already installed: &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;.\n好哎，看来是自己单独安装的文件包都可以用，他会自己解压文件包后提示 All SDK components already installed。\n接下来就是下一步：./emsdk activate latest.\n最后是 source ./emsdk_env.sh 配置好环境变量。\n","categories":["破浪（遇到的bug及解决方案）"],"tags":["Ubuntu"]},{"title":"问题解决：微信小程序通过 node 连接 mysql——方法，简要原理，及一些常见问题","url":"/2023/03/02/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87%20node%20%E8%BF%9E%E6%8E%A5%20mysql%E2%80%94%E2%80%94%E6%96%B9%E6%B3%95%EF%BC%8C%E7%AE%80%E8%A6%81%E5%8E%9F%E7%90%86%EF%BC%8C%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","content":"前言\n博主自己在22年夏天根据课程要求做了一个小程序连接阿里云服务器的案例，在最近又碰到了相应的需求。\n原参考文章：微信小程序 Node连接本地MYSQL_微信小程序nodejs连接数据库_JJJenny0607的博客-CSDN博客 ,还请多多支持原作者！\n第二次尝试的时候已经熟练许多了，但是还是遇到了很多挺烦人的问题，也浪费了很多时间排查 bug。因此博主打算趁着刚做过记忆还深刻的时候，把全过程、博主自己的理解和遇到的一些问题的解决方法整理出来。当然我也不可能能解决所有问题，遇到的部分问题也只是针对我自己的情况可以解决。因此如果 solutions 不起效或遇到其他问题，可以在评论区留言，我会与大家沟通（不保证能否解决~）。\n原理\n\nnodejs 作为中介服务器，可以让小程序连接 mysql 数据库。\n步骤\n如果不出错误的话， 基本流程就是跟着上面的文章来的。\n\n\n下载 node。可以在 cmd 中输入 node -v 查看有无成功下载。\n\n\n\n新建一个数据库，这一部分很简单，有 mysql 相关基础的读者应该没问题，也可以看博主的 mysql 专栏学习。\n\n\n新建一个小程序，在结构中新建 server 文件夹用于存储 node 本地服务器相关代码。\n\n\n\n右键 server 文件夹，点击“在内建终端中打开”，安装一些所需的包。\n\n\nnpm init -ynpm i mysql --save-devnpm install body-parser --save-devnpm install express --save-dev\n\n在文件夹下新建 server.js 文件，编写代码。\n\nconst express=require(&#x27;express&#x27;)const bodyParser =require(&#x27;body-parser&#x27;)const app=express()const mysql = require(&#x27;mysql&#x27;)const IPAddress=&#x27;[你的数据库地址]&#x27;//因为这里是要链接远程数据库，ip 地址是 mysql 的地址！！本地就是 127.0.0.1，服务器上就自己找找看const UserName=&#x27;[mysql 用户名]&#x27;const PWD=&#x27;[mysql 密码]&#x27;const DBName=&#x27;[要操作的数据库名]&#x27;app.use(express.json())app.use(bodyParser.json())app.use(bodyParser.urlencoded(&#123; extended: false &#125;))//这上面一段固定的，[] 的部分需要根据自己数据库的信息修改//处理get请求。这里是一个 get 请求的方法演示，作用是查询 table1 表中的所有数据并返回。app.get(&#x27;/getUser&#x27;,(req,res)=&gt;&#123; //这里的是 get 方法 getUser，对应了刚才的页面发来的请求。就会执行这个方法。  //参数传入是在 req.body 对象里面。比如上面的语句是获取传入的 openid 变量，并且我们新定义一个叫 openid 的变量存储传入的 openid 变量  var connection=mysql.createConnection(&#123;    host:IPAddress,    port: 3306,\t\t//端口号，mysql 固定3306    user:UserName,    password:PWD,    database:DBName  &#125;)//配置连接的属性  connection.connect();//尝试连接  connection.query(&quot;select * from table1&quot;,function(error,results,fields)&#123;//执行查找语句    if(error) console.log(error);//执行失败的话    res.json(results)    console.log(results)      &#125;)  connection.end();//断开连接  &#125;)app.listen(3000,()=&gt;&#123;//这是一个监听端口，会输出监听到的信息。上面的 console.log 就会在这里输出  console.log(&#x27;server running at http://&#x27;+IPAddress+&#x27;:3000&#x27;)&#125;)\n我们的 nodejs 是部署在本地的，就在 server 文件夹里。node_modules 是下载的 nodejs 包，server.js 是我们的操作 nodejs 的代码。\n我们在需要调用数据库的页面里先调用本地服务器，比如在 mysqlTest.js 中，onLoad 里：\nonLoad() &#123;    //我们写一个调用数据库函数，使得本页面加载时调用此函数，查找 youqi.data 里的所有条目。        wx.request(&#123;            method: &#x27;GET&#x27;,//这里要和 server.js 定义的 post or get 一致！！！            url: &#x27;http://[本地 IPV4 地址]:3000/getUser&#x27;,//这里的 ip 地址不是数据库的地址，而是你的电脑本地的地址，因为这一步的操作是要找到本地 nodejs 服务器。getUser 要和 server.js 中定义的方法名一致。            data: &#123;              //这里面是传入参数。比如我们要 select * from data where openid= 给定的 openid，就可以从这里传入            &#125;,            success: function (res) &#123;//成功获取到值，返回一个 res 对象。如果不知道 res 对象里面包含什么，可以先输出 res 对象看一下其中都包含什么              console.log(res);            &#125;,            fail: function () &#123;//没有获取到值，说明这中间出问题了。              console.log(&quot;获取失败&quot;);            &#125;          &#125;)    &#125;,\n本地 IPV4 地址是怎么查出来的？打开 cmd，输入 ipconfig。无线局域网适配器 WLAN 里的 IPV4 即是。\nnodejs 接收到了请求，就会执行 server.js 里对应的方法。\n如何运行\n首先 nodejs 服务器需要手动开启，我还不会自动开启。\n右键 server 文件夹，在内建终端中打开，然后在终端中输入：\n\n下面那句话说明正常启动服务器并且开始监听。\n我们输出一下 res，看看成功会返回什么信息。调试器里的 console 输出：\n\ndata 里是我们数据库的查询结果。\n\nres.data 获取这个15长度的 Array。\n\n然后比如我们要获取其中的 time 值，就是 res.data[0].time, res.data[1].time… res.dat[14].time。\n{} 表示其中是一个对象变量，通过句号+索引名称获取特定的值。\n而刚才的一直在监听的内建终端里输出：\n\n这个的输出对应 function(error,results,fields) 里的 console.log(results)。如果查询失败，error 也是在这个内建终端里输出。\n常见问题\n数据库无法连接？\n建好数据库后，最好就先用 cmd 或 workbench 连接一下试试。如果能成功连接并查询，之后出问题也可以排除 mysql 的一部分问题。\n如果采用云服务器（如阿里云）连接不上，可能的问题有：\n\n\n服务器端口 80 和 3306 没开。（不建议一键全部放行，有被hacker get 的风险）\n\n\nmysql 需要有一个用户能在所有 ip 地址里对该数据库进行读写操作，这里可以参考 DCL 的内容来新建符合要求的 user。Mysql_9 SQL 语句——DCL_sql语言dcl_灰海宽松的博客-CSDN博客\n\n\n服务器防火墙的问题，要开启3306端口。\n\n\n\n小程序报错 ERR TIMEOUT\n打开网站可以看到 404 显示。\n\n\n首先先确保前面那个问题确实解决了，该数据库确实可以从本地连接，，不是数据库的问题。\n\n\n再确认 get post 方法是否对应，方法名是否写错。很多时候输入了错误的链接也会显示 404.\n\n\n小程序不校验合法域名是否打开。\n\n\n启用或关闭 windows 功能——Internet Information Services，及其可承载 web 核心，子项全部打开。点击确定。如果成功启动，在浏览器中输入 127.0.0.1，应该可以看到：\n\n\n\n检查方法名，get post 类别是否写错。\n\n\n","categories":["破浪（遇到的bug及解决方案）"],"tags":["WXMiniProgram"]},{"title":"技术学习：黑马程序员 Redis","url":"/2025/05/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Redis/","content":"前言\n学习自：【黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目】 \nSQL vs. NoSQL\n\nS：结构化，比如在 MySQL 我们需要定义一个表，第一个属性是 id 第二个是 name 第三个是 age…… 定义好表之后所有新插入的数据都必须遵循这个结构，各个表还可能有外键等关联，所以总的来说不能随意修改表的属性。而 NoSQL 结构要求没那么严格，比如下面这种 Redis 定义方式也可以，就是没啥章法：\n\n\n​\t除了键值类型，还有文档类型，列类型，图类型等 NoSQL。\n\n\nR：关联的，SQL 数据库的各个属性之间有关联而 NoSQL 未必。\n\n\nSQL 语句查询：关系型数据库都支持，而非关系型不支持。\n\n\nACID 事务：NoSQL 不支持。\n\n\n存储位置：SQL 在硬盘，NoSQL 在内存。\n\n\nSQL 对安全一致性要求较高，NoSQL 对性能要求较高。\n\n\nRedis\nRedis Remote Dictionary Server 是一种基于内存的键值对数据库，被创造的原因就是 MySQL 性能太差。里面没有表什么的结构，就是存储一对一对的键值，所以是 NoSQL 数据库。值可以是复杂的数据形式，比如键是 1001，值是 {name: “xxx”, age:“19”}…… 这样的 json 格式。\nRedis 是单线程的，但是效率仍然比 MySQL 高很多，因为内存存取速度远大于硬盘，C 语言编写，IO 多路复用等特点。\n支持数据持久化，定期将数据从内存持久化到磁盘存储。\n支持主从集群，分片集群。\n支持多语言客户端。\nRedis 基础\n安装部分就跳过不做过多赘述了。\nRedis 默认启动方式是前台启动，会阻塞整个会话窗口。可以通过修改配置文件的方式改为后台启动。或者在 system 文件夹内新建一个系统服务 .service 文件，实现开机自启动。\n配置完成后，终端客户端连接：\n$ systemctl start redis # 启动 redis 后台服务$ redis-cli -h 127.0.0.1 [-p port] [-a password] # 客户端终端方式连接 redis-cli&gt; AUTH password # 输入用户名和密码进行登录，也可以在上面 -a 那一步登录 不过这样不安全&gt; ping # 如果成功登录了就会收到：PONG 否则会受到权限不够的提示&gt; SELECT 1 # 选择一个库，0-15&gt; get key # 获取某个键对应的值&gt; set key value # 添加一个键值对\n图形化客户端连接：其实不是官方开发的是 Github 上有人发布的开源图形化客户端。\nRedis 通用命令\nKeys\nKeys pattern 查询符合某种模式的键，比如 keys a* 是查询 a 打头的所有键值。\n这个查询并不高效，而且会阻塞其他请求，所以在生产环境中尽量不要使用，特别是不要在主节点上使用。\nDel\nDel key1 key2 ... 删除键值对。返回值是成功删除的键数量。\nMSet\nmsel k1 v1 k2 v2 ... 批量添加键值对。\nExists\nexists key 查询指定键是否存在。\nExpire\n给键值对设定一个有效期，到期自动删除。\nexpire key seconds\nTTL\nttl key 查询这个键还有多久过期。-1表示永久有效，-2表示已过期。\nRedis 数据结构\nkey 一般是 string 类型，而 value 类型多种多样。\n\nString：字符串。\nhash\nlist\nset\nsortedset\n\n以上为基本数据类型。\n\ngeo\nbitmap\nhyperlog\n\n以上为特殊数据类型。\n在 redis 里面输入 help @想要查询的 command 名称 就可以进行查询。\nString\n最简单的存储方式，字符串类型。具体可以分为三类：String，int，float。\n是的 int 和 float 在 redis 里被视作属于 string。\n这些底层存储方式都是字节数组，只不过数字会被直接转化为对应的二进制，这样能存储的范围更大。\n\n\n\n字符串常用命令\n解释\n\n\n\n\nSet key value\n添加键值对，如果存在则覆盖\n\n\nGet key\n获取这个键的值\n\n\nMSet k1 v1 k2 v2\n批量添加\n\n\nMGet k1 k2 k3\n批量获取\n\n\nINCR key\n让一个整形 Key 对应的值自增1\n\n\nINCRBY key step\n指定步长的自增，如步长是2。可以指定为负数来取代 DECR 的功能。\n\n\nINCRBYFLOAT key step\n浮点数据的指定长度的自增\n\n\nSETNX k v\n添加一个 String 类型的键值对，如果存在则不执行返回0. 其实 set key value nx 也能实现同样的效果\n\n\nSETEX k v seconds\n添加一个 String 类型的键值对并指定有效期。set key value ex 也能实现同样的效果\n\n\n\nKey 的层级格式\nRedis 没有 MySQL 的 Table，如何区分不同的 key 意义呢，比如一个商品 id 是1，一个顾客 id 也是1.\nRedis 允许键值进行拼接，如：项目名:业务名:类型:id 这样。\n127.0.0.1:6379&gt; set project:user:1 &#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;: 21&#125;&#x27;OK127.0.0.1:6379&gt; set project:user:2 &#x27;&#123;&quot;id&quot;:2, &quot;name&quot;:&quot;Rose&quot;, &quot;age&quot;: 18&#125;&#x27;OK127.0.0.1:6379&gt; set project:product:1 &#x27;&#123;&quot;id&quot;:1, &quot;name&quot;:&quot;小米11&quot;, &quot;price&quot;: 4999&#125;&#x27;127.0.0.1:6379&gt; set project:product:2 &#x27;&#123;&quot;id&quot;:2, &quot;name&quot;:&quot;荣耀6&quot;, &quot;price&quot;: 2999&#125;&#x27;OK\n查看图形化客户端可以发现：Key 已经形成层级结构。\n\nHash\n无序字典，类似 java HashMap.\n之前我们学过，String 处理对象的方式是变成 json 字符串，但是这样缺点是修改比较难操作。而 Hash 数据结构是可以真正将所有字段都分开存储方便操作。\n\n\n\nHash 常用命令\n解释\n\n\n\n\nHSET key field value\n添加或者修改 hash 类型 key 的 field 的值\n\n\nHGET key field\n获取一个 hash 类型 key 的 field 的值\n\n\nHMSET key f1 v1 ...\n批量添加多个 hash 类型 key 的 field 的值（Redis 4.0+ 推荐用 HSET）\n\n\nHMGET key f1 f2 ...\n批量获取多个 hash 类型 key 的 field 的值\n\n\nHGETALL key\n获取一个 hash 类型的 key 中的所有的 field 和 value\n\n\nHKEYS key\n获取一个 hash 类型的 key 中的所有 field\n\n\nHVALS key\n获取一个 hash 类型的 key 中的所有 value\n\n\nHINCRBY key field step\n让一个 hash 类型 key 的字段值自增，并指定步长\n\n\nHSETNX key field value\n添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行\n\n\n\n添加完字段之后，图形化界面中可视化结构：\n\nList\n大致可以看做 java 的双向链表结构。有序，插入删除速度快，查询速度一般。\n常常用于存储有顺序的数据，比如排队，朋友圈点赞列表等。\n\n\n\nList 常用命令\n解释\n\n\n\n\nLPUSH key element ...\n向列表左侧插入一个或多个元素\n\n\nLPOP key\n移除并返回列表左侧的第一个元素，没有则返回 nil\n\n\nRPUSH key element ...\n向列表右侧插入一个或多个元素\n\n\nRPOP key\n移除并返回列表右侧的第一个元素\n\n\nLRANGE key start end\n返回一段脚标范围内的所有元素（脚标从左0开始向右逐渐增加）\n\n\nBLPOP key [key ...] timeout\n与 LPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil\n\n\nBRPOP key [key ...] timeout\n与 RPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil\n\n\n\n用 List 模拟栈：只用 LPUSH 和 LPOP 或者 RPUSH RPOP 同向。\n用 List 模拟队列：LPUSH+RPOP 或 RPUSH+LPOP 不同向。\n用 List 模拟阻塞队列：首先需要入口和出口在不同边；其次出队使用 BLPOP 或者 BRPOP。\n阻塞队列：当队列为空的时候，取元素的线程会等待一段时间直到队列非空。应用：线程池，待处理的任务先到等待队列，等待有空闲的线程时再开始被执行。这样不用一直创建新的线程，只利用现有的最大线程数，节约资源和响应速度。\nSet\n类似 Java 中的 HashSet，无序，不重复，查找快，支持并集差集交集等运算。\n\n\n\nSet 常用命令\n解释\n\n\n\n\nSADD key member ...\n向 set 中添加一个或多个元素\n\n\nSREM key member ...\n移除 set 中的指定元素\n\n\nSCARD key\n返回 set 中元素的个数\n\n\nSISMEMBER key member\n判断一个元素是否存在于 set 中\n\n\nSMEMBERS key\n获取 set 中的所有元素\n\n\nSINTER key1 key2 ...\n求 key1 与 key2 的交集\n\n\nSDIFF key1 key2 ...\n求 key1 与 key2 的差集\n\n\nSUNION key1 key2 ...\n求 key1 和 key2 的并集\n\n\n\nSortedSet\n有点类似 java 的 treeset 但是底层逻辑差得很远。\njava 的 treeset：一种有序集合，底层逻辑是红黑树。红黑树类似 AVL 树，这两种树在排序的同时也会保证树的左右子节点深度，数量差别不大以免树结构的复杂度变得和线性结构差不多，AVL 是规定左右子节点深度差不能超过1，而红黑树要求松一些，规定从根到叶子的最长路径不可能达到最短路径的2倍长，所以旋转操作相对 AVL 少一些，AVL 更适用于查找操作远多于插入删除操作数量的情况。\nSortedSet 每个元素都带有一个 score 属性可以排序，通过跳表+hash表排序。\n跳表结构大概如下，来加速单链表的查找效率。可以再多建几级索引。图源：跳表的原理与实现 [图解]_跳表实现-CSDN博客\n\nSortedSet 由于其排序效率高，常常被用于实现如排行榜这样的功能。\n\n\n\nSorted Set 常用命令\n解释\n\n\n\n\nZADD key score member\n添加一个或多个元素到 sorted set，如果已经存在则更新其 score 值\n\n\nZREM key member\n删除 sorted set 中的一个指定元素\n\n\nZSCORE key member\n获取 sorted set 中指定元素的 score 值\n\n\nZRANK key member\n获取 sorted set 中指定元素的排名（从 0 开始）\n\n\nZCARD key\n获取 sorted set 中的元素个数\n\n\nZCOUNT key min max\n统计 score 值在指定范围内的元素个数\n\n\nZINCRBY key increment member\n让 sorted set 中指定元素自增，步长为指定的 increment 值\n\n\nZRANGE key start stop\n按 score 排序，获取指定排名范围内的元素 如前十名\n\n\nZRANGEBYSCORE key min max\n按 score 排序，获取指定 score 范围内的元素 如60分~70分\n\n\nZDIFF / ZINTER / ZUNION\n分别用于求差集、交集、并集\n\n\n\n以上都是升序，降序就在 Z 后面加 REV。\nRedis 的 Java 客户端\n主要有一下三种：\n\n\n\n客户端\n简介\n特点\n\n\n\n\nJedis\n以 Redis 命令作为方法名称，学习成本低，简单实用。\n实例非线程安全，多线程环境下需基于连接池使用。\n\n\nLettuce\n基于 Netty 实现，支持同步、异步和响应式编程方式，线程安全。\n支持 Redis 的哨兵模式、集群模式和管道模式。\n\n\nRedisson\n基于 Redis 实现的分布式、可伸缩 Java 数据结构集合。\n提供如 Map、Queue、Lock、Semaphore、AtomicLong 等强大功能，适合分布式场景。\n\n\n\nspring data redis 整合了前两种。\nJedis\n使用方式很简单：引入依赖，建立连接，使用，释放资源。\n引入依赖\n在 pom.xml 文件中粘贴：\n\n&lt;dependencies&gt;    &lt;!--jedis--&gt;    &lt;dependency&gt;        &lt;groupId&gt;redis.clients&lt;/groupId&gt;        &lt;artifactId&gt;jedis&lt;/artifactId&gt;        &lt;version&gt;3.7.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--单元测试--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;        &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;        &lt;version&gt;5.7.0&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n第一部分依赖是必须引入的，第二部分是测试用的。\n执行代码：\nimport org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import redis.clients.jedis.Jedis;import java.util.Map;public class JedisTest &#123;    private Jedis jedis;    @BeforeEach    void SetUp()&#123;        jedis = new Jedis(&quot;192.168.73.129&quot;,6379);        jedis.auth(&quot;369789&quot;);        jedis.select(0);    &#125;    @Test    void testString() &#123;        // 存入数据        String result = jedis.set(&quot;name&quot;, &quot;虎哥&quot;);        System.out.println(&quot;result = &quot; + result);        // 获取数据        String name = jedis.get(&quot;name&quot;);        System.out.println(&quot;name = &quot; + name);    &#125;    @Test    void testHash() &#123;        // 插入hash数据        jedis.hset(&quot;user:1&quot;, &quot;name&quot;, &quot;Jack&quot;);        jedis.hset(&quot;user:1&quot;, &quot;age&quot;, &quot;21&quot;);        // 获取        Map&lt;String, String&gt; map = jedis.hgetAll(&quot;user:1&quot;);        System.out.println(map);    &#125;    @AfterEach    void tearDown() &#123;        if (jedis != null) &#123;            jedis.close();        &#125;    &#125;&#125;\n连接池\nJedis 线程不安全，而且频繁创建销毁 Jedis 线程性能损耗比较大。\n线程不安全的大概原因：每次 set 的时候都要调用 connect 方法。在 connect 方法里，一个实例的多个线程都共用一个 socket, inputstream, outputstream。所以如果线程1正在读写，线程2把 socket重新初始化了，那么1的连接就断了。或者两个线程同时读写，inputstream outputstream 共用可能就会导致输入或读取数据错误。使用jedis面临的非线程安全问题-腾讯云开发者社区-腾讯云\n\n\n图源：java客户端：Jedis和Jedis连接池的基本使用和配置 - 知乎\n\n创建连接池代码：\npublic class JedisConnectionFacotry &#123;     private static final JedisPool jedisPool;     static &#123;         //配置连接池         JedisPoolConfig poolConfig = new JedisPoolConfig();         poolConfig.setMaxTotal(8);// 最大连接数         poolConfig.setMaxIdle(8);// 最大空闲连接数         poolConfig.setMinIdle(0);// 最小空闲连接数，防止空闲连接被释放         poolConfig.setMaxWaitMillis(1000);         //创建连接池对象         jedisPool = new JedisPool(poolConfig,                 &quot;192.168.150.101&quot;,6379,1000,&quot;123321&quot;);     &#125;     public static Jedis getJedis()&#123;          return jedisPool.getResource();     &#125;&#125;\n然后创建 Jedis 的时候改成使用连接池的获取代码：\njedis = JedisConnectionFactory.getJedis();\njedis.close() 函数底层如果判断有连接池的时候，就不会 close 关闭 Jedis 资源了，而是归还资源，所以不需要改。\nSpringDataRedis\nSpringData 是 Spring 的数据操作模块，其中的 Redis 集成模块叫做 SpringDataRedis。整合了多个 Redis 客户端，并提供了统一的访问 API。\n支持 JDK json 字符串 对象等的序列化和反序列化，因为现在我们直接操作 Jedis 传入的都是 byte[] 数组，如果想传入 json 或者对象需要自己手动调整序列化。\n\n\n\nAPI\n返回值类型\n说明\n\n\n\n\nredisTemplate.opsForValue()\nValueOperations\n操作 String 类型数据\n\n\nredisTemplate.opsForHash()\nHashOperations\n操作 Hash 类型数据\n\n\nredisTemplate.opsForList()\nListOperations\n操作 List 类型数据\n\n\nredisTemplate.opsForSet()\nSetOperations\n操作 Set 类型数据\n\n\nredisTemplate.opsForZSet()\nZSetOperations\n操作 SortedSet 类型数据\n\n\nredisTemplate\n-\n通用的命令接口\n\n\n\n使用起来也非常简单。首先在 IDEA 里面创建项目的时候就可以创建 spring initilize 的项目，然后导入相关依赖（redis，连接池等），配置连接，直接使用。\n依赖：\n&lt;!-- pom.xml --&gt;&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--common-pool--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--Jackson依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n配置：\n# application.yamlspring:  data:    redis:      host: 127.0.0.1      port: 6379      password: 123456      database: 0      lettuce:        pool:          max-active: 8          max-idle: 8          min-idle: 0          max-wait: 100ms\nSpringDataRedis 默认引入了 Lettuce 的依赖，如果想在上面的配置文件中使用 jedis 也可以只不过就是需要在 pom.xml 里面也引入 jedis 的依赖。\n代码测试：\n@SpringBootTestclass RedisDemoApplicationTests &#123;    @Autowired    RedisTemplate redisTemplate;    @Test    void testString() &#123;        redisTemplate.opsForValue().set(&quot;springtest&quot;,&quot;springtest&quot;);        Object value = redisTemplate.opsForValue().get(&quot;springtest&quot;);        System.out.println(&quot;value &quot;+value);    &#125;&#125;\n在 Redis 数据库中可见真正存入的数据形式其实是：\\xAC\\xED\\x00\\x05t\\x00\\x0Aspringtest，前面这一串可能就是 Spring Redis 的自动序列化用于记录对象格式的，反正 System.out.print 输出的是没有乱码的。\n老师的案例里面，老师是写入的 name xxx 键值对，然后再去终端执行 redis 命令 get name 发现获取到的值并没有更新，也是一样的道理，因为老师实际存入的键也是类似 \\乱码 \\乱码 name 这样的形式，和 get name 访问的键不一样.\n这种方式的主要两个问题：可读性差；内存占用大。Java 的 String 也会被视作是一种对象，而非单纯的 String。\nRedisTemplate 自定义和序列化\n想要“写入什么值就存入什么值”，就必须去改写 RedisTemplate 的序列化方法（其实底层调用的是 JDKSerializationRedisSerializer 的序列化方法）。\n对于字符串，或者键，可以将底层序列化方法改成：StringRedisSerializer，这个是专门处理字符串的序列化方法。\n对于对象，可以用 GenericJackson2JsonRedisSerializer 转 JSON 字符串的序列化方法。\n具体修改：新建一个 RedisConfig 文件：\n@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory)&#123; // 这里可见我们直接让 key 默认就是 String 类型了        // 创建RedisTemplate对象        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 设置连接工厂        template.setConnectionFactory(connectionFactory);        // 创建JSON序列化工具，用于对象处理        GenericJackson2JsonRedisSerializer jsonRedisSerializer =                new GenericJackson2JsonRedisSerializer();        // 设置Key的序列化        template.setKeySerializer(RedisSerializer.string());        template.setHashKeySerializer(RedisSerializer.string());        // 设置Value的序列化        template.setValueSerializer(jsonRedisSerializer);        template.setHashValueSerializer(jsonRedisSerializer);        // 返回        return template;    &#125;&#125;\n这个代码是所有 key 都用字符串序列化方法，而所有的 value 都用 json 对象处理方法。\n使用的时候，唯一区别就是声明要使用的 RedisTemplate 类是 &lt;String, Object&gt; 的，也就是我们刚刚生成的。\n@Autowiredprivate RedisTemplate&lt;String, Object&gt; redisTemplate;\n重新运行后发现数据库里面的键值都没有乱码了（值的话，可能 String Object 转换成 JSON 也是 String 的形式）。\n尝试传入对象也非常顺利，假设新建了一个 User 对象，数据库中成功传入后的 json value 如下（第一句话就是帮助反序列化还原用的）：\n\n并且 java 输出里面自动反序列化成对象的输出形式：\nvalue User(name=jingqing, age=22)\n但是可以看出，上面 class 那一行占用存储空间还是挺大的，比这个对象的其余部分内容都长。\n不要这部分，就不能实现自动的反序列化了。要吧，又要占用内存空间。\nStringRedisTemplate 手动序列化\n另一种实现方式是 StringRedisTemplate ，就是统一使用 String 序列化器。对于对象的存储，需要手动序列化或者反序列化。\n实现起来也不是特别难，就是通过一个 ObjectMapper 将 String 映射成一个 json String 后传入数据库，传出的时候再通过映射类映射回来。也不需要自定义 RedisTemplate 的序列化方案了。\n@Autowiredprivate StringRedisTemplate stringRedisTemplate;@Testvoid testString() &#123;    // 写入一条String数据    stringRedisTemplate.opsForValue().set(&quot;verify:phone:13600527634&quot;, &quot;124143&quot;);    // 获取string数据    Object name = stringRedisTemplate.opsForValue().get(&quot;name&quot;);    System.out.println(&quot;name = &quot; + name);&#125;private static final ObjectMapper mapper = new ObjectMapper();@Testvoid testSaveUser() throws JsonProcessingException &#123;    // 创建对象    User user = new User(&quot;虎哥&quot;, 21);    // 手动序列化    String json = mapper.writeValueAsString(user);    // 写入数据    stringRedisTemplate.opsForValue().set(&quot;user:200&quot;, json);    // 获取数据    String jsonUser = stringRedisTemplate.opsForValue().get(&quot;user:200&quot;);    // 手动反序列化    User user1 = mapper.readValue(jsonUser, User.class);    System.out.println(&quot;user1 = &quot; + user1);&#125;\n我们还可以进一步将序列化后写入和读出后反序列化封装成工具类，用工具类直接写入和读出，这样代码复杂度上也降低了。\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["Java","Redis"]},{"title":"题目练习：代码随想录解题思路分析","url":"/2025/05/29/%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/","content":"前言\n其实博主从大二开始闲着没事陆续刷 leetcode 也刷了不少了，但是感觉都是没什么思想地刷，可能大多数题能记住解法，但是很多题再看到第一眼还是想不到什么双指针，滑窗之类的优解，没有这个意识，要扫一眼题解的方法才会恍然大悟“哦对哦可以这么做的”然后才能写出来。\n\n所以这回（第 N 次为了面试做准备而重刷，从代码随想录开始，我还没试过这个）我决定重点在于“看到题目如何构思解法”的分析上。比如双指针一般应用于什么题型？为什么这道题看到后第一眼知道用双指针？\n希望对你也有所帮助。\n注：博主使用语言为 java。\n数组\n二分查找（Leetcode 704.）\n\n时间复杂度是 log2(n)，空间复杂度 O(1)。\n二分法使用的时候注意自己规定好左右边界，不要漏掉一些边界情况等。我的常用玩法是循环跳出条件为 left&gt;right，每次校验完 mid 之后让 left=mid+1 或 right=mid-1。\nclass Solution &#123;    public int search(int[] nums, int target) &#123;        if(nums == null || nums.length&lt;=0)return -1;        int left=0, right = nums.length-1;        int mid=(left+right)/2;        while(left&lt;=right &amp;&amp; nums[mid]!=target )&#123;            // nums[mid]&gt;target?right=mid-1:left=mid+1;            if(nums[mid]&gt;target)right=mid-1;            else left=mid+1;            mid=(left+right)/2;        &#125;        if(left&gt;right)return -1;        else return mid;    &#125;&#125;\n移除数组指定值元素（Leetcode 27.）\n\n如果没有原地的要求，我们新开辟一个数组空间，有选择性地把原数组值复制过去就行，记得记一下数看有多少个非 val 值。\nGPT 总结双指针使用场景总览：\n\n\n\n类型\n描述\n常见题型举例\n\n\n\n\n1. 对撞指针\n从两端向中间逼近\n排序数组的和、回文串判断、三数之和等\n\n\n2. 快慢指针\n一快一慢遍历链表或数组\n环形链表、删除重复元素、寻找中点等\n\n\n3. 滑动窗口\n左右指针控制一个动态区间\n最小覆盖子串、最长无重复子串等\n\n\n4. 区间遍历/合并区间\n对多个数组或区间双向扫描\n区间交集、归并两个有序数组等\n\n\n\nclass Solution &#123;    public int removeElement(int[] nums, int val) &#123;        int slowIndex = 0, fastIndex = 0;        for (; fastIndex &lt; nums.length; fastIndex++) &#123;            if(nums[fastIndex]!=val)nums[slowIndex++]=nums[fastIndex];        &#125;        return slowIndex;    &#125;&#125;\n有序数组的平方（Leetcode 977.）\n\n这个题的关键点在于负数，也就是原数组按原顺序平方后得到的数组可能是先减后增的。\n那么问题就变成怎么把负数那一部分按从小到大顺序插入到正数那一部分（我的理解），这和“合并两个数组”差不多。所以就是两个指针分别指向数组左右两端（负数绝对值的最大值和正数绝对值的最大值），每次拿出相对更大的一个放入到新数组中并移动该指针。\nclass Solution &#123;    public int[] sortedSquares(int[] nums) &#123;        int leftIndex = 0, rightIndex = nums.length - 1;        int resIndex = rightIndex;        int[] resultNums = new int[nums.length];        while (leftIndex &lt;= rightIndex &amp;&amp; resIndex &gt;= 0) &#123;            int left = nums[leftIndex] * nums[leftIndex], right = nums[rightIndex] * nums[rightIndex];            if (left &gt; right) &#123;                resultNums[resIndex--] = left;                leftIndex++;            &#125; else &#123;                resultNums[resIndex--] = right;                rightIndex--;            &#125;        &#125;        return resultNums;    &#125;&#125;\n长度最小的子数组（Leetcode 209.）\n\n从一个序列中找到符合标准的一个连续子序列，很明显的滑动窗口问题。\n依然是双指针，确定左右边界。\n每次循环先移动右指针，窗口 sum 值加上右指针指向的新值，如果超过 target 先试一试移动左指针后是否仍然满足（sum-当前左指针值，尽可能让满足条件的序列更短一些），如果不满足就不移动左指针了，然后比较记录当前子序列长度。\nclass Solution &#123;    public int minSubArrayLen(int target, int[] nums) &#123;        if (nums == null || nums.length == 0)            return 0;        int left = 0, right = 0;        int sum = 0;        int minLength = nums.length + 1;        for (; right &lt; nums.length; right++) &#123;            sum += nums[right];            if (sum &gt;= target) &#123;                while (sum - nums[left] &gt;= target) &#123;                    sum -= nums[left++];                &#125;                if (right - left + 1 &lt; minLength)                    minLength = right - left + 1;            &#125;        &#125;        if (minLength == nums.length + 1)            return 0;        return minLength;    &#125;&#125;\n螺旋矩阵II（Leetcode 59.）\n\n这个其实没啥难度，主要就是自己遍历的时候边界判定条件要统一，别自己写乱了。\n做这种题我一般习惯于设置成下面这种 direction 矩阵，这样比较方便一些（学嵌入式时候的习惯）：\nclass Solution &#123;    public int[][] generateMatrix(int n) &#123;        int[][] resMatrix = new int[n][n];        int[] direction = &#123; 0, 1, 1, 0, 0, -1, -1, 0 &#125;;        int currentDirection = 0;        int currentX = 0, currentY = 0;        for (int i = 1; i &lt;= n * n; i++) &#123;            resMatrix[currentX][currentY] = i;            if (currentX + direction[currentDirection] &lt; 0 ||                    currentX + direction[currentDirection] &gt;= n ||                    currentY + direction[currentDirection + 1] &lt; 0 ||                    currentY + direction[currentDirection + 1] &gt;=n ||                    resMatrix[currentX + direction[currentDirection]][currentY                            + direction[currentDirection + 1]] != 0) &#123;                currentDirection = (currentDirection + 2) % 8;            &#125;            currentX = currentX + direction[currentDirection];            currentY = currentY + direction[currentDirection + 1];        &#125;        return resMatrix;    &#125;&#125;\n区间和（代码随想录 58.）\n\n主要练习一下 ACM 算法模式，整个程序都要自己写。\n代码上，像这种需要区间求和的题目，如果每次都遍历求和就容易超时。取而代之的方法是搞一个 sum 数组，每个位置记录“从0位置到当前位置的所有元素和”（前缀和）。这个数组初始化的时候计算很方便，sum[i-1]+nums[i] 就可以了。求区间和的话就作差就行，sum[j]-sum[i-1]，注意 i=0 的时候单独处理。\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args)&#123;        Scanner sc=new Scanner(System.in);        int n=sc.nextInt();        int[] vector = new int[n];        for(int i=0;i&lt;n;i++)&#123;            vector[i]=sc.nextInt();            if(i&gt;0)vector[i]+=vector[i-1];        &#125;        while(sc.hasNextInt())&#123;            int left=sc.nextInt();            int right=sc.nextInt();            if(left ==0)System.out.println(vector[right]);            else System.out.println(vector[right]-vector[left-1]);        &#125;        return ;    &#125;&#125;\n开发商购买土地（代码随想录 44.)\n\n这个是二维上的区间和，所以要点也是在于创造一个 sum 数组每个点存储当前位置的值+之前位置值之和（前缀和），通过 sum 数组值相减快速获取区间值，只不过变成两个维度了。\n如果暴力求解的话，时间复杂度是 O(n^3)，每次选取一个维度进行遍历求该行或者列的求和值，再遍历组合所有分割可能的求和值的组合方式找到差值最小的情况。简化后变成 O(n^2).\nimport java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int n = sc.nextInt(), m = sc.nextInt();        int[][] matrix = new int[n][m];        int[] row = new int[n];        int[] column = new int[m];        int minDiff = -1;        for (int i = 0; i &lt; n; i++) &#123;            for (int j = 0; j &lt; m; j++) &#123;                matrix[i][j] = sc.nextInt();                row[i] += matrix[i][j];                column[j] += matrix[i][j];            &#125;        &#125;        for (int i = 1; i &lt; n; i++) &#123;            row[i] += row[i - 1];        &#125;        for (int i = 0; i &lt; n; i++) &#123;            if (minDiff == -1 || minDiff &gt; Math.abs(row[n - 1] - 2 * row[i]))                minDiff = Math.abs(row[n - 1] - 2 * row[i]);            if (minDiff == 0) break;        &#125;        for (int i = 1; i &lt; m; i++) &#123;            column[i] += column[i - 1];        &#125;        for (int i = 0; i &lt; m; i++) &#123;            if (minDiff == -1 || minDiff &gt; Math.abs(column[m - 1] - 2 * column[i]))                minDiff = Math.abs(column[m - 1] - 2 * column[i]);            if (minDiff == 0) break;        &#125;        System.out.println(minDiff);        return;    &#125;&#125;\n总结\n数组可以说是必考的基础类型题目。主要考察算法就是二分法，双指针法，滑动窗口，前缀和。\n数组在内存中是连续的存储空间，二维数组是多条连续的存储空间（两行之间地址不一定连续）。\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["Data Structure"]},{"title":"技术学习：翁恺C语言程序设计","url":"/2020/11/27/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%BF%81%E6%81%BAC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","content":"0. 前言\n是翁恺老师的 132PC 语言程序设计网课。\n链接：【C 语言】翁恺 C 语言程序编程全系列\n是 C 语言入门的地方~还是希望多多指正！\n1. 背景\n计算机和编程语言\n学习目的：理解计算机是怎样工作的\n计算机是生活中的必需品。 如果我们想要自己设计一些功能和行为，让计算机按照自己的意图做事，就需要写程序了。\n本课程的主要目的是通过学习编程，来理解计算机是如何解决问题，计算机的能与不能，pros and cons.\n计算机怎样解决问题？把大问题拆分成小问题分步进行\n人：what to do。比如告诉同桌开一下灯，他去把灯打开。\n计算机：how to do。同桌不知道如何开灯，你要和他说：走到开关前，按下开关，走回来……\n程序是用特殊的编程语言写出来表达如何解决问题的。\n我们不是在用编程语言和计算机交谈，而是要求它如何做事情，向它描述做事情的过程和方法。\n//例：hello world!#include&lt;stdio.h&gt;int main()&#123;\tprintf(&quot;Hello World!\\n&quot;);//输出“Hello World!（换行）”引号内的部分\treturn 0;&#125;\n\n\n\n普通人能读懂的东西 →\n程序员能懂的东西 →\n计算机能懂的东西\n\n\n\n\n计算机\n程序\n算法\n\n\n（算法：我们想让计算机做计算，先要写出计算的步骤，然后用编程语言写出来。计算机做的所有事情都是计算；计算的步骤就是算法。）\n\n\n\n\n\n计算机的思维方式\n例：解方程 2x+6 = 20 ，    x∈(1,10）直接解方程对计算机来说太难理解了。\n计算机的思维：\n\n枚举法\n代入 x = 1，不行；代入 x = 2，不行；代入……\n二分法\n代入 x = 5，小了；代入 x = 7……\n\n计算机执行程序有两种方案：\n\n解释：借助一个程序，那个程序可以试图 理解你的程序，然后按照你的要求执行\n编译：借助一个程序把你的程序 翻译成机器语言 写的程序，然后计算机就可以直接执行了。\n\n解释语言 vs 编译语言：语言本无解释与编译之分，只是常用的执行方式不同。\n解释型语言有特殊的计算能力；\n编译型语言有确定的运算性能。\n为什么编程入门从 C 学起？\n[语言排行\n\n\n\n在很多场合，C 语言是唯一的选择\n现代编程语言在语法上差异很小，基本都和 C 接近\n语言的能力、适用领域主要是由 库 和 传统 决定的。\n\nC 的简单历史\n1969 诞生。\nFORTRAN→BCPL→B 语言 →C 语言\n1967 年，剑桥大学的 Martin Richards 对 CPL 语言进行了简化，于是产生了 BCPL（Basic Combined Pogramming Language)语言。\n1970 年，美国贝尔实验室的 Ken Thompson。以 BCPL 语言为基础，设计出很简单且很接近硬件的 B 语言（取 BCPL 的首字母）。并且他用 B 语言写了第一个 UNIX 操作系统。\n在 1972 年，美国贝尔实验室的 D.M.Ritchie 在 B 语言的基础上最终设计出了 C 语言。\n因为 B 和 BCPL 都支持指针间接方式，所以 C 语言也支持了。\nC 语言还受到了 PL/I（和底层系统很接近，可以拿来做操作系统等）的影响，还和 PDP-II 的机器语言有很大关系\n1973/3，第三版的 Unix 上出现了 C 语言的编译器\n1973/11，第四版的 Unix 完全用 C 语言重新写的。\n\n经典 C，又叫 K&amp;R the C\n1989 年，ANSI 发布了一个标准：ANSI C\n1990 年，ISO 接受了 ANSI 的标准：C89\nC 的标准在 1995 年和 1999 年两次更新：C95 和 C99。现在的编译器都基于 C99 了，因此本课程也是。\n编程软件用什么\nC 语言的用途：写操作系统、嵌入式系统、驱动程序（用来驱动 U 盘）、底层驱动、图形引擎、图像处理、声音效果（直接给我们提供数据的代码不是用 C 语言写的）一些底层的东西。\nC 语言是一种工业语言，由基础人员使用。所以：\n开发效率 &gt;&gt; 学习过程\n开发效率 &gt;&gt; 开发乐趣\n而在日常的应用中，很少直接用 C 语言编写。学习 C 的过程主要是写练习代码，而不是写真实软件。\nC 语言需要被编译才能运行，所以需要：编辑器和编译器\n（或者 IDE，Integrated Development Environment 集成开发环境，一个顶俩）\n推荐的编程软件：Dev C++。免费，安装简单，还不用建工程。\n\n2. 入门：从 Hello World 开始\n第一个 C 程序\n在 Dev C++中：文件-&gt; 新建-&gt; 源代码\n输入之前确保是英文输入！！！\n#include&lt;stdio.h&gt;int main()&#123;\tprintf(&quot;Hello World!\\n&quot;);\treturn 0;&#125;\n梦开始的地方。\n可以先自己敲进去运行玩玩\n**上端显示星号，说明没有保存。Ctrl + S 保存并且记得选择.c 格式。\n编译之后再运行。**运行后出现黑色的终端，上面显示了结果。\n详解第一个 C 程序\n#include&lt;stdio.h&gt;int main()&#123;\t\treturn 0;&#125;\n本课程中所有的程序都需要用到这一段框架（直到学函数之前）\nprintf()会把 &quot; &quot; 内的内容（字符串）原封不动地输出，\\n 表示换行。\n如果出现编译错误，会在下面用红色的 error 显示出来，而具体错误原因在下方窗口里。\n简单计算\nprintf(&quot;%d&quot;,23+43);\n%d 是占位符，说明后面会有一个整数输出到这个位置上。\nprintf(&quot;23+43=%d&quot;,23+43);\n\n\n\n四则运算\nC 符号\n意义\n\n\n\n\n+\n+\n加\n\n\n-\n-\n减\n\n\n×\n*\n乘\n\n\n÷\n/\n除\n\n\n\n%\n取余\n\n\n( )\n( )\n括号\n\n\n\n3. 变量\n变量定义\n找零钱问题：100-(用户输入)物品的价格 = 找你的钱\n我们需要：\n\n有办法输入数字；\n有地方放输入的数字；\n输入的数字参与计算。\n\nint price=0;//定义了整形变量price，类型是int，初始值=0printf(&quot;请输入金额（元）：&quot;);int change=100-price;printf(&quot;找您%d元。\\n&quot;,change);\n变量 是一个保存数据的地方。\n变量定义的一般形式就是：\n&lt;类型名称&gt; &lt;变量名称&gt;\n变量的名字叫“标识符”，基本原则只能由字母、数字、下划线构成，数字不能出现在第一个位置上。C 语言的关键字（又叫保留字）不可用作字符。\n如何输入：\n输入也在终端窗口中。输入以行为单位进行，敲下回车，行结束。\n（敲下回车之前，程序不会读到任何东西。）\n变量赋值与初始化\nint price=0;//其中=是赋值运算符，把右边的值赋给左边的变量。\n和数学中不同，b = a 和 a = b 在程序中有着相反的含义。\n当赋值发生在刚定义变量时，就叫程序的初始化。虽然 C 语言并没有强制要求所有的变量在被定义的地方做初始化，但所有变量在第一次被使用（出现在 = 等号右边）前都应该被赋值一次。\n如果没有初始化呢？\n就是使用这个变量在内存中的那个值。\n变量初始化：&lt;类型名称&gt; &lt;变量名称&gt; = &lt;初始值&gt;\n也可以在组合变量定义中给单个变量单独赋初值，如\nint a=0,b=1;\n有运算符的式子就叫表达式（比如 = 是赋值运算符）\nC 语言是有类型的语言，所有变量在使用前必须先定义或声明；所有变量必须有确定的数据类型（表示在变量中可以存放什么样的数据），变量中也只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。\nint charge=100-price;\n比较 C 和 ANSI C\n//C语言\tint price=0;\tprintf(&quot;请输入金额（元）：&quot;);\tscanf(&quot;%d&quot;,&amp;price);\tint change=100-price;\tprintf(&quot;找您%d元。\\n&quot;,change);\n//传统的ANSI C只能在开头的地方定义变量\tint price=0;\tint change=0;\t\tprintf(&quot;请输入金额（元）：&quot;);\tscanf(&quot;%d&quot;,&amp;price);\tchange=100-price;\tprintf(&quot;找您%d元。\\n&quot;,change);\n变量输入\nscanf() 函数，读到的结果赋值给后面的变量\n（注意变量前的&amp;）\n如果输入非整数（比如找钱一例中：输入字母，找我 100 元）应该怎么处理？这种情况后面再说。\n常量 vs 变量\n固定不变的数，是常数。直接写在程序里的，叫直接量。\nconst int amount=100;\n其中 const 是个修饰符，加在 int 前面，给这个变量加上一个 const（不变的）属性，表示这个变量的值一旦初始化，就不能再更改了。\n好处：1.便于理解 2.修改的时候好找\n编译时会显示：read-only variable is not assignable\n（一般 const 的变量全大写）\nscanf 的空格有讲究，以后再说。输入时如果要两个数，在中间、最后敲空格或回车，计算机读到两个数字时停止\n当 scanf 扫描数字时输入字母，可能会出来很多奇怪的数字。（应该是 ASCII 码吧？）后面再细说。\n浮点数\nC 语言中两个整数做运算得到的结果也只能是个整数（去掉小数部分）。而 10 和 10.0 在 c 中是完全不同的两个数字，10.0 是浮点数（浮点数指小数点时可以浮动的，是计算机中表示分数和无理数的一种方式。人们用浮点数来称呼有小数点的数）（其实还有定点数。但是在 c 语言中无）\n当浮点数和整数放在一起运算时，计算机会自动把整数转化为浮点数计算（如：\nint a,b;printf(&quot;a/b*3&quot;);//改进为a/b*3.0\n有一次尝试 printf(“%f”,3/2); 输出的是整数。应该是先进行整数运算再以%f 形式输出，而不是以%f 形式输出。所以应该改进为 3/2.0\n有单精度 float(%f)和双精度 double(%lf)\n(计算机里会有这种纯粹的整数，是因为运算快、占地小。而且日常生活中大多也是整数运算。)\n表达式\n一个表达式是一系列运算符和算子的结合，用来计算一个值\n运算符(operator)是指进行运算的动作，比如加/减法运算符±\n算子(operand)是指参与运算的值，可能是常数/变量/一个方法的返回值\n\n计算时间差：这里只记录分钟错位的情况（1:40 和 2:10）\n方法：全部记为分钟（小时*60）\nint hour1,min1;int hour2,min2;scanf(&quot;%d %d&quot;,&amp;hour1,&amp;min1);scanf(&quot;%d %d&quot;,&amp;hour2,&amp;min2);int t1=hour1*60+min1;//把小时转化为分钟单位int t2=hour2*60+min2;int t=t2-t1;printf(&quot;时间差是%d小时%d分。“,t/60,t%60);//t/60是小时部分；t%60取余，是分钟部分\n运算符优先级\n（double 输入的时候用 %lf，输出的时候用 %f 就行）\n运算符优先级\n\n\n\n优先级\n运算符\n运算\n结合关系\n举例\n\n\n\n\n1\n+\n单目不变\n自右向左\na*+b\n\n\n1\n-\n单目取负\n自右向左\na*-b\n\n\n2\n*\n乘\n自左向右\na* b\n\n\n2\n/\n除\n自左向右\na/b\n\n\n2\n%\n取余\n自左向右\na%b\n\n\n3\n+\n加\n自左向右\na+b\n\n\n3\n-\n减\n自左向右\na-b\n\n\n4\n=\n赋值\n自右向左\na = b\n\n\n（a+b, a-b 是双目；+a,-a 是单目，相当于正负号）\n\n\n\n\n\n\n赋值也是运算，也有结果。\n\n\n\n\n\n\na=6 的结果就是 a 被赋予的值，也就是 6\n\n\n\n\n\n\n如 a=b=6：自右向左，a =(b = 6)。\n\n\n\n\n\n\n\n嵌入式赋值：int c=1+(b=a)\n缺点：不利于阅读；容易产生错误\n运算符的结合关系一般自左向右；单目 +- 和赋值 = 自右向左\n下面的式子过于复杂，不利于阅读和理解。\nresult=a=b=3+c;result=(result=result*2)*6*(result=3+result);\n所以应该把它拆开来计算。\n（C 语言没有幂次，所以只能一个个乘。）\n交换变量\n交换 a 和 b 的值（a = 6, b = 5）\n错误 示例\na=b;b=a;\n程序表达的是顺序执行的动作，而不是关系.所以这样做先把 b 赋给 a，然后再把 a 赋给 b，都是 5.\n方法：再找一个变量 c，c = a 储存一下 a 的值，然后 a = b, b = c\nc=a;a=b;b=c;\n断点\n\nDEV C++中，在左边数字那里点击一下，然后程序运行时就会在这一行停止。\n\n运行也只能到这一行\n点下一行，就会运行到下一行。\n这样可以方便排 bug\nC 语言：使用 Dev C++断点调试\n复合赋值\na+=5 表示 a=a+5(注意两个运算符之间无空格)\n类似有 -=，*=，/=\n（a*=b+5 表示 a=a*(b+5), 如果想先算 a=a*b 记得加括号）\nINC 递增、DEC 递减运算符：++，--：单目运算符，只能有一个算子，这个算子还只能是变量（如 a++ 后缀形式，++a 前缀形式）让该变量+1/-1；\na++ 运算式的值是 a+1 以前的值；++a 运算式的值是 a+1 以后的值。无论哪个，a 的值都+1 了\n\n++ 和 -- 可以单独使用，但不要把它组合进表达式，复杂。\n4. 判断（选择结构）\nif 条件判断\nif(条件)&#123;\t要执行的语句，只有条件成立时才会执行&#125;\n判断的条件\n计算两个值之间的关系，叫做关系运算\n== 判断相等\n!= 不相等\n还有 &gt;；&gt;=；&lt;；&lt;=，当两个值的关系复合这些关系运算符的预期时，关系运算的结果为整数 1，否则为整数 0\nprintf(&quot;%d\\n&quot;,5&gt;3);printf(&quot;%d\\n&quot;,5==3);\n输出结果: 1（换行）0\n所有关系运算符的优先级都比算数运算低，比赋值运算高\n(编程语言都是可以人为验证的)\n如 int r=a&gt;0; 先判断 a 是否 &gt; 0, 再把 0/1 的值赋给 r\n== 和 != 优先级比其他的低\n连续的关系运算是从左到右进行的\n5&gt;3==6&gt;4 → 1==1 成立\n6&gt;5&gt;4 → 1&gt;4 不成立\n找零计算器\nst=&gt;start: 开始i1=&gt;inputoutput: 输入购买的金额i2=&gt;inputoutput: 输入支付的票面o1=&gt;operation: 计算找零c=&gt;condition: 判断余额是否充足o2=&gt;inputoutput: 打印找零o3=&gt;inputoutput: 告知用户余额不足以购买e=&gt;end: 结束st-&gt;i1-&gt;i2-&gt;o1-&gt;cc(yes)-&gt;o2-&gt;ec(no)-&gt;o3-&gt;e\n//初始化int price=0;int bill=0;//读入金额和票面printf(&quot;请输入金额：&quot;);scanf(&quot;%d&quot;,&amp;price);printf(&quot;请输入票面：&quot;);scanf(&quot;%d&quot;,&amp;bill);//计算找零\n// 是（单行）注释，把程序分成了三个部分：初始化，读入金额和票面，计算并打印找零；\nc99 可以，ASCII 不支持\ncomment 对程序的功能没有任何影响，但是往往能使程序更容易被人类读者理解。\n/* */ 中间可以有多行注释。\n否则\n比如刚刚的找零计算器：金额 &lt; 票面\nelse&#123;  &#125; 是 if 的补集\n输入两数，找最大者：\n方案一\nint a,b;printf(&quot;请输入两个整数：&quot;);scanf(&quot;%d %d&quot;,&amp;a,&amp;b);int max=0;if(a&gt;b)max=a;else max=b;printf(&quot;大的那个是%d\\n&quot;,max);\n方案二\nint a,b;printf(&quot;请输入两个整数：&quot;);scanf(&quot;%d %d&quot;,&amp;a,&amp;b);int max=b;if(a&gt;b)max=a;printf(&quot;大的那个是%d\\n&quot;,max);\n可以对比两种方案，方案二绝绝子\n没有大括号的 if 语句\nif 语句可以不加大括号\nif（a&gt;b）\tmax=a;\nIf 这行结束并没有语句结束的标志 ; 而后面的赋值语句写在下一行且缩进了，结束时有“；”。这表明这条赋值语句是 if 语句的一部分，if 语句拥有和控制这条赋值语句，决定他是否要被执行。\n就是说，没有大括号，后面一句话是有效的，也只能这一句是有效的（包含在 if 里）。\n嵌套的 if-else\n找三个数中的最大数：先比较两个数谁更大，较大的再和 c 比较。\nif(a&gt;b)&#123;\tif(a&gt;c)max=a;\telse max=c;&#125;else&#123;\tif(b&gt;c)max=b;\telse max=c;&#125;\n级联的 if-else if\n如分段函数。这时可以用级联的 else if 表达多种情况\n每个 else 是前一个 if 的 else，但是前面两个都不满足的话就只剩下第三个了\nflowchart TD\n    Start[开始]\n    Input[/输入/]\n    C1{是否满足条件1}\n    O1[/输出条件1/]\n    C2{是否满足条件2}\n    O2[/输出条件2/]\n    O3[/输出条件3/]\n    End[结束]\n\n    Start --> Input --> C1\n    C1 -- 是 --> O1 --> End\n    C1 -- 否 --> C2\n    C2 -- 是 --> O2 --> End\n    C2 -- 否 --> O3 --> End\n其实相当于：\nelse&#123;\tif()\telse&#125;\n比较该分段函数的两种写法\nif(x&lt;0)f=-1;else if(x==0)f=0;else f=1;printf(&quot;%d&quot;,f);\nif(x&lt;0)printf(&quot;%d&quot;,-1);else if(x==0)printf(&quot;%d&quot;,0);else printf(&quot;%d&quot;,1);\n更建议上面的方法，有单一出口（都是输出 f），因为代码要降低重复性，出问题的时候才好统一处理。\nif-else 的常见错误\n\n忘记写大括号的话，条件成立时只执行后面一句\nIf 后面无分号\n== 和 =：if 只要求括号里是 0 或非 0\n使人困惑的 else\n尊重 warning！\n大括号内的语句加 tab 缩进是代码风格。\n3.2.4 多路分支\n\nswitch(print)&#123;\tcase 1:\t\tprintf(&quot;1&quot;);\t\tbreak;\tcase 2:\t\tprintf(&quot;2&quot;);\t\tbreak;\tcase 3:\t\tprintf(&quot;3&quot;);\t\tbreak;\tdefault:\t\tprintf(&quot;0&quot;);&#125;\n与 if 的自顶向下判断不同，switch 从几个 case 中找出 3 后执行, 就是说几个 case 的判断是同时的.\n但是 switch 语句只能判断 int 整形变量, 而且 case 后面的必须是常量（如 mon=1，case 1）\nSwitch 是先跳到对应的 case 处，然后一条条向下执行直到遇到 break 跳出 switch\n如果进入下一个 case 前还没有碰到 break，那就进入下一个 case\n按成绩分等级的题：可以先/10，再分 case。\n注意一定要在每个 case 后加上 break.\nint i=1;switch ( i%3 ) &#123;case 0: printf(&quot;zero&quot;);case 1: printf(&quot;one&quot;);case 2: printf(&quot;two&quot;);&#125;\n结果输出的是 onetwo。\n解释：switch 是一个路标牌，计算控制表达式的值后，就知道跳转到哪了（在哪里上车），但是分支符号只是说明 switch 内部位置的路标，在执行完分支后，如果后面没有 break（下车提示），就会顺序执行到下面的 case，直到遇到 break，或者 switch 结束（终点站）\n也就是说，程序跳到了 one 那个 case，然后因为没有 break 就继续往下顺延，又输出了 two。\n5. 循环（循环结构）\n写程序在写的是步骤，一步一步走。\nW 判断一个数的位数\n人 vs 计算机\n人一看就出来了，很快啊\n计算机：判断数的范围来确定数的位数（100~999 范围内是三位数）但人对数字处理比文字弱\n但是位数太多也不能用这种方法了。改用一步步查位数的方法。\n所以从最左边开始约，每次约一位，\nif(n!=0)&#123;\tn/=10;i++;&#125;if(n!=0)&#123;\tn/=10;i++;&#125;\n……不过这样也是无限循环。\n所以我们可以引入新函数，while。条件满足，就会不断重复大括号里的内容。\n（尝试的时候不要拿太大的数去试，计算机里的整数是有范围的。）\nwhile 循环\n数字位数的算法\n\n用户输入 x；\n初始化 n 为 0；\nX/= 10，去掉个位；\ncnt++;\n如果 x &gt; 0，回到 3；\n否则 cnt 就是结果。\n\ndo-while 循环：进入循环的时候不做检查，而是执行完一轮循环体的代码之后再来检查循环条件是否满足，满足的话继续，不满足的话结束循环\n(while(); 最后一定要有分号！！！)\nwhile 和 do while 很像，区别在于 do while 在循环体执行结束时才来判断条件。也就是说无论如何，循环都会执行至少一遍。\ndo-while 循环\nif 和 while 的区别在于，if 判断只一次，不管结果如何都结束了。\nWhile 一定要有结束循环的条件！！ 否则会一直循环，超时\nWhile 可以翻译为当。循环有可能一次都没有被执行。条件成立是循环成立的条件。\n如何看出程序运行结果？\n人脑模拟计算机的运行，在纸上列出所有变量，随着程序的进展不断重新计算变量的值。当程序运行结束时，留在表格最下面的就是程序的最终结果。\n测试程序常常使用边界数据，如有效范围两端的数据、特殊的倍数等等。\n（此题求位数，特殊数据可以是个位数、10、0、负数）\n然后可以发现，0 是 1 位数，但是用 while 算法的话算出来是 0 位数。那我们可以用 do-while 就能得到 1 位数了。\n或者 if(x &gt; 0), 做 while；else 位数 = 1，单独列出 x = 0 的情况。\n另一种调试方法：在适当的位置加上 printf 输出\n作用不只有输出数据。比如在 while 括号内加一个 printf(“in loop”); 证明程序到这个地方了，也就是进入 while 循环了（还可以看循环了几次）\n循环计算\n编程难在小问题。\n如：有的时候可能需要保存原始数据。\n求 log2x：x/= 2，计数（当 x &gt; 1 时）\n但是如果 printf（“log2 of %d is %d.”, x, 计数）；最后输出的 x 总是 1，因为循环算完的时候 x 总是 1\n所以我们开始要把原始的 x 保存一下。又是一个小细节~诸如此类，还有很多。\n如：\n\nWhile 可以用 do while 吗？\n为什么计数从 0 开始，可以从 1 开始吗？\n为什么 while 判断条件是 x &gt; 1?\n循环最后输出的是多少？\n\n#include&lt;stdio.h&gt;int main()&#123;\tint x,ret=0;\tscanf(&quot;%d&quot;,&amp;x);\tint t=x;\twhile(x&gt;1)&#123;\t\tx/=2;\t\tret++;\t&#125;\tprintf(&quot;log2 of %d is %d.&quot;,t,ret);\treturn 0;&#125;\n其实都是相互牵扯的。\n1、\t当 x = 1 的时候，结果是 0.也就是说我们希望当 x = 1 时不要进入这个循环。\n2、\t计数 ret 是我们希望进入这个循环是最小的数。\n如果想改成 while(x &gt; 2)，那我们的计数 ret 就要相应改成初始值 = 1.但是 x = 1 时条件不满足。为了兼顾两种情况，还得用上面的方法。\n也可以 ret =-1，while(x &gt; 0)\n编程肯定会有很多不同的方法。\n对于很大次数的循环，我们可以模拟较少的循环次数，然后做出推断，解决上面提到的四个问题。因为很多小细节，要多加注意。\n猜数游戏\n计算机想一个数，用户来猜，猜不对的话告诉用户大了还是小了，最后猜中了告诉用户猜了多少次。\n\n因为要不断重复去猜，所以我们要用到循环\n实际写出程序之前，我们可以先用文字描述出程序的思路。\n核心重点是循环的条件。\n人们往往会考虑循环终止的条件。\n\nst=&gt;start: 开始i=&gt;inputoutput: 用户输入猜的数ocnt=&gt;operation: count++o=&gt;operation: 计算机随机想一个数，记在number里c=&gt;condition: 判断a是否等于numbere=&gt;end: 结束o2=&gt;inputoutput: 告诉用户大了还是小了oe=&gt;operation: 输出cnt猜的次数st-&gt;o-&gt;i-&gt;ocnt-&gt;cc(yes)-&gt;oe-&gt;ec(no)-&gt;o2(right)-&gt;i\n循环的条件是 a!= number\n用函数 rand()召唤随机整数\n使用方法：\n//先加入两个头文件#include&lt;stdlib.h&gt;和#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main()&#123;\tsrand(time(0));//Main里加上srand(time(0));  先不用管什么意思\tint a=rand();//如果想要a是100以内的整数：用取余即可（a%=100）\tint number=rand()%100+1;//这样召唤出来的数范围是1~100\t//不管怎样用户都要进入这个循环，输入至少一个数；所以应该用do-while循环。&#125;\n算平均数\n读入一系列正整数，输入-1 时终止。然后输出他们的平均数\n变量-&gt; 算法-&gt; 流程图-&gt; 程序\nnum: 我们需要读到的那一个数。\nsum(总和)：每读到一个数把他加到 sum 里就完事了\n另一个变量 count 记录累加的次数，最后算平均数 ÷count\nflowchart TD\n    st([开始: sum=0, cnt=0])\n    i1([输入: 读 num])\n    c{num != -1 ?}\n    o[操作: sum += numcnt++]\n    op([输出: 计算和打印结果])\n    e([结束])\n\n    st --> i1 --> c\n    c -- 是 --> o --> i1\n    c -- 否 --> op --> e\n注意转化成浮点数来求平均值。\n浮点数转化方法： 1.0*sum/count\n整数逆序\n整数分解方法：%10 得到个位数，/10; 再%10 得到十位数……\n整数逆序问题注意结尾 0 的处理；\n如果不用考虑 0 的话，我们可以每得到一位就输出一位。%10 一下输出一下，/10，再%10 输出一下，很快啊\n考虑 0：那就应该把逆序数算出来在输出了。搞一个 ret = 0, 每次 ret = ret*10+n%10;\nfor 循环\n阶乘 n!=n*(n-1)*(n-2)*……*2*1\n程序：输入 n，输出 n!\n需要借助一个变量 i 从 1~n.这里的循环，我们用 for 来处理。\nfor 循环像一个计数器。达到一个数之前一直进行循环，在过程中 i++ 或 i--\nfor(int i=0;i&lt;n;i++) n 次循环\n求和时，初始值为 0；求积时，初始值为 1\nstill, 可以尝试细节。\n比如阶乘，第一项是 1，乘不乘不变。如果去掉的话，可以吗？对 all n 有影响吗？\n或者把方向反过来，从 n 乘到 1 可以吗？\n循环的计算和选择\n循环的起点终点对结果都有影响\n有固定次数，明确起点与终点：for\n至少执行一次: do while\n可能一次不执行：while\n循环控制\n设定判定变量 isprime = 1;\n如果出现可以整除，isprime = 0; break;\nbreak: 结束循环\ncontinue: 可以跳过此循环剩下的部分，进入下一轮循环\n\n嵌套的循环\n如：输出 100 内的素数，for 里有 for（第一个 for 遍历 1~100，第二个检验该数是不是素数）\nint x;//再scan xint isprime=1;for(int i=2;i&lt;x;i++)&#123;\tif(x%i==0)&#123;\t\tisprime=0;\t\tbreak;\t&#125;&#125;//再根据isprime是不是1判断x是不是素数\n除了特别设计，每一层循环的控制变量应该不一样（i），要注意。所以在第一层循环每层开始的时候重新赋值或定义 int i，免得上次循环完的 i 这次拿来接着用，乱套了。\n/t 可以对齐，具体以后再讲\n从嵌套的循环中跳出\n凑硬币：用 1,2,5 元凑出 100\n如果我们想，发现了一种合适的就结束：在 if 内加 break 跳出（下图是错误示例）\nfor(one=1;one&lt;x*10;one++)&#123;\tfor(two=1;two&lt;x*10/2;two++)\t&#123;\t\tfor(five=1;five&lt;x*10/5;five++)//break跳出的是这层循环，而没有跳出上面的两层循环\t\t&#123;\t\t\tif(one+two*2+five*5==x*10)\t\t\t&#123;\t\t\t\tprintf(&quot;可以用%d个一角加%d个两角加%d个五角得到%d元\\n&quot;,one,two,five,x);\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n但是图中的 break 只跳出了第三层 for 循环；接着又进到了第二层 for 循环（图中蓝色位置），Break 和 continue 都只能在他那一层循环里做；\n如何一直跳出呢？\n方法一：连环跳\n加一个判定变量 exit=0;\nif 内写 exit=1;\n在两个 for 后面都写上 if(exit)break;\n//接力breakint x,one,two,five,x;int exit=0;scanf(&quot;%d&quot;,&amp;x);for(one=1;one&lt;x*10;one++)&#123;\tfor(two=1;two&lt;x*10/2;two++)\t&#123;\t\tfor(five=1;five&lt;x*10/5;five++)\t\t&#123;\t\t\tif(one+two*2+five*5==x*10)\t\t\t&#123;\t\t\t\tprintf(&quot;可以用%d个一角加%d个两角加%d个五角得到%d元\\n&quot;,one,two,five,x);\t\t\t\texit=1;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tif(exit==1)break;\t&#125;\tif(exit==1)break;&#125;\n方法二：goto out\n//gotoint x,one,two,five,x;int exit=0;scanf(&quot;%d&quot;,&amp;x);for(one=1;one&lt;x*10;one++)&#123;\tfor(two=1;two&lt;x*10/2;two++)\t&#123;\t\tfor(five=1;five&lt;x*10/5;five++)\t\t&#123;\t\t\tif(one+two*2+five*5==x*10)\t\t\t&#123;\t\t\t\tprintf(&quot;可以用%d个一角加%d个两角加%d个五角得到%d元\\n&quot;,one,two,five,x);\t\t\t\tgoto out;\t\t\t&#125;\t\t&#125;\t&#125;&#125;out:return 0;\n（除了这种多重 break 的结构建议使用 goto，别的地方不建议。）\n补充：PTA 例题\n前 n 项和\n求 1+1/2+1/3+……+1/n.\n在这个循环里，起点数字 1，终点数字 n 都是明确的\n#include&lt;stdio.h&gt;int main()&#123;\tint n;\tdouble sum=0.0;\tscanf(&quot;%d&quot;,&amp;n);\tfor(int i=1;i&lt;=n;i++)\t&#123;\t\tsum+=1.0/i;\t&#125;\tprintf(&quot;f(%d)=%f&quot;,n,sum);\treturn 0;&#125;\n例 2：1-1/2+1/3-1/4+……\n解决方案：定义一个 sign=1;\nsum+=sign*1.0/i;sign=-sign;\n技巧：如果我们 double sign=1.0，算式中就出现小数了，就不用*1.0 了。\n整数分解\n比如输入：12345\n输出：1 2 3 4 5\n考虑之前逆序输出的方法，我们可以先把这个数逆过来之后再逆序输出（鬼才）\n即：\n\n先求 x 的逆序数 t\n逆序逐位输出 t\n\n这种方法的缺陷在于：对于末尾有 0 出现的数字（如 700）只能得到 7\n我们可以回想 3 位数的题，我们用三位数/100 得到最高位数字。\n所以我们知道位数之后，可以正序逐位得到每一位的数字。\n可以先一个 while 循环求出 x 的位数和 mask（位数），（还是记得提前把 x 保存下来）然后正序输出。\n123456 / 100000 = 1\n123456%100000 = 23456\n23456 / 10000 = 2\n……\n求最大公约数\n算法 1：枚举。\n循环t++if(u/t==0&amp;&amp;v/t==0)gcd=t;//不断刷新gcdif(t==u||t==v)break;//并输出gcd;\n效率更高的算法 2：辗转相除\n1. 如果 b = 0，计算结束，a 就是最大公约数；\n2. 否则，让 a = b，b = a%b；\n3. 回到第一步\n   （可以使用之前提到过的变量表格法来人工运行）\n\n求符合给定条件的整数集\n给定 &lt;= 6 的正整数 A，从 A 开始的连续四个数字，请输出所有由它们组成的无重复数字的三位数。\n输出满足条件的三位数，从小到大，且每行 6 个整数，行末无多余空格。\n如：输入 A = 2\n234 235 243 245 253 254\n324 325 342 345 352 354\n423 425 432 435 452 453\n523 524 532 534 542 543\n int i,a,j,k,cnt=0;    scanf(&quot;%d&quot;,&amp;a);    i=a;    //思路：i,j,k都从a开始，从小到大逐渐增加到a+3，三者不能相等        while(i&lt;=a+3)&#123;        j=a;        while(j&lt;=a+3)&#123;            k=a;            while(k&lt;=a+3)&#123;               if(i!=j&amp;&amp;j!=k&amp;&amp;i!=k)&#123;                   printf(&quot;%d%d%d&quot;,i,j,k);                   cnt++;                   if(cnt==6)&#123;                       printf(&quot;\\n&quot;);                       cnt=0;                   &#125;                   else printf(&quot; &quot;);               &#125;               k++;            &#125;            j++;        &#125;        i++;    &#125;\n\n水仙花数\n水仙花数指一个 N 位正整数（N &gt;= 3)，它的每位上的数字的 N 次幂之和等于它自己。如：153 = 1^3^+3^3^+5^3^;\n给定一个 N（3 &lt;= N &lt;= 7），按顺序输出所有 N 位水仙花数。\n输入：3\n输出：\n153\n370\n371\n第一个循环：遍历所有 N 位数。\n第二个循环来求和，循环里面第三个循环来求每一位的 N 次幂（N 次循环），最后 if 判断是否 == sum。\n打印乘法口诀表\n\na*b，a、b 两重循环。\n还要注意对齐问题。如果结果是一位数，输出两个空格；两位数输出一个空格。\n统计素数并求和\n给定 M 和 N 区间内的素数的个数并对它们求和。\n读题后得知: 包含两头 [M, N]\n先定义 isprime=1; 当可以被比他小的数整除的时候就 isprime = 0。\n这道题很好做。注意特殊情况，如 m = 1 时，循环直接不判断，isprime=1\n可以在 m~n 循环开始前判断，if(m==1)m++;\n猜数游戏\n输入要猜的数字和猜的最大次数，大了输出 too big, 小了输出 too small，直到猜对或者次数用光或者用户输入负数为止\n还有就是注意不同次数猜到的输出结果也有区别。\n一次猜到：BINGO！\n两次猜到：LUCKY YOU！\n三次以上猜到：GOOD GUESS!\n//也不难，1.考的是语文的阅读理解；2.你是否有足够的耐心。（文中条件太多）\nn 项求和\n2/1+3/2+5/3+8/5+……的前 n 项之和（从第二项开始，每一项的分子是前一项的分子和分母之和，分母是前一项的分子）\ndividend=2;//分母divisor=1;//分子for(i=1;i&lt;=n;i++)&#123;\tsum+=dividend/divisor;\tt=dividend;\tdividend+=divisor;\tdivisor=t;&#125;printf(&quot;%.2f/n&quot;,sum);\n因为分子分母变大的相当快，所以出于范围考虑，也建议使用 double 储存 dividend（分子）和 divisor（分母）\n(inf 是越界，即无穷；nan 是无效数字)\n约分最简分式\n输入一个分式，如 32/45，输出最简形式。\n\nscanf(“%d/%d”)这样处理输入\n辗转相除法寻找最大公约数；\n念数字：比如输入-12：fu yi er\n先判断-的情况之后 switch case 很好办。以后学会数组之后会有更优解。\n\n求 a 的连续和\n输入 a, n，计算 a+aa+aaa+……+n 个 a 的和\n循环的每一轮 a1 = a1*10+a。\n6. 数据类型\nC 语言是有类型的语言。C 语言的变量，必须：\n\n在使用前定义;\n确定类型.\n\n如果我们一开始直接说 a = 6: 使用了未定义的标识符 a。\nC 语言之后语言朝着两个方向发展：\n\nC++和 Java 更强调类型，对类型的检查更加严格\nJavaScript、Python、PHP 不着重类型，甚至不需要事先定义。\n支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误；\n反对强类型的观点认为过于强调类型，迫使程序员面对底层，实现而非事务逻辑\n\n总的来说，早期语言、面向底层的语言强调类型。\nC 语言需要类型，但是对类型的安全检查并不足够：\n（以下斜体的是 c99 类型）\n整数：char、short、int、long、long long；\n浮点数：float, double, long double；\n逻辑：bool；\n指针；\n以及自定义类型。\n类型的不同之处在于：\n\n类型名称：int, long, double……\n输入输出时的格式化（占位符）：%d,%ld,%lf……\n所表达的数的范围：char &lt; short &lt; int &lt; float &lt; double\n内存中占据的大小：1~16 个字节\n\n内存中的表达形式：二进制数（补码）、编码（浮点是编码形式）\n编码形式不能直接进行运算，而两个整数可以。\nSizeof()是一个运算符，给出某个类型或变量在内存中所占据的字节数。如：\nsizeof(int)\nsizeof(i)\n(1 个字节是 8 个比特，所以 int 4 个字节 32 个比特)\nsizeof 是一个静态运算符，在编译时其结果就已经决定了\n比如上一行写 sizeof(a++), 但输出 a 之后会发现 a 其实没有++。\n整数类型\nsizeof(char)=1;//char1字节（8比特）sizeof(short)=2;//short2字节sizeof(int)=4;//由编译器决定，通常代表“1个字”sizeof(long)=4;//由编译器决定，通常代表“1个字”sizeof(long long)=8;//long long 8字节\n\n说一台计算机的字长的时候，我们指的是寄存器 RAM 是多少字长（比特）的。\n每一次从 CPU 中取数据取 32 个比特\n所以说 int 就是用来表达寄存器的，不同计算机可能得到不一样的 sizeof(int)。\n整数的内部表达\n计算机内部，一切都是二进制的，只是说我们以不同的方式去看待它。\n十进制：18→ 二进制：00100010\n十进制用负号来表示负数，运算一般在结果上再加负号。\n而二进制怎么表示负数呢？\n一个字节（8 位）可以表达的数：00000000 ~ 11111111（0~255）\n三种方案：\n\n\n像十进制一样，有一种特殊的标志（类似符号）来表示负数（缺陷：计算机做加减法的时候，要像判断十进制的负号一样，我们需要一个东西去控制加号还是减号。不过每次计算机都要特别地去判断这个符号的正负，这样就会比较复杂。）\n\n\n从 0000 0000 到 1111 11111，取中间的数为 0，如 1000 0000 表示 0，比他小的是负数，比他大的是正数，各一半（缺陷：所有数都要和这个数做减法来计算其值，会比较复杂）\n\n\n补码\n思路：本质上来看，（互为相反数的）负数+正数 = 0。这是提供思路的一种方法。\n比如我们希望-1+1→0，如何能够做到？\n如 0→0000 0000，1→0000 0001，我们让一个数+1 得到 0。这个数字选谁？\n全 1 的数字 1111 1111。因为 0000 0001+1111 1111→1 0000 0000 多出来的一位（溢出）那一位被丢掉了，相加结果即是 00000000。妙啊\n或者换个角度：-1 = 0-1 =(1)0000 0000-0000 0001→1111 1111\n（1111 1111 被当作纯二进制看待时是 255，被当做补码看待时是-1）\n所以对于-a 来说，他的补码就是 0-a，实际就是 2^n^-a，n 是该种类型的位数\n补码的意义就是拿补码和原码可以加出一个溢出的 0。\n另一个好处是这样我们做计算的时候，不需要调整加减，全部都是加法（+补码就是-原码）。\n\n\n整数的范围：如何推算整数类型所能表达的数的范围，越界了会怎样？\n一个字节（8 位）：0000 0000~1111 1111\n其中 0000 0000→0\n0000 0001 ~ 0111 1111→1~127（纯二进制数）\n1000 0000 ~ 1111 1111→-128 ~ -1（用补码表示的数）\n还是那句话，关键在于我们以什么样的方式去看待这个数。当成纯二进制数，1111 1111 就是 255；当成整数，就是-1\nchar c=255;int i=255;printf(&quot;%d%d&quot;,c,i);\n输出结果：c =-1, i = 255。\n因为对于字符 c 来说，255→1111 1111\n而对于整形变量 i 来说，266→0000 0000  0000 0000  0000 0000  1111 1111\n\n\n\n类型\n大小\n范围\n\n\n\n\nchar\n1 字节\n-128~127\n\n\nshort\n2 字节\n-2^15^~2^15^-1\n\n\nint\n取决于编译器\n-2^31^~2^31^-1\n\n\nlong\n4 字节\n-2^31^~2^31^-1\n\n\nlong long\n8 字节\n-2^63^~2^63^-1\n\n\n\n比如 char 长度 256，会被分成三部分：-128~-1,0,1~127\n所有整数类型范围都是-2^(n-1)^~2^(n-1)^-1\n如果我们希望一个数据从计算机中拿出来时我们将其视为纯二进制看待，我们要在其前面加上一个关键字 unsigned.\nunsigned char c=255;\nunsigned 使得这个类型在正整数表达部分范围扩大一倍，但是不能表达负数了。\n如果一个字面量常数想要表达自己是 unsigned，可以在后面加 u/U：255U\nSimilarly, 想表达自己是个 long, 后面加 l\nunsigned 的初衷不是为了扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位。\n整数是以纯二进制方式进行运算的。\n\n补码就是顺时针-，逆时针+\nchar c=127;c++;\n然后 c 变成了-128。\nSimilarly，-128-1 变成了 127。\nunsigned（无符号）则是直接加减。\n但是\nunsigned char c=255;c++;\n并不像预想中的得到 256，我们得到 c = 0，因为 256 在 8 比特里是全 0，第九位是 1 被丢掉。\nc=0;c--;\n得到 255。\n所以对于 unsigned，也是顺时针-，逆时针+\n\nint a=0,b=1;while(++a&gt;0);printf(&quot;int数据类型的最大数是：%d\\n&quot;,a-1);while((a/=10)!=0)b++;printf(&quot;int数据类型最大的数的数位是:%d&quot;,b);\n可以用这种方法推算 int 的最大范围。while(++a&gt;0) 使得 a 加到 127→-128 越界后变成负数，然后 printf(&quot;%d&quot;,a-1); 再返回到 127，得到 int 可以表达的最大数\n同理，如果想得到 unsigned 的最大范围，参考上面的表，while(a!=0);\n整数的格式化：如何格式化地输入输出整数，如何处理 8 进制/16 进制\n整数的输入输出只有两种形式：int 和 long long\n%d：int\n%u: unsigned\n%ld: long long\n%lu: unsigned long long\n若 int i =-1; 储存在计算机中是二进制形式，即全 1，若以%u 即 unsigned 形式输出，得到的结果就是 int 型的最大值（4294967295）\n如此仍然可见，重点在于我们以什么样的正确的方式去看待这个结果。\n8 进制（octal）：一个以 0 开始的数字字面量\n16 进制（Hexadecimal）：一个以 0x 开始的数字字面量\nchar c=012;int i=0x12;printf(&quot;c=%d,i=%d\\n&quot;,c,i);\n得到结果（%d 转化为十进制）：c = 10, i = 18\n（计算机内部同样还是二进制的形式）\n想要输出 8 进制：%o 或 %O\n想输出 16 进制: %x 或 %X, 小写的 x 输出小写的字母，大写的输出大写的\n(但是这样输出的结果前面是没有 0 和 0x 的。所以可以写 printf(“c=0%o,i=0x%x\\n”,c,i);\n8 进制和 16 进制只是如何把数字表达为字符串，与内部如何表达数字无关。\nscanf 中也可以用%o，表示读进来的数我们把其当做 8 进制来读。\n16 进制很适合表达二进制数据，因为 4 位二进制正好是一个 16 进制位（0001 0010→1 2）\n八进制的一个数字正好表达 3 位二进制，因为早期计算机的字长是 12 的倍数，并非 8。\n整数类型的选择\n`char, short, int, long, long long\n每种类型有不同大小，不同范围，内部是什么样，表达出来是什么样，……\nC 语言这些又多又复杂的原因：1.C 语言的严谨性，为了准确表达内存，做底层程序的需要\n2.C 语言要和硬件打交道，要准确表达计算机里的东西（内存、寄存器、接口……）\n建议：没有特殊需要，就选择 int\n原因 ：\n\n现在 CPU 字长（CPU 和内存之间的通道。如果 char 可能会从 32 位中先挑出来 8 个，可能会花费时间）普遍是 32 位/64 位，一次内存读写、一次计算都是 int，选择更短的类型不会更快，甚至可能会更慢\n现代编译器一般会设计内存对齐，（比如这个东西虽然占据 8bit，在内存中仍然占据了一个 int。这个事等到结构再讲）所以更短的类型实际在内存中也可能占据一个 int 的大小。除非在做顶层的硬件，告诉你硬件多大你就要用多大去运算\n至于 Unsigned 与否，只是输出的形式不同，内部的计算还是一样的\n\n浮点类型\nfloat，double\n32 位，64 位\n10^38^,10^308^\n7 位有效数字，15\n但是 float 靠近 0 的部分（0~10^38^）有很小一部分不能表达（这应该是之前的题目为什么 if 判断浮点数不写做差 == 0，而是写做差 &lt; 1e-6）\nfloat 还能表达 0，±inf（无穷），nan（非有效数字）\n%e/%E: 科学计数法\n1234.56789 输出得到：1.234567e+03\n-5.67E+16，科学计数法可选的有：±号，e 或 E，小数点，E 后面的符号±\nDouble ff = 1E-10；\n输出精度：%.数字f 可以指定输出小数点后几位，这样输出的结果是做四舍五入的\n%.3f,-0.0045→-0.004\n%.30f→ 后面输出 30 位，-0.0049→-0.00489999……（计算机最终只能用离散的数字来表示数字，这就是浮点数的误差。Double 更准确，但可能依然不精确）\n%.3f，-0.00049→-0.000\n浮点数的范围和精度\nInf 无穷，nan 输出不存在的浮点数\n正数除 0.0→inf\n负数除 0.0→-inf\n0.0/0.0→nan\n(如果是整数，12/0 编译不过)\n浮点数范围不包括无穷大，但它可以表示。\n float a,b,c;a=1.345f;b=1.123f;c=a+b;if(c==2.468)printf(&quot;相等&quot;);else printf(&quot;不相等，c=%.10f，或%f&quot;,c,c);\n加 f: 表明身份，让它是 float\n结果：不相等！c = 2.4679999352，或 2.468000\nf1 == f2 不一定成功，应该写 fabs(f1-f2)&lt;1e-12\n所以浮点数不能做精确计算，最后误差会累积起来的。只能在一定范围内相信小数点\nAndroid 计算器低级错误？都是二进制惹的祸！\n而传统计算器直接用整数做运算\n而浮点数内部是编码形式\n\n从左到右分别表示正数负数、指数、小数\n如果没有特殊需要，就用 double\n现代 cpu 能直接对 double 做硬件计算，性能不会比 float 差，而且在 64 位的机器上数据存储的速度也不会比 float 慢\n字符类型：char 是整数也是字符\nchar 是整数，也是字符。（character）\n原因 1：我们可以用单引号表示字符的字面量 'a', '1'\n'' 也是字符\n我们可以在 printf 和 scanf 里用%c 来输入和输出字符。\n计算机内部每一个值都有一个字符去表达它（ASCII）如 1 对应的码是 49\n输入 1 给计算机的方法：scanf(&quot;%c&quot;,&amp;c); 输入 1\n或者 scanf(&quot;%d&quot;,&amp;c); 输入 49\n输出同样，因为 49=='1'\n注意空格的问题。\nscanf(&quot;%d%c&quot;,&amp;i,&amp;c);scanf(&quot;%d %c&quot;,&amp;i,&amp;c); \n这样中间几个空格回车都没关系，中间的空格会全部被读掉\n从 A 到 Z 的 ASCII 码都是连着的\n一个字符加一个数字可以转到后面那个对应 ASCII 码的字符处\nint i='Z'-'A';//两个字符相减，得到它们在表中的距离\n字母在 ASCII 表中顺序排列，且大小写字母分开排列\n'a'-'A' 可以得到小写字母与大写字母之间的距离，所以 'a'+('A'-'a') 可以转小写为大写\n\n逃逸字符\n用来表达无法印出来的控制字符或特殊字符，由一个反斜杠\\开头，后面跟着一个字符\nprintf(&quot;请分别输入身高的英尺和英寸，&quot;&quot;如输入\\&quot;5 7\\&quot;表示5英尺7英寸：&quot;);\n\n\n\n字符\n意义\n字符\n意义\n\n\n\n\n\\b\n回退一格\n&quot;\n双引号\n\n\n\\t\n到下一个表格位\n'\n单引号\n\n\n\\n\n换行\n\\\n反斜杠本身\n\n\n\\r\n回车\n\n\n\n\n\n（作业时就会有最后结尾多个空格，使用/b 来删掉的情况，但其实应该说是覆盖了吧，总之这样运行的时候是不正确的，还是要想办法控制输出的空格等的格式正确）\n例子\nprintf(&quot;123\\b\\n456\\n&quot;); \n得到结果：\n\n但是到了其他程序那边运行\n123\n456\n原因：dev c++那个黑框框，是别人写的程序(shell)来帮助我们运行的；部分东西是经过它处理的，比如\\b\\n，不同 shell 对此处理不一样。如 dev c++用 BS 字符来表示。\n\\b\\n 都是控制字符\nBS 是回到上一格，没输出东西就什么结果都没有，输出了就把他盖住了\n也不能否认有的程序，输出的时候把\\b 翻译成删除\n\\t: 到下一个表格位（在每一行中有一些固定的位置，\\t 代表输出的固定的位置）\n比如\n printf(&quot;123\\t456\\n&quot;);printf(&quot;12\\t456\\n&quot;);\n\n\\n 换行\\r 回车，源自打字机的动作\n一直敲键盘，打字机的轴就往左移\n敲一下回车就回到右边，这叫回车\n然后往上调一下纸，这叫换行。\n不过 dev c++把回车就当做回车+换行了。\n类型转换\n自动类型转换：当运算符两边出现不一样的类型时，会自动转成较大的类型，即能表达的数范围更大的类型。\nchar-&gt;short-&gt;int-&gt;long-&gt;long long\nint-&gt;float-&gt;double\n对于 printf，任何小于 int 的类型都会被转换成 int；float 会被转换成 double。所以 printf 输出 double 的时候写%f 就也行。\n但 scanf 不会，想输入 short 时，需要%hd。\n强制类型转换：(类型)值\n如：\n (int)10.2;(short)32;\n但是注意安全性，小的变量不总能表达大的量。如 (short)32768，因为 short 最大范围是 32767，所以会被转化为-32768\n只是从那个变量计算出了一个新类型的值，他并不改变那个变量的值或类型。\nint i=32768;short s=(short)i;printf(&quot;%d\\n&quot;,i);\ni 输出仍然是 32768。强制类型转换不会改变这个变量自身的类型或值。\n如果想计算 a，b 的 int 型相除得到的 i 的 int 型的值：\n double a=1.0;double b=2.0;int i=(int)a/b;\n实际上是先 int a，再/浮点数 b, 强制类型转换的优先级高于四则运算。\n所以正确的写法是\nint i=(int)(a/b);(double)(a/b);\n逻辑类型：表示关系运算和逻辑运算结果的量\nbool 类型\n首先要包含头文件#include &lt;stdbool.h&gt;，然后可以使用 bool，true, false。\nbool b=6&gt;5;\n只要 bool 量不是 0，都 = 1.\n逻辑运算：对逻辑量进行与、或、非运算\n逻辑运算是对逻辑量进行的运算，结果只有 0 或 1。\n逻辑量是关系运算或逻辑运算的结果。\n\n\n\n运算符\n描述\n示例\n结果\n\n\n\n\n!\n逻辑非\n! a\na 的 true 或 false 反转\n\n\n&amp;&amp;\n逻辑与\na&amp;&amp;b\n只有 a&amp;b 都是 true 时结果才是 true\n\n\n||\n逻辑或\na||b\n只有 a&amp;b 都是 false 时结果才是 false\n\n\n\n例：表达数学区间时，(4,6)或 [4,6]：\n同样像之前 if 一样，不可以写 4 &lt; x &lt; 6 这种式子。因为 4 &lt; x 的结果是一个逻辑值（0 或 1）\nx&gt;4&amp;&amp;x&lt;6 或 x&gt;=4&amp;&amp;x&lt;=6\n判断一个字符是大写字母：c&gt;='A'&amp;&amp;c&lt;='Z'\n优先级：!&gt;&amp;&amp;&gt;||\n例：!done&amp;&amp;(count&gt;MAX)：done 是 0 且 count&gt;MAX 时结果为 1\n所有的优先级\n\n\n\n优先级\n运算符\n结合性\n\n\n\n\n1\n()\n从左到右\n\n\n2\n!，+，-，++，–\n从右到左（单目的+和-）\n\n\n3\n*，/，%\n从左到右\n\n\n4\n+，-\n从左到右\n\n\n5\n&lt;，&lt;=，&gt;，&gt;=\n从左到右\n\n\n6\n==，!=\n从左到右\n\n\n7\n&amp;&amp;\n从左到右\n\n\n8\n||\n从左到右\n\n\n9\n=，+=，-=，*=，/=，%=\n从右到左\n\n\n\n短路：逻辑运算自左向右，如果左边足以决定结果，就不会进行右边的计算了\na==6&amp;&amp;b==1 如果左边 a!=6 就终止了。\n即：&amp;&amp;左边 false 就不做右边了；||左边是 true 就不做右边了。就算右边是赋值的话右边也不会做了。\n int a=-1;if(a&gt;0&amp;&amp;a++&gt;1)&#123;\tprintf(&quot;OK\\n&quot;);&#125;printf(&quot;%d\\n&quot;,a);\n这样输出结果 a =-1，没有进行右边的 a++。\n所以不要把赋值和复合赋值组合进表达式！\n条件运算符\n条件运算符 1：问号\n cnt=(cnt&gt;20)?cnt-10:cnt+10;//格式：条件?条件满足时的值:条件不满足时的值\n相当于\nif(cnt&gt;20)cnt-=10;else cnt+=10;\n这种条件运算符 ? 的优先级高于赋值运算符，但是低于其他运算符，但是这样会很麻烦。\n条件运算符自右向左，先计算右边的分支\n不建议使用嵌套的条件表达式！太复杂，太难理解\n条件运算符 2：逗号\n逗号是个运算符，连接两个表达式，并且以右边的表达式的值作为其结果。\n逗号的优先级是最低的，所以两边的表达式会先运算，而右边的表达式的值留下来作为运算的结果。\ni=3+4,5+6;//编译时会提示warning。因为赋值的优先级也要高于逗号，该式子其实是(i=3+4),(5+6);//右边编译错误,i=7如果写作i=(3+4,5+6);//编译时同样会warning，因为3+4没有用到;i=11\n逗号表达式主要在 for 中使用\nfor(i=0,j=10;i&lt;j; i++,j--)\n目前来说，逗号表达式只有这一个用处。\n7. 函数\n初见函数\n回想起区间 [m, n] 内素数求和的例子，对于每个数我们定义 isPrime=1，如果最后仍然 = 1 的话 sum+=i.\n这样让这一层循环显得很大，而这一层代码的功能很单纯\n我们可以以函数的形式把这一堆代码取出来\nint isPrime(int i)&#123;\tint ret=1;\tint k;\tfor(k=2;k&lt;i-1;k++)&#123;\t\tif(i%k==0)&#123;\t\t\tret=0;\t\t\tbreak;//有1~i-1间的因数就可以判断i不是素数了，break节约时间\t\t&#125;\t&#125;\treturn ret;&#125;\n我们之前从第一个程序 printf 开始就是在用函数。只不过这次我们在自己定义了一个函数。\n这样 main 里面很简洁，而且 isPrime 可以很方便地多次使用\nPS: 程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。\n（吓得我立刻就去改大作业了）我们用函数替换，可以把重复的代码提出。\n //闭区间内所有数求和的函数 void sum(int begin,int end) &#123; \tint i,sum=0; \tfor(i=begin;i&lt;=end;i++)&#123; \t\tsum+=i; \t&#125; \tprintf(&quot;%d到%d的和是%d\\n&quot;,begin,end,sum); &#125;int main()&#123;\tsum(1,10);\treturn 0;&#125;\n函数的定义和调用\n函数是一块代码，接收 0 个/多个参数做一件事情，并返回 0 个/1 个值。\n可以先想象成数学中的函数 y = f(x)。\n调用函数时要写出 函数名(参数值);\n（）起到了表示函数调用的重要作用，即使没有参数我们也需要（）。\n不给括号的话，会给 warning，而且函数不会被调用。\n如果有参数，参数的数量、顺序都必须正确。而且函数知道每一次是哪里调用它，还会返回到正确的地方。\n从函数中返回\nint 函数会有返回值 return\nreturn 停止函数的执行，并返回一个值\nreturn;\nreturn 一个值;\n可以写  c=函数()；这样 c = 函数的返回值。\n可以把这个值赋给变量/传给函数/丢掉。\n没有返回值的函数: void，不能使用带值的 return ，可以没有 return 。调用的时候也不可以做返回值的赋值。\n函数原型：用来告诉编译器这个函数长什么样\n使用函数的先后顺序：先写函数再调用。\n\n可以先想象成数学函数 y=f(x)\nC 的编译器自上而下分析你的代码，它会记住函数 sum() 长什么样子要几个参数，每个参数的类型如何，返回什么类型\n如果把函数放在后面，C 语言可能会猜，你在 main 函数里使用的这个函数是什么类型。如果后面发现后面的函数类型和它猜测的不符，就输出 error 。\n因此也可以先不用写完函数，光把一句函数头放到前面编译也能通过。\n（事先声明了函数的样子)\n下面函数还会判断一下和你之前的声明是否一致\nvoid sum(int begin,int end);//声明int main()&#123;\t//略去不表，其中用到了sum(a,b)&#125;void sum(int begin,int end)//定义&#123;\tint i,sum=0; \tfor(i=begin;i&lt;=end;i++)&#123; \t\tsum+=i; \t&#125; \tprintf(&quot;%d到%d的和是%d\\n&quot;,begin,end,sum);&#125;\n函数头以分号结尾，就构成了函数的原型；\n在函数里定义的参数类型与输入的变量的类型不一样，会发生自动类型转换。\n double max(double a,double b);\n在以前是把函数原型写在调用它的函数(main())里面的。\n函数的原型里可以不写参数名，但一般仍然写上。\nVoid sum(int ,int)\n不过对于人类读者，一般来说写上会更好理解。\n参数传递：调用哪个函数的时候，是用表达式的值来初始化函数的参数\n传递给函数的值可以是表达式的结果 (max(a+b,c))\n包括字面量、变量、函数返回值（函数调用里有函数）、计算结果\n当调用函数的值与参数类型不匹配：编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的。这是 C 语言传统上最大的漏洞。\n后续语言如 c++/java 在这方面会很严格。\n这样的函数代码能交换 a, b 的值吗？\n   void swap(int a,int b)//形参int main()&#123;\tint a=5;\tb=6;\tswap(a,b);//实参&#125; void swap(int a,int b)//形参 &#123; \tint t=a; \ta=b; \tb=t; &#125;\n不能。\nC 语言在调用函数时，永远只能传值给函数。\n每个函数有它自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系。\n后面递归还会再提。\n过去对于函数参数表中的参数叫做形式参数。调用函数时给的数值叫做实际参数。\n（见上图）\n由于易误会，我们不再这么称呼。我们把参数表中叫做参数，调用函数的叫做值。\n本地变量：定义在函数内部的变量是本地变量，参数也是本地变量\n函数每次运行都会产生一个独立的变量空间，其中的变量是函数这一次运行所独有的。（本地变量）\n所有我们定义在函数内部的变量就是本地变量。（我们现在学过的都是定义在函数内部的）我们写在函数参数表里的参数也是本地变量。\n变量的生存期和作用域\n生存期：这个变量出现和消亡的时间\n作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用）\n对于本地变量，这两个答案都是：大括号内（块）\n    void swap(int a,int b)//形参int main()&#123;\tint a=5;\tb=6;\tswap(a,b);//实参&#125; void swap(int x,int y)//形参 &#123; \tint t=x; \tx=y; \ty=t; &#125;\n比如仍然是上例，进入 swap 函数之后（离开了自己的变量空间）a, b 就没了。还在生存，但是不在当前的作用域了（显示：Not found in current context)\n而回到原函数中之后，x, y, t 就不存在了\n所以在 swap 函数里交换 a, b 不会影响到原函数\n本地变量的规则\n\n本地变量定义在块内。可以是函数的块内，语句的块内，如：\nif (a &lt; b)int i = 10;\n离开 if 语句之后未定义使用 i 编译错误。（没声明）\n程序运行进入这个块前，其中的变量不存在。离开后就消失了。\n如果在块里定义了块外已经定义过的变量，就把块外的变量掩盖了；出来之后又回到块外的值。（C 语言）\n但是不能在块里面定义同名变量（多次定义）\n本地变量不会被默认初始化，不会得到一个初始值。而参数进入函数的时候被初始化了。\n\n函数庶事：一些细节，main() 的解释\n函数没有参数的时候写 void f(void)。而写 void f()在传统 C 语言中表示 f 的函数的参数表未知，并不表示没有参数。（编译器可能会猜测什么类型）\n所以不要写空的括号\n调用函数时的逗号和逗号运算符怎么区分？再加一层括号就是逗号运算符 f((a, b))\nC 语言不允许函数嵌套定义。\n（也最好不要写 return (i); 虽然意思上没变，但是会让人误会 return 是个函数）\nint main(void) 也是个函数，所以 return 0; 也是有意义的。\n8. 数组\n初试数组\n之前提到过如何计算用户输入的数字的平均数？\n之前的做法：每读到一个数（!=-1）加到 sum 里，cnt++, 最后 sum/cnt\n这样我们不需要记录每一个数\n如果题目还要求：输出所有大于平均数的数？这样就必须记录每一个数了，因为我们是最后才计算平均数的，要最后再用每个数和平均数做判断\n如何记录很多数？int num1, num2……？不好。这样下去无穷无尽。\n使用数组\nint number[100];//定义数组，表示数组可以放100个intscanf(“%d”,&amp;x);while(x!=-1)&#123;\tnumber[cnt]=x;//对数组中的元素赋值\tcnt++;\tscanf(“%d”,&amp;x);&#125;\n最后再加个 cnt 长度的循环，判断每一个数与平均数比较大小\n if(cnt&gt;0)&#123;\tint i;\tdouble average=sum/cnt;\tfor(i=0;i&lt;cnt;i++)&#123;\t\tif(number[i]&gt;average)&#123;//使用数组中的元素\t\t\tprintf(&quot;%d &quot;,number[i]);//遍历数组\t\t&#125;\t&#125;&#125;\n这个程序的安全隐患在于没有考虑使用的数组下标是否会超过 100.定义的时候注意要求。\n数组的使用：如何定义和使用数组，数组的下标和下标的范围\n定义数组：\n&lt;类型&gt; 变量名称 [元素数量];//方括号表示这是个数组\nint grades[100];double weight[20];\n元素数量必须是整数。在 c99 之前，元素数量必须是编译时确定的字面量。(a [n] 不行)vscode 中好像就不行，提示 variable-sized object may not be initialized\n数组是一种容器，特点是：\n其中所有元素具有相同的数据类型；\n一旦创建，不能改变大小；\n其中元素在内存中连续依次排列（从 0 开始）；\n如：定义十个单元 a [10] →a [0]~a [9]\n\n每个单元就是一个 int 类型的变量。像普通变量一样可以出现在赋值的左边或右边。左边的叫左值，右边的叫右值。\n数组的每个单元就是数组类型的一个变量。使用数组时 [] 中的数字/变量叫下标或索引，从 0 开始计数\n（要习惯数数从 0 开始到 n-1）\n但编译器和运行环境不会检查数组下标是否越界，无论读、写数组单元。\n不过数组越界时可能出问题: segmentation fault，运气好的话不会造成严重的后果。\n所以这是程序员的责任来保证程序只适用有效的下标值（范围：[0, 数组大小-1]）\n防止读入数字超过 100 个的方法：\n方法一：cnt = 100 之后停止读数；\n方法二：利用 c99 数组大小可以是动态的的特性，定义 number[cnt];//用户先输入cnt\n可不可以 int a [0];?\n可以，但是没用。\n数组的例子：统计个数\n不停输入 0~9 范围内的整数，读到-1 停止，统计每种数字出现的次数。\n和上一道题不同的是，不用记录每次输入的数字，我们需要记录的是每种数字出现的次数。\n学到了定义数组为 0 的方法：\nfor(int i=0;i&lt;10;i++)count[i]=0;\n和打印方法：\nfor(int i=0;i&lt;10;i++)printf(“%d\\n”,count[i]);\n该题中出现多次数字 10。根据之前学到的方法，我们可以定义 const number = 10（c99 才能用）; 每一个 10 用 number 代替。\n通常用到数组的程序都需要的环节：\n\n确定数组大小；\n定义数组；\n初始化数组；\n数组参与运算；\n遍历数组输出。\n\n数组运算\n搜索：在一组给定数据中，怎样找出某个数据是否存在？\n（往函数中传数组：int sum(a [])）\n数组的集成初始化：\n int a[]=&#123;2,4,6,7,1,3,5,9&#125;/*直接用大括号给出数组所有元素的初始值；不需要给出数组的大小，编译器替你数了。*/\n依次初始化数组的每一个单元\n如果 a[13]=&#123;2&#125;; 只有 a [0] 是 2，后面的单元都是 0\n所以如果想定义一个数组全为 0：a[13]=&#123;0&#125;;\nC99 还可以在大括号里给指定的位置赋值。\n用 [n] 在初始化数据中给出定位，没有定位的数据接在前面的位置后面；其他位置的值补 0.\nint a[0]=&#123;[0]=2,[2]=3,6&#125;;\n这个例子里，a [0] = 2，a [2] = 3，a [3] = 6\n我们也可以不给出数组大小，让编译器计算。比如上例可写为：\nint a[]=&#123;[0]=2,[2]=3,6&#125;;\n这样会根据大括号里最大的数字下标来算数组的大小。即下标最大为 3\n这样特别适合初始数据稀疏的数组。\n数组的大小\nsizeof 给出整个数组所占据的内容的大小，单位是字节。（n*4，sizeof(a)/sizeof(a [0])就能得到数组元素个数）\n不能直接把一个数组赋给另一个数组 b[]=a;\n==数组变量本身不能被赋值==。如果想把一个数组的值全部交给另一个数组，必须遍历。\n遍历数组\n通常使用 for 循环，从 0 开始到 &lt; n，这样循环体最大的 i 正好是数组最大的有效下标。\n常见错误：1.循环结束条件是 &lt;= 数组长度\n2.离开循环之后继续使用 i 作为数组元素下标。\n数组作为函数参数时，往往需要另一个参数来传递数组大小。\n原因：1、数组传入函数之后我们不能用 sizeof 来计算数组的元素个数；\n2.不能在 [] 中给出数组的大小。\n具体原因后面再说。\n数组例子：素数\n之前找素数的例子。我们可以定义 isPrime()函数来判断一个数是否是素数。\nisPrime()函数：我们从 2 到 x-1 都拿去除 x，循环要走很多遍，重复执行的次数很多（程序很差）。\n优化：当 x 是!= 2 的偶数，一定不是素数，就直接不用判断。\n因为剩下需要判断的书都是奇数，肯定%2 = 1，这样我们判断接下来的数时 for 循环除数就可以从 3 开始的奇数判断。\nfor(int i=3;i&lt;x;i+=2)\n再次优化：我们不需要走到 x。我们只要走到 sqrt(x)就够了。\nfor(int i=3;i&lt;=sqrt(x);i+=2)\n引入：当我们想了解一个函数时，在编译器中输入 man 函数名称（man sqrt）就能得到其相关信息。（man: manual 手册）\nWindows 用户：打开浏览器搜索。\n再再次优化：我们不需要拿比 x 小的数字来测试 x 是不是素数，我们只需要拿比 x 小的素数就够了。\n int isPrime(int x,int knowsPrimes[],int numberofKnownPrimes)int main()&#123;\tconst int number=100;\tint prime[number]=&#123;2&#125;;\tint count=1;\tint i=3;\twhile(count&lt;number)&#123;\t\tif(isPrime(i,prime,count))&#123;\t\t\tprime[count++]=i;\t\t&#125;\t\ti++;\t&#125;//prime数组装着所有素数\tfor(i=0;i&lt;number;i++)&#123;\t\tprintf(&quot;%d&quot;,prime[i]);\t\tif((i+1)%5)printf(&quot;\\t&quot;);\t\telse printf(&quot;\\n&quot;);\t&#125;\treturn 0;&#125; int isPrime(int x,int knowsPrimes[],int numberofKnownPrimes) &#123; \tint ret=1; \tint i; \tfor(i=0;i&lt;numberofKnownPrimes;i++)&#123; \t\tif(x%knownPrimes[i]==0)&#123; \t\t\tret=0; \t\t\tbreak; \t\t&#125; \t&#125; \treturn ret; &#125;\n一边构造素数表，一边利用表来证明素数。\n其中 prime[cnt++]=i; 一举两得，cnt++ 的同时还把 i 的值放到了对应的数组位上。\nwhile(count&lt;number)&#123;\tif(isPrime(i,prime,count))&#123;\t\tprime[count++]=i;\t&#125;\t&#123;\t\tprintf(&quot;i=%d \\tcnt=%d\\t&quot;,i,count);\t\tint i;\t\tfor(i=0;i&lt;number;i++)&#123;\t\t\tprintf(&quot;%d\\t&quot;,prime[i]);\t\t&#125;\t\tprintf(&quot;\\n&quot;);\t&#125;\ti++;&#125;\n这样加个括号在里面 int i 之后，我们使用 i 就不会影响到外面的 i 的值了（但是我宁愿重新定义个变量 j = i。因为太绕了）\n同样的方法，我们可以先输出一个表头。\n &#123;\tint i;\tprintf(&quot;\\t\\t\\t\\t&quot;);\tfor(i=0;i&lt;number;i++)&#123;\t\tprintf(&quot;%d\\t&quot;,i);\t&#125;\tprintf(&quot;\\n&quot;);&#125;\n\n换一个思路，使得最后这张表里留下来的数都是素数。\n欲构造 n 以内的素数表：\n\n令 x = 2\n将 2x,3x……直到 ax &lt; n 的数标记为非素数\n令 x 为下一个没有被标记为非素数的数，重复 2；直到所有的数都已经被尝试完毕。\n（从 2,3,4,5,6,7,8……删掉 2 的所有倍数，再删掉 3 的所有倍数，再删掉 5 的所有倍数……）\n先开辟数组 prime [n]，初始化其所有元素为 1，prime [x] = 1 表示 x 是素数，prime [x] = 0 表示 x 不是素数\n令 x = 2\n如果 x 是素数，则 for(int i=2;x*i&lt;n;i++) 令 prime[i*x]=0\nx++，重复 3 直到 x == n，否则结束。\n\n int main()&#123;\tconst int maxNumber=25;\tint isPrime[maxNumber];\tint i,x;\tfor(i=0;i&lt;maxNumber;i++)\t&#123;\t\tisPrime[i]=1;\t&#125;\tfor(x=2;x&lt;maxNumber;i++)\t&#123;\t\tif(isPrime[x])\t\t&#123;\t\t\tfor(i=2;i*x&lt;maxNumber;i++) isPrime[i*x]=0;\t\t&#125;\t&#125;\tprintf(&quot;\\n&quot;);\treturn 0;&#125;\n如此可见，算法的思考方式不见得与人相同。\n二维数组\nint a[3][5]; 通常理解为 a 是一个 3 行 5 列的矩阵\n\n最好先行号再列号，和线性代数也是相对应的。\n二维数组的遍历需要两个 for 循环\nint a[][5]=&#123;\t&#123;0,1,2,3,4&#125;,\t&#123;2,3,4,5,6&#125;,&#125;;\na[i][j] 表示一个 int\na[i,j] 是逗号运算符（等于逗号右边的值），表示 a[j]，不是正确表达二维数组的方式。\n二维数组的列数必须给出，行数可以交给编译器来数。\n给数的时候每行一个{}，用逗号分隔。如果省略表示 0。\n也可以用定位（注意只能是 c99）\n二维数组是逐行填满的，所以也可以不加大括号，当做一维数组去初始化\nPS: tic-tac-toe 井字棋判断输赢问题：行列对角线分开检查。\nconst int size = 3;int board[size][size];int i,j;int num0fX;//X是一方int num0fO;//O是一方int result=-1;//-1：平局，1：X方赢，0:O方赢//读入矩阵for(i=0;i&lt;size;i++)&#123;\tfor(j=0;j&lt;size;j++)&#123;\t\tscanf(&quot;%d&quot;,&amp;board[i][j]);\t&#125;&#125;//检查行for(i=0;i&lt;size&amp;&amp;result==-1;i++)&#123;\tnum0fO=num0fX=0;\tfor(j=0;j&lt;size;j++)&#123;\t\tif(board[i][j]==1)num0fX++;\t\telse num0fO++;\t&#125;\tif(num0fO==size)result=0;//O方赢\telse if(num0fX==size)result=1;//X方赢&#125;\n类似的，遍历 j 检查列。\n其实这样代码是重复的，我们可以想个办法用一个两重循环遍历行与列。\n对角线就是 board[i][i] 和 board[i][2-i] 两种情况。\n9. 指针\n取地址运算：&amp;运算符取得变量的地址\nscanf 里一定要加&amp;（运算符）作用：取得变量的地址，其操作数必须是变量\nC 语言的变量是放在内存里的，&amp;是取出该变量的地址\nprintf(&quot;0x%x&quot;,&amp;i);//%x是以16进制输出；&amp;i是一个地址printf(&quot;%p&quot;,&amp;i);p=(int)&amp;i;printf(&quot;0x%x&quot;,p);\n上面几条得到的是一样的结果。（前提是 %lu, sizeof(int) 和 sizeof(&amp;i) 的值相等，在 32 位编译器中满足，而 64 位中不满足）\n%p：会把值作为地址以十六进制输出，前面加 0x\n地址的大小是否与 int 相同取决于编译器。所以输出地址时应该用 %p，而不要把地址转化为 int 类型后输出。\n&amp;不能对没有地址的东西取地址（&amp;(a+b)，&amp;(a++)，&amp;(++a)）；&amp;右边必须有一个明确的变量，才能去取这个地址。\nint a;int b;\n连续定义的 a 和 b 之间的地址差了 4。说明他们是相邻相邻地址之间差了 4（因为 int 占据了四个字节）先定义的变量地址值更高。他们都是本地变量，分配在一个叫做堆栈的地方（stack）自顶向下。\n数组 a [1] 的地址比 a [0] 大 4.\n数组的地址：printf 输出 %p 时，&amp;a，a，&amp;a[0] 输出的地址相同。\n指针 就是记录地址的变量\n如果我们能够取得一个变量的地址传给一个函数，能否在那个函数里通过这个地址访问这个变量？\nscanf 的原型就是个函数，他一定有办法可以接收到该地址。（就是这个&amp;）\n经过之前的尝试我们知道如果我们把这个地址交给一个整数，不太靠谱。所以我们需要一个新参数可以保存别的变量的地址，如何表达能够保存地址的变量？\n指针就是保存地址的变量。\n* 是一个单目运算符，用来访问指针的值所表示的地址上的变量。*可以做右值也可以做左值。\n int i;int *p=&amp;i;//（p指向了i）*p理解为指向p指针地址所存在的值=i的地址。int* p,q;int  *p,q;\n上面两种一样。这告诉我们，其实我们是定义了 *p，而不是 int * 型变量。\n所以第四种不是定义了 p，q 的地址，只定义了 p 的地址，要想都定义需要 *p, *q\n普通变量的值是实际的值。\n而指针变量的值是具有实际值的（别的）变量的地址。\n我们在函数里可以通过指针访问外面的普通变量。\n void f(int*p);int main()&#123;\tint i=6;\tprintf(&quot;&amp;i=%p\\n&quot;,&amp;i);\tf(&amp;i);\treturn 0;&#125;void f(int *p)&#123;\tprintf(&quot;p=%p\\n&quot;,p);&#125;//该函数在被调用的时候得到了某个变量的地址\nvoid f(int *p);\np 是地址，*p 是该地址中的数。\n//我们调用的时候可以这么写：int i=0;f(&amp;i);\n在函数外面可以通过这个指针访问外面的这个 i。如在 f 函数中输入 *p=26; 再输出 i 时会发现 i 变成 26 了。虽然传进来的是地址值，但可以通过这种方法在函数中访问 p 地址中的 i 的值，还可以通过地址改变 i 的值。\n左值为什么叫左值？因为出现在赋值号左边的是值，可以接收值。\n指针的运算符&amp;和*是起相反作用的，\n*&amp;yptr-&gt;*(&amp;yptr)-&gt;*(yptr的地址)-&gt;得到那个地址上的变量，即yptr\n&amp;*yptr-&gt;&amp;(*yptr)-&gt;&amp;(y)-&gt;得到y的地址，即yptr\n有的时候 int i; scanf(&quot;%d&quot;,i); 没有报错的原因：C 语言把你传入的那个值当成地址了。尽管没有报错，但运行一定会出错。\n指针的用处\n\n现在在函数里利用指针就能使交换两个变量成为可能。可以直接对该地址的变量改变值。和之前的 swap 函数（传递的是两个值）不一样。\n\n void swap(int *pa,int *pb)&#123;\tint t=*pa;\t*pa=*pb;\t*pb=t;&#125;\n函数要返回多个值的时候，某些值就只能通过指针返回。\n传入的参数实际上是 需要保存带回的结果 的变量。传入的这些参数的作用是得到结果。\n写一个求最大值最小值的函数，要返回最大值和最小值两个值。int a[10],min,max;minmax(a,sizeof(a)/sizeof(a[0]),&amp;min,&amp;max);void minmax(int a[],int len,int *min,int *max)/*sizeof(a)/sizeof(a[0])是数组元素个数。函数内部：一个len次的循环来比较每一个a[i]和*min,*max大小，然后令*min,*max不断改变主函数中min和max的值\n\n函数要返回运算的状态，结果通过指针返回。\n\n比如函数计算得不到有效结果，让函数返回不属于有效范围内的特殊值来表示出错：比如作业中在 str1 数组中找 str2 数组，如果找不到的话返回 NULL\n状态用 return 返回值；实际的值通过指针参数返回，这样可以把 return 返回值放到 if 里判断。\n给你两个数做除法，当分母等于0时返回0，分母不等于0的时候要返回1和除法的结果。int divide(int a,int b,int *result)&#123;\tint ret=1;\tif(b==0)ret=0;\telse&#123;\t\t*result=a/b;\t&#125;\treturn ret;&#125;如果返回1再输出a/b结果。\n后续语言采用了异常机制来解决这样的问题。\n指针最常见的错误：定义了指针变量，还没有让它指向任何变量，就开始使用。比如一上来就 int *p=12; 这就不行。\n一定要先让他先得到实际的变量的地址！\n指针与数组：为什么数组函数之后的 sizeof 不对了\n\nsizeof(a)（a 是个数组）返回的是 int*的 sizeof，而不是 int [] 的 sizeof\n如果我们在 minmax 函数中改变 a [0] 的值，在 main()函数中 a [0] 的值也会被改变，和指针一样。\n可以看出函数参数表中 int a [] 这其实是个指针！（在函数的注释中可以写 int a[]，也可以写 *a）\n但我们仍然可以用数组的运算符 [] 进行运算\n所以下面这四种函数原型是等价的\nint sum(int *ar,int n);int sum(int *,int);int sun(int ar[],int n);int sum(int [],int);\n数组变量是特殊的指针，因为数组变量本身表达地址，所以 int a [10]; int *p = a;//无需用&amp;取地址。但是数组的单元表达的是变量，需要用&amp;取地址。如：\na==&amp;a[0]\n[] 运算符可以对数组做，也可以对指针做\nP[0] 就相当于 *P\n pritnf(&quot;min=%d,max=%d\\n&quot;,min,max);int *p=&amp;min;printf(&quot;*p=%d\\n&quot;,*p);printf(&quot;p[0]=%d\\n&quot;,p[0]);//得到的是一样的结果。\n虽然 min 是个数，但是 p [0] 实际上就是 min.不过普通变量 min 没有 min [0].\n同样，*运算符也可以对数组做。\n*a=a[0]\n数组变量是 const 的指针，所以不能通过指针的方式被赋值。\nint b[]-&gt;int * const b;\n所以（a，b 是两个数组）不能写 b=a; 他是个常量指针，不能被赋值。\n指针与 const：指针本身和所指的变量都可能 const（本节只适用于 c99）\n如果指针是 const，表示指针一旦得到了某个变量的地址，不能再指向其他变量。\nint * const q=&amp;I;//q是const*q=26//可以改变i的值q++//errorconst int *p=&amp;I;*p=26;//error!(*p)是const，不能通过p做赋值。I=26;//可以直接改iP=&amp;j;//改变p指向的地址，可以\n辨析意思\nint I;const int*p1=&amp;I;int const*p2=&amp;I;int *const p3=&amp;I;\n加 const 只有两种意思：1. 地址不可改变；2.不能通过该地址来赋值。\n判断谁被 const 的标志是：*在 const 前面还是后面。\n转换：总可以把一个非 const 的值转化成 const 的\nvoid f(const int*x);int a=15;f(&amp;a);//可以const int b=a;f(&amp;b);//可以b=a+1;//不行！\n当我们要传递的参数类型比地址大的时候，这是常用的手段：既能用比较少的字节数传递值给参数，又能避免函数对外面的变量的修改。\nConst int a[]=&#123;1,2,3,4,5,6&#125;;\n数组变量已经是 const 的指针了，这里的 const 表示数组的每个单元都是 const int。所以必须通过初始化进行赋值。\n因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值。\n为了保护数组不被函数破坏，可以这样设置参数为 const。\nint sum(const int a[],int length);\n指针运算\n指针加一，会发生什么？\nchar a[]=&#123;0,1,2,3,4,5,6&#125;char *p=ac;printf(&quot;p的地址是%p\\n&quot;,p);printf(&quot;p+1的地址是%p\\n&quot;,p+1);\n输出\n0xbffbbd5e\n0xbffbbd5f\n当我们把 char 换成 int 时，输出\n0xbffbad2c\n0xbffbad30（加了 4）\n因为 sizeof(char)=1,sizeof(int)=4，可见对指针+1 会让指针指向下一个单元。*(p+1)也就是从 ac [0] 跳到了 ac [1]。\n注意是 *(p+1) 而不是 *p+1，因为 * 号是单目运算符，优先级高。\n由此可以猜测如果指针不是指向一片连续的空间（比如数组），那这种运算是没有意义的。\n这种运算可以+，+=，-，-=，++，–，指针做差(p1-p 得到的是两个指针之间的距离，即地址差/sizeof()，int 和 char 结果都是一样的)\n*p++：取出 p 所指的数据，之后顺便把指针移动到下一个位置。（++的优先级比 * 高）不需要括号，常常用于数组类连续空间。\np=ac;while(*p!=-1)&#123;\tprintf(&quot;%d\\n&quot;,*p++);&#125;\n（在某些 CPU 上，*p++ 被直接翻译成一条指令，使得取得 p 地址内的值之后，p 指针++。）\n&gt;,&gt;=,&lt;,&lt;=,!= 也都可以对指针做，比较指针在内存中的地址。数组中单元的地址是线性递增的。\n0 地址\n有，但是通常不随便碰，所以指针最好不要有 0 值。\n因此我们可以用 0 地址来表示特殊的事情：\n1.返回的指针是无效的\n2.指针没有真正被初始化（先初始化为 0 地址）\nNULL 是一个预定定义的符号，表示 0 地址，建议使用，因为有的编译器不接受用 0 来表示 0 地址。\n所有指针大小都是一样的，不管指向什么类型，因为他们都是地址。但指向不同类型的指针之间不能互相赋值，避免用错。\n指针的类型转换\nvoid* 表示不知道指向什么东西的指针，计算时与 char* 相同。\n指针也可以转换类型\nint *p=&amp;i;void*q=(void*)p;\n并没有改变 p 所指的变量的类型， 而是让后人用不同的眼光通过 p 看他所指的变量。（初学者可以不用做）\n指针的用处\n需要传入较大的数据时指针用作参数\n穿如数组后对数组进行操作\n函数返回不止一个结果\n需要用函数来修改不止一个变量\n动态申请的内存……\n动态内存分配\n输入数据时先读入个数 n，再输入 n 个数，并且要记录每个数据\nC99 可以用变量做数组定义的大小。C99 之前该怎么做？\n动态内存分配\nint *a=(int*)malloc(n*sizeof(int));\n另：编译时输入 man malloc 可以查看使用方法\n#include&lt;stdlib.h&gt;&#123;\tint n;\tint *a;\tscanf(&quot;%d&quot;,&amp;n);\ta=(int*)malloc(n*sizeof(int));\t//用完之后\tfree a;&#125;\n向 malloc 申请的空间的大小是以字节为单位的\n如果申请失败会返回 0，或称作 NULL\nfree()：把申请的空间还给系统，只能还该空间的首地址。一定要还。\n习惯养成：定义指针的时候就先初始为 0\nvoid *p=0; 之后再 free(p)，不管有没有使用 malloc，free()都没有问题。\n常见问题就是申请了没有 free，长时间运行内存逐渐下降。做大程序时问题显现出来。\n新手：忘了\n老手：找不到合适的 free 的时机\n问题 2：free 了又 free\n问题 3：地址变过了，直接去 free()。\n纸上得来终觉浅。\n10. 字符串\nchar word[]=&#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;!&#x27;&#125;;\n得到的字符数组应该是这样子的\n\n\n\n\n\n\n\n\n\nword [0]\nH\n\n\nword [1]\ne\n\n\nword [2]\nl\n\n\nword [3]\nl\n\n\nword [4]\no\n\n\nword [5]\n!\n\n\n不过这只是字符数组而不是字符串。因为他不能用字符串的方式做运算。\n\n\n\n定义一个 C 语言的字符串，结尾要加上 word [6] =‘\\0’。\n\n\n\n对 C 语言来说，字符串就是以 0（整数 0）结尾的一串字符数组。\n\n\n\n0 和’\\0’是一样的，但是和’0’不同。0 标志着字符串的结束，但他自己不是字符串的一部分，计算字符串长度的时候不包含这个 0。\n\n\n\n字符串以数组的形式存在，以数组或指针的形式访问（更多以指针的形式）\n\n\n\nPS: string.h 里有很多处理字符串的函数。\n\n\n\n\nchar *str=&quot;Hello&quot;;//一个指针指向了一个字符数组char word[]=&quot;Hello&quot;;//字符数组，结尾0char line[10]=&quot;Hello&quot;;//字符数组，结尾0\n字符串常量\n“Hello” 双引号括起来的叫做字符串的字面量/常量，我们在 scanf 和 printf 里已经见过很多次了。“Hello” 会被编译器变成一个（长度为 6 的）字符数组放在某处，结尾自动添上个 0。\n两个相邻的字符串常量会被自动连接起来。\n比如 printf 里出现连续两个 &quot; &quot; &quot; &quot;，会接起来输出。\nprintf(&quot;123456789&quot;&quot;10111213&quot;);\n另一种连接方法：\nprintf(&quot;123456789\\10111213&quot;);\n会输出 12345678910111213，回车可以用反斜杠的方式搞定。不过这种方法连换行开头的 Tab 也会输出，要小心使用。\n人的眼睛横向是有极限的 hh。所以程序员喜欢把显示器转过来\nC 语言的字符串是以字符数组的形态存在的，因为是个数组，所以不能用运算符对字符串做运算。但可以通过数组的方式遍历字符串。（后面会有很多应用）\n字符串唯一特殊的地方是字符串字面量可以用来初始化字符数组。\n字符串变量\nchar *s=&quot;Hello&quot;;s[0]=&#x27;B&#x27;;//尝试把H替换为B，然后输出s[0]\n编译无问题，但是运行时没法输出 s [0]，出错了。\n再做另一个尝试\nint i=0;char *s=&quot;Hello&quot;;char*s1=&quot;Hello&quot;;//两个一样的字符串变量printf(&quot;i的地址是%p\\n&quot;,&amp;i);printf(&quot;s的地址是%p\\n&quot;,s);printf(&quot;s1的地址是%p\\n&quot;,s1);\n比较得到的地址结果我们可以得出的结论：\n1.i 的地址相对很大，s 和 s1 的地址相对很小。\n2.s 和 s1 的指向了同一个地址。\n其实 s 和 s1 指向的地址是程序的代码端，他是 只读的。\n因此，实际上 s 是 const char*s; 由于历史的原因，编译器接受不带 const 的写法（所以编译通过了）。但试图对 s 所指的字符串做写入会导致严重的后果。\n如果需要修改字符串，应该用数组：\nchar s[]=&quot;Hello!&quot;;\n尝试输出 s 的地址会发现，s 的地址和上例中的 i 的地址一样较大（也就是说在本地变量那里），而且 s 可以修改。\n需要使用字符串的时候，我们要把它写成指针的形式还是数组的形式呢？\n数组：\n\n字符串有确定的地址；\n作为本地变量，空间会自动被回收。\n\n指针：这个字符串不知道在哪；所以通常用来\n\n只读的，不可写的字符串\n处理函数的参数（前面知道如果数组作为指针，函数的参数实际上和指针是一样的）；\n动态分配空间 malloc。\n\n因此，如果要构造一个字符串：数组\n如果要处理一个字符串：指针。\n因此，字符串可以表示为 char* 的形式，而 char* 不一定是字符串。\n他可能是指向字符的指针，可能指向的是字符的数组。只有当 char* 所指的字符数组有结尾的 0，才能说他所指的是字符串。\n字符串输入输出\n所以字符串的地位如此。尽管相较之前的语言，C 语言有很多处理字符串的方法，但比起现在的新语言，C 语言对字符串的处理还是不足。\nchar *t=&quot;title&quot;;char *s;s=t;\n只是让指针 s 指向指针 t 所指的字符串，并没有产生新的字符串。\n至于如何真的复制一个字符串给 s，等到以后字符串函数会学到的。\n字符串的输入输出：%s\nchar string[8];scanf(&quot;%s&quot;,string);printf(&quot;%s&quot;,string);\n输入不再是简单的整数、一个字符，这时候，我们就要考虑下 scanf 的停止条件了。\nscanf() 只能读入一个单词，因为碰到空格、tab 键或回车就会终止。空格、回车是分隔符，是用来分隔两个单词的。\n如果用这种方法读入两个单词可以连续两次 scanf：\nscanf(&quot;%s&quot;,str1);scanf(&quot;%s&quot;,str2);printf(&quot;%s%s&quot;,str1,str2);\n空格不会被读入，输出是没有中间的分隔符（空格）的。\nscanf() 是不安全的，因为不知道读入的长度。\nchar str1[8],str2[8];scanf(&quot;%s&quot;,str1);scanf(&quot;%s&quot;,str2);\n输入 12345678 12345678，结果第一个字符串为空，第二个字符串却是 12345678 读了八个字符。（运气好没有崩溃）\n为什么？涉及到在内存中是怎么排列的。\n安全的方法：scanf(&quot;%7s%7s&quot;,str,str1); 意思是：最多只能读七个字符。多出的部分会分配给下一个字符串。\n这样输入 12345678,8 就会分配给下一个字符串。\n加入的这个数字，最多应该比定义字符串的个数小 1（ 比如上例最多为 7）\nC 语言中常见的错误：误以为 char* 就是定义了字符串类型。其实是一个需要初始化的指针。不初始化可能会出错。（可能会出现：程序在一个地方没问题，到了其他地方就出错了）\nchar zero[100]=&quot;&quot;;\n空的字符串，zero [0] =‘\\0’，不过仍然是有效的字符串。\n但是如果写成：char zero[]=&quot;&quot;; 长度就是 1 了。\n字符串数组，以及程序参数\n如果我们想写一个数组来表示很多个字符串？\nchar **a：a 是个指针，指向另一个指针，另一个指针指向一个字符串\nchar a[][]：a 是个二维数组的变量，第二维（后面的括号）一定要有确定的大小，否则编译不能通过。\nchar a[][10]=&#123;\t&quot;hello&quot;,\t&quot;world&quot;&#125;;//每个字符串长度不要超过n，即10\n还有一种写法：char *a[]，a [0] 相当于 char*，像矩阵的排列方法想的话，a [i] 就是指向每一行的字符串的指针。\n这和二维数组不一样，二维数组 a [0] 就是第一行的字符串。\n填坑：以前做的一道题：输入数字月份，输出对应的月份英文单词。现在可以用数组做。\n现在回归到 int main()主函数，之前说过括号里面什么都不用写，要写也就写个 void\n其实里面是是 int main(int argc,char const*argv[])\nargc 告诉我们，后面的数组有多少个字符串。\n然后我们试着输出后面字符串的内容\nfor(i=0;i&lt;argc;i++)&#123;\tprintf(&quot;%d:%s\\n&quot;,i,argv[i]);&#125;\n然后 ./a.out 运行，只输出了 0:./a.out\n第二次输入 ./a.out 123，输出了\n0:./a.out  1:123\n然后随便输入，./a.out 123 asd asd asd asd 这些字符串都会被一个个记录下来。\n它从第 2 个字符串开始记录所有你输入的字符串，而第一个参数，即 argv [0]，则是输入的这个文件的名字（./a.out）即可执行程序的名字。\n如果将 a.out 称之为 my，ln -s a.out my ，然后我们看 my，ls -l my 发现 my 是个指向 a.out 的链接。如果执行 my ./my 123 输出的字符串 argv [0] 也是 ./my 而不是 ./a.out 了。\n关于到底是怎样运行程序的，建议搜索 busybox，看看别的 box 是怎么做的。（蒙……）等做快捷方式的时候会更理解。\n字符、字符串操作\n单字符输入输出\nputchar(int c)函数：向标准输出写一个字符，但是输入是 int 类型，返回类型也是 int 表示写了几个字符，一般为 1，EOF(即：值-1)表示失败。(end of fail)\ngetchar()：从标准输入读入一个字符，返回类型也是 int(因为要返回 EOF 表示输入结束了）\n写一个程序进一步理解。\nint ch;while((ch=getchar())!=EOF)&#123;\tputchar(ch);&#125;printf(&quot;EOF\\n&quot;);//这样来看读入什么会EOFreturn 0;\n不管怎么输入数字串、字符串都不停止，直到输入 Ctrl-C，程序直接结束但没有看到 EOF，这表示我们将程序强制结束了而不是正确的输入 EOF。\n第二次尝试输入 Ctrl-D，得到输出 EOF（Windows 要输入 Ctrl-Z)。而且另一件奇怪的事情是，即便输入 12435435 数字串，敲下回车之前都不会有回应，敲下回车后才原封不动地输出这一串。为什么？getchar()不是一个个读的吗？\n原因：之前提到过中介 shell，shell 先处理输入的东西再给程序，输出的东西也先经过处理再呈现给我们。（当时在讲\\b 会变成什么样子）\n用户（键盘等输入）→shell→ 程序\n用户 ←shell← 程序\nshell 对输入的东西做了行编辑，也就是敲下回车前输入的部分都在 shell 里处理，放在缓冲区里，按下回车后才送到程序那里。如：输入 123，shell 缓冲区里为“1，2，3，回车”。然后 getchar()再读缓冲区。\n如果按下 Ctrl-D，shell 会生成一个 EOF 的标志。而按下 Ctrl-C，shell 直接关闭了程序。\n所以用户的输入是让 shell 填写缓冲区，而 scanf()和 getchar()都是在缓冲区内读。\n字符串函数 strlen\nstring.h 头文件中处理字符串的函数比如：strlen、strcmp、strcpy、strcat、strchr、strstr 等\nstrlen(const char*s)：返回 s 的字符串长度（不包括结尾 0）由参数表中的 const 可知该函数不会修改传入的数组。\nchar line[]=&quot;Hello&quot;;printf(&quot;%lu\\n%lu&quot;,strlen(line),sizeof(line));\n输出结果：strlen = 5, sizeof = 6（结尾的 0）\n我们能不能写出一个 strlen 函数呢？\nsizeof 不行，因为我们得到的是指针所占据的大小。\n我们需要遍历数组：H,e,l,l,o,\\0\n因为不知道数组有多大，用 while 循环。\nint cnt=0;while(s[cnt]!=&#x27;\\0&#x27;)&#123;\tcnt++;&#125;return cnt;\n字符串数组 strcmp\nint strcmp(const char*s1,const char*s2)：比较两个字符串。\n\n\n\n返回值\n意义\n\n\n\n\n0\n相等\n\n\n1\ns1 大\n\n\n-1\ns2 大\n\n\n大小是怎么定义的？\n\n\n\n我们做一个尝试：\n\n\n\nprintf(&quot;%d\\n&quot;,s1==s2); 来判断 s1 和 s2 是否相等。\n\n\n\n然而即便 s1 和 s2 内容相同还是输出了 0.因为实际上 s1==s2 比较的是 s1 和 s2 的地址，所以数组之间的这种比较永远是 0。\n\n\n\n\ns1[]=&quot;abc&quot;;s2[]=&quot;bbc&quot;;\n再用 strcmp 比较两者输出了-1.这很合理，因为 ASCII 码 b &gt; a.\ns1[]=&quot;abc&quot;;s2[]=&quot;Abc&quot;;\n输出 32？32 是 'a'-'A' 的结果。所以这回给出的结果是不相等的字符的差值。\ns1[]=&quot;abc&quot;;s2[]=&quot;abc &quot;;//多了个空格\n输出-32，是空格位 \\0-' ' 造成的。\n接下来我们自己尝试写 strcmp。我们需要下标 idx，s1 [idx] 与 s2 [idx] 比较，当 s1 [idx] 和 s2 [idx] 都 =='\\0’时停止（假设长度相等）。\nwhile(s1[idx]!=&#x27;\\0&#x27;&amp;&amp;s1[idx]==s2[idx])//当出现不相等的字符或者字符串到了末尾时，返回差值\tidx++;return s1[idx]-s2[idx];\n改进：idx 可不可以不用？\n用指针：\n*s1==*s2s1++;s2++;return *s1-*s2;\n这是处理字符串的两种手段，数组和指针。看个人喜好。\n字符串函数 strcpy\nchar*strcpy(char* restrict dst,char* restrict src);\n把 src 拷贝到 dst 的空间里，包括结尾的\\0.\nrestrict 表示 src 和 dst 不能重叠。比如 src 是\nH E L L O \\0\n，dst 的内容是:\n空 空 空 H E L L O \\0\n也就是说想把 HELLO 挪到第一位开始，这是不行的。因为 strcpy 对于多核计算机，为了提高效率，拷贝可能是交给不同的核不同的段，分别拷贝。\n函数参数中的第一个参数是目的，而第二个参数是源。而且这个函数是有返回值的，返回 dst\nchar *dst=(char*)malloc(strlen(src)+1);//不包含结尾的\\0，所以+1strcpy (dst,src);\n+1 是重点。\n接下来尝试自己写 strcpy()函数。\nchar *mycpy(char*dst,const char*src)&#123;\tint idx=0;\twhile(src[idx]!=&#x27;\\0&#x27;)\t&#123;\t\tdst[idx]=src[idx];\t\tidx++;\t&#125;\tdst[idx+1]=&#x27;\\0&#x27;;\treturn dst;\n指针的做法是：\nchar *ret=dst;while(*src!=&#x27;\\0&#x27;)&#123;\t*dst=*src;\t*dst++;\t*src++;&#125;*dst=&#x27;\\0&#x27;;return ret;\n当然 do-while 也行.\n也可以这样优化：\nwhile(*src)*dst++ = *src++;\n更艹的是，*dst++ = *src++; 的结果就是*src，所以我们可以直接写\nwhile(*dst++ = *src++);\n字符串函数 strcat\nchar*strcat(char* restrict s1,const char* restrict s2);\n把 s2 拷贝到 s1 后面，接成一个长字符串；返回 s1.（s1 结尾的\\0 被 s2 开头替换掉）\n如：s1: H E L L O \\0\ns2: W O R L D\\0\n结果：s1: H E L L O W O R L D \\0\ns1 必须要有足够的空间。\ncpy 和 cat 有可能没有足够的空间，因此这两个函数是不够安全的，不建议使用。\n安全版本：strncpy 和 strncat\nchar*strncpy(char* restrict s1,const char* restrict s2,size_t n);char*strncat(char* restrict s1,const char* restrict s2,size_t n);char*strncat(const char* s1,const char* s2,size_t n);\n会拷贝能拷贝的最多的字符，多的部分掐掉。而 strncmp 则是只判断前几个字符。\n字符串搜索函数\nchar* strchr(const char* s,int c);\nchar* strrchr(const char* s,int c);//从右边开始找\n返回的是指针，返回 NULL 表示没找到。\n那如果像 HELLO 出现两个 L，怎样寻找第二个呢?\nchar *s=&quot;hello&quot;;char *p=strchr(s,&#x27;l&#x27;);printf(&quot;%s&quot;,p);\n输出 llo。\n想找第二个的方法是：\np=strchr(p+1,&#x27;l&#x27;);\n如果想把 l 后面的东西 cpy 到另一个字符串中去：\nchar *t=(char*)malloc(strlen(p)+1);strcpy(t,p);free(t);\n如果我们想要 l 前面的部分？\nchar c=*p;*p=&#x27;\\0&#x27;;//把l的位置改成&#x27;\\0&#x27;char *t=(char*)malloc(strlen(s)+1);strcpy(t,s);//只拷贝了第一个l前面的部分。\nt 就是想要的结果，即 he\n在字符串中找字符串：char* strchr(const char* s1,const char*s2);\n不分大小写寻找：char* strcasestr(const char* s1,const char*s2);\n11. 枚举\n常量符号化：用符号而不是具体的数字来表示程序中的数字。\n让用户输入颜色的代号，我们输出对应的颜色：可以用 const int 和 switch 来解决。\nconst int red=0;const int yellow=1;const int green=2;int main()&#123;\tint color=-1;\tchar *colorname=NULL;\tprintf(&quot;请输入你喜欢的颜色的代码&quot;);\tscanf(&quot;%d&quot;,&amp;color);\tswitch(color)&#123;\tcase red:colorname=&quot;red&quot;;break;\tcase yellow:colorname=&quot;yellow&quot;;break;\tcase green:colorname=&quot;green&quot;;break;\tdefault:colorname=&quot;unknown&quot;;break;\t&#125;\tprintf(&quot;%s&quot;,colorname);\treturn 0;\n再把这件事再往前推进一点，我们使用枚举而不是单独定义 const int 变量。\nenum COLOR&#123;RED,YELLOW,GREEN&#125;;int main()&#123;\tint color=-1;\tchar *colorname=NULL;\tprintf(&quot;输入你喜欢的颜色代码：&quot;);\tscanf(&quot;%d&quot;,&amp;color);\tswitch(color)&#123;\tcase RED:colorname=&quot;red&quot;;break;//在case处就可以直接使用RED YELLOW和GREEN来取代0,1,2\tcase YELLOW:colorname=&quot;yellow&quot;;break;\tcase GREEN:colorname=&quot;green&quot;;break;\tdefault:colorname=&quot;unknown&quot;;break;\t&#125;\tprintf(&quot;你喜欢的颜色是%s\\n&quot;,colorname);\treturn 0;&#125;\n枚举是一种用户定义的数据类型，使用以下格式定义：\nenum 枚举类型名&#123;名字0,名字1……名字n&#125;; enum 是 enumeration。\n枚举类型名通常不用，我们用的是大括号中的名字，因为他们就是常量符号，类型一定是 int，值从 0 到 n。比如上例中，RED = 0, YELLOW = 1, GREEN = 2。\n当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字。\n在函数中使用时要记得说上前缀 enum\nenum color &#123;red,yellow,green&#125;;void f(enum color c);int main()&#123;\tenum color t= red;\tscanf(&quot;%d&quot;,&amp;t);\tf(t);\treturn 0;&#125;void f(enum color c)&#123;\tprintf(&quot;%d\\n&quot;,c);&#125;\n这样可以像 int 一样输入输出。\n因为定义中的名字是从 0 到 n 按顺序排列的，这样要遍历时或者要建立数组时就会很方便。\nenum COLOR&#123;RED,YELLOW,GREEN,numcolors&#125;;//结尾的numcolors表示数组的结尾，同时也可以表示enum中元素的个数。int main()&#123;\tint color=-1; \tchar *ColorNames[numcolors]=&#123;\t\t&quot;red&quot;,&quot;yellow&quot;,&quot;green&quot;,\t&#125;;\tchar *colorname=NULL;\tprintf(&quot;请输入你喜欢的颜色的代码&quot;);\tscanf(&quot;%d&quot;,&amp;color);\tif(color&gt;=0&amp;&amp;color&lt;numcolors) colorname=ColorNames[color];\telse colorname=&quot;unknown&quot;;\tprintf(&quot;你喜欢的颜色是%s&quot;,colorname);\treturn 0;&#125;\n另外，声明枚举量的时候可以指定特殊值，不一定非要按顺序从 0 开始。\nenum color&#123;red=1,yellow,green=5&#125;; 如果输出%d, green 就会输出 5。\n但是枚举只是 int，即使给它赋不存在的值（比如上例中，我们 enum color c=0; 也没有关系）也不会有 warning 或 error。\n枚举虽然可以当做类型来使用，但是并不好用。现在通常定义一些排比的符号量，这样比 const int 一个个来方便。\n枚举比后面会讲到的宏（marco）好，因为枚举有类型 int。\n结构类型\n我们已经知道，在 c 中我们要表达的数据，要有变量，还要有类型。\n如果要表达的数据比较复杂（比如日期，包括年、月、日；或时间，包括时、分、秒），而我们又希望用一个整体去表达，就要用到 C 语言的结构。\n结构是一个复合的数据类型，在里面有很多各种类型的“成员”，然后可以用一个变量来表达多个数据。\nint main()&#123;\tstruct date&#123;\t\tint day;\t\tint month;\t\tint year;\t&#125;;//声明时，结尾有个分号！！\tstruct date today;//像枚举一样不要忘记开头，struct\ttoday.day=12;\ttoday.month=3;\ttoday.year=2021;\tprintf(&quot;Today&#x27;s date is %i-%i-%i.&quot;,today.year,today.month,today.day);\treturn 0;&#125;\n当然，和之前本地、全局变量一样，如果结构是在一个函数内部声明的，则该结构只能在该函数内部使用。在函数外声明就可以在多个函数内使用了。\n另一种声明方式：\nstruct&#123;\tint x;\tint y;&#125;p1,p2;\np1 和 p2 都是一种无名结构，都包含 x 和 y。没有声明结构名字，临时造了两个无名结构出来。\n不过，最常见的还是要声明结构名字的形式。\nstruct point&#123;\tint x;\tint y;&#125;p1,p2;\np1, p2 都是 point，都包含 x 和 y。\n\n\n\nmonth\nday\nyear\n\n\n\n\n11\n23\n2007\n\n\ntoday 的内存中包含 month, day, year.\n\n\n\n\n还有一件要注意的事就是 声明结构类型 和 定义结构变量 要区分。声明类型后 方可定义变量。\n\n\n\n\n结构初始化：\n\n\n\n\n\nstruct date=&#123;12,3,2021&#125;;//注意顺序struct thismonth=&#123;.month=3,.year=2021&#125;;//剩下没有被赋值的部分都是0，和数组一样\n和数组相比，结构中的成员可以是不同类型的。\n数组用 [] 运算符和下标来访问；而结构用 . 运算符和名字来访问。\n结构的运算\n可以用 结构名字.成员名字 来访问某个成员，也可以直接用结构名字来访问整个结构变量。可以做赋值、取地址，传递给函数参数。\np1=(struct point)&#123;5,10&#125;;p1=p2;\n这两种操作，数组变量都做不了。\nstruct date today,day;today=(struct date)&#123;12,3,2021&#125;;day=today;\n和数组不同，结构变量的名字并不是结构变量的地址，取地址要加上&amp;\nstruct date *pdate=&amp;today;\n结构与函数\n结构像 int 等类型一样，可以作为函数的参数。\nint numberofdays(struct date d)\n整个结构可以作为参数的值传入函数。这时候会在函数内部新建一个结构变量，并复制该参数的值。当然，函数也可以返回一个结构。\n（貌似美国的写法是月/日/年）\n&amp;date.month 中，取成员运算符 . 的优先级高于取地址运算符 &amp;\n怎样输入结构？我们不能用 scanf 直接读入一个结构。\n先尝试写一个读入结构的函数：先在 main 函数里定义，然后把该参数传入 getstruct 函数\nstruct point p=&#123;0,0&#125;;gtestruct(p);void getstruct(struct point p)&#123;\tscanf(&quot;%d&quot;,&amp;p.x);\tscanf(&quot;%d&quot;,&amp;p.y);&#125;\n然而这不像指针，这样读入的结构是不会传入原函数中的。（只是一个克隆体而不是直接对结构本身做操作）\n记住函数是有返回值的，我们要做的是在输入函数中创建一个临时的结构变量，返回给调用者。\nstruct point getstruct(void)&#123;struct point p;\tscanf(&quot;%d&quot;,&amp;p.x);\tscanf(&quot;%d&quot;,&amp;p.y);\treturn p;&#125;//main函数中：y=getstruct();\n然而，在函数中建立一个拷贝来回传递，既费空间又费时间。还是结构指针的方法会好很多。\nstruct date myday;struct date *p=&amp;myday;(*p).month=12;//正常应该这样写p-&gt;month=12;//也可以简写成这样\n-&gt; 表示指向结构变量中的成员\n#include&lt;stdio.h&gt; struct point&#123;\tint x;\tint y;&#125;p;struct point *getstruct(struct point *p);void print(const struct point *p);int main()&#123;\tstruct point p=&#123;0,0&#125;;\tprint(getstruct(&amp;p));\treturn 0; &#125;struct point *getstruct(struct point *p)&#123;\tscanf(&quot;%d&quot;,&amp;p-&gt;x);\tscanf(&quot;%d&quot;,&amp;p-&gt;y);\treturn p;&#125;//像这样传入一个参数，对其做处理后再返回该参数的函数，可以直接套用在其他函数中。void print(const struct point *p)//const&#123;\tprintf(&quot;%d %d&quot;,p-&gt;x,p-&gt;y);&#125;\n结构中的结构\n结构中的数组\nstruct date dates[100];struct date dates[]=&#123;\t&#123;3,21,2021&#125;,&#123;3,22,2021&#125;&#125;;printf(&quot;%.2i&quot;,dates[1].month);//不知道%.2i什么意思\n结构里的变量也可以是另外一个结构\nstruct point&#123;\tint x;\tint y;&#125;struct rectangle&#123;\tstruct point pt1;\tstruct point pt2;&#125;//如果有这样的定义：struct rectangle r;/*则可以有：r.pt1.x;r.pt1.y;r.pt2.x;r.pt2.y;*///如果有这样的定义：struct rectangle *rp;rp=&amp;r;//那么下面的四种形式是等价的r.pt1.xrp-&gt;pt1.x(r.pt1).x(r-&gt;pt1).x//但是不能写r-&gt;pt1-&gt;x,因为pt1不是指针而是结构。\n\n如上图所示，rp 指向 r。\n甚至可以做结构里的结构里的数组。\n\n\n（这里也能看出这么写会好看很多~)\n类型定义\n比如我们之前讲 struct 的时候要一直加上 struct 前缀。如何摆脱呢？\n自定义数据类型(typedef)\ntypedef int length;\n这样使得 length 成为 int 类型的别名。可以直接把 length 当做 int 类型来用\nlength a,b;\nlength a[10];\n声明的新类型是某种类型的别名，改变了程序的可读性，简化了复杂的名字。\ntypedef struct ADate&#123;int month;int day;int year;&#125;Date;Date a=&#123;3,24,2021&#125;;\ntypedef *char[10] String;//string是十个字符串的数组的类型。\n联合\nunion，表面上与 struct 非常相似。\nunit xxx&#123;int a;char b;&#125;xxx1,xxx2;xxx1.a=1;xxx2.b=&#x27;c&#x27;;\n和 struct 不同的是，union 中所有变量（即 a, b）占据的是相同的空间，大家联合起来使用同一个空间。\n比如一个 int 4 个字节，也可以被看做是 char 的数组 0~3\n比如 char 是 1234，则转化为十六进制应该是 00 00 04 D2\n我们通过下面的方法来看看是不是这么储存的。\n\n占位符的意思是：1.输出两位，即如果不足 10 要补个 0（比如 2→02）\n2.这就是一个字节了，不要再扩展了\n3.以十六进制输出\n这个在文件那里还会再讲。\n我们现在的 X86 是小端机器，放数的时候其实是小端在前\n也是很有用的，比如做文件时，比如当我们要把一个整数以二进制形式输到一个文件中去时，可以作为中间的媒介（没懂……)。\n12. 全局变量\n全局变量：定义在函数之外的变量，全局的生存期和作用域\n定义在函数内部的是本地变量。而定义在外面的是全局变量。\n本地变量最大特点是生存期、作用域都在函数内部，出来就用不了了。\nint gAll=12;int main()&#123;\tprintf(&quot;in %s, gAll is %d&quot;,__func__,gAll);//__func__是输出当前函数名称\treturn 0;&#125;\n如果在主函数中先输出 gAll，然后执行函数 f，在函数 f 中把 gAll+2, 然后返回主函数，再次输出 gAll，会发现输出结果是 12 14。可见我们可以在任何函数中直接访问、改变全局变量。\n如果全局变量没赋初值，会自动被赋予 0 值，不像本地变量会出现奇怪的值。\n如果是指针的话，没赋初值会得到 NULL，因为只能用编译时已知的值来初始全局变量。而初始化发生在 main 函数前。\n如果 int gAll = f(); 不可以，因为这时候电脑表示他还不知道 f()是什么\n如果 int gAll=12; int g2=gAll; 也不行（Dev C++可以）\n但是如果 const int gAll=12; int g2=gAll; 就可以了。但是不建议这样做。\n如果函数内部有和全局变量同名的变量，那么全局变量会被隐藏。\n比如在主函数中输出 gAll，然后进入函数 f，int gAll = 1，输出 gAll，再回到主函数再次输出 gAll，会得到 12 1 12（因为 f 函数里的 gAll 生存期就是 f）\n静态本地变量：能在函数结束后继续保持原值的本地变量\n在本地变量前加上 static 修饰符，成为静态本地变量。离开函数之后，静态本地变量还会存在。\n静态本地变量的初始化只会在第一次进入这个函数时做，以后再进入函数时还是会保持上次离开的值。就是即便输入：\nf()&#123;\tstatic int a=1;\ta+=2;&#125;\nf()连续执行三次，不是每次都会 a = 1，而是 1 3 3 5 5 7。\n静态本地变量实际是特殊的全局变量。他们位于相同的内存区域；（可以试着看下全局变量、本地变量、静态本地变量的地址%p，静态本地变量和全局变量地址都是一样的）\n静态本地变量有全局内的生存期，但是只有函数内的局部作用域（static 在这里的意思是局部作用域，本地可访问。）\n后记：返回指针的函数，使用全局变量的贴士\n关于指针以前讲过，如果指针返回本地变量的地址，这是一件很危险的事情。因为离开函数之后本地变量就不存在了。\nint *f();void g();int main()&#123;\tint *p=f();\tprintf(&quot;*p=%d&quot;,*p);\tg();\tprintf(&quot;*p=%d&quot;,*p);\treturn 0;&#125;int *f()&#123;\tint i=12;\treturn &amp;i;&#125;void g()&#123;\tint k=24;\tprintf(&quot;k=%d&quot;,k);\treturn 0;&#125;\n输出 p = 12, k = 24, p = 24.\n可以得知，在函数 f 中本地变量 i 那个地址又给了 k 使用。这就容易出问题。\n但是全局变量和静态本地变量可以。\n返回函数在 malloc 内的地址是安全的，但是也容易出问题。最好的办法是返回传入的指针。\ntips\n1.不要用全局变量在函数之间传递参数和结果（可以，但是有问题。详见丰田汽车案？？）。使用全局变量和静态本地变量的函数是线程不安全的，尽量避免全局变量。\n宏定义\n编译预处理指令\n我们在第一节课就见过了。就是#开头的（#include）。他们不是 C 语言的一部分，但是 C 语言离不开他们。\n现在要定义 PI = 3.14159，我们可以定义一个 const 的全局变量；但以前没有 const 的时候，用#define 来定义一个宏\n#define PI 3.14159\n这样 C 语言在编译预处理时会把所有 PI 变成 3.14159。\n我们可以通过下面的方法看在编译过程中留下来的零始文件\ngcc：\ngcc xxx.c --save-tempsls-l\n可以看到会出现 xxx. c,  xxx. i, xxx. s, xxx. o, xxx. out\n文件 c-&gt; i 这一步做了 π 的替换，i-&gt; s 这一步产生汇编代码文件，s-&gt; o 产生目标代码文件 ，最后再和其他可链接的东西链接起来生成可执行的 out。\n可以发现.i 比.c 大很多\n如果用 tail 来输出 c 和 i 的结尾部分\ntail xxx.c;tail xxx.i;\n可以看到.i 中把已经所有的 PI 替换为 3.14159。\n同样的，我们也可以 #define FORMAT &quot;%f\\n&quot; FORMAT 是按格式输出。\n在 main 函数中写：printf(FORMAT,2*PI); 编译出来也是没有问题的。不过注意如果 FORMAT 是写在双引号里面，printf 输出的就是 FORMAT 这六个字母了。\n#define 会先对程序进行预处理，把宏都替换掉；\n#define 单词 值\n#define 会对后面的值原封不动地进行文本替换，所以千万小心结尾不要加分号。因为这不是 c 的语句，c 的语句结尾才需要加分号。\n如果一个宏中嵌套有其他宏的名字，还会再次被替换；\n如果一个宏的值超过一行，最后一行之前的行末需要加\\，应该是处理回车的问题。\n宏的结尾可以有注释。\n#define prt printf(&quot;123&quot;);\\\t\t\tprintf(&quot;456&quot;);\n我们还可以定义没有值的宏 #define -DEBUG 用来做条件编译，例如如果存在编译这一部分代码；如果不存在编译其他部分代码。\nc 编译器里有一些预先定义的宏，可以直接用的\n__LINE__//行号__FILE__//文件名__DATE__//编译时日期__TIME__//编译时时间__STDC__\n带参数的宏\n还可以定义像函数一样的宏，带参数。\n#define cube (x)((x)*(x)*(x))\n第一个括号内是单词名字，后面是它的值。\nprintf(&quot;%d\\n&quot;,cube(5));//输入tail 文件名，输出((5)*(5)*(5))\n也可以括号内做运算，如输出 cube(i+2)。\n一些细节\nx 要加括号。否则比如：（rad to deg 弧度制转化为角度制）\nRADTODEG(x) (x*57.29578);RADTODEG(x) (x)*57.29578;RADTODEG(x) ((x)*57.29578);\n如果 x = 5+2，第一个计算的就是 5+257.29578；\n如果计算 180/RADTODEG(1)，第二个计算的就是 180/157.29578。这样就能看出来如果宏带有参数，整个宏的值和每个参数都要有括号。\n可以带有多个函数\n#define MIN(a,b) ((a)&gt;(b)? (b):(a))\n也可以嵌套、组合使用其他宏。\n千万不要加分号，这不是 c 的语句，比如 if 和 else 中间多了个加分号的宏，展开时就会有两个分号；第二个分号相当于有个空行，就把 if 和 else 分开了。\n大型的参数中，带参数的宏非常常见，运行效率比函数高。（牺牲空间换取效率）\n宏有一个缺点：没有类型检查。\nC 语言有 inline 机制，有类型检查，也许会逐渐取代宏。\n还有很多编译预处理指令，比如条件编译、error 等等，这些补充内容本课中不会讲到了。\n13. 文件和位运算\n多个源代码文件\nmain 中的代码太长，可以分出几个函数；而一个源代码文件(.c)太长可以分出很多.c 文件。\n如果我们直接把函数拿到另一个源代码文件里，编译很明显不会通过。我们需要新建一个项目。\n新建-项目，选择 console application 终端应用，把它保存到和两个目标源代码文件同一个文件夹里。\n新建之后会自带一个.c 文件，这个是假的，删掉即可。然后项目-添加，添加两个目标源代码文件，这样就可以编译并运行了。\n对于一个项目，Dev C++会把里面所有的文件编译并链接起来。\n其实 Dev C++是个比较特殊的(IDE)集成开发环境，绝大多数其他的 IDE 都需要你先建一个项目（哪怕只有一个源代码文件），然后才能进行其他操作。\n比如有的 IDE 是有编译和构建两个按钮，前者对单个源代码文件进行编译，后者对所有源代码文件链接。因为一个源代码文件是一个编译单元，编译器每次只对一个编译单元进行编译（形成.o 目标代码文件）。\n头文件\n在刚才的多个源代码文件中，我们在 main 文件里有加入一条声明：\nint max(int a,int b); 如果不加这条声明，其实 C 语言也会默认 a 和 b 是 Int 类型的。\n可是如果 a, b 都是 double，我们又不加声明呢？输出了一个奇怪的大数字。\nmain 中默认 a, b 是 int→ 传入 double 的 max→ 以 int 形式传回来，链接的确没有问题，但传入传出都是错的。\n如何让他们一致？我们需要头文件。\n1.再新建一个源代码文件，会提示要不要在项目中添加，点 yes；\n2.命名为.h 的文件（如 max.h）输入一句话，就是那句函数的原型\nint max(int a,int b);\n3.在所有调用这个函数的源代码文件：main.c 和 max.c 文件中都加入该头文件\n#include&quot;max.h&quot;\n这下如果两边的 max 函数类型不一样，编译就会提示有问题了。\n#include 是一个编译预处理指令，会把该头文件下的所有内容原封不动地插入他所在的地方；因此也不是必须在最开头。\n注意到#include 后面的括号有两种：\n“”：先去找系统内指定目录有没有这个头文件，没有再去当前目录找。\n&lt;&gt;：只在系统内找这个头文件。\n\n这样查看 stdio.h 里都有什么\n关于#include 的误区：#include 不是用来引入库的。而是 原封不动地把库里的东西插入到这一行来\nstdio.h 里只有 printf 的原型，其代码在另外的地方。比如 windows 在.lib 里，unix 在.a 里。而 stdlib.h 里有 malloc 的原型\n而现在的 C 语言编译器会默认引入所有标准库\n#include &lt;stdio.h&gt; 只是为了让编译器知道 printf 函数的原型，保证调用时给出的参数值是正确的类型。\n应该在使用、定义该函数的地方都包含该头文件，把所有对外公开的函数的原型和全局变量的声明都放进去。\n全局变量也可以在多个源代码文件中共享；不过也像函数一样要有恰当的方法。\n如果在函数前加 static：只能在该源代码文件中使用\n如果在全局变量前加 static：只能在该编译单元中使用。\n声明\n上节课的问题：怎样让全局变量在多个.c 文件中共享？\n在.h 中输入\nextern int gAll;\nint x; 是变量的定义；extern int x; 是变量的声明。\n声明不产生代码（单纯地记住这句声明：这个项目中不管在哪里，有一个全局变量 gAll）；而定义产生代码。\n只有声明才可以被放在头文件中。否则一个项目中多个编译单元里会有重名的实体。\n重复声明：同一个头文件中，同名的结构不能被重复声明。如果头文件里有结构的声明，很难这个文件不会在一个编译单元里被#include 多次。（比如我们在 max.h 里定义过该 struct，然后在 min.h 里要用到这个结构就会#include “max.h”；这样在主函数中就要#include “max.h”  #include “min.h”，就会重复声明，再次出现在.i 中。尽管再怎么避免这件事的发生，在.h 中加入了结构，还是很有可能会发生的。）\n为了解决这种情况，我们需要在 max.h 和 min.h 开头加入标准头文件结构：\n#ifndef __MAX_H__#define __MAX_H__//如果没有定义过max.h则定义max.h//中间是声明#endif\n这样，只要 max.h 被定义过了，在其他头文件就不会被重复#include 了。\n#pragma once 也能起到相同的作用，但是并不是所有的编译器都支持。所以还是用标准头文件结构。\n格式化输入输出\n从第一天学 c 语言就接触到了 printf 和 scanf.下面彻底研究下占位符%d 有多少细节。\nprintf: %[flags][width][.prec][hIL]type\nflag：标志，有以下几种\n\n\n\nflag\n含义\n\n\n\n\n-\n左对齐（和 width 一起用）\n\n\n+\n输出前面带正负号\n\n\n(space)\n正数留空\n\n\n0\n空格用 0 填充（不能和-同时使用）\n\n\nwidth（宽度）或 prec\n\n\n\nwidth 或 prec\n含义\n\n\n–\n–\n\n\nnumber\n最小字符数（包括小数点）\n\n\n*\n下一个读入的参数是字符数\n\n\n.number\n小数点后面的位数\n\n\n.*\n下一个参数是小数点后的位数\n\n\nhIL：类型修饰符\n\n\n\n类型修饰\n含义\n\n\n–\n–\n\n\nhh\n单个字节\n\n\nh\nshort\n\n\nl\nlong\n\n\nll\nlong long\n\n\nL\nlong double\n\n\ntype：类型\n\n\n\ntype\n用于\n\n\n–\n–\n\n\ni 或 d\nint\n\n\nu\nunsigned int\n\n\no\n八进制\n\n\nx\n十六进制\n\n\nX\n大写字母的十六进制\n\n\nf 或 F\nfloat, 6\n\n\ne 或 E\n指数\n\n\ng\nfloat\n\n\nG\nfloat\n\n\na 或 A\n十六进制浮点\n\n\nc\nchar\n\n\ns\n字符串\n\n\np\n指针\n\n\nn\n读入/写出的个数\n\n\n\n\n\n\n%n 是当操作做到这里时，已经输出了多少个字符，并且填到指针所指的变量里。\n\n\n\nscanf: %[flag]type\n\n\n\nflag\n含义\n\n\n–\n–\n\n\n*\n跳过\n\n\n数字\n最大字符数\n\n\nhh\nchar\n\n\nh\nshort\n\n\nl\nlong, double\n\n\nll\nlong long\n\n\nL\nlong double\n\n\ntype\n用于\n\n\n–\n–\n\n\nd\nint\n\n\ni\n整数，可能是十六进制或八进制\n\n\nu\nunsigned int\n\n\no\n八进制\n\n\nx\n十六进制\n\n\na, e, f, g\nfloat\n\n\nc\nchar\n\n\ns\n字符串（单词）\n\n\n[…]\n所允许的字符\n\n\np\n指针\n\n\n%i 会根据输入（如 0x12、012）来判断是十六进制还是八进制还是十进制。\n\n\n\n[…] 举例\n\n\n\nGPS 中会读到一串字符，用逗号分隔\n\n\n\n\n\n\n\n占位符 %[^,] 表示读入逗号前的所有字符\n\n\n\nprintf 和 scanf 是有返回值的。scanf 是返回几个 item，即这次读入了几个 变量；而 printf 则是这次输出了多少个 字符。因此当我们面对要求严格的程序，比如长期运行的大程序，就需要判断每次调用 scanf 和 printf 的返回值来了解程序运行中是否会存在问题。\n\n\n\n\n文件输入输出\n我们之前运行程序的时候在命令行里输入./test（test 是文件名）即可。\n对文件做输入输出：./test &gt; 12.out，然后再输入 scanf 标准输入的内容，但是程序没有 printf 标准输出了。但是打开 12.out 文件（输入 more 12.out），会输出标准输入和标准输出。\n同样，当我们输入 cat &gt; 12.in ，输入标准输入，然后再 Ctrl D 结束程序，再查看 12.in 文件（输入 more 12.in）会输出标准输入。\n然后运行 test 文件的时候这样写：./test &lt; 12.in，12.in 的内容会输入给./test，然后我们会得到其输出。\n（当然还可以./test &lt; 12.in &gt; 12.out，输入是文件，输出也是文件。12.out 里也有我们所期望的结果。）\n以上是程序运行中的重定向。我们用 &lt;来指定一个文件的输入，用&gt; 来指定输出到一个文件中。\n然而这并不是一般的文件输入输出方式，一般的方式需要做一个 FILE，在 stdlib.h 中已经声明好过。\n\n用 fopen 打开文件打开后用 fscanf 和 fprintf 函数来读写。\nFILE* fp=fopen(&quot;file&quot;,&quot;r&quot;);//file是文件名，r表示读if(fp)&#123;//如果没打开，会返回NULL\tfscanf(fp,...);//读文件。省略号的东西和正常的scanf一样了。后面还可以printf\tfclose(fp);&#125;else&#123;&#125;//无法打开的反馈。如：输出 无法打开文件\n直接./test 运行即可，会打开 12.in 然后正常输出。\n如果删掉 12.in(rm 12.in)就无法打开文件。\nfopen 第一个参数是文件名的字符串，第二个参数字符串用途如下：\n\n\n\n\n\n\n\n\n\nr\n打开只读\n\n\nr+\n打开读写，从文件头开始读/写\n\n\nw\n打开只写，如果不存在则新建，如果存在则清空\n\n\nw+\n打开读写，如果不存在则新建，如果存在则清空\n\n\na\n打开追加，如果不存在则新建，如果存在不清空，从文件尾开始\n\n\n在结尾加 x\n只新建，如果文件已存在则不能打开\n\n\n\n二进制文件\n所有文件最终都是二进制的。文本文件，只是用一种简单的方式可以进行读写的文件。如 more, tail 可以打开文件，cat 打开文件或定向到其他文件，vi 做完整的编辑，etc。但是二进制没这么简单。\n选择文本还是二进制？\nUNIX（和 windows 一样都是操作系统。）喜欢用文本文件储存数据、配置程序。交互式终端的出现（类似 windows 的 cmd 窗口）使得人们喜欢用文本和计算机“交流”。因此，UNIX 的 shell 就提供了一些读写文本的小程序。\nwindows（更准确要说 DOS），个人计算机的制作者并不继承、熟悉 UNIX 文化（宛如在围墙之外，不熟悉围墙内）全凭自己的理解做出草根文化的 DOS，更喜欢用二进制文件。\nPC 和 DOS 刚开始的时候能力有限，二进制更加接近底层。\n文本、二进制各有优劣。\n文本方便人类读写，而且跨平台；缺点是程序的输入输出要经过格式化，开销大。\n二进制的缺点是人类读写困难而且不跨平台；（如不同计算机 int 大小不一致）优点是读写快。\n在这里，我们要回顾下为什么程序要使用文件。\n\n\n有配置（比如窗口大小、字体颜色）UNIX 用文本文件就能编辑，Windows 是用一个大文件：注册表编辑。\n\n\n数据：保存数据，如学生成绩。稍微大一些的数据都放数据库那了。\n\n\n媒体：如图片音频，这些不能是文本文件，只能是二进制文件。\n其实现在程序通过第三方库来读写文件，很少直接读写二进制文件了。\n对二进制的读写\n\n第一个参数是指针，要读写的内存；第二个参数是那块内存（一个结构）的大小；第三个参数是有几个这样的内存，第四个参数是文件指针。返回成功读写的字节数。\n因为二进制文件的读写一半是通过对一个结构变量的操作来进行的，所以 nitem 就是用来说明这次读写了几个结构变量。\n这里老师做了一个非常有意思的东西，建议去看看（我懒了)\nfwrite 可以把数据以二进制形式写到文件中，fread 类似。\n定位：找出现在处在文件中的位置，或跳到指定位置。\n\n\nlong ftell(FILE *stream);int fseek(FILE *stream, long offset, int whence);/*whence：SEEK_SET 从头开始SEEK_CUR 从当前位置开始SEEK_END 从末尾开始*/\n如：fseek(fp, 0L, SEEK_END); 当前位置就在结尾了。这时如果我们令 long size=ftell(fp); 得到的就是文件大小。\n我们可以先这样获得文件大小，然后除以 sizeof 来得知内部储存了多少个数据；然后用户说我想看第几个数据，我们再利用 fseek 函数跳到那个位置，输出每一项。\n这样的二进制文件不具备可移植性；即在 int 为 32 位的机器上写出的数据文件不能在 int 为 64 位的机器上正确读出。解决方案 1 是放弃 int，使用 typedef 具有明确大小的类型；2 是用文本。\n按位运算\n按位运算，即把整数当做二进制进行运算。\n\n\n\n\n\n\n\n\n\n·&amp;\n按位的与\n\n\n·|\n按位的或\n\n\n·~\n按位取反\n\n\n·&lt;&lt;\n左移\n\n\n·&gt;&gt;\n右移\n\n\n按位与 &amp;\n\n\n\n如果 (x)_i==1且(y)_i==1，那么(x&amp;y)_i = 1（第 i 位）否则 = 0\n\n\n\n如：\n\n\n\n0101 1010 5A\n\n\n\n1000 1100 8C 做运算后：\n\n\n\n0000 1000 08\n\n\n\n按位与的应用：\n\n\n\n\n1. 让某一位或某些位 = 0，如 x &amp; 0xFE（1111 1110） 会让最后一位变为 0\n2. 取某个数中的某一段：如 x &amp; 0xFF (在 32 位 int 中是 0000 0000 0000 0000 0000 0000 1111 1111）这样只会留下最后 8 位\n   按位或\n   应用：\n\n3. 使得某一位/某几位变为 1： x | 0x01\n4. 把两个数拼起来： 0x00FF | 0xFF00\n\n按位取反：0 变为 1,1 变为 0\n和补码不太一样，补码是用 1 0000 0000-该数。可以试下(char)~c 和(char)-c 的值。\n逻辑运算，相当于把所有非 0 值变为 1 后做按位运算。\n因此还是有不同的，如果忘记逻辑运算是两个&amp;|的话就会出问题。\n按位异或^，两位相等结果为 0，两位不等结果为 1.\n对同一个值做两次异或，还是原来的值。可以拿来做加密的编码，也可以判断两段码是否相等。\n移位运算\ni &lt;&lt; j：i 中所有位向左移动 j 个位置，右边填入 0\n所有小于 int 的类型，移位以 int 的方式做，结果是 int。\n往左移 1 位就等价于乘了 2.最多移动多少位取决于 int 的大小。x &lt;&lt; 1\n右移相当于/2。\n对于小于 int 的类型，移位以 int 的方式做，且结果是 int；\n对于 unsigned 类型，左边填 0\n对于 signed 类型，左边填入原来的最高位（判断符号的 01），保持符号不变。而往左移动的时候是不管符号位的。\n移位的位数不要用负数，这是没有定义的行为！\n位运算例子\n有什么用处？\n例 1：输出一个数字的二进制\n\nunsigned 后面没有跟类型，则是默认为 unsigned int。\nmask 依次是\n1000 0000\n0100 0000\n0010 0000\n…\n\n这样每一位依次取余，看每一位。\n另外一件事：做单片机时常遇到这样的特殊功能寄存器（SFR）\n\n怎么把对应比特置为 0 或 1？\n\n第几位就是 1u &lt;&lt; 几\n如 SBS 是 1，左移 2 位是 100\nPE 是 1，左移 3 位是 1000\n100\n1000\n1100（或后得到的结果)\n用或使某些比特为 1，用和使某些比特为 0。\n位段\n在 SFR 表中可知，有的也不止一个比特。但之前的技巧只能控制一个比特。\n如何控制多个比特？位段，把一个 int 的若干位组合成一个结构。\n\n冒号后面的数字表示 该成员占几个比特。\n\nprtBin 函数就是刚刚看过的输出二进制位。\n输出：sizeof(uu)= 4\n二进制输出后五位 10010\n当我们把 uu.trailing = 0 注释掉后，sizeof(uu)没变，但是二进制位输出变了。后五位仍然是 10010，前面没有赋初值（没有让 trailing = 0），是乱七八糟的 0 和 1.\n当我们 int trailing = 32，仍然让 uu.trailing = 0，这时 sizeof(uu)= 8（所有位数加起来超过了 32，所以用两个 int 来表达）二进制输出仍然只有后五位 10010.\n位段可以直接用位段的成员名称来访问，比移位、与、或还要方便。\n编译器会安排其中的位的排列，不具有可移植性（比如老师的例子是从最右边排起，可能自己试验时会从最左边排。)所需要的位超过一个 int 时会安排多个 int。\n总而言之，位段是操作和硬件相关的底层操作。\n14. 可变数组\n之前的数组是固定大小的，运行过程中无法改变。只能说尽量大一些。\nresizable array\ngrowable 可变大的\nget the current size 能知道现在的大小\naccess to the elements 能访问其中单元\n\ncreate：创建数组\nfree：回收数组空间\nsize：告知单元数量\nat：访问某个单元\ninflate：长大\n结构 Array 包括*array 指针和 size 大小。\nArray array_create(int init_size)&#123;\tArray a;\ta.size=init_size;\ta.array=(int*)malloc(sizeof(int)*init_size);\treturn a;&#125;\n这里为什么不返回 Array*指针呢？\n因为 a 是本地变量，返回 Array*就无效了。\nvoid array_free(Array *a)&#123;\tfree(a-&gt;array);\t//保险起见，令a-&gt;size=0, a-&gt;array=NULL&#125;\n可变数组的数据访问\nsize：读入结构指针，直接 return a-&gt; size 即可。\n既然如此为啥不直接用 a.size 呢？\n第一种方法叫做封装，保护 a-&gt; size。今后随着版本升级、算法改进，可能 a-&gt; size 不能直接用了。\nat\nint *array_at(Array *a, int index)&#123;\treturn &amp;(a-&gt;array[index]);&#125;\n返回的是指针而不是 int，（这样可以赋值，*array_at(&amp;a,0)=10）所以想输出 a 的值需要加 *。\n如果不习惯函数前加 * 的写法，也可以创造 get 和 set 两个函数\nvoid array_get(const Array *a,int index)&#123;\treturn a-&gt;array[index];&#125;void array_set(Array *a,int index,int value)&#123;\ta-&gt;array[index]=value;&#125;\n这是另一种写法。\n可变数组自动增长\n最后就是 inflate 自动增长了。但我们 malloc 的空间是不能长大的，所以我们 malloc 一块新空间。\nvoid array_inflate(Array *a, int more_size)&#123;\tint *p=(int*)malloc(sizeof(int)*(a-&gt;size+more_size);\tint i;\tfor(i=0;i&lt;a-&gt;size;i++)p[i]==a-&gt;array[i];//把老空间里的东西放到新空间里去。\tfree(a-&gt;array);\ta-&gt;array=p;\ta-&gt;size+=more_size;&#125;\n可以在 array_at 中判断 if(index &gt;= a-&gt; size)就增加。增加多少？如果我们需要多少就增加多少， 即 inflate 中 more_size 参数是 index-a-&gt; size，那每次 index 增加我们都要多申请。（比如现有空间是 9，index 需要 10，我们就要申请 10 的空间然后把原来的 9 放进来再 free 原来的空间；然后 index 如果需要 11，我们又要再重新申请 11……）还不如说每次多申请 5 个 10 个的。\nblock 概念：每次多申请 block，const block_size = 常数，\narray_inflate(a,(index/block_size+1)*block_size-a-&gt;size); 多申请这些空间。\n因为这些是写在 array_at 中的，所以在主函数中直接用 array_at 就可，越界的话会在 array_at 中自动申请。\nwhile(number!=-1)&#123;\tscanf(&quot;%d&quot;,&amp;number);\t*array_at(&amp;a,cnt++)=number;&#125;\n这就是可以无限读入整数，并自动增长的数组。\n可变数组的缺陷\n每次长大，都可能会重新申请新的内存空间。\n\n每次都要拷贝，很花时间\n每次都是在之前的内存结尾申请空间，不断往后排，所以最后其实我们不需要那么多内存空间，但我们的内存空间不够了。\n如果我们每次都只申请一块 block 大的内存，把他们链起来，不需要拷贝了节约时间，也可以充分利用给内存的每一块。\n\n15. 链表\n\n实际上的解决方法是每一块都分为两部分，前一块是数据，后一块是指针，指向下一块。然后还需要指向开头的 head，以及结尾不指向任何东西(NULL)。这就是链表（linked-list)。每个块就是结点。\ntypedef struct _node&#123;\tint value;\tstruct _node *next;&#125;Node;\n第一个例子：像可变数组一样，不停读入数字直到-1 为止。\n这件事回想起来，从平均数就开始做了。一开始我们不需要记录每一个数，只需要求平均数即可。后来讲到数组，需要输出比平均数大的数，就需要记录输入的每一个数，用到数组了。不过数组大小需要用户事先告诉我们。但现在是不知道会读入多少个数。\ndo&#123;\tscanf(&quot;%d&quot;,&amp;number);\tif(number!=-1)//add to linked-list&#125;while(number!=-1);\n首先我们需要有 head 开头的指针。一开始 head 指针是 NULL，不停往后挂结点\nNode *head=NULL;\nNode *p=(Node*)malloc(sizeof(Node));p-&gt;value=number;p-&gt;next=NULL;//find the last, attachNode *last=head;if(last)//判断head是否为空&#123;\twhile(last-&gt;next)last=last-&gt;next;\tlast-&gt;next=p;&#125;else head=p;//即：p就是第一个结点\t\n链表的函数\n上面的这些操作（把新的结点挂到上一个结尾）尝试拿出来单独写成一个 add 函数。\n函数的参数应该有什么？head 头指针，以及每次要传入的数据 data。\n错误的方案 1：\nvoid add(Node *head,int number);\n每次新定义一个临时结点 p，p-&gt; last = number，p-&gt; next = NULL; 然后我们把这个结点挂在链表的末尾。\n有两种情况：1、p 是链表的第一个元素，即 head = NULL，那直接令 head = p 完事。\n2、p 不是第一个元素，我们现在只知道链表头是 head，我们要先找到 last 链表的结尾结点，然后把 p 挂在结尾。\nlast=head;while(last-&gt;next)last=last-&gt;next;//找到结尾last结点last-&gt;next=p;\n但是 head = p 是有问题的，head 的值并没有得到修改。如果想不通，可以阅读作者的 另一篇文章，里面有写作者自己的一些理解。\n如果我们把 head 放在外面作为一个全局变量？不好，在全局变量时讲过，不要用 head 做全局变量。因为 add 只能对这个链表的 head 起作用，如果程序中出现其他链表，不能再做操作。\n方案 2：如果 add 函数返回指针，然后 return 理想的 head 指针，在函数中令 head = add 函数呢？不错。\n方案 3：传给 add 的参数不再是 head，而是 head 的地址。我们知道通过指针可以直接修改该地址中的值。\n\n方案 4：我们定义一个结构 list，其中包含*head。在原函数中定义 list，list.head = NULL；然后把 list 的指针 &amp;list 传入 add 函数，add 的参数是 list 的指针，在函数中就可以对 list-&gt; head 进行修改。\n方案 4 的好处在于我们用自己定义的 list 结构来代表整个链表。除了定义的这个 head，还可以有 tail 指向结尾，这样每次 last 不用遍历整个链表才能找到结尾；等等。\n这里讲的比较细，是因为链表的放入东西、插入东西都是比较简单的。对于工程化的东西，我们要深究。\n链表的搜索\n输出链表中读到的所有东西\nnode *p;for(p=list.head;p;p=p-&gt;next)printf(&quot;%d\\t&quot;,p-&gt;value);//遍历\n则这一段可以单独拿出来写作函数，称之为 print，参数为 list 的指针。\n可见 for 循环不一定非要是++。\n然后进一步，我们希望能实现搜索的功能：输入一个数字，在链表中寻找这个数字，如果找到了就将其删除。\nfor(p=list.head;p;p=p-&gt;next)&#123;\tif(p-&gt;value==number)printf(&quot;找到了！&quot;);&#125;\n链表的删除\n删除某个值，我们要做两件事。\n第一，前面的指针指向他后面的值。\n第二，free it.\n也就是说，如果前面的指针是 q，我们要删除的部分指针是 p，则要 q = p, p = p-&gt; next。\n\n怎么考虑到边界情况？\n一个很重要的思想：\n判断出现在 arrow 箭头左边的指针变量是否是 NULL。如图中 for 循环内出现了 p-&gt; next，p-&gt; value，q-&gt; next.因为在 for 循环中判断了 p 会不会是空指针，所以 p-&gt; 是安全的。但是 q-&gt; next 就不安全了，没有判断 q 是否是 NULL。\n也就是说当要删除的节点 p 是第一个时，q = NULL，这就是边界情况。这时可以让 head 等于所指的 next。\n\n最后别忘记 free(p).\n链表的清除\n所有节点都是 malloc 出来的，所以最后都要清除干净。\n可以这样做：令 p = head，q = p-&gt; next\n每次 free(p)，p=q 把最开头的清除，直到 p = NULL 时就清除完成了。\nfor(p=head;p;p=q)&#123;\tq=p-&gt;next;\tfree(p);&#125;\n链表这里只是简单地介绍了一下。在之后的数据结构等还会深入研究。\n完结\n至此，老师的课已经全部过了一遍。虽然还有很多没有记住的要点，没有理解的地方，还要反复翻看、实践，结合其他老师的课和学校的教材来看。\n其实这门课拖拖拉拉的已经听了一年了快。不过对我来说只要能吃透，就是值的。\n谢谢老师！收藏夹-1.\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["C"]},{"title":"技术学习：黑马程序员 Java","url":"/2022/05/02/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Java/","content":"前言\n以黑马程序员全套Java教程网课为主。\nJava 介绍\nJava是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。\nJVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。\nJRE: Java Runtime Environment，运行只需要 JRE 就够了。\nJDK: Java Development Kit，Java 程序开发工具包。\n graph LR\n A[JDK] -->B[开发人员使用的工具, JDK 的 bin 目录下]\n   A --> C[JRE]\n   C -->D[JVM, JRE 的 bin 目录下]\n   C -->E[运行所需要的核心类库, JRE 的 lib 目录下]\n尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~\nJDK 的安装目录如下：\n\n\n\nJDK目录名称\n说明\n\n\n\n\nbin\n存放工具命令，如：javac, java, etc.\n\n\nconf\n配置文件\n\n\ninclude\n某些平台特定的头文件\n\n\njmods\n模块\n\n\nlegal\n授权文档\n\n\nlib\n补充 JAR 包\n\n\n其他\n说明型文档\n\n\n\n环境配置等就不多赘述了，网上好的教程太多太多。总之就是终端 javac 和 java 可以执行，最好使用 IDEA 作为 IDE。\nIDEA 环境介绍\n集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。\n创建项目-项目内创建模块（实现不同的功能）-模块 src 下创建包（类似文件夹，用于归纳区分不同的类）-包下创建类-类中编写代码。\n其中，.class 文件都会放在模块同级的 out 文件夹中。\n\n基础语法（重点比较与C的区别）\nHelloWorld\n使用 Notepad++ 前需要设置：设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI。\n新建一个 HelloWorld.java 文件，编辑内容：\npublic class HelloWorld &#123; // class 类名必须和文件名一致    public static void main(String[] args) &#123; //main 方法        System.out.println(&quot;Hello World!&quot;); // 单独输出一行的意思。注意大小写不可以出错    &#125;&#125;\n然后在DOS窗口中进入当前文件所在目录，输入命令：\njavac HelloWorld.java //编译，得到 .class 字节码文件，可以在任何支持 java 的平台上运行java HelloWorld // .class 文件被解释执行，转化为可以直接在本地对应平台上运行的机器码文件\njava 和 C、C++ 一样，属于编译型语言（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。\n注释\n单行注释 // 、多行注释 /* */ 都和C一样。还有一个文件注释 /** */暂时用不到，之后了解。\n关键字\n字母全部小写。\n数据类型\n整数型：byte, short, int, long\n浮点型：float, double\n字符型：char\n布尔型：boolean\n变量的定义和 c 相似，int a=10; 不能重复定义和未初始化就使用。\nlong l=1000000L;float f=1.235F; //防止 long 类型和 float 类型不兼容\n标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。\n命名规范：\n方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法\n类名：大驼峰命名法\n运算符\n+，-，*，/，%，\n+=，-=，*=，/=，%=（隐含了强制类型转换）\n++，–\n==，&gt;=，&lt;=，&gt;，&lt;，!=\n? :\n&amp;，|，^，!（逻辑运算符）\n&amp;&amp;，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）\n与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。\n1+99+&quot;string&quot; //&quot;100string&quot;&quot;string&quot;+1+99 //&quot;string199&quot;，从左往右计算\n类型转换\n自动类型转换：把小范围的变量赋值给大范围的变量\n数据范围从小到大：\ngraph LR\nA[byte]-->B[short]\nB-->C[int]\nD[char]-->C\nC-->E[long]\nE-->F[float]\nF-->G[double]\n算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。\n强制类型转换：赋值运算符中隐含。\nshort s=10;\t\ts+=10;\t\t\t// 正常s=s+10;\t\t\t// 错，因为右边发生了自动类型转换，变成了int型s=(short)(s+10);// 也可以\n数据输入\n输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。\nimport java.util.Scanner;//导包Scanner sc=new Scanner(System.in);//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。int i=sc.nextInt();//接收数据String s=sc.nextLine();\n分支、循环语句\nif - else 语句：和 C 语言一样。\nswitch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。\nfor, while, do - while 语句，及 break continue 和 C 一样。\n随机数\nRandom 类，在 java.util 包下，需要导包。\nimport java.util.Random;Random r=new Random();int n=r.nextInt(10);//[0,10)的范围内取随机数\n数组\n一次性声明大量同类型变量。\nint[] arr;//推荐。定义了一个 int 型的数组，数组名是 arrint arr[];//定义了一个 int 型变量，变量名是 arr 数组int[] arr=new int[]&#123;1,2,3&#125;;//静态初始化int[] arr=&#123;1,2,3&#125;;//静态初始化简化版int[] arr=new int[3];//动态初始化，只申请了空间，系统赋予初始值//数字类型：初始值为0.0//布尔类型：初始值为 false//字符串类型：初始值为&quot;&quot;//引用类型：初始值为 null\njava 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。\n栈内存\n定义的方法中的变量放在栈内存中，使用完直接消失。\n如int a，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。\n堆内存\n实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。\n如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]=1, arr[1]=2……）\n访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。\n因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。\nint[] arr1=&#123;1,2,3&#125;;int[] arr2=arr1;arr2[0]=11;arr2[1]=22;arr2[2]=33;//这时访问 arr1[]，发现其中的数据也变成了11,22,33\n数组常见异常\n\n数组越界问题，ArrayIndexOutOfException。\n空指针异常问题，NullPointerException。（arr=null，表示数组不指向任何有效对象）\n\nArray.length\n数组自带属性 length，通过arr.length就能获得数组长度。\n字符串\n字符串输入\n查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。\nScanner sc=new Scanner(System.in);String line=sc.nextLine();//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。\nString\nString 类型代表字符串。其内容都是被双引号引住的。\n在 java.lang 包下，不用导包。\nString s=&quot;abc&quot;;//直接赋值String s1=new String();//空字符串char[] c=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;String s2=new String(c);//根据字符数组创建字符串byte[] b=&#123;97,98,99&#125;;//a, b, c 对应的 ascii 码String s3=new String(b);\n字符串一旦创建不能再修改。不过多个字符串的值可以共享s1=s2;\n字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。\n字符串比较：== 和 equals()\n用==判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。\n基本类型 == 比较的是数据值是否相同，引用类型 == 比较的是地址是否相同。\n用字符串的成员方法 equals() 判断，是比较字符串内容是否相同。\nchar[] c=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;String s1=new String(c);String s2=new String(c);System.out.println(s1==s2);//输出 false，因为 s1 s2 地址不同，只有内容是一样的System.out.println(s1.equals(s2));//输出 trueString s3=&quot;abc&quot;;String s4=&quot;abc&quot;;System.out.println(s3==s4);//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。System.out.println(s3.equals(s4));//输出 trueSystem.out.println(s1==s3);//输出 falseSystem.out.println(s1.equals(s3));//输出 true\n遍历字符串：成员方法 length() 和 charAt()\ns.length()可以获取字符串长度。这里注意是有括号的，和数组长度 length 区分开！\ns.charAt(i) 可以获取索引为 i 处的字符\nfor(int i=0;i&lt;s.length();i++)&#123;    System.out.println(s.charAt(i));&#125;\n字符串拼接\n字符串可以直接用 + 号拼接。\nString s1=&quot;Hello &quot;;String s2=&quot;World&quot;;s1=s1+s2;//Hello World\n在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有&quot;Hello &quot;，“World”，&quot;Hello World&quot;三个字符串，而不是直接在&quot;Hello “的位置上拼接&quot;World”）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。\nendsWith()\n查看字符串是否以指定子串结尾。\nString s1=&quot;hello world&quot;;s1.endsWith(&quot;world&quot;);\nStringBuilder 类\n与 String 类相比，最主要的特点在于内容可变。\n在 java.lang 包下，不用导包。\n构造方法：\n\n\n\n构造方法名\n说明\n\n\n\n\nStringBuilder()\n无参构造方法\n\n\nStringBuilder(String s)\n把给定的 String 字符串转换成 StringBuilder 类型的\n\n\n\n\n\n\n成员方法名\n说明\n\n\n\n\nappend(String s)\n在结尾拼接上字符串 s\n\n\nStringBuilder reverse()\n反转字符串\n\n\nString toString()\n把 StringBuilder 类型转换为 String 类型并返回\n\n\n\n用 StringBuilder 完成字符串拼接操作：\n\nString 类型转换为 StringBuilder 类型\nStringBuilder 类型通过 append() 成员方法拼接字符串\nStringBuilder 类型通过 toString() 成员方法转换为 String 类型\n\nString s=&quot;Hello &quot;;StringBuilder sb=new StringBuilder(s);//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举sb.append(&quot;World&quot;);String s1=sb.toString();//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用String s1=new StringBuilder(s).append(&quot;World&quot;).toString();\n用 StringBuilder 完成字符串反转操作：\nString s=&quot;Hello World&quot;;String sr=new StringBuilder(s).reverse().toString();\n方法\njava 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。\n像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。\npublic static 返回值类型 方法名(形参)&#123;//和 main 方法同级    方法体    return 返回值;&#125;//定义方法名(实参);//在 main 方法中调用。有返回值类型的方法建议用变量接收调用\n方法不能嵌套定义。\n方法重载\n多个方法在一个类中，有相同的方法名，但参数不完全相同。\npublic static int max(int a, int b)public static int max(int a, int b, int c)\n**注意：返回值不能作为判断方法是否重载的标准！**只有方法名和参数可以。\n调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。\n**形参值修改不会对实参造成影响。**main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存。\n\n但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。\n\n如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。\n类和对象\n类\n类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠\n类是对象的数据类型，是一个抽象的概念。\n类的定义\npublic class 类名&#123;    数据类型 变量;    数据类型 变量;    数据类型 变量;        方法1;    方法2;&#125;public class Cat&#123;    String name;//初始值为null或0或false或&quot;&quot;    int age;    boolean tail;    String color;        public void meow()&#123;\t\tSystem.out.println(&quot;Meow!&quot;);    &#125;    public void eat(String food)&#123;\t\tSystem.out.println(&quot;Eat &quot;+food);    &#125;&#125;\n对象\n类的实体化。比如罗小黑，是猫类的一个实体化。\n属性\n对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）\n行为\n对象能执行的动作，如猫可以叫，可以跑。\n对象的使用\n//在 main 方法中Cat c=new Cat();c.name=&quot;小黑&quot;;//c 的名字c.age=2;//2岁了c.tail=false;//有尾巴System.out.println(c.age);c.meow();//行为：猫叫c.eat(&quot;猫粮&quot;)//行为：吃饭\n在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。\n对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的属性等具体内容存储在堆内存中。对象中的方法调用时则加载到栈内存中，执行完毕后出栈。\n成员变量和局部变量\n成员变量：类中在方法外的变量（如上例中的属性变量）\n局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）\n\n\n\n成员变量\n局部变量\n\n\n\n\n类中方法外\n方法中，或方法声明上\n\n\n堆内存中\n栈内存中\n\n\n对象消失时随之消失\n方法调用完毕而消失\n\n\n有默认的初始值\n没有默认的初始值，必须先定义、赋值才能使用\n\n\n\n对象内存图介绍\n首先老师汇总介绍了一下所有内存空间。当我们运行 Java 文件的时候系统分配一片内存空间给 JDK，里面具体是这样细分的：\n\n元空间，或者叫方法区，负责加载字节码文件，是 JDK 8 及以后的版本从堆空间中划分出来的。\n栈一般是方法，变量运行时进入。\n堆是我们 new() 出来的对象的存储区域，并产生地址。\n单个对象的内存图\n比如：Student s=new Student();\n在这个过程中内存至少会执行以下七个步骤：\n\n加载 class 文件\n声明局部变量\n在堆内存中开辟一片空间\n默认初始化（将对象中的局部变量值赋值为默认值，如 String name 赋值就是 null, int age 赋值就是0）\n显示初始化（如果在类定义中我们做了赋值，如 int age=19; 显示初始化就会重新赋值成这个我们给定的默认值）\n构造方法初始化（通过构造方法中的参数赋值）\n将堆空间中的地址值赋值给左边的局部变量\n\n\n当方法执行完毕撤出栈空间的时候，没有引用堆内存中对应对象的变量时，堆内存中的对象就没有存在必要了就也被清理了。\n封装 packaging\nJava 的三大特性：封装、继承、多态。\n之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age=-30）\n因此我们要添加一些限制。\nprivate 修饰符\n可以修饰成员变量、成员方法不直接被其他类使用。\nprivate String name;private int age;\n被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get / set 方法。\n构造方法\n写在类中，作为类的方法。主要用于对象初始化。声明变量时Cat c=new Cat();Cat() 就是一种无参构造方法。\n每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。建议无论是否用到构造方法，都写一个无参构造方法。\npublic Cat()&#123;&#125;//我们自己加的无参构造方法，会覆盖系统默认的public Cat(String name)&#123;//写一部分参数的构造方法也可以    this.name=name;//通过 this 赋给成员变量&#125;public Cat(String name, int age)&#123;//写全参数的构造方法也可以    this.name=name;    this.age=age;&#125;//main 中构造对象：Cat c1=new Cat();Cat c2=new Cat(&quot;小黑&quot;);Cat c3=new Cat(&quot;小白&quot;,2);//这些都可以，与自己写的构造方法的参数相对应。\nthis被哪个对象调用，就代表哪个对象。\n\n然后把&quot;林青霞&quot; 字符串类型传入堆内存中。\nget / set\n无参构造方法后用 setXxx() 方法创建对象。\npublic void setName(String name)&#123;//赋值\tthis.name=name;&#125;public void setAge(int age)&#123;    if(age&gt;=0&amp;&amp;age&lt;=20)//在 set 中可以添加一些限制处理\tthis.age=age;&#125;public void getName()&#123;//获取值\treturn name;&#125;public void getAge()&#123;\treturn age;&#125;//在 main 方法中赋值并获取值示例：Cat c=new Cat();c.setName(&quot;小黑&quot;);System.out.print(c.getName);\n总结\n封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。\n集合\n集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。\ngraph TB\nC[Collection]-->L[List]-->A[ArrayList]\nC-->S[Set]-->H[HashSet]\nC-->Q[Queue]\nArrayList 就是集合的一种。\nArrayList&lt;E&gt;\n在 java.util 包下，需要导包。\n&lt;E&gt; 表示泛型，限制数组中的元素只能是某一种类型（或者其子类，多态），可以在编译阶段约束操作的数据类型并进行检查（下面左边的 String）。\nArrayList&lt;String&gt; array=new ArrayList&lt;&gt;();\n泛型只能使用引用数据类型（比如包装类 Integer, Character… 或者我们自己定义的对象 Student，但是不可以使用基本数据类型 int char 这些，具体原因后面还会深入讲解）。\n\n\n\n方法\n说明\n\n\n\n\nArrayList&lt;E&gt;()\n无参构造方法\n\n\nboolean add(E e)\n结尾添加一个元素，成功返回true\n\n\nvoid add(index i, E e)\n在指定索引处添加一个元素（不能越界！）\n\n\nboolean remove(Object o)\n删除指定对象，成功返回 true\n\n\nE remove(int index)\n删除指定索引处的值，返回该值\n\n\nE set(int index, E element)\n修改指定索引处值，返回修改后的值\n\n\nE get(int index)\n返回指定索引处元素\n\n\nint size()\n返回集合元素个数\n\n\n\narray.add(1);array.add(3);array.add(4);array.add(1,2);\t // 1下标位置插入2这个元素System.out.println(array);//输出 array：1，2，3，4\n继承\n有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。\npublic class Animal&#123; // 父类，基类，超类    String name;\tint age;\tboolean tail;\tString color;&#125;public class Cat extends Animal&#123; // 子类，派生类    public void meow()&#123;        System.out.println(&quot;Meow!&quot;);    &#125;&#125;public class Dog extends Animal&#123;    public void bark()&#123;        System.out.println(&quot;Bark!&quot;);    &#125;&#125;\n提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。\n当子类属于父类的一种时，可以使用继承。\n变量访问特点\n范围越小，权限越高。\n访问优先级：子类中局部变量&gt;子类中成员变量&gt;父类中成员变量&gt;找不到就报错\n如果想优先访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）\n\n构造方法的访问特点\n构造方法的访问优先级和变量相反。即使访问子类的构造方法，也会优先访问父类的无参构造方法，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。\n而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。\n因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）\n解决方法：1. 父类中补上无参构造方法\n\n在子类构造方法中手动访问父类的带参构造方法来代替\n\npublic Fu(int age)&#123;    this.age=age;&#125;public Zi()&#123;\tsuper(20);&#125;public Zi(int age)&#123;    super(age);// 子类的带参构造方法就这样传递给父类即可&#125;// 不支持一个子类继承多个父类，但是允许多层基层（爷-&gt;父-&gt;子）\n成员方法的访问特点\n先在子类中寻找，找不到再去父类中寻找。\n权限修饰符\npublic &gt; protected &gt; 默认 &gt; private\n\n状态修饰符\n有 final 和 static。\nfinal\n成员变量和成员方法被 final 修饰后，不可以被重新赋值 / 重写。\n类被 final 修饰后，也不可以作为父类。\n引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容也不可以改变）\nstatic\n被 static 修饰的成员变量在所有对象里值都是一样的。\npublic static String university;//在学生类中的静态成员变量Student.unievrsity=&quot;北大&quot;;//统一赋值Strudent s1=new Student();//university 变量的值是 &quot;北大&quot;Strudent s2=new Student();//university 变量的值是 &quot;北大&quot;\n静态成员方法则是与类本身相关（非静态的方法是和类的具体实例对象有关，静态方法是和整个类有关），调用方式也是 类名.静态方法名。静态方法中不能使用 this 关键字（因为没有具体的实例对象）。此外，静态成员方法只能访问静态成员变量 / 方法！\n包 Package\n文件夹，用于存放编译后生成的 class 文件，方便管理。\n在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。\npackage com.ithema;//命令行根据路径建包javac -d . HelloWorld.java//编译javac HelloWorld.java//运行java com.ithema.HelloWorld\n导包 import\n如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用\nimport B文件夹.要调用的类名;\n之前对于权限的学习，我们知道：只有 public 的类可以被其他跨包无关类访问；被 protected 修饰的父类对跨包的子类可见。\n方法重写\n之前学过方法重载，是函数名相同但是参数设置不同的函数。\n方法重写是子类中重新定义了父类中的方法。\n子类如果想访问父类中的方法，可以通过 super 来指定。\n@Override//注解，可以检查方法重写的正确性public void function()&#123;    System.out.println(&quot;子类中重写方法&quot;);&#125;\n\n父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。\n子类的重写方法权限必须高于父类方法。（public &gt; protected &gt; 默认 &gt; private）\n\n多态\n同一个对象在不同时刻表现出的形态也不同。\nCat c=new Cat();Animal a=new Cat();//父类引用指向子类对象\na 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。\n多态中成员的访问特点\n访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。因为成员变量不会被重写\n访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。\n例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。\npublic class AnimalOperator(Animal a)&#123;    a.eat();&#125;//使用Cat c=new Cat();Dog d=new Dog();Pig p=new Pig();AnimalOperator(c);// 多态AnimalOperator(d);// 多态AnimalOperator(p);// 多态\n调用的都是子类中重写的方法。\n多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类接口就能访问（无论子类具体是哪一种）。\n但是多态无法访问子类中特有的方法。\n解决这一弊端的方法就是转型。\nAnimal a=new Cat();//向上转型，a 不能访问 Cat 类中特有的方法Cat c=(Cat)a;//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。\n使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。ClassCastException\nAbstract, 接口\n抽象方法：没有方法体的方法，待补全，请输入文本。\npublic abstract void eat();\n抽象类：含有抽象方法的类。\n（没有抽象方法的类也可以是抽象类，但是意义何在）\n抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象类。\n接口\n接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：\npublic interface Jumpping&#123; // 接口    public abstract void Jump();&#125;public class Cat implements Jumpping&#123; // 实现    // 重写 Jump() 方法。如果不重写， Cat 就是一个抽象类&#125;\n接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。\n接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。\n（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）\n接口是抽象的，不能直接实例化，可以借助多态的方法实例化。\n相较类与类之间不能多继承，只能层层继承：接口可以多实现 implements interface1, interface2\n接口和接口之间也可以多继承 interface1 extends interface2, interface3\n总结\n\n设计原则\n抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。\n但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。\n例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。但并不是“是人就该会说英语，是运动员和教练就该会说英语”。所以说英语应当作为接口而不是人里面的抽象方法。\ngraph TB\nA[人]-->B[运动员]\nA-->C[教练]\nB-->D[篮球运动员]\nB-->E[乒乓球运动员]\nH[说英语]-->E\nH-->G\nC-->G[乒乓球教练]\nC-->F[篮球教练]\n其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。\n抽象类 / 接口作为形参 / 返回值\n类也可以作为形式参数或函数的返回值。\n抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要传递的是实现了该抽象类的子类的实例对象。\n如函数形参是Animal，实际需要通过多态的方法Animal a=new Cat();然后把a传给函数。\n接口作为形参/函数返回值，和抽象类一样，实际需要的是实现了该接口的类的实例对象。\n内部类\n在类中定义一个类。\n内部类和外部类的互相使用\n无论外部类的成员变量的权限修饰符是什么（private, public……）因为都在同一个类中，所以即使权限修饰符是 private 也可以相互访问。\n内部类都可以直接访问外部类的全部成员变量。\n而外部类如果想访问内部类的成员，需要先创建一个内部类对象再访问。\n外界使用内部类\n外界使用内部类：Outer.Inner oi=new Outer().new Inner();\n如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。封装\n内部类的分类\n在类的成员位置定义：成员内部类\n在类的局部定义：局部内部类。\n局部内部类不能从外界直接创建对象，只能通过调用方法来创建类\npublic class Outer &#123;\tprivate int num=10;    public void method() &#123;        class Inner &#123;\t\t\tpublic void show()&#123;                System.out.println(num);//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量            &#125;        &#125;        Inner i=new Inner();//在方法中创建内部对象        i.show();//创建对象之后，记得调用内部方法的成员变量    &#125;&#125;\n匿名内部类\n继承了另一个类，或实现了接口的子类匿名对象。\n首先有一个父类/接口，其中有具体的/抽象的方法，然后匿名内部类对其进行重写/实现。\n//接口文件 inter.java 中：public interface inter &#123;    public void show();//抽象方法&#125;//外部类文件 Outer.java 中public class Outer &#123;\tprivate int num=10;    public void method() &#123;        new inter &#123;            @Override            public void show()&#123;                System.out.println(&quot;匿名内部类&quot;);            &#125;        &#125;.show();// 创建匿名对象之后，记得调用成员变量                //另一种方法：        inter i=new inter &#123;            @Override            public void show()&#123;                System.out.println(&quot;匿名内部类&quot;);            &#125;        &#125;        i.show();    &#125;&#125;\n使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行 j 的 jump 。\n我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；\n然后用多态的方式jump c=new cat(); jump d=new dog(); 新建对象并传给 method 方法。\n但是可以通过匿名内部类的方法：\njo.method(new jump()&#123;    @Override    public void jump()    &#123;        System.out.println(&quot;猫跳高&quot;);    &#125;&#125;);jo.method(new jump()&#123;    @Override    public void jump()    &#123;        System.out.println(&quot;狗跳高&quot;);    &#125;&#125;);\n直接传一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。\n一些常用类\nMath\n不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。\n\n\n\n方法\n说明\n\n\n\n\npublic static int abs(int a)\n绝对值，支持 double  float int long 类型\n\n\npublic static double ceil(double a)\n向上取整，返回一个 double 值\n\n\npublic static double floor(double a)\n向下取整，返回一个 double 值\n\n\npublic static int round(float a)\n四舍五入\n\n\npublic static int max(int a,int b)\n\n\n\npublic static int min(int a,int b)\n\n\n\npublic static double pow(double a,double b)\na 的 b 次幂\n\n\npublic static double random()\n随机数，范围 [0.0,1.0)\n\n\n\n随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用random()*100。\nSystem\n不用导包，不能实例化，static\n\n\n\n方法\n说明\n\n\n\n\npublic static void exit(int status)\n终止运行 JVM，非零表示非正常终止\n\n\npublic static long currentTimeMillis()\n返回当前时间到1970年1月1日的时间间隔，以毫秒为单位\n\n\n\ncurrentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。\nObject\nObject 类是所有类的根类。\n\n\n\n方法\n说明\n\n\n\n\npublic String toString()\n返回对象的字符串表示形式。建议子类全部重写该方法\n\n\npublic boolean equals(Object obj)\n比较对象是否相等（默认比较地址）。重写可以比较对象内容\n\n\n\ntoString() 方法\nObject 中包含 toString 方法\npublic String toString() &#123;        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;\n输出类名@+一串哈希值。\n一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter / setter 一样自动生成。类似：\n//手动实现public String toString()&#123;return &quot;&#123; Person:name=&quot; + name +&quot; age=&quot; + age+&quot;&#125;&quot;;// name 和 age 都是本类中的成员变量&#125;\nequals\ns1.equals(s2)本质上是比较两个对象的地址，肯定是 false。\n一般也会重写/自动生成可以比较两个对象内容是否一致的方法。\npublic boolean equals(Object o) &#123;    if (this==o) return true; //同一个对象    if(o==null||getClass()!=o.getClass()) return false;//o是空对象，或这两个对象不属于一个类    Student student=(Student) o;//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来    if (age!=student.age)return false;     return name!=null?name.equals(student.name):student.name==null;//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用&#125;\nArrays 类\n需要导包 java.util.Arrays，不能创建对象，成员是 static的。\n\n\n\n方法\n说明\n\n\n\n\npublic static String toString(int[] a)\n返回形如 “[a, b, c]” 的字符串形式\n\n\npublic static void sort(int[] a)\n按数字顺序排列指定的数组\n\n\n\n补充：工具类\n以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。比如 Arrays.sort(arr);\n以下这些方法不能创建对象：\npublic Math()&#123;&#125;;public Arrays()&#123;&#125;;public System()&#123;&#125;;\n因为这些类自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。\n基本类型包装类\n其中有一些方法能更好地处理基本数据类型。\n包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean\n方法示例\n\n\n\n方法\n说明\n\n\n\n\npublic static Integer valueOf(int i)\n把 int 转换为 Integer 类型\n\n\npublic static Integer valueOf(String s)\n把 String 转换为 Integer 类型\n\n\n\npublic String[] split(String regex) 把给定字符串用 regex 分隔开。\n如给定字符串 s 是&quot;1 2 3 4&quot;，s.split(&quot; &quot;)就会得到4个字符串：&quot;1&quot;&quot;2&quot;&quot;3&quot;“4”。\n基本类型转换\nint -&gt; String：\n① 空字符串+int 类型 &quot;&quot;+123\n② String s=String.valueOf(i);\nString -&gt; int：\n① Integer in=Integer.valueOf(s);\nint i=intValue(in);\n② int i=Integer.parseInt(s);\n自动装箱和拆箱\n装箱：基本类型-&gt;对应的包装类型\n拆箱：包装类型-&gt;基本类型\nInteger i=Integer.valueOf(100);//装箱Integer ii=100;//自动装箱ii=ii.intValue()+200;//拆箱ii+=200;//自动拆箱Integer i3=null;i3+=300;//NullPointerException。因此对象使用之前最好先判断是否为 null\n日期类\nDate\nDate 类，需要导包。**注意是 java.util 下的，而不是 java.sql 下的！**java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。\n\n\n\n方法\n说明\n\n\n\n\npublic Date()\n初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒\n\n\npublic Date(long Date)\n分配一个 Date 对象，值为从标准时间起指定的毫秒数\n\n\npublic long getTime()\n获取日期对象从标准时间到现在的毫秒数\n\n\npublic void setTime(long time)\n设置时间，单位为毫秒\n\n\n\n//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份long d=1000*60*60;Date da=new Date(d);//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）long time=System.currentTimeMillis();//可以这样获取当前时间，然后传给 Date() 或 setTime()\nSimpleDateFormat\n可以自己设置日期格式。\n\n\n\n方法\n说明\n\n\n\n\npublic SimpleDateFormat()\n构造方法，并使用系统默认的 Date 格式\n\n\npublic SimpleDateFormat(String pattern)\n构造方法，并使用自己规定的格式\n\n\npublic final String format(Date d)\n将日期对象转换为相应格式的字符串\n\n\npublic final Date parse(String s)\n将字符串转换为日期\n\n\n\npublic static void main(String[] args) throws Parse Exception&#123;//结尾要加一些东西，在 IDEA 中可以自动补全    Date d=new Date;//被分配时的时间    SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年-MM月-dd日 HH:mm:ss&quot;);    String s=sdf.format(d);    System.out.println(s);//输出格式就形如 2022年-05月-05日 10:24:00        String ss=&quot;2022-05-05 10:24:00&quot;;    SimpleDateFormat sdf1=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    Date d1=sdf1.parse(ss);&#125;\ny 年 M 月 d 日\nH 时 m 分 s 秒\n（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把 Date 转换为 String 和把String转换为Date；这两个方法可以设置两个传入参数：\npublic static String dateToString(Date d, String format)\npublic static String StringTodate(String s, String format)\n在方法内根据传入的字符串格式，利用 SimpleDateFormat 的方法进行转换。）\nCalendar 类\n需要导包java.util.Calendar，是一个抽象类。\n为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。\nCalendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？\nCalendar rightnow=Calendar.getInstance();\n其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。\n\n\n\n方法\n说明\n\n\n\n\npublic int get(int field)\n获取给定日历字段的值\n\n\npublic abstract void add(int field, int amount)\n添加/减去给定的日历字段\n\n\npublic final void set(int year, int month, int date)\n设置日历的年月日\n\n\n\ny=c.get(Calendar.YEAR);m=c.get(Calendar.MONTH)+1;//month 是从0开始的，所以要+1d=c.get(Calendar.DATE);//例：求2020年2月有多少天?Calendar c=Calendar.getInstance();c.set(2020,2,1);//设置为3月1日c.add(Calendar.DATE,-1);//倒退1天，就是2月的最后一天System.out.println(&quot;2020年2月有&quot;+c.get(Calendar.DATE)+&quot;天&quot;);\n异常\n有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。\nThrowable\nThrowable 是所有错误、异常的父类。\ngraph LR\nA[Throwable]-->B[Error]\nA-->C[异常]\nC-->R[RuntimeException  运行型异常]\nC-->O[其他  编译型异常]\nError 程序无法处理，而异常程序可以处理。\nRuntimeException：运行时异常，非受检异常， 可以先不处理，等到真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。比如数组越界。\n编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。\n处理异常\nJVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。\n程序员还可以有自己的处理异常方法，如 try…catch 和 throw。\ntry…catch\ntry&#123;    可能出现异常的代码;&#125;catch(异常类名 变量名)&#123;    出现异常后的处理代码;&#125;String s=&quot;2022-05-07&quot;;SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-mm-dd&quot;);sdf.parse(s);// 这个方法不能直接用，必须要加异常处理try&#123;    sdf.parse(s);&#125;catch(ParseException e)&#123;    System.out.print(&quot;parseException!&quot;);//不管会不会发生异常，都要写&#125;\n出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，处理完成后可以继续执行。\n如果异常变量命名为 e ,调用 e 的成员方法 e.printStackTrace() 就会输出平时出现异常时系统默认提示的信息：java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... \n但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。\nThrowable 的成员方法\nThrowable 作为超类，其所有子类都可以使用他的成员方法。\n\n\n\n方法\n说明\n\n\n\n\npublic String getMessage()\n返回此 Throwable 的详细消息字符串\n\n\npublic String toString()\n返回此可抛出的简短描述\n\n\npublic void printStackTrace()\n把异常的错误信息输出到控制台\n\n\n\ne.getMessage():  Index 3 out of bounds for length 3e.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3e.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....\n利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：\npublic class Throwable &#123;    private String detailMessage;//Throwable 类中的一个成员方法        public Throwable(String message)&#123;        detailMessage=message;//构造方法。出现异常时，会通过这种方法构造一个异常对象    &#125;        public String getMessage()&#123;        return detailMessage;    &#125;&#125;\nThrows\n可以抛出异常给 try catch 处理，但是自身不能解决。\nthrows 异常类名;public static void main(String[] args)&#123;    System.out.println(&quot;运行开始&quot;);    method1();    try&#123;        method2();//抛出给了 try catch 处理    &#125;    catch(ParseException e)    &#123;        System.out.println(&quot;运行错误&quot;);    &#125;    System.out.println(&quot;运行结束&quot;);&#125;public static void method1() throws ArrayIndexOutOfException&#123;    int[] arr=&#123;1,2,3&#125;;    System.out.println(arr[3]);//会报错并停止运行，throws 并没有解决数组越界这个异常&#125;public static void method2() throws ParseException&#123;    String s=&quot;2022-05-07&quot;;\tSimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-mm-dd&quot;);\tsdf.parse(s);//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。&#125;\n自定义异常\npublic class 类名 extends Exception&#123;    无参构造    带参构造&#125;public class ScoreException extends Exception&#123;    public ScoreException()&#123;&#125;    public ScoreException(message)&#123;        super(message);//把 message 传给父类处理    &#125;&#125;//异常类的使用public class Teacher throws ScoreException&#123;    public void checkScore(int score)    &#123;        if(score&lt;0||score&gt;100)&#123;            throw new ScoreException(&quot;输入分数有误！请重新输入&quot;);//throw 不是 throws!            /*throw 写在方法体内，throws 写在类定义里。            throws 不一定有异常，而 throw 一定是抛出了异常。*/        &#125;        else            System.out.println(&quot;分数正常&quot;);    &#125;&#125;public static void main(String[] args)&#123;    Scanner sc=new Scanner(System.in);    int score=sc.nextInt();    Teacher t=new Teacher();    try&#123;//调用方法时，要处理抛过来的异常        t.checkScore(score);    &#125;    catch(ScoreException e)&#123;        e.printStackTrace();    &#125;&#125;//异常时就会输出：异常类型 ScoreException，异常原因&quot;输入分数有误！请重新输入&quot;，异常位置。\n集合进阶\ngraph LR\nA[集合]-->C[Collection]\nA-->M[Map]\nC-->L[List]\nC-->S[Set]\nL-->AL(ArrayList)\nL-->LL(LinkedList)\nS-->HS(HashSet)\nS-->TS(TreeSet)\nM-->HM(HashMap)\n其中方形的是接口，圆角的是实现类。\n因此先学习 Collection 和 Map 接口后，只需要学习下一级的特有的部分。\n数据结构\n\n\n栈：后入先出 FILO。\n\n\n队列：先入先出 FIFO。\n\n\n数组：可以根据索引查找，查找效率高；增删效率低。\n\n\n链表：每个结点存储数据和下一个结点的地址值。最后一个结点地址值为空。相比数组，增删只需要修改增删处前后结点的地址值，效率更高。但是查询必须从头开始，效率低。\n\n\n树。\n\n\n红黑树。\n\n添加节点优先是添加红色的（不影响简单路径的黑色节点数，调整次数少）。\n\n红黑树对平衡要求性低一些（最长路径不超过最短路径的2倍），所以插入数据的时候需要的旋转次数平均下来更少。适用于频繁插入删除操作。\n\n\nCollection\njava.util.Collection\nCollection 是单例集合的最高级接口。他表示一组对象，这些对象也被称为 Collection 的元素。\n无法直接实现。可以用多态的方式实现。\nCollection&lt;String&gt; c=new ArrayList&lt;String&gt;();//add(E e) 方法添加元素c.add(&quot;Hello&quot;);c.add(&quot;World&quot;);System.out.println(c);//输出[&#x27;Hello&#x27;,&#x27;World&#x27;]，因为 ArrayList 中重写了 toString 方法，所以得到的不是一串地址\n\n\n\n方法\n说明\n\n\n\n\nboolean add(E e)\n添加元素，永远返回 true\n\n\nboolean remove(Object o)\n从集合中移除指定的元素，成功移除返回 true\n\n\nvoid clear()\n清空集合中的元素\n\n\nboolean contains(Object o)\n判断集合中是否存在指定的元素\n\n\nboolean isEmpty()\n判断集合是否为空\n\n\nint size()\n集合长度\n\n\n\n快捷键：Alt+7，能看到类的所有信息\n迭代器 iterator\njava.util.Iterator\nIterator 是一个接口。使用 Iterator 迭代器遍历集合元素。\nIterator&lt;String&gt; it=c.iterator();//通过集合对象中的迭代方法获取对象\n追根溯源可以得知，Collection.iterator()方法返回的是一个实现了 Iterator 接口的类：Itr.\n所以实际上是通过多态的方式实例化的。\n\n\n\n方法\n说明\n\n\n\n\nE next()\n返回下一个元素（越界访问：NoSuchElementException，被请求的元素不存在）并移动指针到下一个位置\n\n\nboolean hasNext()\n如果存在下一个元素，返回 true\n\n\n\nwhile(it.hasNext())&#123;    String s=it.next();//这样更好一些，因为元素可能还要做其他操作    System.out.println(s);&#125;\nit.next() 像指针一样从0开始遍历。\n并发修改异常\n当不允许这样的修改时，会抛出此方法。\n如：在使用 iterator 遍历过程中，在集合中添加了新的元素。\niterator 调用 next() 方法时，会先调用 checkForComodification() 方法。\ncheckForComodification() 会检验 modCount 修改集合的次数和expectedModCount 预期修改集合的次数是否相等。\nmodCount 来自于 ArrayList 的父类：AbstractList，初始值为0.每次使用 add() 方法时，modCount 就会++。\nexpectedCount 来自于 Itr 类，且初始值为 expectedCount=modCount.\n每次实例化一个 Iterator 类，都会调用其子类 Itr 类，使得 expectedCount 等于当前的 modCount。\n然后遍历过程中每次调用 next() 方法时，都会先检查一下expectedCount==modCount，即集合有没有被修改。如果没有修改就可以顺利地返回下一个元素；如果有异常 checkForComodificationException，就会终止运行。\ngraph TB\nC[Collection]-->|获取迭代对象|I[iterator]\nC-->|多态|Arr[Arraylist]\nI-->|多态|Itr[Itr]\nA-->W{\"iterator.hasNext()==true\"}\nItr-->A(expectedCount=modCount)\nW-->|no|en(遍历结束)\nW-->|yes|N(\"iterator.next()\")\nN-->cf(\"checkForComodification()\")\ncf-->cfe{\"expectedCount==modCount\"}\n\nX-->W\ncfe-->|no|Y(checkForComodificationException)\ncfe-->|yes|X(\"集合没有被修改,继续遍历\")\n\n但是通过 for 循环遍历集合，在遍历过程中对集合进行修改，不会报异常。\nList\njava.util.List\n继承自 Collection 类，可以使用其中的方法。\nList 是有序、有索引的。相较于集合 Set，List 中的元素可以重复。\nList&lt;String&gt; l=new ArrayList&lt;String&gt;();l.add(&quot;Hello&quot;);l.add(&quot;World&quot;);System.out.println(l);//按存储的顺序输出，[&quot;Hello&quot;,&quot;World&quot;]\n\n\n\n方法\n说明\n\n\n\n\nvoid add(int index,E element)\n感觉并不用解释\n\n\nE remove(int index)\n\n\n\nE set(int index,E element)\n\n\n\nE get(int index)\n\n\n\n\n越界报错 IndexOutOfException。\n另一种遍历集合的方法是 for 循环。\nfor(int i=0;i&lt;l.size();i++)System.out.println(l.get(i));\nList Interator\n通过 List 中的 listInterator() 方法得到。可以从各个方向遍历，迭代期间可以修改列表，还可以获取列表迭代器的当前位置。\n\n\n\n方法\n说明\n\n\n\n\nboolean hasNext()\n\n\n\nE next()\n\n\n\nboolean hasPrevious()\n反向遍历用到\n\n\nE previous()\n反向遍历用到\n\n\nvoid add(E e)\n添加元素，注意是通过 listInterator 添加的，不是通过集合添加的！\n\n\n\n\n\n\n\nList&lt;String&gt; l=new ArrayList&lt;String&gt;();l.add(&quot;Hello&quot;);l.add(&quot;World&quot;);l.add(&quot;java&quot;);ListInterator&lt;String&gt; li=l.listInterator();//实际上是 listItr 类作为 listInterator 类的子类，通过多态实现while(li.hasNext())&#123;    System.out.println(l.next());&#125;while(li.hasPrevious())&#123;    System.out.println(l.previous());&#125;while(li.hasNext())&#123;    String s=l.next();    if(s.equals(&quot;World&quot;))&#123;        li.add(&quot;!!!&quot;);//特别注意，并不是调用了l的 add() 方法，而是 li 的 add() 方法！    &#125;    System.out.println(s);&#125;\n在 listItr 类中的 add() 方法，添加完元素之后，有一句expectedModCount=modCount;重新把实际修改值赋给了预期修改值。因此 next() 方法中判断expectedModCount==modCount，即使添加了新元素也仍然是 true. 不会发生并发修改异常。这就是为什么要特殊强调这里的 add 和 List 自身的 add 不一样。\n增强 for\nfor(E e:数组或 Collection 的集合)&#123;\t//在这里使用变量e，把其当做集合元素来用&#125;for(int i:arr)&#123;    System.out.println(i);&#125;for(int i:list)&#123;    System.out.println(i);&#125;//内部是一个 iterator 迭代器，不可以中途修改数据，会引发并发修改异常。\n几种遍历方式的选择\n单纯的遍历：增强 for 最简单。\n需要用到索引：普通 for。\n迭代器也要会用。\nArrayList 底层数据结构是数组，LinkedList 底层数据结构是双向链表。\n用法一模一样，查询效率高就用 ArrayList，增删效率高用 LinkedList。\nArrayList\n实现原理：\n底层先创建一个长度为0的数组。\n添加第一个元素的时候底层扩容为一个长度为10的连续存储区域的数组。指针指向下一个要存入的数据的位置。\n后续继续添加元素，直到装满的时候，整个数组扩容1.5倍（在其他地方开辟一片1.5倍原数组长度的区域，并且把原来的数据全部拷贝进去）。\n如果一次添加多个元素超过扩容后的1.5倍的数量，则按照新添加元素数量来扩容数组。\n\n方法的话没什么特殊的。\nLinkList\n双向链表，有很多操作首尾元素的特殊方法。\n\n\n\n方法\n说明\n\n\n\n\npublic void addFirst(E e)\n这些含义都比较明显就不多赘述了\n\n\npublic void addLast(E e)\n\n\n\npublic E getFirst()\n\n\n\npublic E getLast()\n\n\n\npublic void removeFirst()\n\n\n\npublic void removeLast()\n\n\n\n\n工作原理：\n\n泛型\n之前在介绍 ArrayList 的时候简单介绍过，泛型用于编译阶段约束操作的数据类型，如 ArrayList&lt;String&gt; arrayList=new ArrayList&lt;&gt;(); 就只能存入 String 包装类型了。只能存入指定的泛型数据类型或者其子类（多态）。\n如果集合没有限制泛型类型，那么传入什么类型的对象都可以，ArrayList arrayList=new ArrayList&lt;&gt;(); 传一个 Integer，传一个 String，传一个 Student……（默认 Object 类型，多态）\n但是多态的弊端在于没法使用子类中的特有自定义方法。迭代器的类型也和泛型定义的一样。\n但是其实 java 中的泛型是伪泛型。就是只在编译阶段检查，其实泛型检查相当于一个保安大爷。编译阶段会简单判断一下你传入的数据是否都符合泛型数据类型，符合才让存；但是存进去的时候还是按照 Object 类型存入的。只不过取出数据准备处理的时候多做了一步操作，就是将 Object 类型的数据再转化为对应的泛型数据类型。\n为什么这样做？因为泛型的概念是 JDK 1.5 才提出的，在之前的集合是没有泛型的，而新版本要尽可能向下兼容（因为之前已经诞生了很多 java 代码了，如果全部改成按指定泛型存入数据类型，之前很多旧版本的代码就用不了了，都要改）。\n其实这也解释了为什么泛型不能设定为基本数据类型如 int char 这些，因为这些类型存入的时候无法转换为 Object 类型）\n泛型的几种应用场景\n泛型类：当不确定数据类型的时候使用。\n\n字母写什么都行，不过上面这四个比较常见。\n比如下面这个是一个自定义的泛型类：\npublic class MyArrayList&lt;E&gt; &#123;    Object[] obj = new Object[10];    int size;    /*     * E：表示是不确定的类型。该类型在定义类的时候已经定义过了。     * e：形参的名字，变量名     */    public boolean add(E e) &#123;        obj[size] = e;        size++;        return true;    &#125;    public E get(int index) &#123;        return (E) obj[index];    &#125;    @Override    public String toString() &#123;        return Arrays.toString(obj);    &#125;&#125;\n泛型方法：如果类里面只有一个方法要用到泛型变量，推荐使用这种方法。\n\n/** * 参数一：集合 * 参数二~最后：要添加的元素 */public static &lt;E&gt; void addAll(ArrayList&lt;E&gt; list, E e1, E e2, E e3, E e4) &#123;    list.add(e1);    list.add(e2);    list.add(e3);    list.add(e4);&#125;\n传入该数据类型的集合变量后，后续几个变量都会自动检测是否和集合变量同类型。\nArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();ListUtil.addAll(list, &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;, &quot;ddd&quot;);\n其实也可以传入可变参数 (E… e) 不限制传入参数个数。\n泛型接口：\n\npublic class MyArrayList2 implements List&lt;String&gt;&#123;&#125;public class MyArrayList3&lt;E&gt; implements List&lt;E&gt; &#123;&#125;\n泛型不具备继承性\n但是数据具备继承性。\n比如定义了 public static void method(ArrayList&lt;Ye&gt; arrayList)，Ye 是 Fu 的父类，Fu 是 Zi 的子类，那么：\n// 创建集合的对象ArrayList&lt;Ye&gt; list1 = new ArrayList&lt;&gt;();ArrayList&lt;Fu&gt; list2 = new ArrayList&lt;&gt;();ArrayList&lt;Zi&gt; list3 = new ArrayList&lt;&gt;();// 调用 method 方法// method(list1);// 下面这些方法报错，泛型方法必须传入完全一样数据类型的变量// method(list2);// method(list3);// 这种使用方法不报错，数据具有继承性list1.add(new Ye());list1.add(new Fu());list1.add(new Zi());\n那么怎么传入多种数据类型的变量呢？method 定义成 method(ArrayList&lt;E&gt; arrayList) 这样就什么数据类型都能传了。但是我们没法只限制某一类特殊的类，比如“我只想接收 Ye Fu Zi 类的集合”，办不到，只能所有引用类型都接收。\n要想限制成部分类，需要使用泛型通配符。\npublic static void method(ArrayList&lt;? extends Ye&gt; arrayList 是继承自爷的所有类包括爷可以传入。\npublic static void method(ArrayList&lt;? super Ye&gt; arrayList 是 Fu 的所有父类包括 Fu 可以传入。\nSet\nList 有序，可重复，有索引。Set 无序（存取顺序不一定一样），不重复，无索引。\nHashSet\n增删改查性能都不错。\nJDK8 之前的版本底层是数组+链表实现。JDK8 之后是数组+链表+红黑树实现，做了优化。\n添加元素时存储位置参考哈希值：\n\n加载因子用于判断数组什么时候扩容，比如上例是存入了 16*0.75=12 个元素之后扩容。\n这也解释了为什么 Set 遍历无序（按数组顺序遍历，但是对应的是哈希值从小到大遍历，不一定是存入顺序）\n默认是使用 Object 里面的 hashCode() 方法，利用对象的地址计算哈希值（不同的对象哈希值一定不同），一般会重写 hashCode 方法，根据对象属性计算哈希值（可以 IDEA 快捷生成），使得只要对象的属性相同，计算得到的哈希值就相同。\n不同的地址值或者对象属性值计算哈希值也有小概率会相等，这叫做哈希碰撞。\nString 和 Integer 类型 在 Java 里面已经重写好了 equals 和 hashCode 方法，不需要重写。\nLinkedHashSet\n有序（存取顺序一致），无重复，无索引。\n额外用一个双链表记录元素存储顺序。\n数据去重默认使用 HashSet，如果还有有序需求再使用 LinkedHashSet.\nTreeSet\n不重复，无索引，可排序。\n数据存进去就默认被排序了。数值类型从小到大排序，字符类型按 ASCII 码升序排序。\n但是如果是自定义的对象，直接传入 TreeSet 是无法传入的会报错，因为默认没有写比较方法，尝试使用排序函数也会获得一样的结果。\n第一种排序方式：\n首先要让自定义类 implements Comparable ，如 public Student implements Comparable&lt;Student&gt; 因为这里我们已经确定了要比较的类型就是 Student 类型所以不用泛型 E。\n比较方法重写如下：\n@Overridepublic int compareTo(Student o) &#123;    // 指定排序的规则    // 只看年龄，我想要按照年龄的升序进行排列    return this.getAge() - o.getAge();&#125;\n然后就可以排序了。当然也可以自己修改逻辑规则比如先按照姓名字符串排序，相等的话再按年龄……\n排序的话只重写 compareTo 就可以了，不需要重写 hashCode 和 equals 方法。这两个方法是用于 HashSet 的。\n排序结构是红黑树。\n第二种排序方式：\n创建集合对象的时候，传递比较器进行比较。\n/*需求：请自行选择比较器排序和自然排序两种方式；要求：存入四个字符串 “c”, “ab”, “df”, “qwer”按照长度排序，如果一样长则按照首字母排序采取第二种排序方式：比较器排序*/// 1. 创建集合TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;    @Override    public int compare(String o1, String o2) &#123;        // 按照长度排序        int i = o1.length() - o2.length();        // 如果一样长则按字母顺序        i = i == 0 ? o1.compareTo(o2) : i;        return i;    &#125;&#125;);// 或者 lambda 表达式：TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;((o1, o2) -&gt; &#123;    // 按照长度排序    int i = o1.length() - o2.length();    // 如果一样长则按照首字母排序    i = i == 0 ? o1.compareTo(o2) : i;    return i;&#125;);\nComparator 优先级高于 compareTo，对于 Integer 和 String java 已经定义好 compareTo 的情况我们又不想修改源码，就可以使用 Comparator 来重新设置排序方法。\nList Set 集合使用场景总结\nArrayList：元素可重复，随机存取。\nLinkedList：元素可重复，且增删操作数量明显多于查询。\nHashSet：对集合中的元素去重。\nLinkedHashSet：去重，而且保证存取顺序。\nTreeSet：去重，且排序。\n后续也可以使用 List + 排序方法实现排序。\nMap 双列集合\n双列指的是键值对，添加一条数据需要同时添加键和值两个数据。键不能重复。键和值一一对应。在 Java 中键值对整体被称作”Entry 对象“。\nSet 的底层源码都和 Map 有关。\nMap 常用 API 一览：\n\n\n\n方法签名\n说明\n\n\n\n\nV put(K key, V value)\n添加元素. 默认返回 null，如果该键已经存在则会覆盖旧值，返回旧值\n\n\nV remove(Object key)\n根据键删除键值对元素\n\n\nvoid clear()\n移除所有的键值对元素\n\n\nboolean containsKey(Object key)\n判断集合是否包含指定的键\n\n\nboolean containsValue(Object value)\n判断集合是否包含指定的值\n\n\nboolean isEmpty()\n判断集合是否为空\n\n\nint size()\n集合的长度，即键值对的个数\n\n\n\n和集合有些区别，比如 add 变成了 put，contains 变得复杂了。\nMap&lt;String, String&gt; m = new HashMap&lt;&gt;();\n","categories":["算道求索（课外IT技能学习）","Lecture"],"tags":["Java"]},{"title":"项目学习：黑马点评","url":"/2025/05/21/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/","content":"黑马点评项目介绍\n类似大众点评。\n要实现的功能：\n\n项目导入\n基础代码，数据库等，不过多赘述。\n\n项目架构\n不是微服务是单体架构模式，因为重点还是在 Redis 学习上。Springboot 那个课涉及微服务实战，我后面应该也会学习一下。\n架构图如下，前后端分离，开发完成后前后端分别部署在 Nginx 和 Tomcat 上。\ngraph LR\n    K1[客户端]\n    K2[客户端]\n    K3[客户端]\n    K1-->N[前端Nginx]\n    K2-->N\n    K3-->N\n    N-->T[后端Tomcat]\n    subgraph Redis 集群\n        R1[Redis]\n        R2[Redis]\n        R3[Redis]\n        end\n    T-->R1\n    T-->R2\n    T-->R3\n    subgraph MySQL 集群\n    \tM1[MySQL]\n    \tM2[MySQL]\n    \tM3[MySQL]\n    end\n    T-->M1\n    T-->M2\n    T-->M3\n后期这个项目可能还会做一些水平横向扩展，比如多 Tomcat 集群数据共享等，后面再扩展。\n导入 nginx 前端，mysql 数据库及 java 后端服务器运行后就可以看到如下所示：\n\n短信登录\nSession 实现\n首先用 Session 尝试实现一下。\ngraph TD\n\n%% 校验登录状态\nsubgraph 校验登录状态\n    C1[开始] --> C2[请求并携带 cookie]\n    C2 --> C3[从 session 获取用户]\n    C3 --> C4{判断用户是否存在}\n    C4 -- 有 --> C5[保存用户到 ThreadLocal]\n    C5 --> C6[放行]\n    C6 --> C7[结束]\n    C4 -- 没有 --> C8[拦截]\n    C8 --> C7\nend\n\n%% 短信验证码登录/注册\nsubgraph 短信验证码登录/注册\n    B1[开始] --> B2[提交手机号和验证码]\n    B2 --> B3{校验验证码}\n    B3 -- 不一致 --> B2\n    B3 -- 一致 --> B4[根据手机号查询用户]\n    B4 --> B5{用户是否存在}\n    B5 -- 不存在 --> B6[创建新用户]\n    B6 --> B7[保存用户到数据库]\n    B7 --> B8[保存用户到 session]\n    B5 -- 存在 --> B8\n    B8 --> B9[结束]\nend\n\n%% 发送短信验证码\nsubgraph 发送短信验证码\n    A1[开始] --> A2[提交手机号]\n    A2 --> A3{校验手机号}\n    A3 -- 不符合 --> A2\n    A3 -- 符合 --> A4[生成验证码]\n    A4 --> A5[保存验证码到 session]\n    A5 --> A6[发送验证码]\n    A6 --> A7[结束]\nend\n其他地方都比较好理解。保存用户到 ThreadLocal 是因为每次访问用户信息都要访问 session。\n发送短信验证码\n点击用户登录界面，输入手机号尝试发送短信，根据发送链接 xxx/user/code?phone=xxx 可以看出请求路径是 /user/code，请求参数是电话号码，无返回值。\n在 UserController 类文件中可以看到这个待完成的函数 public Result SendCode，具体的发送短信请求还是交给 userService 去实现的，所以我们这里补全这个函数将任务交给 userService：\n// controller/UserController.java@Resourceprivate IUserService userService;@Resourceprivate IUserInfoService userInfoService;/** * 发送手机验证码 */@PostMapping(&quot;code&quot;)public Result sendCode(@RequestParam(&quot;phone&quot;) String phone, HttpSession session) &#123;    // TODO 发送短信验证码并保存验证码    return userService.sendCode(phone, session);&#125;\n源代码中，有一个 IUserService 接口里面声明了所有需要实现的 UserService 方法（目前是空的），然后 UserServiceImpl 类继承自 ServiceImpl 类实现了 IUserService。所以通过 IDEA 快速补全，我们先在 IUserService 里面添加一个待实现的 sendCode 方法，然后再在 UserServiceImpl 里面实现。\n// service/IUserService.javapublic interface IUserService extends IService&lt;User&gt; &#123;    Result sendCode(String phone, HttpSession session);&#125;\n// service/impl/UserServiceImpl.java@Service@Slf4j // 用于 log.debug 传递多个参数public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService &#123;    @Override    public Result sendCode(String phone, HttpSession session) &#123;        // 根据流程图分析步骤        // 1. 校验手机号        // 2. 如果不符合，返回错误信息        // 在老师提供的 utils 工具类里面有校验手机号的正则表达式        if(RegexUtils.isPhoneInvalid(phone))&#123;            return Result.fail(&quot;手机号格式错误&quot;);        &#125;        // 3， 如果符合，生成验证码        // 随机生成6位数字        String code = RandomUtil.randomNumbers(6);        // 4. 保存验证码到 session        session.setAttribute(&quot;code&quot;, code);        // 5. 发送验证码        // 这里就和具体的运营商服务平台等等有关了，其实不算什么重点，就随便写一下代替一下        log.debug(&quot;发送验证码成功，验证码：&#123;&#125;&quot;, code);        // 6. 返回 ok        return Result.ok();    &#125;&#125;\n\n登录\n现在可以发送验证码了，用户收到验证码之后怎么校验登录呢？\n// controller/UserController.java/** * 登录功能 * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码 */@PostMapping(&quot;/login&quot;)public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session)&#123;    // TODO 实现登录功能    return userService.login(loginForm, session);&#125;\n// service/IUserService.javapublic interface IUserService extends IService&lt;User&gt; &#123;    Result sendCode(String phone, HttpSession session);    Result login(LoginFormDTO loginForm, HttpSession session);&#125;\n// service/impl/UserServiceImpl.java@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    // 1. 校验手机号。虽然之前发送验证码的时候已经校验过了，    // 但是现在用户填写完成验证码又改了一个错误的手机号再提交也是有可能的。所以有必要二次验证    String phone = loginForm.getPhone();    if(RegexUtils.isPhoneInvalid(phone))&#123;        return Result.fail(&quot;手机号格式错误&quot;);    &#125;    // 2. 校验验证码    Object cacheCode = session.getAttribute(&quot;code&quot;);    String code = loginForm.getCode();    if(cacheCode == null || !code.equals(cacheCode.toString()))&#123;        // 3. 不一致，报错        // 反向嵌套，避免越嵌套越深        return Result.fail(&quot;验证码错误&quot;);    &#125;    // 4. 一致，根据手机号查询用户 select * from user where phone = xxx    // 这个类继承自 ServiceImpl，由 mybatisplus 提供，可以实现方便的单表增删改查。    // 我们已经在 User 里面注解了对应的 MySQL 表是 tb_user，传给 ServiceImpl 就可以实现方便的 MySQL 操作    Object user = query().eq(&quot;phone&quot;, phone).one();    // 5. 判断用户是否存在    if(user == null)&#123;        // 6. 不存在，创建新用户，保存用户到数据库        // 其实创建用户大多数字段都不需要知道，先手机号，然后随机生成一个昵称就行了        user = createUserwithPhone(phone);    &#125;    // 7. 保存用户到 session    session.setAttribute(&quot;user&quot;, user);    // return 就不需要给用户 token 了，因为 session id 已经自动存在 cookie 里面了，用户带着 cookie 就能校验    return  Result.ok();&#125;private Object createUserwithPhone(String phone) &#123;    User user = new User();    user.setPhone(phone);    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));    // mybatis 修改数据库命令：    save(user);    return null;&#125;\n这样就可以实现登录校验功能了，不过我们会发现用户登录信息没有被成功保存，登陆之后再点击用户，还是需要输入手机号发验证码登录验证。\n登录校验拦截器\nxxx/user/me 是登录校验的请求，查询是否已经登录。\n按理来说我们应该在每个 Controller 里面补全代码，根据获取到的 cookie 里携带的 session id 去找到对应的 session，进而获取到对应的用户数据。但是有很多 Controller 可能都需要这样获取用户信息，所以这种写法就不太好。\n我们可以用拦截器处理：\ngraph LR\n    A[拦截器（统一入口）] --> B[OrderController]\n    A --> C[UserController]\n    A --> D[XxxController]\n然后拦截器校验完，按我们之前说的，把用户信息缓存到 ThreadLocal 里面供这些控制类取用。\n拦截器可以写在 utils 里面：\n// utils/LoginInterceptor.javapublic class LoginInterceptor implements HandlerInterceptor &#123;    // preHandle 实现：到达 Controller 之前执行，进行登录校验    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1. 获取 session        HttpSession session = request.getSession();        // 2. 获取 session 中的用户信息        Object user = session.getAttribute(&quot;user&quot;);        // 3. 判断用户是否存在        if(user == null)&#123;            // 4. 不存在，拦截。最好加一些标识.401 状态码表示未授权            response.setStatus(401);            return false;        &#125;        // 5. 存在，保存用户信息到 ThreadLocal。老师已经写好了：        UserHolder.saveUser((User) user);        // 6. 放行        return true;    &#125;    // postHandle 实现：Controller 执行完成之后执行，销毁用户数据避免内存泄露    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        UserHolder.removeUser();    &#125;&#125;\n拦截器做好了，接下来需要配置一个 MVC 使其生效。\n// config/MvcConfig.java@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    // 添加拦截器，并且除外一些不需要拦截的路径    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        // 其实有挺多用不到用户信息的，随便写一些做个示范。                        // 比如店铺信息，热门博客，用户发送验证码，用户登录这些其实都用不到用户的信息                        &quot;shop/xx&quot;,                        &quot;shop-type/xx&quot;,                        &quot;blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                        );    &#125;&#125;\n最后，再回到对应的控制类里面完善代码：\n// controller/UserController.java    @GetMapping(&quot;/me&quot;)    public Result me()&#123;        // 获取当前登录的用户并返回        User user = UserHolder.getUser();        return Result.ok(user);    &#125;\n运行，现在登录完就可以看到用户信息了：\n\n但是目前这样实现有一个非常严重的问题：\n\n是的密码也会返回。\n隐藏用户敏感信息\n我们再捋一下用户信息泄露的整个过程：\n\n用户信息在数据库里。\n登录校验后，从数据库中取得用户信息，存到 session 也就是 Tomcat 的内存空间里面，方便后续使用。\n校验登录状态：根据 cookie 传来的 session id，在 session 中找到对应存在的用户后，存到 ThreadLocal 里面方便后续使用。\n\n要不直接就不把密码什么的无用或者敏感信息存到 session 里面，也能节约内存空间，也安全？\n这里老师直接定义了一个类：UserDTO，里面只有用户 id 昵称 头像三个属性。所以我们存数据到 session 里面之前需要将 User 转成 UserDTO 类型。这里也可以直接用工具类实现：\n// service/impl/UserServiceImpl.java// public Result login(LoginFormDTO loginForm, HttpSession session)session.setAttribute(&quot;user&quot;, BeanUtil.copyProperties(user, UserDTO.class));\n相应的，取用户信息的时候也应该用 UserDTO 类型接着。包括 ThreadLocal 里面也应该改成存入 UserDTO 信息。\n这部分我就不一一阐述了，记不太清都有哪些要改了，反正就顺着改类型就行，UserDTO 也有 getId() 等方法。\n现在在开发者模式看获取到的 UserDTO 信息格式如下：\n\nSession 共享问题\nSession 是存在服务器自身的内存空间的，所以多台 Tomcat 不共享 Session。\n所以可能上一秒用户请求被负载均衡到服务器1，成功登陆，下一秒被负载均衡到服务器2又要重新登陆，非常影响使用体验。\n解决方法：其实也不难嘛，多服务器 session 拷贝就行吗？并不是，会有很多内存和时间上的损失，拷贝过程中如果用户发送请求可能也会出错。\n那么就需要找到 session 的替代方案，这个替代品需要满足：\n\n数据共享，因为我们就想解决这个问题。\n内存存储，因为要和 session 有差不多的性能。\n键值对形式，因为这种实现方法比较简单。\n\n答案就是 Redis 了。\nRedis 实现\n我们先盘点一下 Redis 实现相较 Session 实现的，不一样的问题：\n\n键值对设计。比如验证码，session 里面是让键=code 值=对应验证码数字，redis 我们可以让 String 表示验证码数字字符串，但是 key 不可以=“code”，因为 session 对于每个不同的客户端都不一样，所以不同客户端的 session 验证码属性都叫 code 也不冲突，但是 redis 是一个键唯一的数据库，所以不能不同客户端的 key 都叫 “code”。可以用手机号代替，手机号也是唯一标识：“phone:xxx” 这样。\n之前将用户数据保存到 session，我们的实现非常简单，直接存到 session，浏览器自动就把 session id 写到 cookie 里面，下次发过来的时候我们用 session id 去查找对应的 session 非常方便，但是换成 redis 这些部分就没有自动实现了，需要我们再根据用户提交的手机号作为 key 去 redis 数据库里查询。这个过程其实也顺带校验了手机号是否存在，因为把手机号作为 key，直接去 redis 里面查询 value，如果找不到对应的键值对，也说明了手机号错误。\n存储用户数据用什么数据类型？存储对象常见两种方式，一种是 String JSON 形式，另一种是 Hash 存储每个字段。推荐 Hash 方法，因为可以对每个字段进行 CRUD，并且内存占用更少。\n存储用户数据，键用什么？也可以用手机号，不过更推荐用 token （生成一个随机字符串）。当然，相比 session （浏览器自动将 session id 存入 cookie）的实现，我们还需要加一步，手动将 token 传回给前端保存，这样用户下次校验登录状态时该客户端才能拿着一样的 token 来取数据。而且相较于手机号更安全，前端可见。\n\n\n修改代码部分，首先我们要将 UserServiceImpl.java 里面的 session 实现转化为 Redis 实现，主要还是之前说的问题，Redis 里面的键值怎么存，怎么保存到浏览器中。\n// service/impl/UserServiceImpl.java@Overridepublic Result sendCode(String phone, HttpSession session) &#123;    //...        // 4. 保存验证码到 redis  // set key value ex 120    // stringRedisTemplate.opsForValue().set(&quot;login:code:&quot; + phone, code, 2, TimeUnit.MINUTES);    // 不过这里我们在 RedisConstant 里定义一下常量，这样方便一些    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);    \t//...&#125;@Overridepublic Result login(LoginFormDTO loginForm, HttpSession session) &#123;    // ...    // 2. 校验验证码    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);    String code = loginForm.getCode();    if(cacheCode == null || !code.equals(cacheCode))&#123;        // 3. 不一致，报错        // 反向嵌套，避免越嵌套越深        return Result.fail(&quot;验证码错误&quot;);    &#125;    // ...    // 7. 保存用户到 redis    // 7.1 随机生成 token，作为登录令牌    String token = UUID.randomUUID().toString(true);    // 7.2 将 User 对象转为 Hash 存储    UserDTO userDTO =  BeanUtil.copyProperties(loginForm, UserDTO.class);    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);    // 7.3 存储    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token, userMap);    // 7.4 设置有效期    stringRedisTemplate.expire(LOGIN_USER_KEY+token, LOGIN_USER_TTL, TimeUnit.MINUTES);    // return 返回 token    return  Result.ok(token);&#125;\n这里还有一个额外的问题，就是 token 有效期这里我们设定的是登录过后30分钟过期，实际上一般 session 的默认配置是“30分钟无活动后过期”，比如我登陆之后访问一下“我的”用户界面，这就算有一次活动，重新计时30分钟后再过期，只不过之前这部分是 session 自动完成，我们需要手动修改。\n也就是每次访问用户状态，都要重新更新 token 有效期，很明显这部分代码在拦截器中实现。\n// utils/LoginInterceptor.javapublic class LoginInterceptor implements HandlerInterceptor &#123;    private StringRedisTemplate stringRedisTemplate;        public LoginInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    // preHandle 实现：到达 Controller 之前执行，进行登录校验    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1. 获取请求头中的 token        String token = request.getHeader(&quot;authorization&quot;);        if (StrUtil.isBlank(token)) &#123;            response.setStatus(401);            return false;        &#125;        // 2. 基于 token 获取 redis 中的用户信息        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY+token);        // 3. 判断用户是否存在        if(userMap.isEmpty())&#123;            // 4. 不存在，拦截。最好加一些标识.401 状态码表示未授权            response.setStatus(401);            return false;        &#125;        // 5. 将查询到的 Hash 数据转化为 UesrDTO 对象        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);                // 6. 存在，保存用户信息到 ThreadLocal。老师已经写好了：        UserHolder.saveUser(userDTO);        // 7. 刷新 token 有效期        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);        // 8. 放行        return true;    &#125;    // postHandle 实现未修改，仍然就是一个简单的 UserHolder remove&#125;\n总结一下 Redis 实现需要注意的几个点，1 在于数据类型选择（key String, value Hash 因为可以单独对字段修改，占用内存空间小）；2  在于选择合适的 key 标识（user:login:token:xxx），自己可以方便找到；3 在于合适的存储粒度，UserDTO 并不是存储全部 User 信息的，节省内存空间的同时也更安全。\n状态登录刷新问题\n不过目前还有一个问题。我们这个拦截器是只有“和用户信息有关的请求”才会工作，比如我访问商户信息，这个用户信息拦截器不工作，没问题吧。\n但是我们的 token 刷新机制是写在拦截器里面的，也就是说：\n\n用户不断访问用户信息页面，则 token 不断刷新，一直登录，没问题。\n用户一直没有访问用户信息界面，比如用户一直在看商家信息，则 token 一直没刷新直到过期退出登录了，这样其实也挺影响用户体验的，用户说我一直在用 app 怎么还给我退出登录了。\n\n解决方式：我们可以加两个拦截器。一级拦截器实际上不拦截任何东西，他只是会处理一些所有请求都会触发的工作，像 token 刷新这种所有请求都会触发的方法就放在一级拦截器中。还有查询 Redis 用户，不存在则创建，然后放到 ThreadLocal 缓存里这种操作也可以放到一级拦截器里面。二级拦截器才处理和用户信息有关的请求，在 ThreadLocal 里面查询对应用户，不存在则拦截。\nflowchart TB\n    subgraph 拦截器A[拦截器：一切路径]\n        A1[获取 token]\n        A2[查询 Redis 的用户]\n        A3[保存到 ThreadLocal]\n        A4[刷新 token 有效期]\n        A5[放行]\n        A1 --> A2 --> A3 --> A4 --> A5\n    end\n\n    subgraph 拦截器B[拦截器：需要登录的路径]\n        B1[查询 ThreadLocal 的用户]\n        B2{用户是否存在？}\n        B2 -- 不存在，拦截 --> B3[拦截]\n        B2 -- 存在，继续 --> B4[放行]\n        B1 --> B2\n    end\n\n    A5 --> B1\n\n    %% 控制器调用链\n    B4 --> C1[OrderController]\n    B4 --> C2[UserController]\n    B4 --> C3[XxxController]\n\n    %% 样式设置（可选）\n    style A1 fill:#fff,stroke:#d43f3a,color:#000\n    style A2 fill:#fff,stroke:#d43f3a,color:#000\n    style A3 fill:#fff,stroke:#d43f3a,color:#000\n    style A4 fill:#fff,stroke:#d43f3a,color:#000\n    style A5 fill:#fff,stroke:#d43f3a,color:#000\n    style B1 fill:#fff,stroke:#d43f3a,color:#000\n    style B2 fill:#fff,stroke:#d43f3a,color:#000\n    style B3 fill:#fdd,stroke:#d43f3a,color:#000\n    style B4 fill:#dfd,stroke:#5cb85c,color:#000\n新建一个拦截器 RefreshTokenInterceptor，把查询用户，缓存，Token 刷新，Controller 执行完成后删除缓存的功能全放进去（并且不需要拦截了，比如如果用户为空，直接放行，给 LoginInterceptor 让它判断是否拦截）：\n// utils/RefreshTokenInterceptor.javapublic class RefreshTokenInterceptor implements HandlerInterceptor &#123;    private StringRedisTemplate stringRedisTemplate;    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    // preHandle 实现：到达 Controller 之前执行，进行登录校验    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1. 获取请求头中的 token        String token = request.getHeader(&quot;authorization&quot;);        if (StrUtil.isBlank(token)) &#123;            return true;        &#125;        // 2. 基于 token 获取 redis 中的用户信息        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY+token);        // 3. 判断用户是否存在        if(userMap.isEmpty())&#123;            return true;        &#125;        // 5. 将查询到的 Hash 数据转化为 UesrDTO 对象        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);                // 6. 存在，保存用户信息到 ThreadLocal。老师已经写好了：        UserHolder.saveUser(userDTO);        // 7. 刷新 token 有效期        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);        // 8. 放行        return true;    &#125;    // postHandle 实现：Controller 执行完成之后执行，销毁用户数据避免内存泄露    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;        UserHolder.removeUser();    &#125;&#125;\n而 LoginInterceptor 就简单多了：\n// utils/LoginInterceptor.javapublic class LoginInterceptor implements HandlerInterceptor &#123;    // preHandle 实现：到达 Controller 之前执行，进行登录校验    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        // 1. 获取请求头中的 token        if(UserHolder.getUser()==null)&#123;            // 4. 不存在，拦截。最好加一些标识.401 状态码表示未授权            response.setStatus(401);            return false;        &#125;        // 8. 放行        return true;    &#125;&#125;\nMVC Config：\n// config/MvcConfig.java@Configurationpublic class MvcConfig implements WebMvcConfigurer &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    // 添加拦截器，并且除外一些不需要拦截的路径    // 这里我们期望 RefreshTokenInterceptor 是一级拦截器，LoginInterceptor 是二级拦截器    // RefreshTokenInterceptor 优先级 &gt; LoginInterceptor    // 如何实现？其实默认添加拦截器的时候，优先级都是0，默认按照添加顺序优先添加的优先级更大    // 这里为了保险，老师还是单独给每个拦截器赋值优先级了    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 登录拦截器        registry.addInterceptor(new LoginInterceptor())                .excludePathPatterns(                        // 其实有挺多用不到用户信息的，随便写一些做个示范。                        // 比如店铺信息，热门博客，用户发送验证码，用户登录这些其实都用不到用户的信息                        &quot;shop/xx&quot;,                        &quot;shop-type/xx&quot;,                        &quot;blog/hot&quot;,                        &quot;/user/code&quot;,                        &quot;/user/login&quot;                        ).order(1);        // token 刷新拦截器        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).addPathPatterns(&quot;/**&quot;).order(0);    &#125;&#125;\n现在，即便是在商户页面刷新，也可以看到 Redis 里面 Token TTL 时长也是恢复到30分钟后才过期了。\n商户查询缓存\n缓存介绍\n缓存就是数据交换的临时缓冲区，数据读写效率较高。比如 CPU 中的缓存区域读写速度远大于内存，硬盘；前端概念上，浏览器也可以缓存一些图片等内容，大大降低加载时间，缓存未命中的内容才会去 Tomcat 找。\nTomcat 应用层上也可以添加一些缓存，比如典型的 Redis 数据库。没命中的数据才会去 MySQL 里面查询。\nMySQL 里面也可以建立缓存，也就是索引。建立索引后查找速度大大提高。\n然后最终数据查找还是落到 CPU 和磁盘，CPU 也有多级缓存，磁盘也有读写缓存……\n缓存的好处非常明显，如降低后端负载，提高读写效率等。但随之而来的成本也会提高。如数据一致性成本，数据库数据更新了缓存中数据也要实时更新确保一致性；代码维护成本，缓存击穿等问题；运维成本，集群服务器维护，硬件等……\n所以对于中小型企业可能缓存并不必要。\n商户查询流程分析\n添加缓存\n我们打开一个商户页面，可以看到：\n\nshop/商户id 就是对应的接口，里面 data 数据还是挺多的，我们需要给这个接口添加缓存。\n那么我们去对应的 ShopController.java 文件里面查看对应代码：\n@Resourcepublic IShopService shopService;/** * 根据id查询商铺信息 * @param id 商铺id * @return 商铺详情数据 */@GetMapping(&quot;/&#123;id&#125;&quot;)public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;    return Result.ok(shopService.getById(id));&#125;\n这里也是基于 mybatis 的 MySQL 查询。\n我们的缓存逻辑就是：\n缓存作用模型：\nflowchart LR\n\nA1[客户端] --> A2[请求]\nA2 --> A3[Redis]\nA3 -->|命中| A4[返回数据]\nA3 -->|未命中| A5[数据库]\nA5 --> A6[写缓存]\nA6 -.-> A3\nA5 --> A4\n查询流程: 根据 ID 查询商铺缓存\nflowchart LR\nB1[开始] --> B2[提交商铺 ID]\nB2 --> B3[从 Redis 查询商铺缓存]\nB3 --> B4{缓存是否命中？}\nB4 -- 命中 --> B5[返回商铺信息]\nB4 -- 未命中 --> B6[根据 ID 查询数据库]\nB6 --> B7{商铺是否存在？}\nB7 -- 不存在 --> B8[返回 404]\nB7 -- 存在 --> B9[将商铺数据写入 Redis]\nB9 --> B5\nB5 --> B10[结束]\nB8 --> B10\n实现起来也并不难：\n// controller/ShopController.java    /**     * 根据id查询商铺信息     * @param id 商铺id     * @return 商铺详情数据     */    @GetMapping(&quot;/&#123;id&#125;&quot;)    public Result queryShopById(@PathVariable(&quot;id&quot;) Long id) &#123;        // 还是给对应的服务类处理        return shopService.queryById(id);    &#125;\n// service/impl/ShopServiceImpl.java@Servicepublic class ShopServiceImpl extends ServiceImpl&lt;ShopMapper, Shop&gt; implements IShopService &#123;    @Resource    private StringRedisTemplate stringRedisTemplate;    public ShopServiceImpl(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public Result queryById(Long id) &#123;        // 1. 从 Redis 查询商铺缓存        // 这里为什么改用 String，完全是老师为了每种方法都让我们看一遍，hash 还是优于 string 的        String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);        // 2. 判断是否存在        if(StrUtil.isNotBlank(shopJson))&#123;            // 3. 存在，直接返回            Shop shop = JSONUtil.toBean(shopJson, Shop.class);            return Result.ok(shop);        &#125;        // 4. 不存在，查数据库判断是否存在        Shop shop = getById(id);        // 5. 不存在，返回错误        if(shop == null)&#123;            return Result.fail(&quot;商户不存在！&quot;);        &#125;        // 6. 存在，添加到 Redis 商铺缓存中，并返回        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop));        return Result.ok(shop);    &#125;&#125;\n说实话加载速度优化没看出来（毕竟其实还有一个同时查询优惠券的操作，那个是一定会去 MySQL 里面查询的），反正 Redis 里是缓存了数据了，证明正确运行了。\n\n然后老师布置的作业是自己把首页的 shop-list 设置缓存机制，就是这10个图标：\n\n因为这些是静态不变的所以特别适合被做成缓存。\n没啥难点，非要说的话其实就是它们的数据类型是 Collection 集合类型，需要琢磨一下类型转换。\n// service/impl/ShopTypeServiceImpl.java@Servicepublic class ShopTypeServiceImpl extends ServiceImpl&lt;ShopTypeMapper, ShopType&gt; implements IShopTypeService &#123;    private final StringRedisTemplate stringRedisTemplate;    public ShopTypeServiceImpl(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public Result queryTypeList() &#123;        String shopTypeJson = stringRedisTemplate.opsForValue().get(&quot;cache:shop-type-list&quot;);        if (StrUtil.isNotBlank(shopTypeJson)) &#123;            List&lt;ShopType&gt; typeList = JSONUtil.toList(shopTypeJson, ShopType.class);            return Result.ok(typeList);        &#125;        List&lt;ShopType&gt; typeList = this.query().orderByAsc(&quot;sort&quot;).list();        if(typeList == null || typeList.isEmpty())&#123;            return Result.fail(&quot;未查询到商店类型列表！&quot;);        &#125;        stringRedisTemplate.opsForValue().set(&quot;cache:shop-type-list&quot;, JSONUtil.toJsonStr(typeList));        return Result.ok(typeList);    &#125;&#125;\n缓存更新策略\n数据库中数据更新，缓存数据也要及时更新不然查出来可能是错的。\n缓存更新策略对比：\n\n\n\n策略\n内存淘汰\n超时删除\n主动更新\n\n\n\n\n说明\n不用自己维护，利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。\n给缓存数据添加 TTL 时间，到期后自动删除缓存。下次查询时更新缓存。\n编写业务逻辑，在修改数据库的同时，更新缓存。\n\n\n一致性\n差\n一般\n好\n\n\n维护成本\n无\n低\n高\n\n\n\n推荐业务场景：\n\n低一致性需求：使用内存淘汰机制。例如：店铺列表类型的查询缓存，几乎不改。\n高一致性需求：主动更新，并以超时删除作为兜底方案。例如：店铺详情查询的缓存，店家更新完希望用户那边实时更新。\n\n主动更新的几种实现方法：\n主动更新策略对比\n\n\n\n编号\n策略名称\n简要说明\n\n\n\n\n01\nCache Aside Pattern\n由缓存的调用者在更新数据库的同时更新缓存。\n\n\n02\nRead/Write Through Pattern\n缓存与数据库整合为一个服务，由服务自动维护一致性，调用者无需关心缓存。\n\n\n03\nWrite Behind Caching Pattern\n调用者只操作缓存，由其他线程异步将数据持久化到数据库，保证最终一致。\n\n\n\n方法1就是我们自己写代码实现。\n方法2找这种服务很难，实现也比较难，维护成本高，但是实现完了很方便。\n方法3好处在于：比如多个数据修改，最后一次写入；包括一个数据修改多次，最终也只将最后的结果写入，效率比较高。但是一致性比较差（比如一个缓存修改了几次还没写入，这时候数据库中的数据就不是最新的，或者万一缓存宕机那更新就没了；而且这个异步任务要实时监控缓存中的变化也比较难）。\n所以总而言之，方法1比较可控，企业里常用。\n更新缓存机制\n选用第一种策略（即我们自己手动编写代码实现主动更新缓存）后还有一些需要确定的细节。\n\n数据库数据更新后，缓存中的数据是随之更新呢，还是删除，等待下次查找时添加进缓存呢？删除处理方式比较好，因为如果数据多次更新第一种方式无效写操作较多。\n如何确保缓存和数据库同时更新？单体数据库用事务实现，分布式系统用 TCC 等分布式事务方案。\n先操作数据库还是先删除缓存？两种方案都有安全问题。先删除缓存，还没更新数据库的时候这时候有其他线程来访问，访问到的就是旧的数据；先更新数据库，还没来得及删除缓存然后另一个线程来访问，访问到缓存里面旧的数据了。但是总体而言第二种方法发生可能性更低因为缓存操作速度远快于数据库操作。\n\n具体实现：\n// controller/ShopController.java/** * 更新商铺信息 * @param shop 商铺数据 * @return 无 */@PutMappingpublic Result updateShop(@RequestBody Shop shop) &#123;    // 写入数据库    return shopService.update(shop);&#125;\n// service/impl/ShopServiceImpl.java@Overridepublic Result update(Shop shop) &#123;    Long id = shop.getId();    if(id == null)&#123;        return Result.fail(&quot;店铺 id 不能为空！&quot;);    &#125;    // 1. 更新数据库    updateById(shop);    // 2. 删除缓存    stringRedisTemplate.delete(CACHE_SHOP_KEY+ id);    return Result.ok();&#125;\n然后因为客户端其实没写商店端，所以这里我们用 Postman 来实现发送请求。首先在 Header 里面加一个 Authorization 请求头（具体值是我们的 token 值），然后发送 put 数据：\n\n\n发送完之后区 RESP 里面看数据发现缓存消失了，然后刷新页面缓存被更新成最新的内容了。\n缓存穿透\n比如用户一直在查询一个不存在的商户信息，这个查询每次都会穿透缓存去数据库里面查询，但是每次因为数据库里面不存在这个数据所以每次都不会缓存到 Redis 里面。\n\n解决方法1：缓存一个空对象。缺点在于占用内存空间，并且可能会造成短期不一致（刚查询完缓存得知商户不存在的瞬间，刚好插入了商户数据，不过问题应该不是特别大）。\n解决方法2：在 Redis 之前建立一个布隆过滤器，利用哈希算法只简单判断哪些数据存在（因为并不存储实际商户数据，只是用01记录这个商户是否存在并用一定的哈希算法映射，所以占用存储不大）。但是哈希可能有冲突，所以布隆过滤器说不存在的一定不存在，但是布隆过滤器说存在的可能不存在。优点在于相比缓存大量空数据，内存占用较小，没有多余的 key；缺点在于实现相对复杂，而且存在误判可能。\n\nflowchart TD\n\nA[客户端] --> B[布隆过滤器]\n\nB -->|不存在，拒绝| C[拒绝] --> Z1[返回客户端]\nB -->|存在，放行| D[Redis]\n\nD -->|缓存命中| E1[返回数据] --> Z1\nD -->|缓存未命中| F[数据库查询]\n\nF --> G[返回数据] --> H[写入缓存] --> D\n\nG --> Z1\n黑马点评这个项目里，我们尝试使用缓存空对象方法（实际企业应用可能使用大部分布隆过滤器+小部分的缓存空对象的结合方法）。\n在原有缓存逻辑上，修改两点：\n\n数据库没查到的话不是直接返回 404 了，而是需要先将空对象存到 Redis 里面。\nRedis 缓存命中之后，我们还要进一步判断是不是空对象。如果不是返回数据，如果是返回404.\n\n// service/impl/ShopServiceImpl.java@Overridepublic Result queryById(Long id) &#123;    ...    // 2. 判断是否存在    // isNotBlank 指的是判断不为 Null，不为空值。    // Null 表示我们的缓存里没有这个数据，未命中，需要进一步去数据库里查找之后再缓存。    // 空值表示缓存里面有这个数据，并且记录了这是一个不存在的商户。    if(StrUtil.isNotBlank(shopJson))&#123;        // 3. 存在，直接返回        Shop shop = JSONUtil.toBean(shopJson, Shop.class);        return Result.ok(shop);    &#125;\t    // 缓存里有记录这是一个不存在商户    if(shopJson!=null)&#123;        return Result.fail(&quot;商户不存在！&quot;);    &#125;    // 4. 缓存未命中，查数据库判断是否存在    Shop shop = getById(id);    // 5. 商户在数据库中不存在，将空值写入 Redis 再返回错误    if(shop == null)&#123;        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES); // 空值2分钟，短一些        return Result.fail(&quot;商户不存在！&quot;);    &#125;    // 6. 存在，添加到 Redis 商铺缓存中，并返回    ...&#125;\n现在我们发送请求查询 1000 号商户的信息：\n\n缓存里面也存入了这个空值：\n\n除了这两种方法，也可以增加 id 的复杂度，避免被别人猜到 id 规律，错误的 id 请求就直接不查。现在我们的商户信息就是简单的 shop/xx 数字形式。\n还可以加一些校验，比如 shop/0 这种肯定不存在，或者可以设定 id&gt;10000 这样的直接不查，软件逻辑上拦截一下。\n以及用户权限管理，不能让任何用户都能访问到一些特殊业务。\n以及热点参数的限流（见老师的 springCloud 微服务课）。\n缓存雪崩\n在同一时间段内大量缓存 key 同时失效或者 Redis 宕机，导致大量请求到达数据库，带来巨大压力。\n正常是大部分缓存命中，少部分请求到达数据库。\n解决方案：\n\nTTL 添加随机值。比如30~35分钟，波动大小可以调整。\n利用 Redis 集群提高服务的可用性。主从 Redis 实现，不仅可以实现数据备份，也可以在主 Redis 宕机的时候从 Redis 顶上，在 Redis 高级部分知识会涉及。\n给缓存业务添加降级限流策略。比如 Redis 整个服务器挂了，不要把所有查询压力都放到数据库，可以适当的服务降级让一些请求失败。详见老师的 springCloud 微服务课，笑死啦\n多级缓存。Nginx 缓存，JVM 缓存，数据库缓存……详见 springCloud 课程。\n\n这部分就不实现了，234都比较进阶，1太简单了一个随机数就完事了。\n缓存击穿\n缓存雪崩是大量缓存失效，而缓存击穿是少部分高并发以及缓存重建业务较复杂（比如多表查询联合运算得到，可能需要上百毫秒）的关键 key 失效，也会给数据库带来较大的冲击。\n\n解决方法1：互斥锁，排队。缺点在于等待时间比较长，比如1k个线程同时访问。\n\n解决方法2：逻辑过期，首先我们并没有给缓存键值对直接设置 expire 过期时间，而是在键值里面标注了过期时间：\n\n也就是说相当于这个键值对是永不过期的。如果我们取出数据校验后发现，value 里面存的过期时间提示已经过期了，我们再用代码去修改并且重写入 Reids 进行更新或者删除。\n重写的过程中，访问数据的线程获取到的将会是没有更新的过期的旧数据（下图中的1,3。1线程发现过期后，不自己更新数据，而是新开一个线程2更新数据，自己返回过期数据，保证速度性能）。虽然一致性有所降低，但是这样的访问方式比数据库崩掉要好吧。\n\n逻辑过期一般用于某些商品活动实现。\n互斥锁实现简单，一致性好，但是线程等待可能时间长，性能受影响，且可能有死锁风险。\n逻辑过期线程无需等待，性能较好，实现复杂，有额外内存消耗，一致性低。\nCAP 理论，Consistency 一致性和 Availablity 可用性的抉择。\n互斥锁实现\n互斥锁我们可以利用 Redis 的 setnx 命令实现。这个命令是如果不存在这个键才插入键值对并返回1证明插入成功，如果存在则不插入并返回0表示插入失败。那么我们直接执行 setnx lock x 命令就直接设置好锁了。\n此外，如果获取互斥锁的线程出问题导致没有及时 del 互斥锁那么也会出现问题。为了避免这个问题可以给互斥锁设置一个 expire 有效期。有效期一般几十倍，比如设置成10s就可以。\nflowchart TD\n    A[开始] --> B[提交商铺 id]\n    B --> C[从 Redis 查询商铺缓存]\n    C --> D{判断缓存是否命中}\n    D -- 命中 --> E[返回数据] --> F[结束]\n    D -- 未命中 --> G[尝试获取互斥锁]\n    G --> H{判断是否获取锁}\n    H -- 否 --> I[休眠一段时间] --> C\n    H -- 是 --> J[根据 id 查询数据库]\n    J --> K[将商铺数据写入 Redis]\n    K --> L[释放互斥锁]\n    L --> E\n代码实现：首先我们写 Redis 加锁和解锁的方法：\n// service/impl/ShopServiceImpl.javaprivate boolean tryLock(String key)&#123;    Boolean b = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, LOCK_SHOP_TTL, TimeUnit.SECONDS);    return Boolean.TRUE.equals(b);&#125;private void unlock(String key)&#123;    stringRedisTemplate.delete(LOCK_SHOP_KEY + key);&#125;\n然后修改原来的查询方法：\n// service/impl/ShopServiceImpl.java@Overridepublic Result queryById(Long id) &#123;    // 缓存击穿，先把原来的查询代码全复制过去然后修改未命中实现    Shop shop = queryWithMutex(id);    return Result.ok(shop);&#125;public Shop queryWithMutex(Long id)&#123;    // 1. 从 Redis 查询商铺缓存    // 这里为什么改用 String，完全是老师为了每种方法都让我们看一遍    String shopJson = stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);    // 2. 判断是否存在    // isNotBlank 指的是判断不为 Null，不为空值。    // Null 表示我们的缓存里没有这个数据，未命中，需要进一步去数据库里查找之后再缓存。    // 空值表示缓存里面有这个数据，并且记录了这是一个不存在的商户。    if(StrUtil.isNotBlank(shopJson))&#123;        // 3. 存在，直接返回        Shop shop = JSONUtil.toBean(shopJson, Shop.class);        return shop;    &#125;    // 缓存里有记录这是一个不存在商户    if(shopJson!=null)&#123;        return null;    &#125;    // 4. 缓存未命中，实现缓存重建    // 4.1 获取互斥锁    Shop shop = null;    try &#123;        boolean isLock = tryLock(LOCK_SHOP_KEY + id);        // 4.2 判断是否获取成功        if (!isLock) &#123;            // 4.3 失败，则休眠并重试            Thread.sleep(50);            return queryWithMutex(id);        &#125;        // 4.4 成功，根据 id 查询数据库        // 这里其实应该再访问一下缓存的 DoubleCheck，如果访问到了说明就在上锁的时候有线程更新了。我们就不需要重建缓存了        shop = getById(id);        // 这里其实我们的获取操作过于简单可能不一定会引发缓存击穿，所以我们这里特地让数据库访问线程延时200ms这样其他并发线程就很容易被互斥锁阻塞了，方便我们实现。        // 比如我们压测同时启动1k个线程查询商店信息，第一个线程会拿到互斥锁然后去数据库查询数据，但是可能很快就查完了。现在我们让这第一个线程拿数据的时间增加200毫秒这样其他很多线程都因为缓存未命中且拿不到互斥锁而进入等待状态，以此判断我们的代码是否生效。        Thread.sleep(200);        // 5. 商户在数据库中不存在，将空值写入 Redis 再返回错误        if(shop == null)&#123;            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES); // 空值2分钟，短一些            return null;        &#125;        // 6. 存在，添加到 Redis 商铺缓存中，并返回        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);    &#125; catch (InterruptedException e) &#123;        throw new RuntimeException(e);    &#125; finally &#123;        // 7. 释放互斥锁        unlock(LOCK_SHOP_KEY + id);    &#125;    return shop;&#125;\n使用 JMeter 压测，我这边的报告如下：\n\n不过所有线程都拿到数据了，而且 IDEA 里面调试信息输出显示确实是只查询了一次数据库。\n\n逻辑过期实现\n首先想办法添加一个 expire 字段到要存储的缓存键值对中。注意尽量不要修改原来的业务，比如直接在 Shop 商店类里面加一个字段这种行为并不可取。\n在 utils 里面添加 RedisData.java，老师已经实现：\n// utils/RedisData.java@Datapublic class RedisData &#123;    private LocalDateTime expireTime;    private Object data;&#125;\n一般有两种实现方式，一种是 RedisData 里面只有 expireTime，然后让 shop 继承它，不过这样也比较有侵入性；另一种方式就是上面这种写法，在其中加入一个 data 对象，和 Shop 绑定。\n首先我们尝试拼接一下 expireTime\n// service/impl/ShopServiceImpl.javapublic void saveShop2Redis(Long id, Long expireSeconds)&#123;        // 1. 查询店铺数据        Shop shop = getById(id);        // 睡眠来引发异常        Thread.sleep(200);        // 2. 封装逻辑过期时间        RedisData redisData = new RedisData();        redisData.setData(shop);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));        // 3. 导入 Redis        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));    &#125;\n然后尝试写一个测试用例并运行，插入一条热点数据：\n// test/HmDianPingApplicationTests.java@SpringBootTestclass HmDianPingApplicationTests &#123;    @Resource    private ShopServiceImpl shopService;    @Test    void testSaveShop() throws InterruptedException &#123;        shopService.saveShop2Redis(1L, 10L);    &#125;&#125;\n编写缓存穿透代码：\n// service/impl/ShopServiceImpl.javaprivate static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);public Shop queryWithLogicalExpire( Long id ) &#123;    String key = CACHE_SHOP_KEY + id;    // 1.从redis查询商铺缓存    String json = stringRedisTemplate.opsForValue().get(key);    // 2.判断是否存在    if (StrUtil.isBlank(json)) &#123;        // 3. 不存在，直接返回，因为热点数据只存在 redis 里数据库中没有        return null;    &#125;    // 4.命中，需要先把json反序列化为对象    RedisData redisData = JSONUtil.toBean(json, RedisData.class);    Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);    LocalDateTime expireTime = redisData.getExpireTime();    // 5.判断是否过期    if(expireTime.isAfter(LocalDateTime.now())) &#123;        // 5.1.未过期，直接返回店铺信息        return shop;    &#125;    // 5.2.已过期，需要缓存重建    // 6.缓存重建    // 6.1.获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;    boolean isLock = tryLock(lockKey);    // 6.2.判断是否获取锁成功    if (isLock)&#123;        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;            try&#123;                //重建缓存                this.saveShop2Redis(id,20L);            &#125;catch (Exception e)&#123;                throw new RuntimeException(e);            &#125;finally &#123;                unlock(lockKey);            &#125;        &#125;);    &#125;    // 6.4.返回过期的商铺信息    return shop;&#125;\nRedis 里面现在存储的是 101 茶餐厅，我们在数据库里改成 105 茶餐厅，然后运行代码并查询餐厅名称（我们设置的热点过期时间很短，10s）。\n使用 JMeter 压测会发现一定线程后数据才更新为新数据，IDEA 里面 mybatis 执行的数据库查询语句只有一条。\n缓存工具类封装\n主要要封装的四个常用方法：\n\n在 utils 文件夹里新建方法：\n// utils/CacheClient.javapackage com.hmdp.utils;import cn.hutool.core.util.StrUtil;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import com.hmdp.entity.Shop;import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.function.Function;import static com.hmdp.utils.RedisConstants.*;@Slf4j@Componentpublic class CacheClient &#123;    private final StringRedisTemplate stringRedisTemplate;    public CacheClient(StringRedisTemplate stringRedisTemplate) &#123;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    // 缓存添加正常值并且带一个 TTL 过期时间    public void set(String key, Object value, Long expireTime, TimeUnit unit) &#123;        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), expireTime, unit);    &#125;    // 添加逻辑过期值    public void setWithLogicalExpire(String key, Object value, Long expireTime, TimeUnit unit) &#123;        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(expireTime)));        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    &#125;    public &lt;R, ID&gt; R queryWithPassThrough(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long expireTime, TimeUnit unit) &#123;        String key = keyPrefix + id;        String json = stringRedisTemplate.opsForValue().get(key);        // 缓存命中且有值        if(StrUtil.isNotBlank(json))&#123;            return JSONUtil.toBean(json, type);        &#125;        // 缓存命中且为空值        if(json != null)&#123;            return null;        &#125;        // 缓存未命中，数据库查询        // 不过这里并不确定要查询的是什么类型        // 所以需要传入查询函数        R r = dbFallback.apply(id);        if(r == null)&#123;            stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);            return null;        &#125;        this.set(key, r, expireTime, unit);        return r;    &#125;    private boolean tryLock(String key)&#123;        Boolean b = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, LOCK_SHOP_TTL, TimeUnit.SECONDS);        return Boolean.TRUE.equals(b);    &#125;    private void unlock(String key)&#123;        stringRedisTemplate.delete(LOCK_SHOP_KEY + key);    &#125;    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);    public &lt;R, ID&gt; R queryWithLogicalExpire(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit) &#123;        String key = keyPrefix + id;        // 1.从redis查询商铺缓存        String json = stringRedisTemplate.opsForValue().get(key);        // 2.判断是否存在        if (StrUtil.isBlank(json)) &#123;            // 3. 不存在，直接返回            return null;        &#125;        // 4.命中，需要先把json反序列化为对象        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);        LocalDateTime expireTime = redisData.getExpireTime();        // 5.判断是否过期        if(expireTime.isAfter(LocalDateTime.now())) &#123;            // 5.1.未过期，直接返回店铺信息            return r;        &#125;        // 5.2.已过期，需要缓存重建        // 6.缓存重建        // 6.1.获取互斥锁        String lockKey = LOCK_SHOP_KEY + id;        boolean isLock = tryLock(lockKey);        // 6.2.判断是否获取锁成功        if (isLock)&#123;            CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;                try&#123;                    // 重建缓存                    R r1 = dbFallback.apply(id);                    // 写入 redis                    this.setWithLogicalExpire(key, r1, time, unit);                &#125;catch (Exception e)&#123;                    throw new RuntimeException(e);                &#125;finally &#123;                    unlock(lockKey);                &#125;            &#125;);        &#125;        // 6.4.返回过期的商铺信息        return r;    &#125;&#125;\n优惠券秒杀\n全局唯一 ID\n商店发布优惠券，用户抢购的时候就会使用订单并保存到 tb_voucher_order 表中。但是表的 id 不建议使用自增 id，因为：\n\n会泄露信息给用户，比如用户今天下单的订单id1，明天id100，用户可以知道我们昨天一天有100单优惠券订单。\n数据量太大，单表存储有限制。所以订单数据往往采用多表存储，但是多表存储自增 id 很难保证不出现重复。\n\n而订单业务有需要 id 唯一。\n我们需要有一个全局 ID 生成器：用于分布式系统生成全局唯一 id，生成的 id 一定是当前业务内唯一的。\n这个 ID 生成器需要满足：\n\n唯一性，不用多说。\n高可用，访问的时候快速获取。\n高性能，创建也要快一些。\n递增性，便于数据库建立索引。\n安全性，不能被轻易找到规律从而获取公司信息。\n\n我们可以借助 Redis 的自增命令实现，同时为了确保安全性再拼接一些其他数据：\n\n当然也可以用一些其他策略，如 UUID 但是是十六进制的字符串，而且并非单调递增的；还有 snowflake 雪花算法。但是需要维护机器内部的自增 id。还有就是数据库自增，但性能也不如 Redis 自增。\n// utils/RedisIdWorker@Componentpublic class RedisIdWorker  &#123;    /**     * 开始时间戳，这个是老师通过当前时间获取的     */    private static final long BEGIN_TIMESTAMP = 1640995200L;    /**     * 序列号位数     */    private static final long COUNT_BITS = 32L;    @Resource    private StringRedisTemplate stringRedisTemplate;    public long nextId(String keyPrefix)&#123;        // 1. 生成时间戳        LocalDateTime now = LocalDateTime.now();        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond + BEGIN_TIMESTAMP;                // 2. 生成序列号        // Redis 自增是基于键自增的，长度2^32的话，一个业务的总订单数可能会超过这个数值        // 所以结尾加上一个当前日期拼接，效果就变成：每天自增序列号上限为2^32        // 此外分层级的 key 也方便查找        String date = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        Long count = stringRedisTemplate.opsForValue().increment(&quot;icr:&quot; + keyPrefix + &quot;:&quot; + date);        // 3. 拼接并返回        return timestamp &lt;&lt; COUNT_BITS | count;    &#125;&#125;\n添加优惠券\n主要分为两种：普通券（折扣较低）和特价秒杀券（折扣较高，但限量）。\n分别对应数据库表的 tb_voucher 和 tb_seckill_voucher 。\n表详情如下：\nCREATE TABLE `tb_voucher` (  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,  `shop_id` bigint unsigned DEFAULT NULL COMMENT &#x27;商铺id&#x27;,  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT &#x27;代金券标题&#x27;,  `sub_title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;副标题&#x27;,  `rules` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;使用规则&#x27;,  `pay_value` bigint unsigned NOT NULL COMMENT &#x27;支付金额，单位是分。例如200代表2元&#x27;,  `actual_value` bigint NOT NULL COMMENT &#x27;抵扣金额，单位是分。例如200代表2元&#x27;,  `type` tinyint unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;0,普通券；1,秒杀券&#x27;,  `status` tinyint unsigned NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;1,上架; 2,下架; 3,过期&#x27;,  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,  PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=COMPACT\nCREATE TABLE `tb_seckill_voucher` (  `voucher_id` bigint unsigned NOT NULL COMMENT &#x27;关联的优惠券的id&#x27;,  `stock` int NOT NULL COMMENT &#x27;库存&#x27;,  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,  `begin_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;生效时间&#x27;,  `end_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;失效时间&#x27;,  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,  PRIMARY KEY (`voucher_id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=COMPACT COMMENT=&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;\n目前茶餐厅里面只有一个普通优惠券没有秒杀券。\n\n我们首先需要添加一些秒杀优惠券。老师已经写好方法了，/voucher/seckill 路径（注意要给登录拦截器里写上这个放行一下）。我们直接 postman 发送请求就能添加：\n\n\n（这里其实要改一下，把 endTime 改成在你当前时间之后。这样才能在前端看到优惠券）\n\n不过现在没法点击抢购，会显示功能未完成。请求 URL 为：http://localhost:8080/api/voucher-order/seckill/10\n","categories":["算道求索（课外IT技能学习）","Project"],"tags":["Java","Redis"]}]