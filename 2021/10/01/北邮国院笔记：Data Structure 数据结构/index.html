<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="北京邮电大学国际学院物联网工程专业数据结构课程学习笔记" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title>北邮国院笔记：Data Structure 数据结构 |  灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      /> 
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>
      <!-- <link
        rel="stylesheet"
        href="https://cdn.staticfile.org/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.staticfile.org/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script> -->

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-北邮国院笔记：Data Structure 数据结构"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  北邮国院笔记：Data Structure 数据结构
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2021-09-30T23:00:00.000Z" itemprop="datePublished">2021-10-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">4.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">24 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1>前言</h1>
<p>因为考试要求，博主学习的是双语的数据结构，因此自己总结一些英文的概念、知识点。希望也可以对读者学习这门课程有所帮助~<br>
特别感谢许可老师的教导！</p>
<p>理解时间复杂度的定义<br>
（本课程涉及到的所有算法，都需要记住时间复杂度O）</p>
<h1>Data structure notes</h1>
<p>Program = Algorithm + Data Structure<br>
An algorithm is a finite set of instructions that, fi followed, accomplishes a particular task. In addition, all algorithms must satisfy the following criteria:</p>
<ul>
<li>Input</li>
<li>Output</li>
<li>Definiteness</li>
<li>Finiteness</li>
<li>Effectiveness</li>
</ul>
<p><em>Note:<br>
A program is written in some programming language, and does not have to be finite.<br>
An algorithm can be described by human languages, flow charts, some programming languages, or pseudocode.</em></p>
<p>引入 time complexities 和 space complexities 的概念。</p>
<p>$2^n^&gt;n^2^&gt;nlogn&gt;n&gt;logn&gt;1$</p>
<h1>单词：</h1>
<p>Algorithm 算法<br>
Definiteness 确定性<br>
Finiteness 有限性<br>
Effectiveness 有效性<br>
Finite 有限的<br>
Pseudocode 伪代码<br>
Assumptions 假设<br>
Asymptotic 渐近线的，渐近的<br>
Notation 记号，标记法<br>
For loops for循环<br>
Nested 嵌套<br>
Consecutive statements 顺序语句<br>
Fibonacci 斐波那契<br>
Euclid 欧几里得<br>
Exponentiation 幂<br>
Pow 指数</p>
<p>【表】<br>
理解链表、数组的特点（优缺点）<br>
会代码实现：单链表 循环链表 双向链表……</p>
<p><em>【栈和队列】</em><br>
<em>理解原理，会算法：两种实现方法</em><br>
<em>会应用算法，如：中序后序互转；前中后缀表达式互换；栈（队列）操作后的状态</em></p>
<h1>ADT</h1>
<p><strong>ADT(Abstract Data Type)</strong> is a data type that is organized in such a way that the <strong>specification</strong>  on the objects and <strong>specification</strong> of the operations on the objects are <strong>separated from</strong> the <strong>representation</strong> of the objects and the <strong>implementation</strong> on the operations.</p>
<h1>The List ADT</h1>
<ol>
<li>Array implementation</li>
</ol>
<ul>
<li><strong>MaxSize</strong> has to be estimated. （大小必须事先给出。给小了数组越界；(可以再申请)给大了太浪费空间）</li>
<li><strong>Find_Kth</strong> takes O(1) time. （随机存取）</li>
<li><strong>Insertion and Deletion</strong> not only take O(N) time, but also involve a lot of data movements which takes time.（插入删除不方便，需要移动大量元素；存储密度高）</li>
</ul>
<ol start="2">
<li>Linked Lists（是否带有头结点）</li>
</ol>
<ul>
<li>三种操作：Find_Kth、Find_Value、Find_Length take O(N) time. 注意循环逻辑，以及有无头结点时对边界情况的处理</li>
<li>找前一个结点不方便，只能重新从头遍历、</li>
</ul>
<h2 id="Doubly-Linked-Lists">Doubly Linked Lists</h2>
<p>找前一个结点更方便。注意初始化、插入、删除、双向遍历的区别。</p>
<h2 id="Circular-Lists">Circular Lists</h2>
<p>头尾相接的单链表。注意判空条件（<code>L-&gt;Next==L</code>）、判断表尾结点条件(<code>p-&gt;Next==L</code>)以及插入删除时修改的操作。<br>
双向循环链表不再赘述。</p>
<h2 id="Application-The-polynomial-ADT">Application: The polynomial ADT</h2>
<p>多项式求和、求积函数，使用链表更好，因为如果出现形如x^100000^+x^5^+x^1^这种，数组会浪费大量空间，而单链表只需要将系数非0的部分申请空间创造结点。<br>
（也可以建立十字链表，两个维度分别存储系数和指数）</p>
<h2 id="Cursor-Implementation-of-Linked-Lists-no-pointer">Cursor Implementation of Linked Lists (no pointer)</h2>
<p>可以使用一个游标int Cursor来作为指针，游标移动访问数组，从而实现类似于指针移动的操作。<br>
The cursor implementation is usually significantly <strong>faster</strong> because of the lack of memory management routines.</p>
<h1>The Stack ADT</h1>
<p>A Stack is a <strong>Last-in-First-Out (LIFO)</strong> list. An ordered list in which insertions and deletion are made at the top only.<br>
类似于一堆书，放书和拿书都只能从最顶上进行。最后放上的书最早被拿出来。<br>
Push: 入栈<br>
Top: 读取并返回栈顶元素<br>
Pop: 栈顶元素出栈</p>
<h2 id="Application-1-Balancing-symbols-括号匹配">Application 1: Balancing symbols 括号匹配</h2>
<p>输入一串表达式，判断其中的括号()[]{}是否匹配。<br>
检验方法：每个右括号都和离他最近的，也就是最晚输入的左括号匹配，正符合栈的后进先出原则。<br>
读到左括号的时候入栈，读到右括号的时候与栈顶的左括号比较，比较后出栈。<br>
最后结束输入，还要检查一下栈是否为空，若非空，栈内剩下的括号全都不匹配。<br>
<a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/1%20STACK/7-1%20Balancing%20Symbols.cpp">7-1 Balancing symbols 代码实现</a></p>
<h2 id="Application-2-Postfix-Evaluation-后缀表达式的计算">Application 2: Postfix Evaluation 后缀表达式的计算</h2>
<p>Infix expression中缀表达式： a + b * c - d / e<br>
Prefix expression 前缀表达式：- + a * b c / d e<br>
Postfix expression 后缀表达式： a b c * + d e / -<br>
中缀表达式更符合人脑的计算方法，而后缀表达式更符合计算机的计算方法。<br>
实际上在计算机中计算表达式，是先转化为postfix expression，再进行计算的。<br>
转换方法：<br>
建立堆栈。</p>
<ol>
<li>读入的字符是操作数：直接输出</li>
<li>读入的字符是操作符：<br>
a)	堆栈是空的，则直接存入堆栈中（push）<br>
b)	该操作符的优先级&gt;栈顶元素操作符，则直接入栈（push）<br>
c)	该操作符的优先级&lt;=栈顶元素操作符，则栈顶元素出栈（pop），直到该操作符的优先级大于栈顶元素（这个栈顶元素也要出栈），然后该操作符入栈（push）<br>
d)	操作符是左括号，则直接入栈（pop），遇到右括号之前永不输出<br>
e)	操作符是右括号，则一直出栈（pop）直到左括号出栈<br>
f)	最终输入结束，栈若非空，栈中元素全部出栈。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/1%20STACK/7-2%20Infix%20to%20Postfix%20Conversion.cpp">7-2 Infix to postfix Conversion 代码实现</a></p>
<h1>The Queue ADT</h1>
<p>A Queue is a <strong>First-In-First-Out (FIFO)</strong> list. An ordered list in which insertions take place at one end and deletions take place at the opposite end.<br>
就像日常生活中的排队，先来后到，先排的有机会先出。<br>
EnQueue: 入队<br>
DeQueue: 出队</p>
<h2 id="Circular-Queue：循环链表">Circular Queue：循环链表</h2>
<h2 id="Application-who-is-the-last">Application: who is the last</h2>
<p>输入n、m；n个人坐成一个圈，从第一个人开始报数，每m个人淘汰掉第m个人，然后下一个人继续重新报数。问：谁能留到最后？<br>
<a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Data-Structure-in-BUPT/blob/main/2%20QUEUE/7-4%20who%20is%20the%20last.cpp">7-4 who is the last 代码实现</a></p>
<p>树<br>
【基本概念】各类树的度、高、深、节点数与叶子节点的关系；孩子兄弟节点树；<br>
【二分检索树】：概念 平衡二叉树 完全二叉树 满二叉树 AVL树…… 会插入 删除；<br>
【遍历树】：先序 后序 中序 层序；会代码创建树和检索、会执行画图<br>
【B-树】：会画图 构建B-树，增加节点，删除节点 B-树<br>
【霍夫曼树】：理解原理 给出数据 会画霍夫曼树的图；节点关系<br>
理清各种树之间的关系</p>
<h1>Tree</h1>
<h2 id="Conception">Conception</h2>
<ul>
<li>degree of a node: number of its subtrees</li>
<li>degree of a tree: max{degree(node)}</li>
<li>parent;children;siblings</li>
<li>leaf:a node with degree 0</li>
<li>path from n_1 to n_k: a <strong>unique</strong> sequence of n_1, n_2 …… n_k (n_i is the parent of n_{i+1})</li>
<li>length of path: number of <strong>edges</strong> on the path</li>
<li>depth of n_i: path to root (depth(root)=0)</li>
<li>height of n_i：length of the longest path from n_i to a leaf.(Height(leaf)=0)</li>
<li>ancestors of anode: all the nodes along the path from the node up to the root</li>
<li>descendants of a node: all the nodes in its subtrees</li>
</ul>
<h2 id="Representation">Representation</h2>
<h3 id="FirstChild-NextSibling-Representation">FirstChild-NextSibling Representation</h3>
<p>Each Node carries its element and 2 pointers. The first points its FirstChild; The second points its NextSibling.<br>
<em>This representation is <strong>not unique</strong> since the children in a tree can be of any order.</em></p>
<h3 id="Binary-Trees">Binary Trees</h3>
<p>a tree in wh ich no node can have more than 2 children.<br>
<em>Rotate the FirstChild-NextSibling tree clockwise by 45°</em></p>
<h2 id="Tree-Traversals-significant">Tree Traversals (significant!)</h2>
<h3 id="Preorder-Traversal">Preorder Traversal</h3>
<p>visit This Node first;<br>
visit its child recursively.</p>
<h3 id="Postorder-Traversal">Postorder Traversal</h3>
<p>visit its child recursively;<br>
At last, visit this node itself.</p>
<h3 id="Levelorder-Traversal">Levelorder Traversal</h3>
<p>visit Tree via a queue.</p>
<ul>
<li>Enqueue root node;</li>
<li>while(queue is not empty){</li>
<li>visit first node in queue and Dequeue;</li>
<li>for its each child, enqueue.}</li>
</ul>
<h3 id="Inorder-Traversal-for-binary-trees">Inorder Traversal(for binary trees)</h3>
<p>Recursive:</p>
<ul>
<li>visit left tree recursively.</li>
<li>visit root node.</li>
<li>visit left tree recursively.<br>
Iterative:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iter_inorder</span><span class="params">(Tree)</span></span><br><span class="line">&#123;</span><br><span class="line">	Stack S;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;tree;tree=tree-&gt;Left)Push(tree,S);</span><br><span class="line">		tree=Top(S);Pop(S);</span><br><span class="line">		<span class="keyword">if</span>(!tree)<span class="keyword">break</span>;</span><br><span class="line">		visit(tree-&gt;Element);</span><br><span class="line">		tree=tree-&gt;Right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inorder traversal: infix expression<br>
preorder traversal: prefix expression<br>
postorder traversal: postfix expression<br>
<em>Depth is a evry important conception. we can use a function to calculate it:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ListDir</span><span class="params">(DirOrFile D,<span class="type">int</span> Depth)</span><span class="comment">//at first, Depth is 0</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(D is a legitimate entry)&#123;</span><br><span class="line">		PrintName(D,Depth);</span><br><span class="line">		<span class="keyword">if</span>(D is a directory)</span><br><span class="line">			<span class="keyword">for</span>(each child C of D)</span><br><span class="line">				ListDir(C,Depth+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Threaded-Binary-Trees">Threaded Binary Trees</h2>
<ul>
<li>If tree-&gt;Left is null, 指向中序遍历的前一个结点  a pointer to the inorder predecessor of Tree.</li>
<li>If tree-&gt;Right is null, 指向中序遍历的前一个结点  a pointer to the inorder successor of Tree.</li>
<li>最开头、最结尾结点的左、右指针指向head node. There must not be any loose threads. Therefore a threaded binary tree must have a <strong>head node</strong> of which the left child points to the first node.</li>
</ul>
<h2 id="The-Search-Tree-ADT-–-Binary-Search-Trees">The Search Tree ADT – Binary Search Trees</h2>
<ul>
<li>Every node has a key which is an integer, and it’s distinct.</li>
<li>The keys in a nonempty <strong>left</strong> subtree must be <strong>smaller</strong> than the key in the root of the subtree.</li>
<li>The keys in a nonempty <strong>right</strong> subtree must be <strong>larger</strong> than the key in the root of the subtree.</li>
<li>The left and right subtrees are also binary search trees.</li>
</ul>
<p>insert is quite easy while delete not.<br>
Delete:</p>
<ul>
<li>if it’s leaf node:just delete it.</li>
<li>if it’s degree is 1: use its child to replace it.</li>
<li>if it’s degree is 2: use the <strong>largest</strong> node in its <strong>left</strong> subtree or the <strong>smallest</strong> node in its <strong>right</strong> subtree to replace it.<br>
<em>will the lazy deletion be in the scope of final exam?</em><br>
<strong>Internal path length: O(Nlog N);depth of any node is O(log N)</strong><br>
要会计算Average Search Time (AST)<br>
<em>If you print Binary Search Tree inorder, then it is an increasing order.</em></li>
</ul>
<p>Get Depth: preorder traversal</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Height</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	ekse <span class="keyword">return</span> <span class="number">1</span>+Max(Height(T-&gt;Left),Height(T-&gt;Right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AVL-Trees">AVL Trees</h2>
<p>If the tree is too high, AST can be very large and time complexities is O(N). So we need to balance the height by rotating.<br>
<strong>If |h_L-h_R|&gt;1,rotate.</strong></p>
<ul>
<li>Single Rotation: Trouble is left subtree’s left subtree or right subtree’s right subtree.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Tree <span class="title function_">SingleRotatewithLeft</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	TreeNode LeftTree = T-&gt;LeftChild;</span><br><span class="line">	T-&gt;LeftChild = LeftTree-&gt;RightChild;</span><br><span class="line">	LeftTree-&gt;RightChild = T;</span><br><span class="line">	<span class="keyword">return</span> LeftTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">SingleRotatewithRight</span><span class="params">(Tree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	TreeNode RightTree = T-&gt;RightChild;</span><br><span class="line">	T-&gt;RightChild = RightTree-&gt;LeftChild;</span><br><span class="line">	RightTree-&gt;LeftChild = T;</span><br><span class="line">	<span class="keyword">return</span> RightTree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Double Rotation: Trouble is left subtree’s right subtree or right subtree’s left subtree.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tree <span class="title function_">DoubleRotatewithLeft</span><span class="params">(Tree T)</span> 			</span><br><span class="line">&#123;</span><br><span class="line">	T-&gt;LeftChild = SingleRotatewithRight(T-&gt;LeftChild);</span><br><span class="line">	<span class="keyword">return</span> SingleRotatewithLeft(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tree <span class="title function_">DoubleRotatewithRight</span><span class="params">(Tree T)</span> 			</span><br><span class="line">&#123;</span><br><span class="line">	T-&gt;RightChild = SingleRotatewithLeft(T-&gt;RightChild);</span><br><span class="line">	<span class="keyword">return</span> SingleRotatewithRight(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="B-Trees-要会插入、建立">B Trees 要会插入、建立</h2>
<h3 id="Insertion">Insertion</h3>
<p>考完试补全<br>
$$<br>
Depth(M,N)=O(log_{[M/2]}N)<br>
$$</p>
<p>$$<br>
T_{Find}(M,N)=O(log N)<br>
$$</p>
<h2 id="Forest-Empty">Forest Empty</h2>
<h2 id="Huffman-Tree">Huffman Tree</h2>
<p>Weighted Path Length, WPL<br>
$$<br>
WPL=\sum^k_{i=1}w_i*l_i<br>
$$<br>
Huffman Tree: the binary tree with the minimum weighted path length.<br>
0 is appended to left branch,<br>
1 is appended to right branch.</p>
<p>哈希<br>
要求：<br>
会算法 给出散列函数 会画图 会计算比较成功的次数 比较失败的次数 平均查找时间<br>
【分离链接法】<br>
【开放定址法】线性探测法 平方探测法 双散列<br>
【再散列】</p>
<h1>HASHING</h1>
<p>散列表（hashing table）的实现叫散列（hashing）散列是一种用于以常数时间执行插入、删除和查找的技术，但不能排序。<br>
散列函数（hashing function）是关键字被映射到0～TableSize-1范围内的函数。</p>
<ul>
<li>must be easy to compute and minimizes the number of collisions.</li>
<li>Should be unbiased. For any x and any i, we have that probability(f(x)=i)=1/b. (Uniform hash function)<br>
** f(x)=x%TableSize**<br>
TableSize=prime number is good for random integer keys.</li>
</ul>
<h2 id="处理冲突的办法">处理冲突的办法</h2>
<h3 id="open-addressing-开放定址法">open addressing 开放定址法</h3>
<p>find another empty cell to solve collision</p>
<h4 id="Linear-Probing-线性探测法">Linear Probing 线性探测法</h4>
<p>f(i)=i (a linear function)<br>
如果对应位被占了，则往下继续寻找空位。<br>
下一位是否为空？若为空放入，若不为空检查下一位；<br>
再下一位是否为空？……<br>
查找：先去对应位找，如果没找到再继续往下遍历。</p>
<h4 id="Quadratic-Probing-平方探测法">Quadratic Probing 平方探测法</h4>
<p>f(i)=i^2^<br>
如果对应位被占了，则+1^1；<br>
若这一位也被占了，则原位置+2^2；<br>
……<br>
（也有的算法是±i^2）<br>
最大加到（n/2）的平方<br>
查找：先去对应位找，如果没找到再去加1、加4等等位找。</p>
<h4 id="Double-Hashing-双散列法">Double Hashing 双散列法</h4>
<p>第一个散列函数冲突时，使用第二个散列函数。<br>
<strong>hash2(x)必须不恒等于0！</strong><br>
<em>Tips: hash2(x)=R-(x%R) with R a prime smaller than TableSize, will work well.</em></p>
<h3 id="Rehashing-再散列">Rehashing 再散列</h3>
<p>当插入数据达到N/2时，再散列。</p>
<ul>
<li>建立一个原表的二倍大的表（接近原表二倍大的素数）</li>
<li>从原表中读取数据，用新hash function 存到新表中。</li>
</ul>
<p>堆<br>
【二叉堆】<br>
要求：会构建堆 插入 删除； 画图，手动执行中间数据；</p>
<h1>Piority Queue(Heap)</h1>
<p>Can find the element with the highest \ lowest priority.</p>
<table>
<thead>
<tr>
<th></th>
<th>Insertion</th>
<th>Deletion</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td>O(1)</td>
<td>find:O(n) delete:O(n)</td>
</tr>
<tr>
<td>Linked List</td>
<td>O(1)</td>
<td>find:O(n) delete:O(n)</td>
</tr>
<tr>
<td>Ordered Array</td>
<td>find:O(1) insert:O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>Ordered Linked List</td>
<td>find:O(1) insert:O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>## complete binary tree</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Its nodes correspond to the nodes numbered from 1 to n in the perfect binary tree of height h.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A complete binary tree of height h has between 2^h and 2^{h+1}-1 nodes.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Array representation: BT[n+1](BT[0]is not used)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>For node i:</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- parent: i/2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- left child: 2*i</td>
<td></td>
<td></td>
</tr>
<tr>
<td>- right child: 2*i+1</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>A min tree</strong> is a tree in which the key value in each node is no larger than the key values in its children.<br>
<strong>A min heap</strong> :a complete binary tree + a min tree. And the max heap is visa versa.</p>
<h2 id="Insertion-Min-Heap">Insertion(Min Heap)</h2>
<p>Because a heap is a complete binary tree, the nth node only has one possible position to insert. Then, if nth node is smaller than its parent:exchange upward will its location is proper.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = ++H-&gt;Size; H-&gt;Elements[ i / <span class="number">2</span> ] &gt; X; i /= <span class="number">2</span> ) </span><br><span class="line">	H-&gt;Elements[ i ] = H-&gt;Elements[ i / <span class="number">2</span> ]; </span><br><span class="line"></span><br><span class="line">     H-&gt;Elements[ i ] = X; </span><br></pre></td></tr></table></figure>
<p><em>Another kind of Insertion is: insert all nodes first, then adjust their location. We need to check from n/2 node. If its children node is smaller than it, choose the smallest node and exchange them. n/2 node go downward until reach the proper location. Then do the same thing to the n/2-1 node until the first node.</em></p>
<h2 id="Deletion">Deletion</h2>
<p>We only need to delete the root node——the smallest node.</p>
<ul>
<li>Exchange the root node with the last node——the nth node.</li>
<li>do the same thing mentioned above in the Italic text: re-arrange the new node.</li>
<li>Iteratively delete root node until delete the whole heap.<br>
*<em>Those 2 operations’ time complexity are O(log N). Insertion all node is O(nlogn).</em></li>
</ul>
<p><em>For the perfect binary tree of height h containing 2h+1 - 1 nodes, the sum of the heights of the nodes is 2h+1 - 1 - (h + 1).</em></p>
<h1>Graph</h1>
<p>G:graph</p>
<p>V:finite nonempty set of vertices</p>
<p>E:finite set of edges</p>
<p>Undirected graph: $(v_i,v_j)$ <em>v_i and v_j are adjacent</em></p>
<p>Directed graph: $&lt;v_i,v_j&gt;$ <em>v_i is adjacent to v_j;v_j is adjacent from v_i</em></p>
<p><strong>Complete Graph</strong>: a graph that has the maximum number of edges</p>
<p><strong>Subgraph</strong></p>
<p><strong>Path from v_p to v_q</strong></p>
<p><strong>Length of a path</strong></p>
<p><strong>Simple path</strong>: v_i1, v_i2 …… v_in are distinct (on the path)  路径上的顶点不重复出现</p>
<p><strong>Cycle</strong> Simple path with v_p = v_q</p>
<p><strong>A graph is connected</strong>: every pair of distinct v_i and v_j are connected  图中任意两点都连通</p>
<p><strong>Connected Component of an undirected G</strong>: the maximal connected subgraph</p>
<p><strong>A tree</strong>: a graph that is connected and  acyclic</p>
<p><strong>A DAG</strong>: a directed acyclic graph  有向无环图</p>
<p><strong>Strongly connected directed graph G</strong>: for every pair of v_i and v_j in V(G), there exist directed paths from v_i to v_j and from v_j to v_i.<br>
(Graph without direction: <strong>weakly connected</strong>)</p>
<p><strong>Stronhly connected component</strong>: the maximal subgraph that is strongly connected</p>
<p><strong>Degree(v)</strong>: in-degree and out-degree  进入某个顶点的边数和传出该顶点的边数</p>
<h2 id="Representation-of-Graphs">Representation of Graphs</h2>
<h3 id="Adjacency-Matrix-邻接矩阵法">Adjacency Matrix 邻接矩阵法</h3>
<p>二维矩阵存储边信息。如果v_i to v_j 有边，adj_mat[i][j]=1，否则=0.（undirected graph还要考虑双向，同时也要让adj_mat[j][i]=1）</p>
<h3 id="Adjacency-Lists-邻接表法">Adjacency Lists 邻接表法</h3>
<p>每个顶点结点都是一个单链表的头结点，后面挂着他连接的顶点的节点。</p>
<p>如：</p>
<p>0-&gt;1-&gt;2</p>
<p>1-&gt;0</p>
<p>2-&gt;0</p>
<p>这就是一个三个顶点的无向图，01、02相连。</p>
<p>S(n+2e) Space complexities</p>
<h2 id="Topological-Sort">Topological Sort</h2>
<p><strong>AOV Network</strong>: digraph in which V(G) represents activities and E(G) represents precedence relations 顶点表示事件，边表示事件之间的进程关系。比如A-&gt;B，就是要先做完A才能做B</p>
<p><strong>i is a predecessor of j</strong>: there is a path from i to j  前驱</p>
<p><strong>i is an immediate predecessor</strong>: &lt;i,j&gt;=1.  直接前驱 Then j is called a <strong>successor (immediate successor)</strong> of i 直接后继</p>
<p><strong>Partial order</strong>: transitive (i-&gt;k,k-&gt;j: i-&gt;j) &amp;&amp; irreflexive (i-&gt;j is impossible)</p>
<p>AOV network must be a dag (directed acyclic graph)</p>
<p><strong>Topological order</strong>: a linear ordering of the vertices of a graph such that, for any 2 vertices, i, j, if i is a predecessor of j in the network then i precedes j in the linear ordering.  所有时间都是按完成顺序排序的.<br>
算法：</p>
<ol>
<li>找出入度为0的节点</li>
<li>visit 该节点，并删除该节点的所有出度边</li>
<li>再重新寻找入度为0，没有 visit 过的节点，循环往复</li>
</ol>
<p>If we use a special box (queue or stack) to sort, T=O(|V|+|E|)</p>
<h2 id="Shortest-Path-Algorithms-最短路径算法">Shortest Path Algorithms 最短路径算法</h2>
<p>两类问题：</p>
<ol>
<li>从物流中心（一个顶点）往其他所有顶点运输物品，怎样路径最短？</li>
<li>怎样让所有顶点之间路径总和最短？</li>
</ol>
<h3 id="1-Single-Source-Shortest-Path-Problem">1. Single-Source Shortest-Path Problem</h3>
<p>Given as input a weighted graph, G = ( V, E ), and a distinguished vertex, s, find the shortest weighted path from s to every other vertex in G.</p>
<p><strong>Breadth-first search 广度优先搜索</strong></p>
<p>Similar to the topological order. We will visit every node connect to the fist node (if they haven’t been visit) and Enquque; and Dequeue this node, do the same thing to every node in the Queue.</p>
<p>Just simply scan the whole table</p>
<p>T+(|V|^2+|E|)</p>
<p><strong>Dijkstra’s Algorithm 迪杰斯特拉算法</strong></p>
<p>建立三个数组，final[]标记哥哥顶点是否已经找到最短路径；dist[]最短路径长度；path[]路径上的前驱<br>
第一次循环：遍历所有结点，找到还没有确定最短路径且dist最小的顶点，final[i]=true<br>
检查i结点的所有final=false邻接节点，如果把i作为路径上的前驱，最短路径会不会缩短？如果会，更新最短路径长度dist和路径上的前驱path信息。<br>
进入下一轮循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">( Table T )</span></span><br><span class="line">&#123;   <span class="comment">/* T is initialized by Figure 9.30 on p.303 */</span></span><br><span class="line">    Vertex  V, W;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        V = smallest unknown distance vertex;</span><br><span class="line">        <span class="keyword">if</span> ( V == NotAVertex )</span><br><span class="line">	<span class="keyword">break</span>; </span><br><span class="line">        T[ V ].Known = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( each W adjacent to V )</span><br><span class="line">	<span class="keyword">if</span> ( !T[ W ].Known ) </span><br><span class="line">	    <span class="keyword">if</span> ( T[ V ].Dist + Cvw &lt; T[ W ].Dist ) &#123;</span><br><span class="line">	    	Decrease( T[ W ].Dist  to</span><br><span class="line">			 T[ V ].Dist + Cvw );</span><br><span class="line">		T[ W ].Path = V;</span><br><span class="line">	    &#125; <span class="comment">/* end-if update W */</span></span><br><span class="line">    &#125; <span class="comment">/* end-for( ; ; ) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>not work for edge with negative cost!</strong></p>
<p>T=O(|E|log|V|)</p>
<h2 id="Acylic-Graphs">Acylic Graphs</h2>
<p>If the graph is acyclic, vertices amy be selected in topological order since when a vertex is selected, its distance can no longer be lowered without any incoming edges from unknown nodes.</p>
<p>T=O(|E|+|V|)</p>
<p>Application: AOE(Activity On Edge)Networks</p>
<p>EC[ j ] \ LC[ j ] :: the earliest \ latest completion time for node v_j</p>
<p><strong>CPM (Critical Path Method)</strong></p>
<p>Calculation of EC: start from v_0, for any a_i=&lt;v,w&gt;, we have $EC[w]=max_{(v,w)\in E(EC[v]+C_{v,w})}$</p>
<p>Calculation of LC: Start from the last vertex v_e, for any a_i = &lt;v,w&gt;, $LC[v]=min_{(v,w)\in E}(LC[w]-C_{v,w})$</p>
<p>Slack Time of &lt;v,w&gt;: $LC[w]-EC[v]-C_{v,w}$</p>
<p>Critical Path: path consisting entirely of zero-slack edges.</p>
<p><strong>All-Pairs Shortest Path Problem</strong></p>
<p>Method 1: Use single-source algorithm  for |V| times.<br>
T = O(|V|^3) – works fast on sparse graph. 稀疏图</p>
<p>Method 2  O( |V|^3 ) algorithm given in Ch.10, works faster on dense graphs.</p>
<h2 id="Network-Flow-Problems">Network Flow Problems</h2>
<p>Find Maximum Path from s to t.</p>
<p>Step 1:  Find any path s -&gt; t in Gr ;</p>
<p>Step 2:  Take the minimum edge on this path as the amount of flow and add to G_f ;</p>
<p>Step 3:  Update G_r and remove the 0 flow edges;</p>
<p>Step 4:  If (there is a path s -&gt; t in G_r )<br>
Goto Step 1;<br>
Else<br>
End.</p>
<h2 id="Minimum-Spanning-Tree">Minimum Spanning Tree</h2>
<p>is a tree which consists of V(G) and a subset of E(G).</p>
<ul>
<li>It is acyclic – the number of edges is |V|-1.</li>
<li>It is minimum for the total cost of edges is minimized.</li>
<li>A minimum spanning tree exists if G is connected.</li>
</ul>
<h2 id="2-Method-of-calculating-the-minimum-spanning-tree">2 Method of calculating the minimum spanning tree:</h2>
<ol>
<li>
<p>Prim’s Algorithm<br>
very samiliar to Dijkstra’s algorithm. We choose a vertex to start, and every time add a a least cost vertex until all vertex is connected.</p>
</li>
<li>
<p>Kruskal’s Algorithm – maintain a forest<br>
every time add a a least cost edge &lt;v,w&gt; from E until all vertex is connected.</p>
</li>
</ol>
<h2 id="DFS-–-Depth-First-Search">DFS – Depth-First Search</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ListComponents</span> <span class="params">( Graph G )</span> </span><br><span class="line">&#123;   <span class="keyword">for</span> ( each V in G ) </span><br><span class="line">        <span class="keyword">if</span> ( !visited[ V ] ) &#123;</span><br><span class="line">	DFS( V );</span><br><span class="line">               <span class="built_in">printf</span>(“\n“);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span> <span class="params">( Vertex V )</span>  <span class="comment">/* this is only a template */</span></span><br><span class="line">&#123;   visited[ V ] = <span class="literal">true</span>;  <span class="comment">/* mark this vertex to avoid cycles */</span></span><br><span class="line">    <span class="keyword">for</span> ( each W adjacent to V )</span><br><span class="line">        <span class="keyword">if</span> ( !visited[ W ] )</span><br><span class="line">	DFS( W );</span><br><span class="line">&#125; <span class="comment">/* T = O( |E| + |V| ) as long as adjacency lists are used */</span></span><br></pre></td></tr></table></figure>
<p>Applications:</p>
<ol>
<li>Undirected Graphs</li>
<li>Biconnectivity</li>
<li>Euler Circuits</li>
</ol>
<h2 id="NP-Completeness">NP-Completeness</h2>
<h1>KMP</h1>
<h2 id="Basic-String-Operations">Basic String Operations</h2>
<p>The StrAssign、Strcopy、StrCompare、StrLength、Concat and SubString</p>
<h2 id="String-Operations-Library-in-C">String Operations Library (in C)</h2>
<p>gets(str)  //Input a string;</p>
<p>puts(str) //Output a string；</p>
<p>strcat(str1, str2)  // string Concatenation；</p>
<p>strcpy(str1, str2, k)  //String copy；</p>
<p>strcmp(str1, str2) //String comparision；</p>
<p>strlen(str)  //Get the length of string</p>
<h2 id="Pattern-Matching-algorithm">Pattern Matching algorithm</h2>
<p>旧模式匹配算法：每次不匹配时，子串都从头重新匹配。效率很低</p>
<p>Basic match algorithm is inefficient</p>
<h3 id="Knuth-Morris-Pratt-KMP-Algorithms">Knuth-Morris-Pratt (KMP Algorithms)</h3>
<p>When dismatch happens, we don’t need to go back to first. We can use a next array to decide where to go back.</p>
<p>next[]: compare s[i] and t[j]，if equals then continue comparing following items, else compare s[i] and t [ next[j] ], till end.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">Get_next</span><span class="params">( SString T, <span class="type">int</span>  &amp;next[] )</span></span><br><span class="line">&#123;    j = <span class="number">1</span> ;  <span class="comment">// postfix pointer</span></span><br><span class="line">     k = <span class="number">0</span>;   <span class="comment">//prefix pointer</span></span><br><span class="line">     next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( j &lt;= T[<span class="number">0</span>] )</span><br><span class="line">     &#123;  <span class="keyword">if</span> ( k == <span class="number">0</span> || T[j] == T[k] ) </span><br><span class="line">             &#123; ++j ;  ++k ;  next[j]=k; &#125;</span><br><span class="line">         <span class="keyword">else</span>  </span><br><span class="line">             k = next[k];  <span class="comment">// k go back, then compare T[j] with T[ next[k] ]</span></span><br><span class="line">     &#125;<span class="comment">// end while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example:<br>
a  a  b  c  a  a  a  b  c  a  d<br>
0  1  2  1  1  2  3  3  4  5  6</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Contact Me
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://jingqing3948.github.io/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/05/02/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Java/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            技术学习：黑马程序员 Java
          
        </div>
      </a>
    
    
      <a href="/2021/09/11/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%20C%E8%AF%AD%E8%A8%80%E8%AE%A2%E9%A4%90%E7%B3%BB%E7%BB%9F/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">北邮国院项目：程序设计课程设计 C语言订餐系统</div>
      </a>
    
  </nav>

  
   
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">

  <script>
    window.addEventListener('DOMContentLoaded', function () {
      const gitalkScript = document.createElement('script');
      gitalkScript.src = 'https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js';
      gitalkScript.onload = function () {
        const md5Script = document.createElement('script');
        md5Script.src = 'https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js';
        md5Script.onload = function () {
          const gitalk = new Gitalk({
            clientID: 'Ov23li1TkQEYXFu51qLu',
            clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
            repo: 'Jingqing3948.github.io',
            owner: 'Jingqing3948',
            admin: ['Jingqing3948'],
            id: md5(location.pathname),
            distractionFreeMode: true,
            pagerDirection: 'last'
          });
          gitalk.render('gitalk-container');
        };
        document.body.appendChild(md5Script);
      };
      document.body.appendChild(gitalkScript);
    });
  </script>

  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 
  <script type="text/javascript">
    window.MathJax = {
      tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      showProcessingMessages: false,
      messageStyle: 'none',
      skipStartupTypeset: false
    };
  </script>
  <script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML-full"></script>


<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>
 
<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>