<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jingqing3948 的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-08T16:21:32.523Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jing Qing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式_1</title>
    <link href="http://example.com/2022/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_1/"/>
    <id>http://example.com/2022/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_1/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-08T16:21:32.523Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式可以被视作是增强版的通配符，可以匹配制定规则的字符串。</p><h1 id="练习方法"><a href="#练习方法" class="headerlink" title="练习方法"></a>练习方法</h1><p>可以在编译器中自带的查找功能尝试，也可以在 <a href="https://regex101.com/">regex101.com</a> 在线测试工具中尝试。</p><h1 id="限定符-Quantifiers"><a href="#限定符-Quantifiers" class="headerlink" title="限定符 Quantifiers"></a>限定符 Quantifiers</h1><p>? 表示前面的字符需要出现0次或1次。</p><p>如：<code>used?</code> 可以匹配 use 和 used.</p><p>* 表示前面的字符需要出现0次或多次。</p><p>如：<code>ab*c</code>会匹配ac、abc、abbbc……但不能匹配到 adc。</p><p>+ 表示前面的字符需要出现1次或多次。</p><p>如上例，<code>ab+c</code>不会匹配 ac。</p><p>{数字} 表示前面的字符需要出现多少次。</p><p>如：<code>ab&#123;6&#125;c</code>表示 abbbbbbc，<code>ab&#123;2,6&#125;c</code> 表示b出现2~6次，<code>ab&#123;2,&#125;c</code>表示b出现2次以上。</p><p>() 用于限定多个字符。</p><p>如：<code>(ab)?c</code>表示c或abc。</p><h1 id="或运算-or"><a href="#或运算-or" class="headerlink" title="或运算 or"></a>或运算 or</h1><p><code>a (cat|dog)</code> 表示 a cat 或 a dog.<strong>括号不能少</strong></p><h1 id="字符类-Character-Classes"><a href="#字符类-Character-Classes" class="headerlink" title="字符类 Character Classes"></a>字符类 Character Classes</h1><p>[]+，用于匹配单词，单词的字符只能取自方括号内。</p><p>如：<code>[abc]+</code>表示只由 abc 组成的字符，<code>aabbcc</code>等。</p><p><code>[a-z]+</code>表示所有小写字母</p><p><code>[a-zA-Z]+</code>表示所有字母</p><p><code>[0-9]+</code>表示所有数字</p><p>方括号内加^表示取反，如<code>[^a-z]+</code>表示所有非小写字母的字符（甚至包括换行符）</p><h1 id="元字符-Meta-characters"><a href="#元字符-Meta-characters" class="headerlink" title="元字符 Meta-characters"></a>元字符 Meta-characters</h1><p>\d：数字字符</p><p>\D：非数字字符</p><p>\w：单词字符（英文字符、数字字符、下划线）</p><p>\W：非单词字符</p><p>\s：空白字符（Tab、空格、换行符）</p><p>\S：非空白字符</p><p>\b：单词字符的边界，相当于文本的开头或结束。</p><p>.：任意字符（不包括换行符）</p><p>^：匹配行首，如<code>^a</code>只会匹配出现在行开头的a</p><p>$：匹配行尾，如<code>a$</code>只会匹配出现在行开头的a</p><p>反斜杠用在符号前还可以做转义，如\.表示.字符。</p><h1 id="贪婪与懒惰匹配-Greedy-vs-Lazy-Match"><a href="#贪婪与懒惰匹配-Greedy-vs-Lazy-Match" class="headerlink" title="贪婪与懒惰匹配 Greedy vs Lazy Match"></a>贪婪与懒惰匹配 Greedy vs Lazy Match</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>This is a simple text<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果想匹配所有的标签，也就是匹配&lt;&gt;，中间的内容是一个或多个任意字符。</p><p><code>&lt;.+&gt;</code></p><p>但是这样匹配，会把整行都匹配起来，而不是每个标签单独匹配。这就是贪婪匹配，会尽可能多地匹配。因为.也会匹配&gt;号。</p><p><code>&lt;.+?&gt;</code></p><h1 id="例：-IP-地址"><a href="#例：-IP-地址" class="headerlink" title="例： IP 地址"></a>例： IP 地址</h1><p>IP 地址形如 192.168.0.1</p><p>由四部分数字和三个.组成，每部分数字都不能大于255.</p><p>首先表示出四部分数字+3个.的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(\d+\.)&#123;3&#125;(\d+)<br></code></pre></td></tr></table></figure><p>然后再考虑处理数字大小的问题。</p><p>首先，如果百位是2，十位是5，个位只能取0-5</p><p>如果百位是2，十位是0-4，个位任意数字</p><p>如果百位是0或1，十位和个位可以是任意数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">((25[0-5]|2[0-4]\d|[01]\d\d)\.)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]\d\d)<br></code></pre></td></tr></table></figure><p>然后考虑百位和十位可能不存在的问题：用?处理这两位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">((25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)<br></code></pre></td></tr></table></figure><p>最后首尾加一个\b限定字符边界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">\b((25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(25[0-5]|2[0-4]\d|[01]?\d?\d)\b<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;正则表达式可以被视作是增强版的通配符，可以匹配制定规则的字符串。&lt;/p&gt;
&lt;h1 id=&quot;练习方法&quot;&gt;&lt;a href=&quot;#练习方法&quot; class=&quot;headerlink&quot; title=&quot;练习方法&quot;&gt;&lt;/a&gt;练习方法&lt;/h1&gt;&lt;p&gt;可以在编译器中自带的查找功能尝试，也可以在 </summary>
      
    
    
    
    <category term="regex" scheme="http://example.com/categories/regex/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式_2</title>
    <link href="http://example.com/2022/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_2/"/>
    <id>http://example.com/2022/05/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_2/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-09T10:01:17.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>() 是有分组提取功能的。如提取电话号码可以<code>/(\d&#123;4&#125;)\-(\d&#123;7&#125;)/</code>，就会把<code>1111-1111111</code>的电话号码提取为<code>1111</code>和<code>1111111</code>。</p><p>如果想使用分组的功能，但是又不想提取，就可以使用(?:)。如提取电话号码<code>/(?:\d&#123;4&#125;)\-(\d&#123;7&#125;)/</code>，就只会提取出后七位<code>1111111</code>。</p><h2 id="分组使用示例：提取日期"><a href="#分组使用示例：提取日期" class="headerlink" title="分组使用示例：提取日期"></a>分组使用示例：提取日期</h2><p>日期格式各种各样，如：</p><p>2022-05-09</p><p>2022-5-9</p><p>20220509</p><p>2022 5 9</p><p>2022.05.09</p><p>统一提取这些不同格式日期的方法：用[]处理年月日分隔处可能出现的字符。</p><p><code>(\d&#123;4&#125;)[\-\. ]?(\d&#123;1,2&#125;)[\-\. ]?(\d&#123;1,2&#125;)</code>[]里的内容表示分隔符可能是-，.，空格，还可能没有（用?处理）。</p><p>(\d{1,2})表示月日可能1位或2位。</p><h1 id="分组的回溯引用"><a href="#分组的回溯引用" class="headerlink" title="分组的回溯引用"></a>分组的回溯引用</h1><p>对于刚才分组得到的数据，可以通过反向引用来获取。</p><p>如查询 abcabc 式的数据：<code>/(abc)(\1)/</code>.</p><p>查询abcdefdefabc：<code>/(abc)(def)(\2)(\1)/</code>.</p><h1 id="先行断言"><a href="#先行断言" class="headerlink" title="先行断言"></a>先行断言</h1><p>或者叫环视、预搜索。</p><h2 id="正向先行断言"><a href="#正向先行断言" class="headerlink" title="正向先行断言"></a>正向先行断言</h2><p>(?=表达式)，指在某个位置向右看，表示所在位置右侧必须能匹配<code>表达式</code>。</p><p>如：<code>/我爱(?=你)</code>表示我爱右边必须要有你。</p><p>检验密码中必须要有大写和小写字母：</p><p><code>(?=.*?[a-z])(?=.*?[A-Z]).+</code></p><p>检验密码中必须要有大写小写字母、数字，长度还要&gt;=8：</p><p><code>(?=.*?[a-z])(?=.*?[A-Z])(?=.*?[0-9]).&#123;8,&#125;</code></p><h2 id="反向先行断言"><a href="#反向先行断言" class="headerlink" title="反向先行断言"></a>反向先行断言</h2><p>(?!表达式)，指在某个位置向右看，表示所在位置右侧必须<strong>不匹配</strong><code>表达式</code>。</p><p>如：<code>/我爱(?!你)</code>表示我爱右边必须<strong>没有</strong>你。</p><h2 id="正向后行断言"><a href="#正向后行断言" class="headerlink" title="正向后行断言"></a>正向后行断言</h2><p>(?&gt;=表达式)，从右往左看。</p><p>如：<code>(?&lt;=我)爱你</code>表示爱你左边必须有我。</p><h2 id="反向后行断言"><a href="#反向后行断言" class="headerlink" title="反向后行断言"></a>反向后行断言</h2><p>(?&gt;!表达式)</p><p>如：<code>(?&lt;!我)爱你</code>表示爱你左边必须<strong>没有</strong>我。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>匹配质数个x。如xx，xxx，xxxxx。</p><p>首先，质数只能被1和它自身整除。所以只需要排除掉可以被2整除，被3整除，被4整除……的数即可。也就是2以上的数字要重复出现两次以上。<br>出现2以上的数字次数的x是(..+)，但是不能用(..+)+，因为+号并不保证每次括号内的字符数相同（可能是2+3+4+……）。所以要用\1反向引用(..+)，再让\1重复出现1次以上，因此(..+)\1+就是任意一个&gt;2的数* 任意一个&gt;=2的数，涵盖了所有合数。<br>最后取反，再限制一下行首行尾就能得出所有质数。<em>有一个小问题好像这样会把x也看做质数。</em></p><p>因此答案是：<code>^(?!(..+)\1+$)</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分组&quot;&gt;&lt;a href=&quot;#分组&quot; class=&quot;headerlink&quot; title=&quot;分组&quot;&gt;&lt;/a&gt;分组&lt;/h1&gt;&lt;p&gt;() 是有分组提取功能的。如提取电话号码可以&lt;code&gt;/(\d&amp;#123;4&amp;#125;)\-(\d&amp;#123;7&amp;#125;)/&lt;/co</summary>
      
    
    
    
    <category term="regex" scheme="http://example.com/categories/regex/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_14 入门——集合进阶1</title>
    <link href="http://example.com/2022/05/08/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_14%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B61/"/>
    <id>http://example.com/2022/05/08/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_14%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B61/</id>
    <published>2022-05-07T16:00:00.000Z</published>
    <updated>2022-05-08T06:03:20.506Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>A[集合]--&gt;C[Collection]<br>A--&gt;M[Map]<br>C--&gt;L[List]<br>C--&gt;S[Set]<br>L--&gt;AL(ArrayList)<br>L--&gt;LL(LinkedList)<br>S--&gt;HS(HashSet)<br>S--&gt;TS(TreeSet)<br>M--&gt;HM(HashMap)<br></code></pre></td></tr></table></figure><p>其中方形的是接口，圆角的是实现类。</p><p>因此先学习 Collection 和 Map 接口后，只需要学习下一级的特有的部分。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>java.util.Collection</p><p>Collection 是单例集合的最高级接口。他表示一组对象，这些对象也被称为 Collection 的元素。</p><p>无法直接实现。可以用多态的方式实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;String&gt; c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-comment">//add(E e) 方法添加元素</span><br>c.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>c.add(<span class="hljs-string">&quot;World&quot;</span>);<br>System.out.println(c);<span class="hljs-comment">//输出[&#x27;Hello&#x27;,&#x27;World&#x27;]，因为 ArrayList 中重写了 toString 方法，所以得到的不是一串地址</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加元素，永远返回 true</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中移除指定的元素，成功移除返回 true</td></tr><tr><td>void clear()</td><td>清空集合中的元素</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在指定的元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合长度</td></tr></tbody></table><p>快捷键：Alt+7，能看到类的所有信息</p><h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h2><p>java.util.Iterator</p><p>Iterator 是一个接口。使用 Iterator 迭代器遍历集合元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; it=c.iterator();<span class="hljs-comment">//通过集合对象中的迭代方法获取对象</span><br></code></pre></td></tr></table></figure><p>追根溯源可以得知，Collection.iterator()方法返回的是一个实现了 Iterator 接口的类：Itr.</p><p>所以实际上是通过多态的方式实例化的。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>E next()</td><td>返回下一个元素（越界访问：NoSuchElementException，被请求的元素不存在）</td></tr><tr><td>boolean hasNext()</td><td>如果存在下一个元素，返回 true</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>    String s=it.next();<span class="hljs-comment">//这样更好一些，因为元素可能还要做其他操作</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>it.next() 像指针一样从0开始遍历。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>java.util.List</p><p>继承自 Collection 类，可以使用其中的方法。</p><p>List 是有序、有索引的。相较于集合 Set，List 中的元素可以重复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; l=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>l.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>l.add(<span class="hljs-string">&quot;World&quot;</span>);<br>System.out.println(l);<span class="hljs-comment">//按存储的顺序输出，[&quot;Hello&quot;,&quot;World&quot;]</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void add(int index,E element)</td><td>感觉并不用解释</td></tr><tr><td>E remove(int index)</td><td></td></tr><tr><td>E set(int index,E element)</td><td></td></tr><tr><td>E get(int index)</td><td></td></tr></tbody></table><p>越界报错 IndexOutOfException。</p><p>另一种遍历集合的方法是 for 循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l.size();i++)System.out.println(l.get(i));<br></code></pre></td></tr></table></figure><h2 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h2><p>当不允许这样的修改时，会抛出此方法。</p><p>如：在使用 iterator 遍历过程中，在集合中添加了新的元素。</p><p>iterator 调用 next() 方法时，会先调用 checkForComodification() 方法。</p><p>checkForComodification() 会检验 modCount 修改集合的次数和expectedModCount 预期修改集合的次数是否相等。</p><p>modCount 来自于 ArrayList 的父类：AbstractList，初始值为0.每次使用 add() 方法时，modCount 就会++。</p><p>expectedCount 来自于 Itr 类，且初始值为 <code>expectedCount=modCount</code>.</p><p>每次实例化一个 Iterator 类，都会调用其子类 Itr 类，使得 expectedCount 等于当前的 modCount。</p><p>然后遍历过程中每次调用 next() 方法时，都会先检查一下<code>expectedCount==modCount</code>，即集合有没有被修改。如果没有修改就可以顺利地返回下一个元素；如果有异常 checkForComodificationException，就会终止运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>C[Collection]--&gt;|获取迭代对象|I[iterator]<br>C--&gt;|多态|Arr[Arraylist]<br>I--&gt;|多态|Itr[Itr]<br>I--&gt;W&#123;&quot;iterator.hasNext()==true&quot;&#125;<br>Itr--&gt;A(expectedCount=modCount)<br>W--&gt;|no|en(遍历结束)<br>W--&gt;|yes|N(&quot;iterator.next()&quot;)<br>N--&gt;cf(&quot;checkForComodification()&quot;)<br>cf--&gt;cfe&#123;&quot;expectedCount==modCount&quot;&#125;<br><br>X--&gt;W<br>cfe--&gt;|no|Y(checkForComodificationException)<br>cfe--&gt;|yes|X(&quot;集合没有被修改,继续遍历&quot;)<br></code></pre></td></tr></table></figure><p>但是通过 for 循环遍历集合，在遍历过程中对集合进行修改，不会报异常。</p><h2 id="ListInterator"><a href="#ListInterator" class="headerlink" title="ListInterator"></a>ListInterator</h2><p>通过 List 中的 listInterator() 方法得到。可以从各个方向遍历，迭代期间可以修改列表，还可以获取列表迭代器的当前位置。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean hasNext()</td><td></td></tr><tr><td>E next()</td><td></td></tr><tr><td>boolean hasPrevious()</td><td>反向遍历用到</td></tr><tr><td>E previous()</td><td>反向遍历用到</td></tr><tr><td>void add(E e)</td><td>添加元素，<strong>注意是通过 listInterator 添加的，不是通过集合添加的！</strong></td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; l=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>l.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>l.add(<span class="hljs-string">&quot;World&quot;</span>);<br>l.add(<span class="hljs-string">&quot;java&quot;</span>);<br>ListInterator&lt;String&gt; li=l.listInterator();<span class="hljs-comment">//实际上是 listItr 类作为 listInterator 类的子类，通过多态实现</span><br><span class="hljs-keyword">while</span>(li.hasNext())&#123;<br>    System.out.println(l.next());<br>&#125;<br><br><span class="hljs-keyword">while</span>(li.hasPrevious())&#123;<br>    System.out.println(l.previous());<br>&#125;<br><br><span class="hljs-keyword">while</span>(li.hasNext())&#123;<br>    String s=l.next();<br>    <span class="hljs-keyword">if</span>(s.equals(<span class="hljs-string">&quot;World&quot;</span>))&#123;<br>        li.add(<span class="hljs-string">&quot;!!!&quot;</span>);<span class="hljs-comment">//特别注意，并不是调用了l的 add() 方法，而是 li 的 add() 方法！</span><br>    &#125;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 listItr 类中的 add() 方法，添加完元素之后，有一句<code>expectedModCount=modCount;</code>重新把实际修改值赋给了预期修改值。因此 next() 方法中判断<code>expectedModCount==modCount</code>，即使添加了新元素也仍然是 true. 不会发生并发修改异常。</p><h2 id="增强-for"><a href="#增强-for" class="headerlink" title="增强 for"></a>增强 for</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(E e:数组或 Collection 的集合)<br>&#123;<br><span class="hljs-comment">//在这里使用变量e，把其当做集合元素来用</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:arr)&#123;<br>    System.out.println(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:list)&#123;<br>    System.out.println(i);<br>&#125;<br><span class="hljs-comment">//内部是一个 iterator 迭代器，不可以中途修改数据，会引发并发修改异常。</span><br></code></pre></td></tr></table></figure><h2 id="几种遍历方式的选择"><a href="#几种遍历方式的选择" class="headerlink" title="几种遍历方式的选择"></a>几种遍历方式的选择</h2><p>单纯的遍历：增强 for 最简单。</p><p>需要用到索引：普通 for。</p><p>迭代器也要会用。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>后入先出 FILO。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先入先出 FIFO。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>可以根据索引查找，查找效率高；增删效率低。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>每个结点存储数据和下一个结点的地址值。最后一个结点地址值为空。</p><p>相比数组，增删只需要修改增删处前后结点的地址值，效率更高。</p><p>但是查询必须从头开始，效率低。</p><h1 id="List-的子类"><a href="#List-的子类" class="headerlink" title="List 的子类"></a>List 的子类</h1><p>ArrayList 底层数据结构是数组，LinkedList 底层数据结构是链表。</p><p>用法一模一样，查询效率高就用 ArrayList，增删效率高用 LinkedList。</p><h2 id="LinkList-特有功能"><a href="#LinkList-特有功能" class="headerlink" title="LinkList 特有功能"></a>LinkList 特有功能</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public void addFirst(E e)</td><td></td></tr><tr><td>public void addLast(E e)</td><td></td></tr><tr><td>public E getFirst()</td><td></td></tr><tr><td>public E getLast()</td><td></td></tr><tr><td>public void removeFirst()</td><td></td></tr><tr><td>public void removeLast()</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_13 入门——异常</title>
    <link href="http://example.com/2022/05/07/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_13%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/"/>
    <id>http://example.com/2022/05/07/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_13%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8/</id>
    <published>2022-05-06T16:00:00.000Z</published>
    <updated>2022-05-07T07:51:50.045Z</updated>
    
    <content type="html"><![CDATA[<p>有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。</p><h1 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h1><p>Throwable 是所有错误、异常的父类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>A[Throwable]--&gt;B[Error]<br>A--&gt;C[异常]<br>C--&gt;R[RuntimeException 运行型异常]<br>C--&gt;O[其他 编译型异常]<br></code></pre></td></tr></table></figure><p>Error 程序无法处理，而异常程序可以处理。</p><p>RuntimeException：运行时异常，非受检异常， 可以先不处理，真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。</p><p>编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。</p><h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><p>JVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。</p><p>程序员还可以有自己的处理异常方法，如 try…catch 和 throw。</p><h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    可能出现异常的代码;<br>&#125;<br><span class="hljs-keyword">catch</span>(异常类名 变量名)&#123;<br>    出现异常后的处理代码;<br>&#125;<br><br>String s=<span class="hljs-string">&quot;2022-05-07&quot;</span>;<br>SimpleDateFormat sdf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-mm-dd&quot;</span>);<br>sdf.parse(s);<span class="hljs-comment">//这个方法不能直接用，必须要加异常处理</span><br><br><span class="hljs-keyword">try</span>&#123;<br>    sdf.parse(s);<br>&#125;<br><span class="hljs-keyword">catch</span>(ParseException e)&#123;<br>    System.out.print(<span class="hljs-string">&quot;parseException!&quot;</span>);<span class="hljs-comment">//不管会不会发生异常，都要写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，<strong>处理完成后可以继续执行。</strong></p><p>如果异常变量命名为 e ,尝试调用 e 的成员方法<code>e.printStackTrace()</code>就会输出平时出现异常时系统默认提示的信息：<code>java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... </code></p><p>但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。</p><h3 id="Throwable-的成员方法"><a href="#Throwable-的成员方法" class="headerlink" title="Throwable 的成员方法"></a>Throwable 的成员方法</h3><p>Throwable 作为超类，其所有子类都可以使用他的成员方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回此 Throwable 的详细消息字符串</td></tr><tr><td>public String toString()</td><td>返回此可抛出的简短描述</td></tr><tr><td>public void printStackTrace()</td><td>把异常的错误信息输出到控制台</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">e.getMessage():  Index 3 out of bounds for length 3<br>e.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3<br>e.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....<br></code></pre></td></tr></table></figure><p>利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Throwable</span> &#123;<br>    <span class="hljs-keyword">private</span> String detailMessage;<span class="hljs-comment">//Throwable 类中的一个成员方法</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Throwable</span><span class="hljs-params">(String message)</span>&#123;<br>        detailMessage=message;<span class="hljs-comment">//构造方法。出现异常时，会通过这种方法构造一个异常对象</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> detailMessage;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a>Throws</h2><p>可以抛出异常给 try catch 处理，但是自身不能解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throws</span> 异常类名;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;运行开始&quot;</span>);<br>    method1();<br>    <span class="hljs-keyword">try</span>&#123;<br>        method2();<span class="hljs-comment">//抛出给了 try catch 处理</span><br>    &#125;<br>    <span class="hljs-keyword">catch</span>(ParseException e)<br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;运行错误&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;运行结束&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ArrayIndexOutOfException&#123;<br>    <span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    System.out.println(arr[<span class="hljs-number">3</span>]);<span class="hljs-comment">//会报错并停止运行， throws 并没有解决异常</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException&#123;<br>    String s=<span class="hljs-string">&quot;2022-05-07&quot;</span>;<br>SimpleDateFormat sdf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-mm-dd&quot;</span>);<br>sdf.parse(s);<span class="hljs-comment">//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名 <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    无参构造<br>    带参构造<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScoreException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScoreException</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScoreException</span><span class="hljs-params">(message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);<span class="hljs-comment">//把 message 传给父类处理</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//异常类的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">throws</span> ScoreException&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(score&lt;<span class="hljs-number">0</span>||score&gt;<span class="hljs-number">100</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScoreException</span>(<span class="hljs-string">&quot;输入分数有误！请重新输入&quot;</span>);<span class="hljs-comment">//throw 不是 throws!</span><br>            <span class="hljs-comment">/*throw 写在方法体内，throws 写在类定义里。</span><br><span class="hljs-comment">            throws 不一定有异常，而 throw 一定是抛出了异常。*/</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;分数正常&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    <span class="hljs-type">int</span> score=sc.nextInt();<br>    Teacher t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>    <span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//调用方法时，要处理抛过来的异常</span><br>        t.checkScore(score);<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(ScoreException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//异常时就会输出：异常类型 ScoreException，异常原因&quot;输入分数有误！请重新输入&quot;，异常位置。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。&lt;/p&gt;
&lt;h1 id=&quot;Throwable&quot;&gt;&lt;a href=&quot;#Throwable&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_11 入门——内部类</title>
    <link href="http://example.com/2022/05/05/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_11%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://example.com/2022/05/05/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_11%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2022-05-04T16:00:00.000Z</published>
    <updated>2022-05-05T02:49:56.316Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>在类中定义一个类。</p><h1 id="内部类和外部类的互相使用"><a href="#内部类和外部类的互相使用" class="headerlink" title="内部类和外部类的互相使用"></a>内部类和外部类的互相使用</h1><p>无论外部类的成员变量的权限修饰符是什么（private, public……）内部类都可以直接访问外部类的全部成员变量。</p><p>而外部类如果想访问内部类的成员，需要先创建一个内部类对象再访问。</p><p><em>因为都在同一个类中，所以即使权限修饰符是 private 也可以访问。</em></p><h1 id="外界使用内部类"><a href="#外界使用内部类" class="headerlink" title="外界使用内部类"></a>外界使用内部类</h1><p>外界使用内部类：<code>Outer.Inner oi=new Outer().new Inner();</code></p><p>如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。</p><h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><p>在类的成员位置定义：成员内部类</p><p>在类的局部定义：局部内部类。</p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>不能从外界直接创建对象，只能通过调用方法来创建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(num);<span class="hljs-comment">//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量</span><br>            &#125;<br>        &#125;<br>        Inner i=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<span class="hljs-comment">//在方法中创建内部对象</span><br>        i.show();<span class="hljs-comment">//创建对象之后，记得调用内部方法的成员变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>继承了另一个类，或实现了接口的子类匿名对象。</p><p>首先有一个父类/接口，其中有具体的/抽象的方法，然后匿名内部类对其进行重写/实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口文件 inter.java 中：</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">inter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<span class="hljs-comment">//抽象方法</span><br>&#125;<br><br><span class="hljs-comment">//外部类文件 Outer.java 中</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">inter</span> &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>);<br>            &#125;<br>        &#125;.show();<span class="hljs-comment">//创建匿名对象之后，记得调用成员变量</span><br>        <br>        <span class="hljs-comment">//另一种方法：</span><br>        inter i=<span class="hljs-keyword">new</span> <span class="hljs-title class_">inter</span> &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;匿名内部类&quot;</span>);<br>            &#125;<br>        &#125;<br>        i.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行j的 jump 。</p><p>我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；</p><p>然后用堕胎的方式<code>jump c=new cat(); jump d=new dog();</code> 新建对象并传给 method 方法。</p><p>但是可以通过匿名内部类的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">jo.method(<span class="hljs-keyword">new</span> <span class="hljs-title class_">jump</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jump</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;猫跳高&quot;</span>);<br>    &#125;<br>&#125;);<br><br>jo.method(<span class="hljs-keyword">new</span> <span class="hljs-title class_">jump</span>()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jump</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;狗跳高&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>直接穿一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;在类中定义一个类。&lt;/p&gt;
&lt;h1 id=&quot;内部类和外部类的互相使用&quot;&gt;&lt;a href=&quot;#内部类和外部类的互相使用&quot; class=&quot;headerlink&quot; title=&quot;内部类和外部类的互相使用&quot;&gt;&lt;/a&gt;内部类和外部</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_12 入门——常用 API</title>
    <link href="http://example.com/2022/05/05/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_12%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%20API/"/>
    <id>http://example.com/2022/05/05/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_12%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%20API/</id>
    <published>2022-05-04T16:00:00.000Z</published>
    <updated>2022-05-05T02:50:22.594Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><h1 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h1><p>不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>绝对值，支持 double  float int long 类型</td></tr><tr><td>public static double ceil(double a)</td><td>向上取整，返回一个 double 值</td></tr><tr><td>public static double floor(double a)</td><td>向下取整，返回一个 double 值</td></tr><tr><td>public static int round(float a)</td><td>四舍五入</td></tr><tr><td>public static int max(int a,int b)</td><td></td></tr><tr><td>public static int min(int a,int b)</td><td></td></tr><tr><td>public static double pow(double a,double b)</td><td>a 的 b 次幂</td></tr><tr><td>public static double random()</td><td>随机数，范围 [0.0,1.0)</td></tr></tbody></table><p>随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用<code>random()*100</code>。</p><h1 id="System"><a href="#System" class="headerlink" title="System"></a>System</h1><p>不用导包，不能实例化，static</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static void exit(int status)</td><td>终止运行 JVM，非零表示非正常终止</td></tr><tr><td>public static long currentTimeMillis()</td><td>返回当前时间到1970年1月1日的时间间隔，以毫秒为单位</td></tr></tbody></table><p>currentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。</p><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Object 类是所有类的根类。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String toString()</td><td>返回对象的字符串表示形式。建议子类全部重写该方法</td></tr><tr><td>public boolean equals(Object obj)</td><td>比较对象是否相等（默认比较地址）。重写可以比较对象内容</td></tr></tbody></table><h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h2><p>Object 中包含 toString 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出类名@+一串哈希值。</p><p>一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter / setter 一样自动生成。类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//手动实现</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123; Person:name=&quot;</span> + name +<span class="hljs-string">&quot; age=&quot;</span> + age+<span class="hljs-string">&quot;&#125;&quot;</span>;<span class="hljs-comment">// name 和 age 都是本类中的成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><p><code>s1.equals(s2)</code>本质上是比较两个对象的地址，肯定是 false。</p><p>一般也会重写/自动生成可以比较两个对象内容是否一致的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>==o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//同一个对象</span><br>    <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">null</span>||getClass()!=o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//o是空对象，或这两个对象不属于一个类</span><br>    Student student=(Student) o;<span class="hljs-comment">//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来</span><br>    <span class="hljs-keyword">if</span> (age!=student.age)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    <span class="hljs-keyword">return</span> name!=<span class="hljs-literal">null</span>?name.equals(student.name):student.name==<span class="hljs-literal">null</span>;<span class="hljs-comment">//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h1><p>需要导包 <code>java.util.Arrays</code>，不能创建对象，成员是 static的。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回形如 “[a, b, c]” 的字符串形式</td></tr><tr><td>public static void sort(int[] a)</td><td>按数字顺序排列指定的数组</td></tr></tbody></table><h1 id="补充：工具类"><a href="#补充：工具类" class="headerlink" title="补充：工具类"></a>补充：工具类</h1><p>以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。</p><p>不能创建对象的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Math</span><span class="hljs-params">()</span>&#123;&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Arrays</span><span class="hljs-params">()</span>&#123;&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">System</span><span class="hljs-params">()</span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。</p><h1 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h1><p>其中有一些方法能更好地处理基本数据类型。</p><p>包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p><h2 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public static Integer valueOf(int i)</td><td>把 int 转换为 Integer 类型</td></tr><tr><td>public static Integer valueOf(String s)</td><td>把 String 转换为 Integer 类型</td></tr></tbody></table><p>public String[] split(String regex) 把给定字符串用 regex 分隔开。</p><p>如给定字符串 s 是”1 2 3 4”，<code>s.split(&quot; &quot;)</code>就会得到4个字符串：”1””2””3””4”。</p><h2 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h2><p>int -&gt; String：</p><p>① 空字符串””+int 类型</p><p>② String s=String.valueOf(i)</p><p>String -&gt; int：</p><p>① Integer in=Integer.valueOf(s);</p><p>int i=intValue(in);</p><p>② int i=Integer.parseInt(s);</p><h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p>装箱：基本类型-&gt;对应的包装类型</p><p>拆箱：包装类型-&gt;基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer i=Integer.valueOf(<span class="hljs-number">100</span>);<span class="hljs-comment">//装箱</span><br>Integer ii=<span class="hljs-number">100</span>;<span class="hljs-comment">//自动装箱</span><br><br>ii=ii.intValue()+<span class="hljs-number">200</span>;<span class="hljs-comment">//拆箱</span><br>ii+=<span class="hljs-number">200</span>;<span class="hljs-comment">//自动拆箱</span><br><br>Integer i3=<span class="hljs-literal">null</span>;<br>i3+=<span class="hljs-number">300</span>;<span class="hljs-comment">//NullPointerException。因此对象使用之前最好先判断是否为 null</span><br></code></pre></td></tr></table></figure><h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 类，需要导包。<strong>注意是 java.util 下的，而不是 java.sql 下的！</strong>java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public Date()</td><td>初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒</td></tr><tr><td>public Date(long Date)</td><td>分配一个 Date 对象，值为从标准时间起指定的毫秒数</td></tr><tr><td>public long getTime()</td><td>获取日期对象从标准时间到现在的毫秒数</td></tr><tr><td>public void setTime(long time)</td><td>设置时间，单位为毫秒</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份</span><br><br><span class="hljs-type">long</span> d=<span class="hljs-number">1000</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>;<br>Date da=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(d);<span class="hljs-comment">//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）</span><br><br><span class="hljs-type">long</span> time=System.currentTimeMillis();<span class="hljs-comment">//可以这样获取当前时间，然后传给 Date() 或 setTime()</span><br></code></pre></td></tr></table></figure><h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p>可以自己设置日期格式。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public SimpleDateFormat()</td><td>构造方法，并使用系统默认的 Date 格式</td></tr><tr><td>public SimpleDateFormat(String pattern)</td><td>构造方法，并使用自己规定的格式</td></tr><tr><td>public final String format(Date d)</td><td>将日期对象转换为相应格式的字符串</td></tr><tr><td>public final Date parse(String s)</td><td>将字符串转换为日期</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Parse Exception&#123;<span class="hljs-comment">//结尾要加一些东西，在 IDEA 中可以自动补全</span><br>    Date d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>;<span class="hljs-comment">//被分配时的时间</span><br>    SimpleDateFormat sdf=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年-MM月-dd日 HH:mm:ss&quot;</span>);<br>    String s=sdf.format(d);<br>    System.out.println(s);<span class="hljs-comment">//输出格式就形如 2022年-05月-05日 10:24:00</span><br>    <br>    String ss=<span class="hljs-string">&quot;2022-05-05 10:24:00&quot;</span>;<br>    SimpleDateFormat sdf1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    Date d1=sdf1.parse(ss);<br>&#125;<br></code></pre></td></tr></table></figure><p>y 年 M 月 d 日</p><p>H 时 m 分 s 秒</p><p>（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把Date转换为String和把String转换为Date；这两个方法可以设置两个传入参数：</p><p>public static String dateToString(Date d, String format)</p><p>public static String StringTodate(String s, String format)</p><p>在方法内根据传入的字符串格式，利用SimpleDateFormat的方法进行转换。）</p><h2 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h2><p>需要导包<code>java.util.Calendar</code>，是一个抽象类。</p><p>为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。</p><p>Calendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Calendar rightnow=Calendar.getInstance();<br></code></pre></td></tr></table></figure><p>其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public int get(int field)</td><td>获取给定日历字段的值</td></tr><tr><td>public abstract void add(int field, int amount)</td><td>添加/减去给定的日历字段</td></tr><tr><td>public final void set(int year, int month, int date)</td><td>设置日历的年月日</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">y=c.get(Calendar.YEAR);<br>m=c.get(Calendar.MONTH)+<span class="hljs-number">1</span>;<span class="hljs-comment">//month 是从0开始的，所以要+1</span><br>d=c.get(Calendar.DATE);<br><br><span class="hljs-comment">//例：求2020年2月有多少天?</span><br>Calendar c=Calendar.getInstance();<br>c.set(<span class="hljs-number">2020</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//设置为3月1日</span><br>c.add(Calendar.DATE,-<span class="hljs-number">1</span>);<span class="hljs-comment">//倒退1天，就是2月的最后一天</span><br>System.out.println(<span class="hljs-string">&quot;2020年2月有&quot;</span>+c.get(Calendar.DATE)+<span class="hljs-string">&quot;天&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;h1 id=&quot;Math&quot;&gt;&lt;a href=&quot;#Math&quot; class=&quot;headerlink&quot; title=&quot;Math&quot;&gt;&lt;/a&gt;Math&lt;/h1&gt;&lt;p&gt;不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>html_css_案例_1</title>
    <link href="http://example.com/2022/05/04/html%20css_%E6%A1%88%E4%BE%8B_1%20Header/"/>
    <id>http://example.com/2022/05/04/html%20css_%E6%A1%88%E4%BE%8B_1%20Header/</id>
    <published>2022-05-03T16:00:00.000Z</published>
    <updated>2022-05-04T04:24:07.600Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV14J4114768?p=1">黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动端前端视频教程_哔哩哔哩_bilibili</a></p><p><img src="https://s1.328888.xyz/2022/05/02/Av2CA.png" alt="Av2CA.png"></p><p>以上为学成在线网页案例。本文主要涉及老师讲解的 Header 部分。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>建议样式设置遵循以下步骤：</p><ol><li><strong>布局定位属性：display / position / float / clear / visibility / overflow</strong></li><li><strong>自身属性：width / height / margin / padding / border / background</strong></li><li><strong>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</strong></li><li><strong>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient……</strong></li></ol><p>设计思路：</p><ol><li>确定版心（在页面最中央的），宽度一旦确定不能更改</li><li>确定行模块（标准流）和列模块（浮动）。<em>网页布局第一准则</em></li><li>确定浮动元素中每个列的大小和位置。<em>网页布局第二准则</em></li><li><strong>先理清布局结构，再写代码。</strong></li></ol><h1 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h1><p>首先记得清除全局样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="版心"><a href="#版心" class="headerlink" title="版心"></a>版心</h3><p>利用 Ps 测量知，版心部分宽1200像素，并且全部居中对齐。</p><p>因为涉及到好几个块级元素都是这样的样式，所以用类选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.w</span> &#123;<span class="hljs-comment">/*版心的宽度、居中样式*/</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1200px</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<span class="hljs-comment">/*设置 margin-left 和 right 都是 auto，就会居中*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后设计顺序是先把一行设计完（包括这行内的所有元素），然后再设计下一行。</p><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p><img src="https://s1.328888.xyz/2022/05/02/AEZUX.png" alt="AEZUX.png"></p><p>从左到右依次为：logo，导航栏 nav，搜索 search，头像 user 四列。</p><p>四列有着同样的高度，设置这一行的盒子的样式第一种做法是一整个盒子把这一行四列包起来，这个盒子和这四个元素一样高，然后设置上下外边距；（老师的方法）</p><p>第二种做法是一整个盒子包住这四个元素，但是这个盒子更大一些，在盒子内部设置内边距留有一些空间；解法很多。</p><p>记得 header 盒子要同时选中 header 和版心 w 两个样式类。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;header w&quot;</span>&gt;</span>头部盒子<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测量得知：logo 高度42像素，上下各有30像素的空白。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.header</span> &#123;<span class="hljs-comment">/*包裹 header 一行的盒子的样式*/</span><br><span class="hljs-attribute">height</span>: <span class="hljs-number">42px</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">30px</span> auto;<span class="hljs-comment">/*表示：上下30px，左右水平居中*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="logo：学成在线"><a href="#logo：学成在线" class="headerlink" title="logo：学成在线"></a>logo：学成在线</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image/logo.png&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>logo 图标高42像素，宽200像素。此外记得，这几个盒子横向放在一行中，所以都要加 float 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.logo</span> &#123;<br>    <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>:<span class="hljs-number">42px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p><strong>实际开发中，导航栏是采用 li 包裹 a 标签的方法实现的</strong>，这样使得链接标签结构更加清晰，而且如果堆叠 a 标签，有可能被搜索引擎怀疑恶意堆砌关键字而降权。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>课程<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>职业规划<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>先把页面中的所有 li 标签前面的圆点去掉，然后写 nav 类选择器。</p><p>测量得知，其距离左边的 logo 图标60像素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">li</span> &#123;<br>    line-style: none;<br>&#125;<br><span class="hljs-selector-class">.nav</span> &#123;<br>    <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">60px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于具体的三个导航栏，浮动要给 li 标签设置而不是 a 标签设置。每个导航栏按钮之间相距30像素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，真正想实现点击跳转的链接效果，点击范围不只局限于文字区域，而是整块盒子可以点击。所以要给 a 设置为块级元素属性。</p><p>三个导航栏长度随其内容的长度而变化，所以要设置水平方向上内边距 padding 而不能设置盒子具体大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: none;<span class="hljs-comment">/*去掉链接标签自带的下划线*/</span><br>&#125;<br><br><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">display</span>: block;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">42px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">42px</span>;<span class="hljs-comment">/*使得文字内容垂直居中对齐*/</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure><p>li 标签不用设置宽度，一方面是浮动的块级元素的特性：其宽度会和内容一样宽；</p><p>一方面考虑到以后可能还会添加新的导航栏。</p><p>最后是期望鼠标经过导航栏链接元素的时候，文字变成蓝色，且盒子底部会出现蓝色的线提示鼠标悬停在该块上。用 hover 完成。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.nav</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br><span class="hljs-attribute">border-bottom</span>: blue;<span class="hljs-comment">/*线宽和文字内容一样宽*/</span><br>    <span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h4><p><img src="https://s1.328888.xyz/2022/05/03/hdRMC.png" alt="hdRMC.png"></p><p>一个大盒子包住，左侧：输入文本框；右侧：按钮。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> / <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;输入关键词&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.search</span> &#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">410px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">42px</span>;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">50px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.search</span> <span class="hljs-selector-tag">input</span> &#123;<span class="hljs-comment">/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/</span><br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">345px</span>;<span class="hljs-comment">/*其实整个输入框宽360px。只是因为盒子设置了宽度，再有了 padding-left 会撑大盒子。因此要360-15*/</span><br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">42px</span>;<br>    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">15px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">0</span>;<span class="hljs-comment">/*因为右边是搜索按钮，可以不用边框*/</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#bfbfbf</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<span class="hljs-comment">/*Ps 中测量得到的 pt 单位和 px 一样大*/</span><br>&#125;<br><br><span class="hljs-selector-class">.search</span> <span class="hljs-selector-tag">button</span> &#123;<span class="hljs-comment">/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/</span><br>    <span class="hljs-attribute">float</span>: left;<br>    wdith； <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">42px</span>;<br>    <span class="hljs-selector-tag">button</span>: <span class="hljs-number">0</span>;<span class="hljs-comment">/*去掉按钮默认的边框*/</span><br>    <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">image/button.png</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="登录状态"><a href="#登录状态" class="headerlink" title="登录状态"></a>登录状态</h4><p><img src="https://s1.328888.xyz/2022/05/04/hlga2.png" alt="hlga2.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    qq-leishui<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.user</span> &#123;<br>    <span class="hljs-attribute">float</span>: right;<br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">42px</span>;<br>    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">30px</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>图片文字部分居中：之后的课程涉及到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV14J4114768?p=1&quot;&gt;黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动端前端视频教程_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    <category term="html+css" scheme="http://example.com/categories/html-css/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>git_3 版本控制</title>
    <link href="http://example.com/2022/05/03/git_3%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2022/05/03/git_3%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</id>
    <published>2022-05-02T16:00:00.000Z</published>
    <updated>2022-05-04T04:23:41.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看历史版本信息"><a href="#查看历史版本信息" class="headerlink" title="查看历史版本信息"></a>查看历史版本信息</h1><p><code>git log</code>查看之前的版本信息。</p><p>其中可以看到 HEAD-&gt;master（或 main），HEAD 是指向当前版本的指针，之后修改版本其实就是移动这个指针。</p><p>如果最下面一行是冒号，说明记录多到一页装不下了。</p><p>多屏显示控制方式：空格向下翻页，b 向上翻页，q退出。</p><p><code>git log --pretty=oneline</code>以每次版本占一行的，漂亮的方式 显示版本信息。</p><p><code>git log --oneline</code>连哈希值也会缩短（被称为局部索引值）。<strong>只能查看之前的版本信息，版本回退后不能看到将来的版本。</strong></p><p><code>git reflog</code>显示 commit 信息，以及从当前版本移动到这个版本需要多少步（如：HEAD@{1}表示差了一个版本，0表示这个版本就是当前版本）<strong>可以查看历史/未来版本。</strong></p><h1 id="版本前进-回退"><a href="#版本前进-回退" class="headerlink" title="版本前进 / 回退"></a>版本前进 / 回退</h1><p>本质就是移动 HEAD 指针。</p><p>方法1：首先通过 <code>git log --oneline</code>找到要跳转的版本的哈希值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git reset --hard Fd83ed9 // 结尾是刚才获取的哈希值，即局部索引值<br></code></pre></td></tr></table></figure><p>不管前进后退都是这种方法。</p><p>方法2：只能后退</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git reset --hard^//回退一个版本。有几个异或符号，回退几个版本。<br></code></pre></td></tr></table></figure><p>方法3：只能后退</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git reset hard~3//回退3个版本<br></code></pre></td></tr></table></figure><p>soft：修改本地库的指针。修改后输入<code>cat good.txt</code> 查看本地库的文件，会发现文件已经变成修改版本后的文件了。</p><p><em>如果输入 <code>git status</code> ，会发现暂存区也被 modified 了。并不是因为暂存区变了，而是本地库指针移动了，和暂存区无法对应了。</em></p><p>mixed：修改本地库的指针，并重置暂存区。</p><p>hard：修改本地库的指针，并重置暂存区和工作区。</p><h1 id="删除及找回删除文件"><a href="#删除及找回删除文件" class="headerlink" title="删除及找回删除文件"></a>删除及找回删除文件</h1><p>如果是删除并提交了删除操作之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs git">rm aaa.txt//删除文件<br>git add aaa.txt//添加删除操作<br>git commit -m &quot;&quot; aaa.txt//提交删除操作<br><br>git reflog//查看历代版本及其哈希值<br>git reset --hard abcdef//回退到有这个文件的版本<br>git checkout -- aaa.txt//另一种方法<br></code></pre></td></tr></table></figure><p>如果是删除后把删除操作添加到暂存区后：<code>git reset --hard HEAD</code>。</p><h1 id="比较文件差异"><a href="#比较文件差异" class="headerlink" title="比较文件差异"></a>比较文件差异</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//工作区未提交到暂存区：<br>git diff a.txt//比较该文件做的改动。红色行删除，绿色行新增/修改。<br>//工作区提交到暂存区后：上一种方法查不出差别。<br>git diff HEAD a.txt//比较本地库的版本<br>git diff HEAD^3 a.txt//比较本地库的当前版本和倒退三个版本的区别<br></code></pre></td></tr></table></figure><p>不带文件名就是比较多个文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查看历史版本信息&quot;&gt;&lt;a href=&quot;#查看历史版本信息&quot; class=&quot;headerlink&quot; title=&quot;查看历史版本信息&quot;&gt;&lt;/a&gt;查看历史版本信息&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git log&lt;/code&gt;查看之前的版本信息。&lt;/p&gt;
&lt;p&gt;其中可以看到 H</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_10 入门——抽象类、抽象方法、接口</title>
    <link href="http://example.com/2022/05/02/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_10%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2022/05/02/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_10%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-05-01T16:50:35.968Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>抽象方法：没有方法体的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>抽象类：含有抽象方法的类。</p><p>（没有抽象方法的类也可以是抽象类，但是意义何在）</p><p>抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象方法。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Jumpping</span>&#123;<span class="hljs-comment">//接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Jump</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Jumpping</span>&#123;<span class="hljs-comment">//实现</span><br>    <span class="hljs-comment">//重写 Jump() 方法。如果不重写， Cat 就是一个抽象类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。</p><p>接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。</p><p>（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）</p><p>接口是抽象类，不能直接实例化，可以借助多态的方法实例化。</p><p>相较类与类之间不能多继承，只能层层继承：接口可以多实现<code>implements interface1, interface2</code></p><p>接口和接口之间也可以多继承<code>interface1 extends interface2, interface3</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s1.328888.xyz/2022/05/01/An2QF.png" alt="An2QF.png"></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。</p><p>但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。</p><p>例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。分析本例如何用具体类、抽象类、接口实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>A[人]--&gt;B[运动员]<br>A--&gt;C[教练]<br>B--&gt;D[篮球运动员]<br>B--&gt;E[乒乓球运动员]<br>H[说英语]--&gt;E<br>H--&gt;G<br>C--&gt;G[乒乓球教练]<br>C--&gt;F[篮球教练]<br></code></pre></td></tr></table></figure><p>其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。</p><h2 id="抽象类-接口作为形参-返回值"><a href="#抽象类-接口作为形参-返回值" class="headerlink" title="抽象类 / 接口作为形参 / 返回值"></a>抽象类 / 接口作为形参 / 返回值</h2><p>类也可以作为形式参数或函数的返回值。</p><p>抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要的是实现了该抽象类的子类对象。</p><p>如函数形参是Animal，实际需要通过多态的方法Animal a=new Cat();然后把a传给函数。</p><p>接口作为形参/函数返回值，和抽象类一样，实际需要的是实现了该接口的类对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;抽象方法：没有方法体的方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>git_2 命令行添加、提交操作</title>
    <link href="http://example.com/2022/05/02/git_2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B7%BB%E5%8A%A0%E3%80%81%E6%8F%90%E4%BA%A4%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/05/02/git_2%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B7%BB%E5%8A%A0%E3%80%81%E6%8F%90%E4%BA%A4%E6%93%8D%E4%BD%9C/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-05-02T05:16:35.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h1><p>git 的专属命令都是以 git 打头的。</p><p>在文件夹中右键 – git bash here 启动 git 命令行。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>ll</td><td>当前目录下的资源</td></tr><tr><td>ls -lA</td><td>带隐藏资源</td></tr><tr><td>ls -l|less</td><td>分频查看</td></tr><tr><td>pwd</td><td>当前位置路径</td></tr><tr><td>mkdir 目录名</td><td>新建目录</td></tr><tr><td>git init</td><td>初始化当前目录（并创建 .git 文件夹）</td></tr></tbody></table><p><strong>.git 里存放的是本地库相关的子目录和文件，不要删除和随便修改！！</strong></p><h1 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h1><p>需要设置用户名和 email 地址，唯一用处就是标识开发者身份。</p><p><strong>登录代码托管中心的账号密码（如 github、gitee）和签名的用户名、email 地址没有任何关系。</strong></p><p>项目/仓库级别：只对当前本地库范围内有效。</p><p>系统用户级别：对当前系统的登录账号（lenovo）有效。</p><p>同时存在的话，项目/仓库级别优先级更高。但是二者必须至少有一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git config user.name Jingqing//项目级别<br>git config user.email Jingqing@163.com//项目级别<br><br>git config --global user.name Jingqing//系统用户级别<br>git config --global user.email Jingqing@163.com//系统用户级别<br></code></pre></td></tr></table></figure><p>项目级别的签名：在项目文件夹下输入 <code>cat .git/config</code>，会发现在签名就保存在 .git 文件夹的 config 目录下。</p><p>项目级别的签名：<code>cat ~/.gitconfig</code>跳转到家目录查看。</p><p><em>开发时如果不是特殊需求，一般一个系统级别签名即可。</em></p><h1 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h1><p>git status 查看工作区、暂存区状态</p><p>no commit yet：指本地库里没有内容，因为 commit 之后是会放到本地库里的。</p><p>nothing to commit：暂存区没有内容可以提交。</p><p>changes to be committed：暂存区有内容等待提交。</p><h1 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//vim 新建文件<br>vim good.txt<br>//然后输入文本文档内容，按 esc 后按两次大写 Z 保存退出。<br>git add good.txt<br>//这里提示：warning, 行末的 LF 会被替换为 CRLF，这和安装时 git 的配置有关，影响不大<br>git rm --cached good.txt<br>//撤回暂存区的内容<br>git commit good.txt<br>//提交文件，然后会提示：请输入提交的信息备注，并且显示一个 vim 编辑器<br>//输入注释信息后按 esc 输入 冒号+wq 退出<br><br>//但是其实这样才是更常见的用法<br>git commit -m &quot;信息备注&quot; good.txt<br></code></pre></td></tr></table></figure><p>第一次提交会显示 root commit 根提交</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本地库初始化&quot;&gt;&lt;a href=&quot;#本地库初始化&quot; class=&quot;headerlink&quot; title=&quot;本地库初始化&quot;&gt;&lt;/a&gt;本地库初始化&lt;/h1&gt;&lt;p&gt;git 的专属命令都是以 git 打头的。&lt;/p&gt;
&lt;p&gt;在文件夹中右键 – git bash here 启</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>git_1 版本控制介绍</title>
    <link href="http://example.com/2022/05/02/git_1%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/05/02/git_1%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-05-02T05:17:13.167Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1pW411A7a5?p=3&spm_id_from=pageDriver">【尚硅谷】Git与GitHub基础全套完整版教程（快速上手，一套搞定）_哔哩哔哩_bilibili</a></p><h1 id="为什么需要版本控制？"><a href="#为什么需要版本控制？" class="headerlink" title="为什么需要版本控制？"></a>为什么需要版本控制？</h1><p>单人开发有的时候，在开发过程中需要回退到之前的版本。好的版本管理可以大大提高开发效率。</p><p>多人开发的时候，不同人做修改 / 上传时间不统一，如果两个人同时上传，后者就会把前者的内容覆盖。普通文件服务器不能管理文件内容。</p><h1 id="版本控制工具特性"><a href="#版本控制工具特性" class="headerlink" title="版本控制工具特性"></a>版本控制工具特性</h1><p><strong>版本控制是一种思想，版本控制工具（如 SVN、git）是对其实现。</strong></p><p>集中式版本控制工具：如 SVN，开发人员都是客户端，而内容存储在服务器上，所有人和服务器交互。缺点在于服务器一挂，历史数据全部丢失，客户端上只能保存当前状态。（单点故障）</p><p>分布式版本控制工具：如 git ，开发人员在本地就能进行完整的版本控制。就算一个人的数据丢失了，依靠其他人的也能找回来，能有效避免单点故障。不过还是不建议本地库传数据，还是有一个远程库。</p><p>git其他优点：</p><ul><li>大部分操作在本地进行，不需要联网</li><li>完整性保证（哈希算法，之后介绍）</li><li>尽可能添加数据，而不是删除或修改数据</li><li>分支操作快捷流畅</li><li>与 Linux 命令全面兼容</li></ul><h1 id="版本控制工具应该具有的功能？"><a href="#版本控制工具应该具有的功能？" class="headerlink" title="版本控制工具应该具有的功能？"></a>版本控制工具应该具有的功能？</h1><ul><li>协同修改：多个人并行不悖地修改同一份文件。</li><li>数据备份：保存历史版本。</li><li>版本管理：各个版本之间肯定有重叠的部分，这一部分不要重复保存。对此，SVN 采用增量式管理的方法（每次只保存修改的部分），git 采取的是文件系统快照的方法。</li><li>权限控制：不同人的权限不同。git 不仅支持权限控制，还可以对团队外开发者贡献的代码进行审核。</li><li>历史记录：查看修改人、时间、内容、日志等，还可以把本地文件恢复到之前的状态。</li><li>分支管理：允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。</li></ul><h1 id="Git-结构"><a href="#Git-结构" class="headerlink" title="Git 结构"></a>Git 结构</h1><p><img src="https://s1.328888.xyz/2022/05/01/AbdOT.png" alt="AbdOT.png"></p><h1 id="Git-和代码托管中心"><a href="#Git-和代码托管中心" class="headerlink" title="Git 和代码托管中心"></a>Git 和代码托管中心</h1><p>代码托管中心可以帮我们维护远程库</p><p>局域网内：Gitlab</p><p>外网：Github，Gitee</p><p>开发者通过 push 把代码推送到远程库。其他开发者要先 clone 把代码克隆下来，然后加入团队，然后才能把自己做的修改 push 推送到远程库。再通过 pull 把其他人的操作拉取下来。</p><p>如果需要项目成员之外的人修改代码：那个人先通过 fork 克隆一个自己的远程库，然后自己对自己的远程库做 clone、push 等操作，修改完成之后向项目开发者发送 pull request 请求，开发者审核同意后 merge 合并代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1pW411A7a5?p=3&amp;spm_id_from=pageDriver&quot;&gt;【尚硅谷】Git与GitHub基础全套完整版教程（快速上手，一套搞定）_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_8 入门——继承</title>
    <link href="http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_8%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_8%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF/</id>
    <published>2022-04-30T16:00:00.000Z</published>
    <updated>2022-05-01T16:50:07.142Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//父类，基类，超类</span><br>    String name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">boolean</span> tail;<br>String color;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//子类，派生类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meow</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Meow!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Bark!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。</p><p>当子类属于父类的一种时，可以使用继承。</p><h2 id="变量访问特点"><a href="#变量访问特点" class="headerlink" title="变量访问特点"></a>变量访问特点</h2><p>范围越小，权限越高。</p><p>访问优先级：子类中局部变量&gt;子类中成员变量&gt;父类中成员变量&gt;找不到就报错</p><p>如果想访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）</p><p><img src="https://s1.328888.xyz/2022/05/01/AmPt7.png" alt="AmPt7.png"></p><h2 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h2><p>即使访问子类的构造方法，也会优先访问父类的无参构造方法，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。</p><p>而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。</p><p>因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）</p><p>解决方法：1. 父类中补上无参构造方法</p><ol start="2"><li>在子类构造方法中手动访问父类的带参构造方法来代替</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Fu</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br>    <span class="hljs-built_in">this</span>.age=age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Zi</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Zi</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br>    <span class="hljs-built_in">super</span>(age);<span class="hljs-comment">//子类的带参构造方法就这样传递给父类即可</span><br>&#125;<br><span class="hljs-comment">//不支持一个子类继承多个父类，但是允许多层基层（爷-&gt;父-&gt;子）</span><br></code></pre></td></tr></table></figure><h2 id="成员方法的访问特点"><a href="#成员方法的访问特点" class="headerlink" title="成员方法的访问特点"></a>成员方法的访问特点</h2><p>先在子类中寻找，找不到再去父类中寻找。</p><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>public &gt; protected &gt; 默认 &gt; private</p><p><img src="https://s1.328888.xyz/2022/05/01/Awiam.png" alt="Awiam.png"></p><h2 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h2><p>有 final 和 static。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>成员变量和成员方法被 final 修饰后，不可以被重新赋值 / 重写。</p><p>类被 final 修饰后，也不可以作为父类。</p><p><em>引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容不可以改变）</em></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>被 static 修饰的成员变量在所有对象里值都是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String university;<span class="hljs-comment">//在学生类中的静态成员变量</span><br><br>Student.unievrsity=<span class="hljs-string">&quot;北大&quot;</span>;<span class="hljs-comment">//统一赋值</span><br>Strudent s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//university 变量的值是 &quot;北大&quot;</span><br>Strudent s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//university 变量的值是 &quot;北大&quot;</span><br></code></pre></td></tr></table></figure><p><strong>静态成员方法只能访问静态成员变量 / 方法！</strong></p><h2 id="包-Package"><a href="#包-Package" class="headerlink" title="包 Package"></a>包 Package</h2><p>文件夹，用于存放编译后生成的 class 文件，方便管理。</p><p>在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ithema;<br><br><span class="hljs-comment">//命令行根据路径建包</span><br>javac -d . HelloWorld.java<br><br><span class="hljs-comment">//编译</span><br>javac HelloWorld.java<br><br><span class="hljs-comment">//运行</span><br>java com.ithema.HelloWorld<br></code></pre></td></tr></table></figure><h2 id="导包-import"><a href="#导包-import" class="headerlink" title="导包 import"></a>导包 import</h2><p>如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用</p><p><code>import B文件夹.要调用的类名;</code></p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>子类中重新定义了父类中的方法。</p><p>子类如果想访问父类中的方法，可以通过 super 来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-comment">//注解，可以检查方法重写的正确性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span><br>&#123;<br>    System.out.println(<span class="hljs-string">&quot;子类中重写方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。</li><li>子类的重写方法权限必须高于父类方法。（public &gt; protected &gt; 默认 &gt; private）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_9 入门——多态</title>
    <link href="http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_9%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/"/>
    <id>http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_9%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/</id>
    <published>2022-04-30T16:00:00.000Z</published>
    <updated>2022-05-01T16:50:20.885Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>同一个对象在不同时刻表现出的形态也不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>Animal a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//父类引用指向子类对象</span><br></code></pre></td></tr></table></figure><p>a 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。</p><h2 id="多态中成员的访问特点"><a href="#多态中成员的访问特点" class="headerlink" title="多态中成员的访问特点"></a>多态中成员的访问特点</h2><p>访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。<em>因为成员变量不会被重写</em></p><p>访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。</p><p>例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalOperator</span>(Animal a)<br>&#123;<br>    a.eat();<br>&#125;<br><br><span class="hljs-comment">//使用</span><br>Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>Dog d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>Pig p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>();<br>AnimalOperator(c);<span class="hljs-comment">//多态</span><br>AnimalOperator(d);<span class="hljs-comment">//多态</span><br>AnimalOperator(p);<span class="hljs-comment">//多态</span><br></code></pre></td></tr></table></figure><p>调用的都是子类中重写的方法。</p><p>多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类就能访问（无论子类具体是哪一种）。</p><p>但是多态无法访问子类中特有的方法。</p><p>解决这一弊端的方法就是转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Animal a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//向上转型，a 不能访问 Cat 类中特有的方法</span><br>Cat c=(Cat)a;<span class="hljs-comment">//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。</span><br></code></pre></td></tr></table></figure><p>使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。<em>ClassCastException</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;同一个对象在不同时刻表现出的形态也不同。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_4 入门——类和对象</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_4%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_4%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:22.870Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠</p><p>类是对象的数据类型，是一个抽象的概念。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>类的实体化。比如罗小黑，是猫类的一个实体化。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）</p><h2 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h2><p>对象能执行的动作，如猫可以叫，可以跑。</p><h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名&#123;<br>    数据类型 变量;<br>    数据类型 变量;<br>    数据类型 变量;<br>    <br>    方法<span class="hljs-number">1</span>;<br>    方法<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;<br>    String name;<span class="hljs-comment">//初始值为null或0或false或&quot;&quot;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">boolean</span> tail;<br>    String color;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meow</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Meow!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Eat &quot;</span>+food);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在 main 方法中</span><br>Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>c.name=<span class="hljs-string">&quot;小黑&quot;</span>;<span class="hljs-comment">//c 的名字</span><br>c.age=<span class="hljs-number">2</span>;<span class="hljs-comment">//2岁了</span><br>c.tail=<span class="hljs-literal">false</span>;<span class="hljs-comment">//有尾巴</span><br>System.out.println(c.age);<br>c.meow();<span class="hljs-comment">//行为：猫叫</span><br>c.eat(<span class="hljs-string">&quot;猫粮&quot;</span>)<span class="hljs-comment">//行为：吃饭</span><br></code></pre></td></tr></table></figure><p>在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。</p><p>对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的<strong>属性</strong>等具体内容存储在<strong>堆内存</strong>中。对象中的<strong>方法</strong>调用时则加载到<strong>栈内存</strong>中，执行完毕后出栈。</p><h1 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h1><p>成员变量：类中在方法外的变量（如上例中的属性变量）</p><p>局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）</p><table><thead><tr><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>类中方法外</td><td>方法中，或方法声明上</td></tr><tr><td>堆内存中</td><td>栈内存中</td></tr><tr><td>对象消失时随之消失</td><td>方法调用完毕而消失</td></tr><tr><td>有默认的初始值</td><td>没有默认的初始值，必须先定义、赋值才能使用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;h1 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h1&gt;&lt;p&gt;类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_5 入门——封装</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_5%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_5%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:20.454Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>Java 的三大特性：封装、继承、多态</p><h1 id="封装-packaging"><a href="#封装-packaging" class="headerlink" title="封装 packaging"></a>封装 packaging</h1><p>之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age=-30）</p><p>因此我们要添加一些限制。</p><h2 id="private-修饰符"><a href="#private-修饰符" class="headerlink" title="private 修饰符"></a>private 修饰符</h2><p>可以修饰成员变量、成员方法不被其他类使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br></code></pre></td></tr></table></figure><p>被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get / set 方法。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>写在类中，作为类的方法。主要用于对象初始化。声明变量时<code>Cat c=new Cat();</code>Cat() 就是一种无参构造方法。</p><p>每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。<strong>建议无论是否用到构造方法，都写一个无参构造方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span>&#123;&#125;<span class="hljs-comment">//我们自己加的无参构造方法，会覆盖系统默认的</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;<span class="hljs-comment">//写一部分参数的构造方法也可以</span><br>    <span class="hljs-built_in">this</span>.name=name;<span class="hljs-comment">//通过 this 赋给成员变量</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<span class="hljs-comment">//写全参数的构造方法也可以</span><br>    <span class="hljs-built_in">this</span>.name=name;<br>    <span class="hljs-built_in">this</span>.age=age;<br>&#125;<br><span class="hljs-comment">//main 中构造对象：</span><br>Cat c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>Cat c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小黑&quot;</span>);<br>Cat c3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//这些都可以，与自己写的构造方法的参数相对应。</span><br></code></pre></td></tr></table></figure><p>this被哪个对象调用，就代表哪个对象。</p><p><img src="https://s1.328888.xyz/2022/04/30/AlrRQ.png" alt="AlrRQ.png"></p><p>然后把”林青霞” 字符串类型传入堆内存中。</p><h2 id="get-set"><a href="#get-set" class="headerlink" title="get / set"></a>get / set</h2><p>无参构造方法后用 setXxx() 方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<span class="hljs-comment">//赋值</span><br><span class="hljs-built_in">this</span>.name=name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>    <span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">0</span>&amp;&amp;age&lt;=<span class="hljs-number">20</span>)<span class="hljs-comment">//在 set 中可以添加一些限制，处理</span><br><span class="hljs-built_in">this</span>.age=age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//获取值</span><br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-comment">//在 main 方法中赋值并获取值示例：</span><br>Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>c.setName(<span class="hljs-string">&quot;小黑&quot;</span>);<br>System.out.print(c.getName);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;Java 的三大特性：封装、继承、多态&lt;/p&gt;
&lt;h1 id=&quot;封装-packaging&quot;&gt;&lt;a href=&quot;#封装-packaging&quot; class=&quot;headerlink&quot; title=&quot;封装 packaging&quot;&gt;</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_6 入门——字符串类</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_6%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_6%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:37.296Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>JDK 中提供了实现各种功能的封装类，供我们使用。</p><p>就像灯的开关，我们只用知道按下开关就能开灯关灯，并不需要弄明白底层原理如何实现。</p><p>可以下载一个 java 帮助文档，在其中搜索这些类的具体使用方法。</p><p>（<em>点击索引，打开输入框</em></p><p><em>如果只有左侧目录显示，右侧不显示：</em></p><p><em>右键帮助文档-属性-常规-最下面解除锁定</em></p><p><em>重新打开帮助文档即可。</em>）</p><p><img src="https://s1.328888.xyz/2022/04/30/AWwYX.png" alt="AWwYX.png"></p><p>Pakckage：该类所处的包下（除了 java.lang，其他包都要导包）</p><p>下拉还有构造方法、成员方法的详解。</p><h2 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h2><p>查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>String line=sc.nextLine();<br><span class="hljs-comment">//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。</span><br></code></pre></td></tr></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 类型代表字符串。其内容都是被双引号引住的。</p><p>在 java.lang 包下，不用导包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//直接赋值</span><br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<span class="hljs-comment">//空字符串</span><br><br><span class="hljs-type">char</span>[] c=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<span class="hljs-comment">//根据字符数组创建字符串</span><br><br><span class="hljs-type">byte</span>[] b=&#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>&#125;;<span class="hljs-comment">//a, b, c 对应的 ascii 码</span><br>String s3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b);<br></code></pre></td></tr></table></figure><p>字符串一旦创建不能再修改。不过多个字符串的值可以共享<code>s1=s2;</code></p><p>字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。</p><h2 id="字符串比较：-和成员方法-equals"><a href="#字符串比较：-和成员方法-equals" class="headerlink" title="字符串比较：== 和成员方法 equals()"></a>字符串比较：== 和成员方法 equals()</h2><p>用==判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。</p><p><strong>基本类型 == 比较的是数据值是否相同，引用类型 == 比较的是地址是否相同。</strong></p><p>用字符串的成员方法 equals() 判断，是比较字符串内容是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] c=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<br>String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<br>System.out.println(s1==s2);<span class="hljs-comment">//输出 false，因为 s1 s2 地址不同，只有内容是一样的</span><br>System.out.println(s1.equals(s2));<span class="hljs-comment">//输出 true</span><br><br>String s3=<span class="hljs-string">&quot;abc&quot;</span>;<br>String s4=<span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(s3==s4);<span class="hljs-comment">//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。</span><br>System.out.println(s3.equals(s4));<span class="hljs-comment">//输出 true</span><br><br>System.out.println(s1==s3);<span class="hljs-comment">//输出 false</span><br>System.out.println(s1.equals(s3));<span class="hljs-comment">//输出 true</span><br></code></pre></td></tr></table></figure><h2 id="遍历字符串：成员方法-length-和-charAt"><a href="#遍历字符串：成员方法-length-和-charAt" class="headerlink" title="遍历字符串：成员方法 length() 和 charAt()"></a>遍历字符串：成员方法 length() 和 charAt()</h2><p><code>s.length()</code>可以获取字符串长度</p><p>s.charAt(i) 可以获取索引为 i 处的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length;i++)&#123;<br>    System.out.println(s.charAt(i));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>字符串可以直接用 + 号拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;Hello &quot;</span>;<br>String s2=<span class="hljs-string">&quot;World&quot;</span>;<br>s1=s1+s2;<span class="hljs-comment">//Hello World</span><br></code></pre></td></tr></table></figure><p>在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有”Hello “，”World”，”Hello World”三个字符串，而不是直接在”Hello “的位置上拼接”World”）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。</p><h2 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h2><p>查看字符串是否以指定子串结尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;hello world&quot;</span>;<br>s1.endsWith(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><p>与 String 类相比，最主要的特点在于内容可变。</p><p>在 java.lang 包下，不用导包。</p><p>构造方法：</p><table><thead><tr><th>构造方法名</th><th>说明</th></tr></thead><tbody><tr><td>StringBuilder()</td><td>无参构造方法</td></tr><tr><td>StringBuilder(String s)</td><td>把给定的 String 字符串转换成 StringBuilder 类型的</td></tr></tbody></table><table><thead><tr><th>成员方法名</th><th>说明</th></tr></thead><tbody><tr><td>append(String s)</td><td>在结尾拼接上字符串 s</td></tr><tr><td>StringBuilder reverse()</td><td>反转字符串</td></tr><tr><td>String toString()</td><td>把 StringBuilder 类型转换为 String 类型并返回</td></tr></tbody></table><p>用 StringBuilder 完成字符串拼接操作：</p><ol><li>String 类型转换为 StringBuilder 类型</li><li>StringBuilder 类型通过 append() 成员方法拼接字符串</li><li>StringBuilder 类型通过 toString() 成员方法转换为 String 类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;Hello &quot;</span>;<br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<span class="hljs-comment">//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举</span><br>sb.append(<span class="hljs-string">&quot;World&quot;</span>);<br>String s1=sb.toString();<br><br><span class="hljs-comment">//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用</span><br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s).append(<span class="hljs-string">&quot;World&quot;</span>).toString();<br></code></pre></td></tr></table></figure><p>用 StringBuilder 完成字符串反转操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;Hello World&quot;</span>;<br>String sr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s).reverse().toString();<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;h1 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h1&gt;&lt;p&gt;JDK 中提供了实现各种功能的封装类，供我们使用。&lt;/p&gt;
&lt;p&gt;就像灯的开关</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_7 入门——集合类</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_7%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_7%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:53.751Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。</p><p>ArrayList 就是集合的一种。</p><h1 id="ArrayList-lt-E-gt"><a href="#ArrayList-lt-E-gt" class="headerlink" title="ArrayList&lt;E&gt;"></a>ArrayList&lt;E&gt;</h1><p>在 java.util 包下，需要导包。</p><p>&lt;E&gt; 表示泛型，随便加一种数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; array=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ArrayList&lt;E&gt;()</td><td>无参构造方法</td></tr><tr><td>boolean add(E e)</td><td>结尾添加一个元素，成功返回true</td></tr><tr><td>void add(index i, E e)</td><td>在指定索引处添加一个元素（不能越界！）</td></tr><tr><td>boolean remove(Object o)</td><td>删除指定对象，成功返回 true</td></tr><tr><td>E remove(int index)</td><td>删除指定索引处的值，返回该值</td></tr><tr><td>E set(int index, E element)</td><td>修改指定索引处值，返回修改后的值</td></tr><tr><td>E get(int index)</td><td>返回指定索引处元素</td></tr><tr><td>int size()</td><td>返回集合元素个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">array.add(<span class="hljs-number">1</span>);<br>array.add(<span class="hljs-number">3</span>);<br>array.add(<span class="hljs-number">4</span>);<br>array.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>System.out.println(array);<span class="hljs-comment">//输出 array：1，2，3，4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。&lt;/p&gt;
&lt;p&gt;ArrayList 就是集合的一种。&lt;/p&gt;
&lt;h1 id=&quot;ArrayList-lt-E-gt&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_3 入门——基础语法</title>
    <link href="http://example.com/2022/04/29/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_3%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/04/29/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_3%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-28T16:00:00.000Z</published>
    <updated>2022-04-29T09:13:18.957Z</updated>
    
    <content type="html"><![CDATA[<p>以<a href="https://www.bilibili.com/video/BV18J411W7cE?p=1">黑马程序员全套Java教程</a>网课为主。</p><h1 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h1><p>输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导包</span><br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<span class="hljs-comment">//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。</span><br><span class="hljs-type">int</span> i=sc.nextInt();<span class="hljs-comment">//接收数据</span><br>String s=sc.nextLine();<br></code></pre></td></tr></table></figure><h1 id="分支、循环语句"><a href="#分支、循环语句" class="headerlink" title="分支、循环语句"></a>分支、循环语句</h1><p>if - else 语句：和 C 语言一样。</p><p>switch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。</p><p>for, while, do - while 语句，及 break continue 和 C 一样。</p><h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>Random 类，在 java.util 包下，需要导包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br>Random r=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> n=r.nextInt(<span class="hljs-number">10</span>);<span class="hljs-comment">//[0,10)的范围内取随机数</span><br></code></pre></td></tr></table></figure><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p>集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。</p><p>创建项目-项目内创建模块-模块 src 下创建包-包下创建类-类中编写代码。</p><p>其中，.class 文件都会放在模块同级的 out 文件夹中。</p><p><img src="https://s1.328888.xyz/2022/04/28/AJdw2.png" alt="AJdw2.png"></p><p>可以在 File - Settings - Editor - Font 中修改字体</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>psvm + Tab：public static void main</p><p>sout + Tab：System.out.println()</p><p>Ctrl + Alt + Space：自动补全代码</p><p>Ctrl + /：单行注释</p><p>Ctrl + Shift + /：多行注释</p><p>Ctrl + Alt + L：代码格式化</p><h2 id="模块操作"><a href="#模块操作" class="headerlink" title="模块操作"></a>模块操作</h2><p>新增模块： File - Project Structure - Modules - New Module - Java - 命名，修改路径</p><p>删除模块：右键模块 - Remove Module</p><p>​    不过删除后在文件目录中仍然存在。</p><p>导入模块：File - Project Structure - Modules - (+) - Import Modules - 选择模块。</p><p>​    如果显示 project SDK is not defined：点 set up.</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>DeBug 调试，断点调试，可以查看程序运行细节。</p><p>添加断点：在行号前点一下，出现红点。</p><p>调试：右键，不是 run ,而是 debug。</p><p>Debugger 窗口下的Frames：查看代码运行到了哪里，也可以查看方法调用情况。</p><p>Debugger 窗口下的Variables：查看各变量运行过程中值的变化</p><p>Console 窗口：查看代码运行过程中的输出变化。如果代码中出现需要输入的情况，需要先在 Console 窗口中输入才能继续执行。</p><p>step info 按钮：下一步</p><p>stop：停止</p><p>再次点击红点，取消该断点。</p><p>批量取消断点：点击两个红点的图案，选择 Java line breakpoints，点击 - 号即可全部删除。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>一次性声明大量<strong>同类型</strong>变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr;<span class="hljs-comment">//推荐。定义了一个 int 型的数组，数组名是 arr</span><br><span class="hljs-type">int</span> arr[];<span class="hljs-comment">//定义了一个 int 型变量，变量名是 arr 数组</span><br><br><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//静态初始化简化版</span><br><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//动态初始化，只申请了空间，系统赋予初始值</span><br><span class="hljs-comment">//数字类型：初始值为0.0</span><br><span class="hljs-comment">//布尔类型：初始值为 false</span><br><span class="hljs-comment">//字符串类型：初始值为&quot;&quot;</span><br><span class="hljs-comment">//引用类型：初始值为 null</span><br></code></pre></td></tr></table></figure><p>java 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>定义的方法中的变量放在栈内存中，使用完直接消失。</p><p>如<code>int a</code>，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。</p><p>如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]=1, arr[1]=2……）</p><p>访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。</p><p>因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] arr2=arr1;<br>arr2[<span class="hljs-number">0</span>]=<span class="hljs-number">11</span>;<br>arr2[<span class="hljs-number">1</span>]=<span class="hljs-number">22</span>;<br>arr2[<span class="hljs-number">2</span>]=<span class="hljs-number">33</span>;<span class="hljs-comment">//这时访问 arr1[]，发现其中的数据也变成了11,22,33</span><br></code></pre></td></tr></table></figure><h2 id="数组常见问题"><a href="#数组常见问题" class="headerlink" title="数组常见问题"></a>数组常见问题</h2><ol><li>数组越界问题，ArrayIndexOutOfException。</li><li>空指针异常问题，NullPointerException。（<code>arr=null</code>，表示数组不指向任何有效对象）</li></ol><h2 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h2><p>数组自带属性 length，通过<code>arr.length</code>就能获得数组长度。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>java 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。</p><p>像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名(形参)&#123;<span class="hljs-comment">//和 main 方法同级</span><br>    方法体<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<span class="hljs-comment">//定义</span><br><br>方法名(实参);<span class="hljs-comment">//在 main 方法中调用。有返回值类型的方法建议用变量接收调用</span><br></code></pre></td></tr></table></figure><p>方法不能嵌套定义。</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>多个方法在一个类中，有相同的方法名，但参数不完全相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span><br></code></pre></td></tr></table></figure><p><strong>注意：返回值不能作为判断方法是否重载的标准！</strong>只有方法名和参数可以。</p><p>调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。</p><p><strong>形参值修改不会对实参造成影响。</strong>main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存</p><p><img src="https://s1.328888.xyz/2022/04/29/A8wxg.png" alt="A8wxg.png"></p><p>但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。</p><p><img src="https://s1.328888.xyz/2022/04/29/A8Kh1.png" alt="A8Kh1.png"></p><p>如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以&lt;a href=&quot;https://www.bilibili.com/video/BV18J411W7cE?p=1&quot;&gt;黑马程序员全套Java教程&lt;/a&gt;网课为主。&lt;/p&gt;
&lt;h1 id=&quot;数据输入&quot;&gt;&lt;a href=&quot;#数据输入&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Python——语法基础1</title>
    <link href="http://example.com/2022/04/28/Python%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801/"/>
    <id>http://example.com/2022/04/28/Python%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801/</id>
    <published>2022-04-27T16:00:00.000Z</published>
    <updated>2022-04-28T11:44:51.361Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始跟着 Alex老师 <a href="https://www.bilibili.com/video/BV1Z64y1S72C?p=1">Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili</a>的课程学习Python~</p><p>关于编译器解释器的部分、Python 安装及 Path 配置就不再赘述了。从计算机三大件的部分开始学习。</p><h1 id="计算机三大件"><a href="#计算机三大件" class="headerlink" title="计算机三大件"></a>计算机三大件</h1><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>数据的永久存储。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>数据的临时存储。处理数据速度远快于硬盘，所以才有存在的意义。处理数据应该尽量避免对硬盘的直接读写。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>进行运算。计算数据来自于内存。</p><p>计算时，数据从硬盘传到内存，再传给 CPU 进行运算。</p><p>保存数据后，数据再保存到硬盘。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>先定义，后使用。</p><p>定义规则和 C 一样，字母数字下划线，数字不能开头，不能是关键字。</p><p>可以是中文名，但很 low~ 尽量不要用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Jingqing&quot;</span><br>name = <span class="hljs-string">&quot;Rename&quot;</span> <span class="hljs-comment">#直接重新赋值，地址不变</span><br></code></pre></td></tr></table></figure><p>可以通过 id(变量名) 方法获取变量地址。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>int / long / float</td><td>数字类型</td></tr><tr><td>str</td><td>字符串</td></tr><tr><td>list</td><td>列表</td></tr><tr><td>bool</td><td>布尔</td></tr><tr><td>set</td><td>集合</td></tr><tr><td>dict</td><td>字典</td></tr><tr><td>bytes</td><td>字节</td></tr></tbody></table><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>python 3之后没有 long 类型了，全是 int.</p><p>字符串类型不可以修改。如果已经把字符串类型赋给了一个变量，再重新赋值成其他字符串值，会发现地址变了，说明没法对原来的字符串做修改。（<code>name[2]=&#39;A&#39;</code>无效）</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串像数组一样，可以依照从0开始的索引访问。也可以切片访问<code>name[2:4]</code>，取得[2]~[3]的字符串。</p><p>多行字符串：’’’三个单引号后输入的内容，如果包含回车，就会把回车内容记录在字符串内。</p><p>字符串拼接：直接做加法。</p><p>字符串外部连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Jingqing&quot;</span><br>msg=<span class="hljs-string">&quot;%s&quot;</span> % (name)<br></code></pre></td></tr></table></figure><p>%s：字符串占位符</p><p>%d：数字占位符</p><p>%f：浮点占位符</p><p>字符串中有几个%s，结尾的括号中就应该有几个变量。</p><p>python 3 之后有另一种处理方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">msg=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> is me.&quot;</span><br></code></pre></td></tr></table></figure><p>在字符串开头输入 f，会把字符串中的大括号内容都替换成变量。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>相当于数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list=[<span class="hljs-string">&quot;Jingqing&quot;</span>,<span class="hljs-string">&quot;Fuwu&quot;</span>,<span class="hljs-string">&quot;Fugu&quot;</span>]<br><span class="hljs-built_in">print</span>(name_list[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>增：name_list.append(x) （在结尾插入） insert(i,x)（在第 i 位插入）</p><p>删：del name_list 或del name_list[i] 或列表名.remove(x)</p><p>改：name_list[i]=”要修改的字符串”</p><p>查：name_list.index(x) 根据内容查索引号</p><p>切片：第 i 到 j 位：name_list[i:j+1]，如果有一边省略，就是取到头。比如 name_list[0:] 就是取所有数据。</p><p>（切片也可以倒着切。如最后两位：name_list[-2:]）</p><p>步长：name_list[i:j:2]，最后一位表示每几个数切一次，默认是1，也就是每个数都取。2就是隔一个取一个。</p><p>嵌套：列表里面的数据是个列表。name_list [0] [1] 访问嵌套的列表。</p><h2 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h2><p>+、-、*、/（带小数）、//（整除）、**（幂）、%。</p><p>&lt;、&gt;、&lt;=、&gt;=、==、!=、&lt;&gt;（在 python 3中取消了）。</p><p>+=、-=、*=、/=、%=、//=、**=。</p><p>and、or、not。（and 的优先级高于 or）</p><p>in、not in（查找字符串中有无给定子串 / 列表中有无给定成员，子串 in / not in 总数据）（in 不能测试数字类型）</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>name=input(“请输入姓名：”)</p><p>input().strip()：去掉输入时两侧的空格</p><p>input() 接收的都是字符串形式，不能直接拿去做运算。可以通过 int(input()) 强制转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> age.isdigit():<br>    age=<span class="hljs-built_in">int</span>(age)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入类型不是数字&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单分支</span><br><span class="hljs-keyword">if</span> 条件: <span class="hljs-comment"># 顶级代码</span><br>    表达式 <span class="hljs-comment"># 必须缩进，属于子级代码</span><br>    表达式 <span class="hljs-comment"># 同一级代码缩进必须一致，尽量都是 Tab</span><br><span class="hljs-comment"># 双分支</span><br><span class="hljs-keyword">if</span> 条件:<br>    表达式<br><span class="hljs-keyword">else</span>:<br>    表达式<br><span class="hljs-comment"># 多分支</span><br><span class="hljs-keyword">if</span> 条件:<br>    表达式<br><span class="hljs-keyword">elif</span> 条件:<br>    表达式<br><span class="hljs-keyword">elif</span> 条件:<br>    表达式<br><span class="hljs-keyword">else</span>:<br>    表达式<br></code></pre></td></tr></table></figure><p>这里很离谱的地方是：表达式必须缩进（大概是因为不像 C 和 Java 有大括号，可以确定范围）</p><p><strong>if 可以嵌套，最好不要超过4层。</strong></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-comment"># 输出0~9</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>,-<span class="hljs-number">1</span>) <span class="hljs-comment"># 从100输出到50，每次-1，左闭右开</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>] <span class="hljs-comment"># 输出hello\nworld</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;helloworld&quot;</span> <span class="hljs-comment"># 输出h\ne\nl\nl\no\nw\no\nr\nl\nd</span><br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>print() 默认参数：<code>print(end:&quot;\n&quot;)</code>，表示每次print输出后都会换行。如果把 end 的实参修改，就不会换行。</p><p>for 输出的内容必须是一个集合，比如字符串，列表。数字不行。</p><p>i 的作用域只在 for 内。</p><p>for 循环体内的内容和 if 一样，需要缩进。</p><p><strong>for 可以嵌套，最好不要超过4层。</strong></p><p>break、continue、exit()（退出整个程序）</p><p>输出时可以通过字符串*数字来输出指定次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">3</span>) <span class="hljs-comment"># 输出3次 *</span><br></code></pre></td></tr></table></figure><p>for…else… 当循环正常结束时执行 else 后面的内容。即没有中途 break 或 exit()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">break</span> <span class="hljs-comment"># 不会输出 else 里的内容</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;循环正常结束，i=10&quot;</span>)<br></code></pre></td></tr></table></figure><p>例如，判断一个数字是否为素数，正常做法就是先定义一个 flag 变量，然后用小于该数的所有数整除它，看余数是否为0。如果出现了余数为0，就令 flag =1.最后循环结束时如果 flag==0，说明该数为素数。</p><p>用 for else 或 while else 就可以判断循环是正常结束的还是中途跳出的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n不是素数&quot;</span>)<br>    <span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n是素数&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始跟着 Alex老师 &lt;a href=&quot;https://www.bilibili.com/video/BV1Z64y1S72C?p=1&quot;&gt;Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili&lt;/a&gt;的课程学习Python~&lt;</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>SQL 语句——DCL</title>
    <link href="http://example.com/2022/04/26/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DCL/"/>
    <id>http://example.com/2022/04/26/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DCL/</id>
    <published>2022-04-25T16:00:00.000Z</published>
    <updated>2022-04-26T08:22:21.479Z</updated>
    
    <content type="html"><![CDATA[<p>学习于：b站 骆昊jackfrued 老师的网课</p><p>Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问<br>alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;<br>drop user &#x27;人名&#x27;@&#x27;域名&#x27;;<br></code></pre></td></tr></table></figure><p>如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。</p><p>授权：grant</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改<br>grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人<br></code></pre></td></tr></table></figure><p>召回权限：revoke</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">revoke select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br></code></pre></td></tr></table></figure><p>添加权限之后最好 Reconnect 刷新一下。或者执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush privileges;<br></code></pre></td></tr></table></figure><p>Workbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。</p><p>至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习于：b站 骆昊jackfrued 老师的网课&lt;/p&gt;
&lt;p&gt;Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
</feed>
