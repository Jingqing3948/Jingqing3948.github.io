<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jingqing3948 的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-01T16:45:51.490Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jing Qing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git_1 版本控制介绍</title>
    <link href="http://example.com/2022/05/02/Git_1%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/05/02/Git_1%20%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-05-01T16:45:51.490Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p><a href="https://www.bilibili.com/video/BV1pW411A7a5?p=3&spm_id_from=pageDriver">【尚硅谷】Git与GitHub基础全套完整版教程（快速上手，一套搞定）_哔哩哔哩_bilibili</a></p><h1 id="为什么需要版本控制？"><a href="#为什么需要版本控制？" class="headerlink" title="为什么需要版本控制？"></a>为什么需要版本控制？</h1><p>单人开发有的时候，在开发过程中需要回退到之前的版本。好的版本管理可以大大提高开发效率。</p><p>多人开发的时候，不同人做修改 / 上传时间不统一，如果两个人同时上传，后者就会把前者的内容覆盖。普通文件服务器不能管理文件内容。</p><h1 id="版本控制工具特性"><a href="#版本控制工具特性" class="headerlink" title="版本控制工具特性"></a>版本控制工具特性</h1><p><strong>版本控制是一种思想，版本控制工具（如 SVN、git）是对其实现。</strong></p><p>集中式版本控制工具：如 SVN，开发人员都是客户端，而内容存储在服务器上，所有人和服务器交互。缺点在于服务器一挂，历史数据全部丢失，客户端上只能保存当前状态。（单点故障）</p><p>分布式版本控制工具：如 git ，开发人员在本地就能进行完整的版本控制。就算一个人的数据丢失了，依靠其他人的也能找回来，能有效避免单点故障。不过还是不建议本地库传数据，还是有一个远程库。</p><p>git其他优点：</p><ul><li>大部分操作在本地进行，不需要联网</li><li>完整性保证（哈希算法，之后介绍）</li><li>尽可能添加数据，而不是删除或修改数据</li><li>分支操作快捷流畅</li><li>与 Linux 命令全面兼容</li></ul><h1 id="版本控制工具应该具有的功能？"><a href="#版本控制工具应该具有的功能？" class="headerlink" title="版本控制工具应该具有的功能？"></a>版本控制工具应该具有的功能？</h1><ul><li>协同修改：多个人并行不悖地修改同一份文件。</li><li>数据备份：保存历史版本。</li><li>版本管理：各个版本之间肯定有重叠的部分，这一部分不要重复保存。对此，SVN 采用增量式管理的方法（每次只保存修改的部分），git 采取的是文件系统快照的方法。</li><li>权限控制：不同人的权限不同。git 不仅支持权限控制，还可以对团队外开发者贡献的代码进行审核。</li><li>历史记录：查看修改人、时间、内容、日志等，还可以把本地文件恢复到之前的状态。</li><li>分支管理：允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。</li></ul><h1 id="Git-结构"><a href="#Git-结构" class="headerlink" title="Git 结构"></a>Git 结构</h1><p><img src="https://s1.328888.xyz/2022/05/01/AbdOT.png" alt="AbdOT.png"></p><h1 id="Git-和代码托管中心"><a href="#Git-和代码托管中心" class="headerlink" title="Git 和代码托管中心"></a>Git 和代码托管中心</h1><p>代码托管中心可以帮我们维护远程库</p><p>局域网内：Gitlab</p><p>外网：Github，Gitee</p><p>开发者通过 push 把代码推送到远程库。其他开发者要先 clone 把代码克隆下来，然后加入团队，然后才能把自己做的修改 push 推送到远程库。再通过 pull 把其他人的操作拉取下来。</p><p>如果需要项目成员之外的人修改代码：那个人先通过 fork 克隆一个自己的远程库，然后自己对自己的远程库做 clone、push 等操作，修改完成之后向项目开发者发送 pull request 请求，开发者审核同意后 merge 合并代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1pW411A7a5?p=3&amp;spm_id_from=pageDriver&quot;&gt;【尚硅谷】Git与GitHub基础全套完整版教程（快速上手</summary>
      
    
    
    
    <category term="git" scheme="http://example.com/categories/git/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_10 入门——抽象类、抽象方法、接口</title>
    <link href="http://example.com/2022/05/02/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_10%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>http://example.com/2022/05/02/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_10%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3/</id>
    <published>2022-05-01T16:00:00.000Z</published>
    <updated>2022-05-01T16:50:35.968Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>抽象方法：没有方法体的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>抽象类：含有抽象方法的类。</p><p>（没有抽象方法的类也可以是抽象类，但是意义何在）</p><p>抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象方法。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Jumpping</span>&#123;<span class="hljs-comment">//接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Jump</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Jumpping</span>&#123;<span class="hljs-comment">//实现</span><br>    <span class="hljs-comment">//重写 Jump() 方法。如果不重写， Cat 就是一个抽象类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。</p><p>接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。</p><p>（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）</p><p>接口是抽象类，不能直接实例化，可以借助多态的方法实例化。</p><p>相较类与类之间不能多继承，只能层层继承：接口可以多实现<code>implements interface1, interface2</code></p><p>接口和接口之间也可以多继承<code>interface1 extends interface2, interface3</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s1.328888.xyz/2022/05/01/An2QF.png" alt="An2QF.png"></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。</p><p>但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。</p><p>例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。分析本例如何用具体类、抽象类、接口实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TB<br>A[人]--&gt;B[运动员]<br>A--&gt;C[教练]<br>B--&gt;D[篮球运动员]<br>B--&gt;E[乒乓球运动员]<br>H[说英语]--&gt;E<br>H--&gt;G<br>C--&gt;G[乒乓球教练]<br>C--&gt;F[篮球教练]<br></code></pre></td></tr></table></figure><p>其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。</p><h2 id="抽象类-接口作为形参-返回值"><a href="#抽象类-接口作为形参-返回值" class="headerlink" title="抽象类 / 接口作为形参 / 返回值"></a>抽象类 / 接口作为形参 / 返回值</h2><p>类也可以作为形式参数或函数的返回值。</p><p>抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要的是实现了该抽象类的子类对象。</p><p>如函数形参是Animal，实际需要通过多态的方法Animal a=new Cat();然后把a传给函数。</p><p>接口作为形参/函数返回值，和抽象类一样，实际需要的是实现了该接口的类对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;抽象方法：没有方法体的方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_8 入门——继承</title>
    <link href="http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_8%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_8%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF/</id>
    <published>2022-04-30T16:00:00.000Z</published>
    <updated>2022-05-01T16:50:07.142Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//父类，基类，超类</span><br>    String name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">boolean</span> tail;<br>String color;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<span class="hljs-comment">//子类，派生类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meow</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Meow!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bark</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Bark!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。</p><p>当子类属于父类的一种时，可以使用继承。</p><h2 id="变量访问特点"><a href="#变量访问特点" class="headerlink" title="变量访问特点"></a>变量访问特点</h2><p>范围越小，权限越高。</p><p>访问优先级：子类中局部变量&gt;子类中成员变量&gt;父类中成员变量&gt;找不到就报错</p><p>如果想访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）</p><p><img src="https://s1.328888.xyz/2022/05/01/AmPt7.png" alt="AmPt7.png"></p><h2 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h2><p>即使访问子类的构造方法，也会优先访问父类的无参构造方法，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。</p><p>而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。</p><p>因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）</p><p>解决方法：1. 父类中补上无参构造方法</p><ol start="2"><li>在子类构造方法中手动访问父类的带参构造方法来代替</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Fu</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br>    <span class="hljs-built_in">this</span>.age=age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Zi</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-number">20</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Zi</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br>    <span class="hljs-built_in">super</span>(age);<span class="hljs-comment">//子类的带参构造方法就这样传递给父类即可</span><br>&#125;<br><span class="hljs-comment">//不支持一个子类继承多个父类，但是允许多层基层（爷-&gt;父-&gt;子）</span><br></code></pre></td></tr></table></figure><h2 id="成员方法的访问特点"><a href="#成员方法的访问特点" class="headerlink" title="成员方法的访问特点"></a>成员方法的访问特点</h2><p>先在子类中寻找，找不到再去父类中寻找。</p><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>public &gt; protected &gt; 默认 &gt; private</p><p><img src="https://s1.328888.xyz/2022/05/01/Awiam.png" alt="Awiam.png"></p><h2 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h2><p>有 final 和 static。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>成员变量和成员方法被 final 修饰后，不可以被重新赋值 / 重写。</p><p>类被 final 修饰后，也不可以作为父类。</p><p><em>引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容不可以改变）</em></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>被 static 修饰的成员变量在所有对象里值都是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String university;<span class="hljs-comment">//在学生类中的静态成员变量</span><br><br>Student.unievrsity=<span class="hljs-string">&quot;北大&quot;</span>;<span class="hljs-comment">//统一赋值</span><br>Strudent s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//university 变量的值是 &quot;北大&quot;</span><br>Strudent s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<span class="hljs-comment">//university 变量的值是 &quot;北大&quot;</span><br></code></pre></td></tr></table></figure><p><strong>静态成员方法只能访问静态成员变量 / 方法！</strong></p><h2 id="包-Package"><a href="#包-Package" class="headerlink" title="包 Package"></a>包 Package</h2><p>文件夹，用于存放编译后生成的 class 文件，方便管理。</p><p>在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.ithema;<br><br><span class="hljs-comment">//命令行根据路径建包</span><br>javac -d . HelloWorld.java<br><br><span class="hljs-comment">//编译</span><br>javac HelloWorld.java<br><br><span class="hljs-comment">//运行</span><br>java com.ithema.HelloWorld<br></code></pre></td></tr></table></figure><h2 id="导包-import"><a href="#导包-import" class="headerlink" title="导包 import"></a>导包 import</h2><p>如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用</p><p><code>import B文件夹.要调用的类名;</code></p><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>子类中重新定义了父类中的方法。</p><p>子类如果想访问父类中的方法，可以通过 super 来指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-comment">//注解，可以检查方法重写的正确性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span><br>&#123;<br>    System.out.println(<span class="hljs-string">&quot;子类中重写方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。</li><li>子类的重写方法权限必须高于父类方法。（public &gt; protected &gt; 默认 &gt; private）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_9 入门——多态</title>
    <link href="http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_9%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/"/>
    <id>http://example.com/2022/05/01/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_9%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81/</id>
    <published>2022-04-30T16:00:00.000Z</published>
    <updated>2022-05-01T16:50:20.885Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>同一个对象在不同时刻表现出的形态也不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>Animal a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//父类引用指向子类对象</span><br></code></pre></td></tr></table></figure><p>a 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。</p><h2 id="多态中成员的访问特点"><a href="#多态中成员的访问特点" class="headerlink" title="多态中成员的访问特点"></a>多态中成员的访问特点</h2><p>访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。<em>因为成员变量不会被重写</em></p><p>访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。</p><p>例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalOperator</span>(Animal a)<br>&#123;<br>    a.eat();<br>&#125;<br><br><span class="hljs-comment">//使用</span><br>Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>Dog d=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>Pig p=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Pig</span>();<br>AnimalOperator(c);<span class="hljs-comment">//多态</span><br>AnimalOperator(d);<span class="hljs-comment">//多态</span><br>AnimalOperator(p);<span class="hljs-comment">//多态</span><br></code></pre></td></tr></table></figure><p>调用的都是子类中重写的方法。</p><p>多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类就能访问（无论子类具体是哪一种）。</p><p>但是多态无法访问子类中特有的方法。</p><p>解决这一弊端的方法就是转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Animal a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//向上转型，a 不能访问 Cat 类中特有的方法</span><br>Cat c=(Cat)a;<span class="hljs-comment">//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。</span><br></code></pre></td></tr></table></figure><p>使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。<em>ClassCastException</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;同一个对象在不同时刻表现出的形态也不同。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_4 入门——类和对象</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_4%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_4%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:22.870Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠</p><p>类是对象的数据类型，是一个抽象的概念。</p><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>类的实体化。比如罗小黑，是猫类的一个实体化。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）</p><h2 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h2><p>对象能执行的动作，如猫可以叫，可以跑。</p><h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> class 类名&#123;<br>    数据类型 变量;<br>    数据类型 变量;<br>    数据类型 变量;<br>    <br>    方法<span class="hljs-number">1</span>;<br>    方法<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;<br>    String name;<span class="hljs-comment">//初始值为null或0或false或&quot;&quot;</span><br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">boolean</span> tail;<br>    String color;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meow</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Meow!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Eat &quot;</span>+food);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在 main 方法中</span><br>Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>c.name=<span class="hljs-string">&quot;小黑&quot;</span>;<span class="hljs-comment">//c 的名字</span><br>c.age=<span class="hljs-number">2</span>;<span class="hljs-comment">//2岁了</span><br>c.tail=<span class="hljs-literal">false</span>;<span class="hljs-comment">//有尾巴</span><br>System.out.println(c.age);<br>c.meow();<span class="hljs-comment">//行为：猫叫</span><br>c.eat(<span class="hljs-string">&quot;猫粮&quot;</span>)<span class="hljs-comment">//行为：吃饭</span><br></code></pre></td></tr></table></figure><p>在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。</p><p>对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的<strong>属性</strong>等具体内容存储在<strong>堆内存</strong>中。对象中的<strong>方法</strong>调用时则加载到<strong>栈内存</strong>中，执行完毕后出栈。</p><h1 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h1><p>成员变量：类中在方法外的变量（如上例中的属性变量）</p><p>局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）</p><table><thead><tr><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>类中方法外</td><td>方法中，或方法声明上</td></tr><tr><td>堆内存中</td><td>栈内存中</td></tr><tr><td>对象消失时随之消失</td><td>方法调用完毕而消失</td></tr><tr><td>有默认的初始值</td><td>没有默认的初始值，必须先定义、赋值才能使用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;h1 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h1&gt;&lt;p&gt;类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_5 入门——封装</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_5%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_5%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:20.454Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>Java 的三大特性：封装、继承、多态</p><h1 id="封装-packaging"><a href="#封装-packaging" class="headerlink" title="封装 packaging"></a>封装 packaging</h1><p>之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age=-30）</p><p>因此我们要添加一些限制。</p><h2 id="private-修饰符"><a href="#private-修饰符" class="headerlink" title="private 修饰符"></a>private 修饰符</h2><p>可以修饰成员变量、成员方法不被其他类使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br></code></pre></td></tr></table></figure><p>被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get / set 方法。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>写在类中，作为类的方法。主要用于对象初始化。声明变量时<code>Cat c=new Cat();</code>Cat() 就是一种无参构造方法。</p><p>每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。<strong>建议无论是否用到构造方法，都写一个无参构造方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span>&#123;&#125;<span class="hljs-comment">//我们自己加的无参构造方法，会覆盖系统默认的</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span>&#123;<span class="hljs-comment">//写一部分参数的构造方法也可以</span><br>    <span class="hljs-built_in">this</span>.name=name;<span class="hljs-comment">//通过 this 赋给成员变量</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<span class="hljs-comment">//写全参数的构造方法也可以</span><br>    <span class="hljs-built_in">this</span>.name=name;<br>    <span class="hljs-built_in">this</span>.age=age;<br>&#125;<br><span class="hljs-comment">//main 中构造对象：</span><br>Cat c1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>Cat c2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小黑&quot;</span>);<br>Cat c3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;小白&quot;</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//这些都可以，与自己写的构造方法的参数相对应。</span><br></code></pre></td></tr></table></figure><p>this被哪个对象调用，就代表哪个对象。</p><p><img src="https://s1.328888.xyz/2022/04/30/AlrRQ.png" alt="AlrRQ.png"></p><p>然后把”林青霞” 字符串类型传入堆内存中。</p><h2 id="get-set"><a href="#get-set" class="headerlink" title="get / set"></a>get / set</h2><p>无参构造方法后用 setXxx() 方法创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<span class="hljs-comment">//赋值</span><br><span class="hljs-built_in">this</span>.name=name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span>&#123;<br>    <span class="hljs-keyword">if</span>(age&gt;=<span class="hljs-number">0</span>&amp;&amp;age&lt;=<span class="hljs-number">20</span>)<span class="hljs-comment">//在 set 中可以添加一些限制，处理</span><br><span class="hljs-built_in">this</span>.age=age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<span class="hljs-comment">//获取值</span><br><span class="hljs-keyword">return</span> name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><br><span class="hljs-comment">//在 main 方法中赋值并获取值示例：</span><br>Cat c=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>c.setName(<span class="hljs-string">&quot;小黑&quot;</span>);<br>System.out.print(c.getName);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;Java 的三大特性：封装、继承、多态&lt;/p&gt;
&lt;h1 id=&quot;封装-packaging&quot;&gt;&lt;a href=&quot;#封装-packaging&quot; class=&quot;headerlink&quot; title=&quot;封装 packaging&quot;&gt;</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_6 入门——字符串类</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_6%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_6%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:37.296Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>JDK 中提供了实现各种功能的封装类，供我们使用。</p><p>就像灯的开关，我们只用知道按下开关就能开灯关灯，并不需要弄明白底层原理如何实现。</p><p>可以下载一个 java 帮助文档，在其中搜索这些类的具体使用方法。</p><p>（<em>点击索引，打开输入框</em></p><p><em>如果只有左侧目录显示，右侧不显示：</em></p><p><em>右键帮助文档-属性-常规-最下面解除锁定</em></p><p><em>重新打开帮助文档即可。</em>）</p><p><img src="https://s1.328888.xyz/2022/04/30/AWwYX.png" alt="AWwYX.png"></p><p>Pakckage：该类所处的包下（除了 java.lang，其他包都要导包）</p><p>下拉还有构造方法、成员方法的详解。</p><h2 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h2><p>查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>String line=sc.nextLine();<br><span class="hljs-comment">//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。</span><br></code></pre></td></tr></table></figure><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 类型代表字符串。其内容都是被双引号引住的。</p><p>在 java.lang 包下，不用导包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//直接赋值</span><br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<span class="hljs-comment">//空字符串</span><br><br><span class="hljs-type">char</span>[] c=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<span class="hljs-comment">//根据字符数组创建字符串</span><br><br><span class="hljs-type">byte</span>[] b=&#123;<span class="hljs-number">97</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>&#125;;<span class="hljs-comment">//a, b, c 对应的 ascii 码</span><br>String s3=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b);<br></code></pre></td></tr></table></figure><p>字符串一旦创建不能再修改。不过多个字符串的值可以共享<code>s1=s2;</code></p><p>字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。</p><h2 id="字符串比较：-和成员方法-equals"><a href="#字符串比较：-和成员方法-equals" class="headerlink" title="字符串比较：== 和成员方法 equals()"></a>字符串比较：== 和成员方法 equals()</h2><p>用==判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。</p><p><strong>基本类型 == 比较的是数据值是否相同，引用类型 == 比较的是地址是否相同。</strong></p><p>用字符串的成员方法 equals() 判断，是比较字符串内容是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span>[] c=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<br>String s2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(c);<br>System.out.println(s1==s2);<span class="hljs-comment">//输出 false，因为 s1 s2 地址不同，只有内容是一样的</span><br>System.out.println(s1.equals(s2));<span class="hljs-comment">//输出 true</span><br><br>String s3=<span class="hljs-string">&quot;abc&quot;</span>;<br>String s4=<span class="hljs-string">&quot;abc&quot;</span>;<br>System.out.println(s3==s4);<span class="hljs-comment">//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。</span><br>System.out.println(s3.equals(s4));<span class="hljs-comment">//输出 true</span><br><br>System.out.println(s1==s3);<span class="hljs-comment">//输出 false</span><br>System.out.println(s1.equals(s3));<span class="hljs-comment">//输出 true</span><br></code></pre></td></tr></table></figure><h2 id="遍历字符串：成员方法-length-和-charAt"><a href="#遍历字符串：成员方法-length-和-charAt" class="headerlink" title="遍历字符串：成员方法 length() 和 charAt()"></a>遍历字符串：成员方法 length() 和 charAt()</h2><p><code>s.length()</code>可以获取字符串长度</p><p>s.charAt(i) 可以获取索引为 i 处的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length;i++)&#123;<br>    System.out.println(s.charAt(i));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>字符串可以直接用 + 号拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;Hello &quot;</span>;<br>String s2=<span class="hljs-string">&quot;World&quot;</span>;<br>s1=s1+s2;<span class="hljs-comment">//Hello World</span><br></code></pre></td></tr></table></figure><p>在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有”Hello “，”World”，”Hello World”三个字符串，而不是直接在”Hello “的位置上拼接”World”）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。</p><h2 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h2><p>查看字符串是否以指定子串结尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s1=<span class="hljs-string">&quot;hello world&quot;</span>;<br>s1.endsWith(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><p>与 String 类相比，最主要的特点在于内容可变。</p><p>在 java.lang 包下，不用导包。</p><p>构造方法：</p><table><thead><tr><th>构造方法名</th><th>说明</th></tr></thead><tbody><tr><td>StringBuilder()</td><td>无参构造方法</td></tr><tr><td>StringBuilder(String s)</td><td>把给定的 String 字符串转换成 StringBuilder 类型的</td></tr></tbody></table><table><thead><tr><th>成员方法名</th><th>说明</th></tr></thead><tbody><tr><td>append(String s)</td><td>在结尾拼接上字符串 s</td></tr><tr><td>StringBuilder reverse()</td><td>反转字符串</td></tr><tr><td>String toString()</td><td>把 StringBuilder 类型转换为 String 类型并返回</td></tr></tbody></table><p>用 StringBuilder 完成字符串拼接操作：</p><ol><li>String 类型转换为 StringBuilder 类型</li><li>StringBuilder 类型通过 append() 成员方法拼接字符串</li><li>StringBuilder 类型通过 toString() 成员方法转换为 String 类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;Hello &quot;</span>;<br>StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s);<span class="hljs-comment">//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举</span><br>sb.append(<span class="hljs-string">&quot;World&quot;</span>);<br>String s1=sb.toString();<br><br><span class="hljs-comment">//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用</span><br>String s1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s).append(<span class="hljs-string">&quot;World&quot;</span>).toString();<br></code></pre></td></tr></table></figure><p>用 StringBuilder 完成字符串反转操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String s=<span class="hljs-string">&quot;Hello World&quot;</span>;<br>String sr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(s).reverse().toString();<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;h1 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h1&gt;&lt;p&gt;JDK 中提供了实现各种功能的封装类，供我们使用。&lt;/p&gt;
&lt;p&gt;就像灯的开关</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_7 入门——集合类</title>
    <link href="http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_7%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <id>http://example.com/2022/04/30/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_7%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E9%9B%86%E5%90%88%E7%B1%BB/</id>
    <published>2022-04-29T16:00:00.000Z</published>
    <updated>2022-05-01T16:49:53.751Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员全套Java教程网课为主。</p><p>集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。</p><p>ArrayList 就是集合的一种。</p><h1 id="ArrayList-lt-E-gt"><a href="#ArrayList-lt-E-gt" class="headerlink" title="ArrayList&lt;E&gt;"></a>ArrayList&lt;E&gt;</h1><p>在 java.util 包下，需要导包。</p><p>&lt;E&gt; 表示泛型，随便加一种数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; array=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ArrayList&lt;E&gt;()</td><td>无参构造方法</td></tr><tr><td>boolean add(E e)</td><td>结尾添加一个元素，成功返回true</td></tr><tr><td>void add(index i, E e)</td><td>在指定索引处添加一个元素（不能越界！）</td></tr><tr><td>boolean remove(Object o)</td><td>删除指定对象，成功返回 true</td></tr><tr><td>E remove(int index)</td><td>删除指定索引处的值，返回该值</td></tr><tr><td>E set(int index, E element)</td><td>修改指定索引处值，返回修改后的值</td></tr><tr><td>E get(int index)</td><td>返回指定索引处元素</td></tr><tr><td>int size()</td><td>返回集合元素个数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">array.add(<span class="hljs-number">1</span>);<br>array.add(<span class="hljs-number">3</span>);<br>array.add(<span class="hljs-number">4</span>);<br>array.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>System.out.println(array);<span class="hljs-comment">//输出 array：1，2，3，4</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员全套Java教程网课为主。&lt;/p&gt;
&lt;p&gt;集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。&lt;/p&gt;
&lt;p&gt;ArrayList 就是集合的一种。&lt;/p&gt;
&lt;h1 id=&quot;ArrayList-lt-E-gt&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_3 入门——基础语法</title>
    <link href="http://example.com/2022/04/29/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_3%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/04/29/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_3%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-28T16:00:00.000Z</published>
    <updated>2022-04-29T09:13:18.957Z</updated>
    
    <content type="html"><![CDATA[<p>以<a href="https://www.bilibili.com/video/BV18J411W7cE?p=1">黑马程序员全套Java教程</a>网课为主。</p><h1 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h1><p>输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导包</span><br>Scanner sc=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<span class="hljs-comment">//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。</span><br><span class="hljs-type">int</span> i=sc.nextInt();<span class="hljs-comment">//接收数据</span><br>String s=sc.nextLine();<br></code></pre></td></tr></table></figure><h1 id="分支、循环语句"><a href="#分支、循环语句" class="headerlink" title="分支、循环语句"></a>分支、循环语句</h1><p>if - else 语句：和 C 语言一样。</p><p>switch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。</p><p>for, while, do - while 语句，及 break continue 和 C 一样。</p><h1 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h1><p>Random 类，在 java.util 包下，需要导包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br>Random r=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> n=r.nextInt(<span class="hljs-number">10</span>);<span class="hljs-comment">//[0,10)的范围内取随机数</span><br></code></pre></td></tr></table></figure><h1 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h1><p>集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。</p><p>创建项目-项目内创建模块-模块 src 下创建包-包下创建类-类中编写代码。</p><p>其中，.class 文件都会放在模块同级的 out 文件夹中。</p><p><img src="https://s1.328888.xyz/2022/04/28/AJdw2.png" alt="AJdw2.png"></p><p>可以在 File - Settings - Editor - Font 中修改字体</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>psvm + Tab：public static void main</p><p>sout + Tab：System.out.println()</p><p>Ctrl + Alt + Space：自动补全代码</p><p>Ctrl + /：单行注释</p><p>Ctrl + Shift + /：多行注释</p><p>Ctrl + Alt + L：代码格式化</p><h2 id="模块操作"><a href="#模块操作" class="headerlink" title="模块操作"></a>模块操作</h2><p>新增模块： File - Project Structure - Modules - New Module - Java - 命名，修改路径</p><p>删除模块：右键模块 - Remove Module</p><p>​    不过删除后在文件目录中仍然存在。</p><p>导入模块：File - Project Structure - Modules - (+) - Import Modules - 选择模块。</p><p>​    如果显示 project SDK is not defined：点 set up.</p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>DeBug 调试，断点调试，可以查看程序运行细节。</p><p>添加断点：在行号前点一下，出现红点。</p><p>调试：右键，不是 run ,而是 debug。</p><p>Debugger 窗口下的Frames：查看代码运行到了哪里，也可以查看方法调用情况。</p><p>Debugger 窗口下的Variables：查看各变量运行过程中值的变化</p><p>Console 窗口：查看代码运行过程中的输出变化。如果代码中出现需要输入的情况，需要先在 Console 窗口中输入才能继续执行。</p><p>step info 按钮：下一步</p><p>stop：停止</p><p>再次点击红点，取消该断点。</p><p>批量取消断点：点击两个红点的图案，选择 Java line breakpoints，点击 - 号即可全部删除。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>一次性声明大量<strong>同类型</strong>变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr;<span class="hljs-comment">//推荐。定义了一个 int 型的数组，数组名是 arr</span><br><span class="hljs-type">int</span> arr[];<span class="hljs-comment">//定义了一个 int 型变量，变量名是 arr 数组</span><br><br><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//静态初始化</span><br><span class="hljs-type">int</span>[] arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<span class="hljs-comment">//静态初始化简化版</span><br><span class="hljs-type">int</span>[] arr=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<span class="hljs-comment">//动态初始化，只申请了空间，系统赋予初始值</span><br><span class="hljs-comment">//数字类型：初始值为0.0</span><br><span class="hljs-comment">//布尔类型：初始值为 false</span><br><span class="hljs-comment">//字符串类型：初始值为&quot;&quot;</span><br><span class="hljs-comment">//引用类型：初始值为 null</span><br></code></pre></td></tr></table></figure><p>java 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。</p><h2 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h2><p>定义的方法中的变量放在栈内存中，使用完直接消失。</p><p>如<code>int a</code>，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。</p><h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><p>实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。</p><p>如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]=1, arr[1]=2……）</p><p>访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。</p><p>因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr1=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span>[] arr2=arr1;<br>arr2[<span class="hljs-number">0</span>]=<span class="hljs-number">11</span>;<br>arr2[<span class="hljs-number">1</span>]=<span class="hljs-number">22</span>;<br>arr2[<span class="hljs-number">2</span>]=<span class="hljs-number">33</span>;<span class="hljs-comment">//这时访问 arr1[]，发现其中的数据也变成了11,22,33</span><br></code></pre></td></tr></table></figure><h2 id="数组常见问题"><a href="#数组常见问题" class="headerlink" title="数组常见问题"></a>数组常见问题</h2><ol><li>数组越界问题，ArrayIndexOutOfException。</li><li>空指针异常问题，NullPointerException。（<code>arr=null</code>，表示数组不指向任何有效对象）</li></ol><h2 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h2><p>数组自带属性 length，通过<code>arr.length</code>就能获得数组长度。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>java 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。</p><p>像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> 返回值类型 方法名(形参)&#123;<span class="hljs-comment">//和 main 方法同级</span><br>    方法体<br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<span class="hljs-comment">//定义</span><br><br>方法名(实参);<span class="hljs-comment">//在 main 方法中调用。有返回值类型的方法建议用变量接收调用</span><br></code></pre></td></tr></table></figure><p>方法不能嵌套定义。</p><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>多个方法在一个类中，有相同的方法名，但参数不完全相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span><br></code></pre></td></tr></table></figure><p><strong>注意：返回值不能作为判断方法是否重载的标准！</strong>只有方法名和参数可以。</p><p>调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。</p><p><strong>形参值修改不会对实参造成影响。</strong>main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存</p><p><img src="https://s1.328888.xyz/2022/04/29/A8wxg.png" alt="A8wxg.png"></p><p>但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。</p><p><img src="https://s1.328888.xyz/2022/04/29/A8Kh1.png" alt="A8Kh1.png"></p><p>如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以&lt;a href=&quot;https://www.bilibili.com/video/BV18J411W7cE?p=1&quot;&gt;黑马程序员全套Java教程&lt;/a&gt;网课为主。&lt;/p&gt;
&lt;h1 id=&quot;数据输入&quot;&gt;&lt;a href=&quot;#数据输入&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Python——语法基础1</title>
    <link href="http://example.com/2022/04/28/Python%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801/"/>
    <id>http://example.com/2022/04/28/Python%E2%80%94%E2%80%94%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%801/</id>
    <published>2022-04-27T16:00:00.000Z</published>
    <updated>2022-04-28T11:44:51.361Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始跟着 Alex老师 <a href="https://www.bilibili.com/video/BV1Z64y1S72C?p=1">Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili</a>的课程学习Python~</p><p>关于编译器解释器的部分、Python 安装及 Path 配置就不再赘述了。从计算机三大件的部分开始学习。</p><h1 id="计算机三大件"><a href="#计算机三大件" class="headerlink" title="计算机三大件"></a>计算机三大件</h1><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>数据的永久存储。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>数据的临时存储。处理数据速度远快于硬盘，所以才有存在的意义。处理数据应该尽量避免对硬盘的直接读写。</p><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>进行运算。计算数据来自于内存。</p><p>计算时，数据从硬盘传到内存，再传给 CPU 进行运算。</p><p>保存数据后，数据再保存到硬盘。</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>先定义，后使用。</p><p>定义规则和 C 一样，字母数字下划线，数字不能开头，不能是关键字。</p><p>可以是中文名，但很 low~ 尽量不要用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Jingqing&quot;</span><br>name = <span class="hljs-string">&quot;Rename&quot;</span> <span class="hljs-comment">#直接重新赋值，地址不变</span><br></code></pre></td></tr></table></figure><p>可以通过 id(变量名) 方法获取变量地址。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>int / long / float</td><td>数字类型</td></tr><tr><td>str</td><td>字符串</td></tr><tr><td>list</td><td>列表</td></tr><tr><td>bool</td><td>布尔</td></tr><tr><td>set</td><td>集合</td></tr><tr><td>dict</td><td>字典</td></tr><tr><td>bytes</td><td>字节</td></tr></tbody></table><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>python 3之后没有 long 类型了，全是 int.</p><p>字符串类型不可以修改。如果已经把字符串类型赋给了一个变量，再重新赋值成其他字符串值，会发现地址变了，说明没法对原来的字符串做修改。（<code>name[2]=&#39;A&#39;</code>无效）</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串像数组一样，可以依照从0开始的索引访问。也可以切片访问<code>name[2:4]</code>，取得[2]~[3]的字符串。</p><p>多行字符串：’’’三个单引号后输入的内容，如果包含回车，就会把回车内容记录在字符串内。</p><p>字符串拼接：直接做加法。</p><p>字符串外部连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Jingqing&quot;</span><br>msg=<span class="hljs-string">&quot;%s&quot;</span> % (name)<br></code></pre></td></tr></table></figure><p>%s：字符串占位符</p><p>%d：数字占位符</p><p>%f：浮点占位符</p><p>字符串中有几个%s，结尾的括号中就应该有几个变量。</p><p>python 3 之后有另一种处理方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">msg=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> is me.&quot;</span><br></code></pre></td></tr></table></figure><p>在字符串开头输入 f，会把字符串中的大括号内容都替换成变量。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>相当于数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name_list=[<span class="hljs-string">&quot;Jingqing&quot;</span>,<span class="hljs-string">&quot;Fuwu&quot;</span>,<span class="hljs-string">&quot;Fugu&quot;</span>]<br><span class="hljs-built_in">print</span>(name_list[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>增：name_list.append(x) （在结尾插入） insert(i,x)（在第 i 位插入）</p><p>删：del name_list 或del name_list[i] 或列表名.remove(x)</p><p>改：name_list[i]=”要修改的字符串”</p><p>查：name_list.index(x) 根据内容查索引号</p><p>切片：第 i 到 j 位：name_list[i:j+1]，如果有一边省略，就是取到头。比如 name_list[0:] 就是取所有数据。</p><p>（切片也可以倒着切。如最后两位：name_list[-2:]）</p><p>步长：name_list[i:j:2]，最后一位表示每几个数切一次，默认是1，也就是每个数都取。2就是隔一个取一个。</p><p>嵌套：列表里面的数据是个列表。name_list [0] [1] 访问嵌套的列表。</p><h2 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h2><p>+、-、*、/（带小数）、//（整除）、**（幂）、%。</p><p>&lt;、&gt;、&lt;=、&gt;=、==、!=、&lt;&gt;（在 python 3中取消了）。</p><p>+=、-=、*=、/=、%=、//=、**=。</p><p>and、or、not。（and 的优先级高于 or）</p><p>in、not in（查找字符串中有无给定子串 / 列表中有无给定成员，子串 in / not in 总数据）（in 不能测试数字类型）</p><h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>name=input(“请输入姓名：”)</p><p>input().strip()：去掉输入时两侧的空格</p><p>input() 接收的都是字符串形式，不能直接拿去做运算。可以通过 int(input()) 强制转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> age.isdigit():<br>    age=<span class="hljs-built_in">int</span>(age)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入类型不是数字&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单分支</span><br><span class="hljs-keyword">if</span> 条件: <span class="hljs-comment"># 顶级代码</span><br>    表达式 <span class="hljs-comment"># 必须缩进，属于子级代码</span><br>    表达式 <span class="hljs-comment"># 同一级代码缩进必须一致，尽量都是 Tab</span><br><span class="hljs-comment"># 双分支</span><br><span class="hljs-keyword">if</span> 条件:<br>    表达式<br><span class="hljs-keyword">else</span>:<br>    表达式<br><span class="hljs-comment"># 多分支</span><br><span class="hljs-keyword">if</span> 条件:<br>    表达式<br><span class="hljs-keyword">elif</span> 条件:<br>    表达式<br><span class="hljs-keyword">elif</span> 条件:<br>    表达式<br><span class="hljs-keyword">else</span>:<br>    表达式<br></code></pre></td></tr></table></figure><p>这里很离谱的地方是：表达式必须缩进（大概是因为不像 C 和 Java 有大括号，可以确定范围）</p><p><strong>if 可以嵌套，最好不要超过4层。</strong></p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-comment"># 输出0~9</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>,<span class="hljs-number">50</span>,-<span class="hljs-number">1</span>) <span class="hljs-comment"># 从100输出到50，每次-1，左闭右开</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>] <span class="hljs-comment"># 输出hello\nworld</span><br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;helloworld&quot;</span> <span class="hljs-comment"># 输出h\ne\nl\nl\no\nw\no\nr\nl\nd</span><br><span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>print() 默认参数：<code>print(end:&quot;\n&quot;)</code>，表示每次print输出后都会换行。如果把 end 的实参修改，就不会换行。</p><p>for 输出的内容必须是一个集合，比如字符串，列表。数字不行。</p><p>i 的作用域只在 for 内。</p><p>for 循环体内的内容和 if 一样，需要缩进。</p><p><strong>for 可以嵌套，最好不要超过4层。</strong></p><p>break、continue、exit()（退出整个程序）</p><p>输出时可以通过字符串*数字来输出指定次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;*&quot;</span>*<span class="hljs-number">3</span>) <span class="hljs-comment"># 输出3次 *</span><br></code></pre></td></tr></table></figure><p>for…else… 当循环正常结束时执行 else 后面的内容。即没有中途 break 或 exit()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">break</span> <span class="hljs-comment"># 不会输出 else 里的内容</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;循环正常结束，i=10&quot;</span>)<br></code></pre></td></tr></table></figure><p>例如，判断一个数字是否为素数，正常做法就是先定义一个 flag 变量，然后用小于该数的所有数整除它，看余数是否为0。如果出现了余数为0，就令 flag =1.最后循环结束时如果 flag==0，说明该数为素数。</p><p>用 for else 或 while else 就可以判断循环是正常结束的还是中途跳出的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,n-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n不是素数&quot;</span>)<br>    <span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n是素数&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始跟着 Alex老师 &lt;a href=&quot;https://www.bilibili.com/video/BV1Z64y1S72C?p=1&quot;&gt;Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili&lt;/a&gt;的课程学习Python~&lt;</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>SQL 语句——DCL</title>
    <link href="http://example.com/2022/04/26/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DCL/"/>
    <id>http://example.com/2022/04/26/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DCL/</id>
    <published>2022-04-25T16:00:00.000Z</published>
    <updated>2022-04-26T08:22:21.479Z</updated>
    
    <content type="html"><![CDATA[<p>学习于：b站 骆昊jackfrued 老师的网课</p><p>Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问<br>alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;<br>drop user &#x27;人名&#x27;@&#x27;域名&#x27;;<br></code></pre></td></tr></table></figure><p>如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。</p><p>授权：grant</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改<br>grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人<br></code></pre></td></tr></table></figure><p>召回权限：revoke</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">revoke select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br></code></pre></td></tr></table></figure><p>添加权限之后最好 Reconnect 刷新一下。或者执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush privileges;<br></code></pre></td></tr></table></figure><p>Workbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。</p><p>至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习于：b站 骆昊jackfrued 老师的网课&lt;/p&gt;
&lt;p&gt;Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>SQL 语句——DQL</title>
    <link href="http://example.com/2022/04/25/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DQL/"/>
    <id>http://example.com/2022/04/25/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DQL/</id>
    <published>2022-04-24T16:00:00.000Z</published>
    <updated>2022-04-29T09:18:52.921Z</updated>
    
    <content type="html"><![CDATA[<p>学习自b站骆昊jackfrued 老师的网课。</p><p>查询语句。</p><p><em>本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）</em></p><p><em>tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）</em></p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>查询所有学生的所有信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `表名`;-- * 号表示所有字段<br></code></pre></td></tr></table></figure><p>但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。</p><p>实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;<br></code></pre></td></tr></table></figure><p>如果只查询部分列，就只写那几列就行。</p><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>给字段或表起别名—— alias，简写为 as。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_id` as `学号` from `tb_student`;<br></code></pre></td></tr></table></figure><p>as 可以省略，不过还是写上可读性高一些。<em>一般字段不省略，表省略。具体还得看公司编程规范的要求，没有就看个人喜好了。</em></p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>限制查询记录的条件——where（选择 Selection，只查询某几行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where `stu_sex`=&#x27;M&#x27; or `stu_name`=&#x27;Jingqing&#x27;;<br></code></pre></td></tr></table></figure><p>多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。</p><p><em>性能问题，一般不用 or 而使用 union，结果取并集。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where `stu_sex`=&#x27;M&#x27; <br>union<br>select * from table where `stu_name`=&#x27;Jingqing&#x27;;<br></code></pre></td></tr></table></figure><p><em><strong>如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。</strong></em></p><p>类似 10&lt;x&lt;30 的形式不可以直接写两个等式，要拆成 x&gt;10 and x&lt;30 。</p><p>这里的字段如果是数字类型的，也可以进行 + - * / % mod（也是取余）以及 &lt; &gt;  = &gt;= &lt;= &lt;&gt; 等形式的运算。</p><p>还有一种条件写法是 <code>between …… and ……</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from table where `stu_age` between 10 and 30;-相当于 &lt;=30 and &gt;=10<br></code></pre></td></tr></table></figure><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select if(`stu_sex`,&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;性别&#x27; from `tb_student`;-- 有点类似三目运算符 ?:<br></code></pre></td></tr></table></figure><p>if 中第一项可以是表达式，如 age &gt; 10.</p><p><strong>这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。</strong>比如 Oracle 数据库中对应的函数是 decode，不能通用。</p><p>通用的分支结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select case `sex` when 1 then &#x27;男&#x27; else &#x27;女&#x27; end as &#x27;性别&#x27; from `tb_student`;-- end 表示条件判断结束<br></code></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>如：查询所有姓王的学生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `student` where `stu_name` like &#x27;王%&#x27;;-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生<br>select * from `student` where `stu_name` like &#x27;王_&#x27;;-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生<br></code></pre></td></tr></table></figure><p>这里和正则表达式有一定联系，之后会单独学习。</p><p>事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `student` where `字段名` regexp &#x27;正则表达式&#x27;;<br></code></pre></td></tr></table></figure><p>模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。</p><h2 id="空值处理，以及三值逻辑"><a href="#空值处理，以及三值逻辑" class="headerlink" title="空值处理，以及三值逻辑"></a>空值处理，以及三值逻辑</h2><p><strong>下面两种写法是错误的！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `student` where `stu_address` = null;<br>select * from `student` where `stu_address` &lt;&gt; null;<br></code></pre></td></tr></table></figure><p>因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。</p><p>正确做法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `student` where `stu_address` is null;<br>select * from `student` where `stu_address` is not null;<br></code></pre></td></tr></table></figure><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct `字段名` from `表名`;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序<br></code></pre></td></tr></table></figure><p>order by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。</p><h2 id="当前日期"><a href="#当前日期" class="headerlink" title="当前日期"></a>当前日期</h2><p>curdate()获取当前日期，使用 datediff() 函数可以和出生日期做差获取年龄。</p><p>now()获取当前年月日时分秒（datetime）。</p><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p>floor() 函数是下取整。floor(3.99) = 3.</p><p>ceil() 函数是向上取整，ceil(3.1) = 4.</p><p>round() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)=4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select floor(datediff(curdate(),`date`)/365) from `staff`;<br></code></pre></td></tr></table></figure><p><em>可以通过？ functions 查看函数一览。还会有相应的例子提示~</em></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>描述性统计信息：包括集中趋势和离散趋势。</p><p>集中趋势：平均值，中位数等。</p><p>离散趋势：方差，标准差等。</p><p>聚合函数属于 SQL 语句，所有 DBMS 都能用。</p><ul><li><p>min(字段名)</p></li><li><p>max(字段名)</p></li><li><p>avg(字段名) <em>做计算的时候会忽略 null 值</em></p></li><li><p>sum(字段名)</p></li><li><p>count(字段名) <em>做计算的时候会忽略 null 值</em></p><p><em><strong>如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。</strong></em></p><p><em>比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) / count(stu_id) 就是错误的，因为是9个人的成绩 / 10.</em> </p><p><em>如果成绩为空的学生视为 = 0，就要用 sum(score) / count(stu_id)，或者对 avg() 函数做如下处理：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select avg(ifnull(`score`,0)) from student;<br></code></pre></td></tr></table></figure><p><em>ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。</em></p><p>coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。</p></li><li><p>std(字段名)，计算标准差，越小说明越稳定。</p><ul><li>std(), stddev() 和 stddev_pop()：所有数据总体的标准差</li><li>stddev_samp()：样本标准差，抽样计算。</li></ul></li><li><p>variance(字段名)，计算方差，标准差的平方。</p><ul><li>variance(), var_pop()</li><li>var_samp()</li></ul></li></ul><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>聚合函数通常和分组一起使用。分组是非常重要的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `student` group by `sex`;<br></code></pre></td></tr></table></figure><p>PS： Excel 的数据透视表有同样功能：</p><p>插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认</p><p>行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和<br></code></pre></td></tr></table></figure><p>group by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。</p><p><strong>如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_id`,avg(score) from `Score` where avg(score)&gt;90 group by `stu_id`; -- 错误<br>select `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)&gt;90; -- 正确<br></code></pre></td></tr></table></figure><p>分组以前的筛选： where, 写在分组后</p><p>分组以后的筛选： having, 写在分组后。</p><p><em>其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_id` from `tb_record` group by `stu_id` having avg(score)&gt;90;<br></code></pre></td></tr></table></figure><p><em>也是没有问题的。</em></p><p>查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)&gt;90;<br></code></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>查询年龄最大的学生的姓名。</p><p>可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。</p><p>一种方法是嵌套子查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_name` from `tb_student` <br>where `stu_birth` = (<br>    select min(`stu_birth`) from `tb_student`<br>);<br></code></pre></td></tr></table></figure><p>另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set @a =(select min(`stu_birth`) from `tb_student`);<br>select @a; -- 可以查看一下 @a 的值。<br></code></pre></td></tr></table></figure><p>如果子查询有很多结果，满足其中一个即可：不能用等号，要用 <strong>in</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `name` from `tb_student` <br>where `stu_id` in (<br>    select `stu_id` from `tb_record` group by `stu_id` where count(*)&gt;=2<br>); -- 查询出所有至少选了2门课的学生姓名<br></code></pre></td></tr></table></figure><p>如果用了等号，报错： subquery returns more than 1 row.</p><h2 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h2><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;<br></code></pre></td></tr></table></figure><p>如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。</p><p>本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。</p><h3 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h3><ol><li>有外键约束：利用外键连接，不用加条件，自动连接。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` <br>from `tb_student` natural join `tb_college`;<br></code></pre></td></tr></table></figure><ol start="2"><li>没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。<em>注意：不管有几个同名的列，所有列都会作为连接的条件！</em></li><li>如果没有外键也没有同名列，就只会得到笛卡尔积的结果。</li></ol><h3 id="内-外连接"><a href="#内-外连接" class="headerlink" title="内 / 外连接"></a>内 / 外连接</h3><p>另一种连接方式是 inner join / outer join </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` <br>from `tb_student` inner join `tb_college` <br>on `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号<br></code></pre></td></tr></table></figure><p>inner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。</p><p>left outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。</p><p>right outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。</p><p>full outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。</p><h3 id="θ-连接"><a href="#θ-连接" class="headerlink" title="θ 连接"></a>θ 连接</h3><p>添加条件使得两个表中的数据相互对应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` <br>where `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号<br></code></pre></td></tr></table></figure><h3 id="三表连接"><a href="#三表连接" class="headerlink" title="三表连接"></a>三表连接</h3><p>链接条件用多个条件筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`<br>where `tb_course`.`cou_id`=`tb_record`.`cou_id` <br>and `tb_student`.`stu_id`=`tb_record`.`stu_id`;<br><br>select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`<br>inner join `tb_record`<br>on `tb_student`.`stu_id`=`tb_record`.`stu_id`<br>inner join `tb_course`<br>on `tb_course`.`cou_id`=`tb_record`.`cou_id`<br>where `tb_course`.`cou_name` is not null; -- where 写在最后<br><br>select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`<br>natural join `tb_record`<br>natural join `tb_course`;<br></code></pre></td></tr></table></figure><h2 id="查询小技巧"><a href="#查询小技巧" class="headerlink" title="查询小技巧"></a>查询小技巧</h2><p>百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件</p><p>python -推广链接 不想看到广告推送</p><p>site:zhihu.com python 只搜索知乎里的 python 内容</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>limit 是 mysql 的方言。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。<br>select * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)<br>select * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)<br></code></pre></td></tr></table></figure><h2 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h2><p>select 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）</p><p>查询学生姓名和平均成绩。</p><p>查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？</p><p>先通过一个查询，得到一个派生表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_id`,avg(score) from `tb_record` group by `stu_id`;<br></code></pre></td></tr></table></figure><p>然后把其结果作为一个新表，和学生表做关联。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select `stu_name`,`avg(score)`from `tb_student`<br>natural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思<br></code></pre></td></tr></table></figure><p><strong>临时表必须要起别名！！！</strong>不然报错。</p><p><strong>注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！</strong>因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，<strong>没选课的学生就不会查出来。</strong></p><p>如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习自b站骆昊jackfrued 老师的网课。&lt;/p&gt;
&lt;p&gt;查询语句。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）&lt;/em&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>SQL 语句——DML</title>
    <link href="http://example.com/2022/04/23/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DML/"/>
    <id>http://example.com/2022/04/23/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DML/</id>
    <published>2022-04-22T16:00:00.000Z</published>
    <updated>2022-04-26T03:26:32.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行<br>insert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的<br></code></pre></td></tr></table></figure><p>注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 <code>default</code> ，不然系统也难以分辨哪一项使用默认值。</p><p><em>日期可以写字符串 2002-01-01，会自动转换</em></p><p>插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。</p><p><strong>如果主键、unique 的记录重复会报错。</strong>报错显示： <code>duplicate key for key &#39;定义的约束键名称&#39;</code></p><p><strong>填写了规定的 check 以外的内容会报错。</strong>报错显示：<code>check constraint &#39;定义的约束键名称&#39; is violated.</code> 不过字符串不区分大小写，规定性别只能填 ‘F’ ‘M’ 的话，填 ‘f’ ‘m’ 也行。</p><p><strong>如果对应的外键在原表中没有对应的记录会报错。</strong> 报错显示：<code>cannot add or update a child row: a foreign constraint fails</code> 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。</p><p><strong>如果没有给 NOT NULL且没有默认值的字段赋值时会报错。</strong> 报错显示：<code>Field &#39;字段名&#39; doesn&#39;t have a default value.</code> 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from `表名`;//这可不兴用啊！<br>delete from `表名` where `字段名`=&#x27;要删除的记录的对应字段值&#x27;;//不等于可以用&lt;&gt;，有的 DBMS 支持!=<br>delete from `表名` where `字段名` = &#x27;字段值&#x27; or `字段名` = &#x27;字段值&#x27;;//删除多条语句<br>delete from `表名` where `字段名` in (&#x27;字段值&#x27;,&#x27;字段值&#x27;);//删除多条语句<br></code></pre></td></tr></table></figure><p>但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： <code>Cannot delete or update a parent row</code> 。</p><p>删除了外键约束之后就可以随意修改两个表对应的值而不报错了。</p><p>另一种删除表的方式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">truncate table `表名`;<br></code></pre></td></tr></table></figure><p>截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update `表名` set `列名` = &#x27;值&#x27;;//把这一列的数据全都改成这个值，不常用<br>update `表名` set `列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27; where `字段`=&#x27;值&#x27;;//限制条件，只修改某几个记录<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;插入&quot;&gt;&lt;a href=&quot;#插入&quot; class=&quot;headerlink&quot; title=&quot;插入&quot;&gt;&lt;/a&gt;插入&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>SQL 语句——DDL</title>
    <link href="http://example.com/2022/04/19/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DDL/"/>
    <id>http://example.com/2022/04/19/SQL%20%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94DDL/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-22T16:11:37.245Z</updated>
    
    <content type="html"><![CDATA[<p>学习于：b站 骆昊jackfrued 老师的网课</p><table><thead><tr><th>SQL 语句</th><th>作用</th><th>使用示例</th></tr></thead><tbody><tr><td>create</td><td>创建数据库 / 表</td><td>create database `数据库名`; / create table `表名` ( 字段描述 );</td></tr><tr><td>drop</td><td>删除数据库 / 表</td><td>drop database `数据库名`; / drop table `表名`;</td></tr><tr><td>use</td><td>选中数据库</td><td>use `数据库名`;</td></tr><tr><td>alter</td><td>更改数据库 / 表信息</td><td>alter table `表名` add constraint `约束名` unique (`字段名`);</td></tr></tbody></table><p>PS： </p><ol><li><p>修改表的引擎 / 更改自增约束初始值是在 create table `表名` () 后面添加的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table `表名`(<br><br>)engine = innodb auto_increment=2 comment &#x27;表示例&#x27;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">primary key (`列名`),<br></code></pre></td></tr></table></figure><p><em>复合主键语法上没错，但是开发使用时非常不好用，需要至少两条字段才能唯一确定一条记录。一般不会用。</em></p><p><em>如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。</em></p><h3 id="自增约束、非空约束"><a href="#自增约束、非空约束" class="headerlink" title="自增约束、非空约束"></a>自增约束、非空约束</h3><p>都在字段描述后面写即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">`col_name` int auto_increment not null comment &#x27;列名&#x27;,<br></code></pre></td></tr></table></figure><p>以下三种可以在创建表时写，也可以之后写<code>alter table 表名 add constraint...</code>。</p><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">constraint `uk_col_name` unique (`col_name`),<br></code></pre></td></tr></table></figure><p>类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）</p><h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">constraint `ck_col_sex` check (`col_sex`=&#x27;M&#x27; or `col_sex`=&#x27;F&#x27;),<br></code></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。</p><p>外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">constraint `fk_col_id` foreign key (`在本表中的字段名`) references `另一个表名` (`在该表中的主键名`),<br></code></pre></td></tr></table></figure><p>结尾其实还有一句默认的话：<code>on delete restrict on update restrict</code> ，就是限制不要随便删除或修改的意思，因为会牵连到别的表。</p><p>如果改成 <code>on delete cascade on update cascade</code> ，修改时就会发生级联，如果删除这个表中的记录中某一字段的数据另一个表中用到了，就会把另一个表中对应记录也删除。</p><p>如果改成 <code>on delete set null</code> ，就是删除这个记录时，在另一个表中对应字段的记录不会删除，而只是把这格子短的位置变成空（<strong>当然，前提是该字段数据可以为空！</strong>）</p><p>最好还是使用默认的 restrict 。</p><p><em>一对多时，多的一方需要加外键约束。</em></p><p>删除约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table `表名` drop constraint `要删除的约束名`;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习于：b站 骆昊jackfrued 老师的网课&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL 语句&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;使用示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;create&lt;/td&gt;
&lt;t</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 数据类型</title>
    <link href="http://example.com/2022/04/19/Mysql%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/04/19/Mysql%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-04-26T03:26:32.251Z</updated>
    
    <content type="html"><![CDATA[<p>数据类型可以通过 <code>? data types</code> 查看说明，每种数据类型也可以通过 <code>? 数据类型</code> 查看。</p><p><em>除了data types 其他可以用?查看的内容可以输入 <code>? contents</code> 查看。</em></p><table><thead><tr><th>数据类型</th><th>作用</th></tr></thead><tbody><tr><td>整数 (tinyint, smallint, mediumint, int, bigint)</td><td>都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）</td></tr><tr><td>字符串 (char(位数), varchar(位数), text)</td><td>char 长度固定，varchar 长度可变</td></tr><tr><td>小数 (float, double, decimal(总位数, 小数点后位数))</td><td>不要用 float, double！</td></tr><tr><td>时间日期 (year, date, time, datetime, timestamp)</td><td>date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数</td></tr><tr><td>Mysql 中的枚举类型 (enum, boolean)</td><td></td></tr></tbody></table><p>PS: </p><ol><li><p>虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。</p></li><li><p>金额等小数一般不会用小数的数据类型存储，而是整数类型/100使用。因为小数形式有误差，比如0.1+0.2=0.30000000004.</p></li><li><p>decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。</p></li><li><p>时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。</p><blockquote><p>这里了解到了一个很有趣的[“千年虫”问题](<a href="https://zhuanlan.zhihu.com/p/305603895">漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)</a>)。</p><p>Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。</p><p>早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022/04/19，就是22/04/19）</p><p>尽管节约了内存空间，但是40年后1999-&gt;2000年时，问题就出现了……对计算机来说，相当于99-&gt;00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。</p><p>如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：</p><ol><li>只修改核心关键的医疗、航空、金融、军事领域的程序；</li><li>对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。</li></ol></blockquote><p>回到刚才的话题，因此时间戳也并不推荐使用。</p></li></ol><p>5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据类型可以通过 &lt;code&gt;? data types&lt;/code&gt; 查看说明，每种数据类型也可以通过 &lt;code&gt;? 数据类型&lt;/code&gt; 查看。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;除了data types 其他可以用?查看的内容可以输入 &lt;code&gt;? contents&lt;/cod</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Mysql Command Line Client 的使用，及常用命令</title>
    <link href="http://example.com/2022/04/18/Mysql%20Command%20Line%20Client%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/04/18/Mysql%20Command%20Line%20Client%20%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-04-18T03:31:43.820Z</published>
    <updated>2022-04-18T03:37:32.364Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>MYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。</p><p>开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>\h, ?, ?</td><td>获取帮助</td></tr><tr><td>\c</td><td>清除前面输入的内容（内容输入有误时使用）</td></tr><tr><td>\R</td><td>修改 每次输入命令前左侧的提示样式（默认：’mysql&gt;’）</td></tr><tr><td>? 需要查看帮助的命令;</td><td>显示该命令的帮助（如：? show）</td></tr><tr><td>show databases;</td><td>查看所有数据库</td></tr><tr><td>use ‘数据库名’;</td><td>选中某个数据库</td></tr><tr><td>（选中某个数据库后）show tables;</td><td>查看当前数据库中所有表</td></tr><tr><td>exit / quit</td><td>退出</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Mysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class</summary>
      
    
    
    
    <category term="tools" scheme="http://example.com/categories/tools/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Mysql ER 和 EER 模型</title>
    <link href="http://example.com/2022/04/18/Mysql%20ER%20%E5%92%8C%20EER%20%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/04/18/Mysql%20ER%20%E5%92%8C%20EER%20%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-04-17T16:00:00.000Z</published>
    <updated>2022-05-01T16:51:58.125Z</updated>
    
    <content type="html"><![CDATA[<p>本文思路主要来源于<a href="https://www.bilibili.com/video/BV1rP4y157jW?spm_id_from=333.999.0.0">骆昊jackfrued 老师的网课</a><br>仅供本人学习参考，未做其他用途！</p><p>在此也建议读者通过老师的课程学习。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为什么要有 ER 图和 EER 图的存在？</p><p><strong>真正做项目、设计数据库时，</strong>实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR / json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）<strong>是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。</strong></p><h3 id="ER-模型"><a href="#ER-模型" class="headerlink" title="ER 模型"></a>ER 模型</h3><p>ER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e154bec557baf860b9da8b406aa2b411.png" alt="百度百科图片"></p><p>相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。</p><h3 id="EER-模型"><a href="#EER-模型" class="headerlink" title="EER 模型"></a>EER 模型</h3><p>相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。</p><h4 id="泛化层次"><a href="#泛化层次" class="headerlink" title="泛化层次"></a>泛化层次</h4><p>包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。</p><p><strong>子类父类</strong>就是类似 Java 的继承，如动物是父类，猫、狗是其子类。</p><p><strong>泛化</strong>又叫归纳，就是将几个类的共同属性提取出来作为父类；</p><p><strong>特化</strong>又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。</p><p>其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。</p><p><strong>mandatory / optional</strong>：父类中的所有属性都必须包含在每一个子类中 / 不用全部继承，选择部分继承即可（完全性限制）</p><p><strong>disjoint / overlapping</strong>：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）</p><p><img src="https://pic1.zhimg.com/80/v2-11dfbdfea0c8705a7e425554b66ef610_1440w.jpg" alt="img"></p><p>图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D / O，表示 disjoint / overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。</p><h4 id="汇集层次"><a href="#汇集层次" class="headerlink" title="汇集层次"></a>汇集层次</h4><p>Aggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。</p><p><img src="https://pic4.zhimg.com/80/v2-bcf4d6b1f89bc0b8e12f7f835518537b_1440w.jpg" alt="img"></p><p>如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。</p><h4 id="弱实体"><a href="#弱实体" class="headerlink" title="弱实体"></a>弱实体</h4><p>一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。</p><p><img src="https://pic4.zhimg.com/80/v2-2891cd3fb7b84a5b98e158fa77cd3cdb_1440w.jpg" alt="img"></p><p>Workbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b7d05f2614049fce76e68e0121c805a0.png" alt="EER 图示例"></p><p>在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。</p><p><em>自动生成的 SQL 语句中，外键下方有两句话<code>ON DELETE NO ACTION</code> <code>ON UPDATE NO ACTION</code>，意为：当外键参考的主键修改/删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改/删除外键在使用的主键。</em></p><p>同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。</p><p><em>Power Designer 建模工具，也支持正 / 反向工程，可以生成 SQL 方言。完整版付费。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文思路主要来源于&lt;a href=&quot;https://www.bilibili.com/video/BV1rP4y157jW?spm_id_from=333.999.0.0&quot;&gt;骆昊jackfrued 老师的网课&lt;/a&gt;&lt;br&gt;仅供本人学习参考，未做其他用途！&lt;/p&gt;
&lt;p&gt;在</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="problems" scheme="http://example.com/tags/problems/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_1 介绍与安装</title>
    <link href="http://example.com/2022/04/14/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_1%20%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://example.com/2022/04/14/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_1%20%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</id>
    <published>2022-04-13T16:00:00.000Z</published>
    <updated>2022-04-18T03:37:11.098Z</updated>
    
    <content type="html"><![CDATA[<p>以黑马程序员网课为主。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Java是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。</p><p>JVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。</p><p>JRE: Java Runtime Environment，运行只需要 JRE 就够了。</p><p>JDK: Java Development Kit，Java 程序开发工具包。</p><p><img src="https://s1.328888.xyz/2022/04/14/iUcNe.png" alt="123"></p><p>尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~</p><p>JDK 的安装目录如下：</p><table><thead><tr><th>JDK目录名称</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>存放工具命令，如：javac, java, etc.</td></tr><tr><td>conf</td><td>配置文件</td></tr><tr><td>include</td><td>某些平台特定的头文件</td></tr><tr><td>jmods</td><td>模块</td></tr><tr><td>legal</td><td>授权文档</td></tr><tr><td>lib</td><td>补充 JAR 包</td></tr><tr><td>其他</td><td>说明型文档</td></tr></tbody></table><h2 id="在-DOS-窗口下操作命令"><a href="#在-DOS-窗口下操作命令" class="headerlink" title="在 DOS 窗口下操作命令"></a>在 DOS 窗口下操作命令</h2><p>在一开始没有使用 IDEA 等集成开发环境的时候，直接在 DOS ( Disk Operating System ) 窗口运行。Windows 通过 <code>win+R</code> 打开运行窗口，输入 <code>cmd</code> 进入 DOS 窗口。</p><p>常用的DOS窗口命令：</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>盘符名称</code>+<code>:</code>，如<code>D:</code></td><td>切换到该盘</td></tr><tr><td><code>dir</code></td><td>查看当前路径下的内容</td></tr><tr><td><code>cd 目录</code>，如<code>cd java</code></td><td>进入当前路径下的一个单级目录（cd 是 change directory 的意思）</td></tr><tr><td><code>cd ..</code></td><td>回退到上一级目录</td></tr><tr><td><code>cd 目录1\目录2\..</code></td><td>一次性进入多级目录</td></tr><tr><td><code>cd \</code></td><td>回退到盘符目录</td></tr><tr><td><code>cls</code></td><td>清屏</td></tr><tr><td><code>exit</code></td><td>退出 DOS 窗口</td></tr></tbody></table><h2 id="配置-PATH-环境变量"><a href="#配置-PATH-环境变量" class="headerlink" title="配置 PATH 环境变量"></a>配置 PATH 环境变量</h2><p>不得不说虽然之前学习其他语言的时候也做过很多次配置 PATH 环境变量的操作，但是这次才算理解一些意义。</p><p>开发 Java 的时候是肯定会用到 JDK 里的开发工具的，比如编译的 <code>javac</code> ，运行的 <code>java</code>。</p><p>但是没有配置环境变量的时候，cmd 无法直接使用 javac 文件，因为不知道 <code>javac.exe</code> 的路径。</p><p>所以需要输入 <code>&quot;JDK文件的目录\bin\javac.exe&quot; 需要编译的文件的目录\需要编译的文件.java</code> （可以把 javac 和 java 文件直接拖进去，就会自动生成目录）相当麻烦。</p><p>配置环境变量之后，直接在 cmd 窗口里输入 <code>javac 需要编译的文件.java</code> 就能编译。</p><p>配置方法：（ Windows 系统）</p><p>① 此电脑 – 属性 – 高级系统设置 – 环境变量，新建一个用户变量（建议命名和 Java 相关），并放入 JDK 文件夹的路径</p><p>② 在下方系统变量中选中 Path 变量 – 编辑 – 新建 – 命名（建议命名和 Java 相关），并放入 JDK 内 bin 文件夹的路径。</p><p>最后在DOS中输入<code>javac</code>，如果显示使用 javac 的提示信息说明配置成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以黑马程序员网课为主。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Java是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习博客_2 入门——基础语法</title>
    <link href="http://example.com/2022/04/14/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_2%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/04/14/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_2%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-13T16:00:00.000Z</published>
    <updated>2022-04-18T03:37:18.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HelloWorld-案例"><a href="#HelloWorld-案例" class="headerlink" title="HelloWorld 案例"></a>HelloWorld 案例</h2><p>学习的时候除了直接用记事本编辑，推荐使用 Notepad++ 。使用 Notepad++ 前需要设置：<code>设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI</code>。</p><p>新建一个 HelloWorld.java 文件，通过记事本或 Notepad++ 编辑内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123; <span class="hljs-comment">//这里的 class 类名必须和文件名一致</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <span class="hljs-comment">//main 方法</span><br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>); <span class="hljs-comment">// 单独输出一行的意思。注意大小写不可以出错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在DOS窗口中进入当前文件所在目录，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">javac HelloWorld.java //编译<br>java HelloWorld //运行<br></code></pre></td></tr></table></figure><p>这里可见，java 和 C、C++ 一样，属于编译型语言（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。</p><p>如果顺利运行，就会输出 <code>Hello World!</code>。</p><h2 id="Java-基础语法——主要与C语言比较有哪些不同"><a href="#Java-基础语法——主要与C语言比较有哪些不同" class="headerlink" title="Java 基础语法——主要与C语言比较有哪些不同"></a>Java 基础语法——主要与C语言比较有哪些不同</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释 <code>//</code> 、多行注释 <code>/* */</code> 都和C一样。还有一个文件注释 <code>/** */</code>暂时用不到，之后了解。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>字母全部小写。</p><h6 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h6><p>整数型：byte, short, int, long</p><p>浮点型：float, double</p><p>字符型：char</p><p>布尔型：boolean</p><p>变量的定义和 c 相似，<code>int a=10;</code> 不能重复定义和未初始化就使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> l=<span class="hljs-number">1000000L</span>;<br><span class="hljs-type">float</span> f=<span class="hljs-number">1.235F</span>; <span class="hljs-comment">//防止 long 类型和 float 类型不兼容</span><br></code></pre></td></tr></table></figure><p>标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。</p><p><em>命名规范：</em></p><p><em>方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法</em></p><p><em>类名：大驼峰命名法</em></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>+，-，*，/，%，</p><p>+=，-=，*=，/=，%=（隐含了强制类型转换）</p><p>++，–</p><p>==，&gt;=，&lt;=，&gt;，&lt;，!=</p><p>? : </p><p>&amp;，|，^，!（逻辑运算符）</p><p>&amp;&amp;，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）</p><p>与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>+<span class="hljs-number">99</span>+<span class="hljs-string">&quot;string&quot;</span> <span class="hljs-comment">//&quot;100string&quot;</span><br><span class="hljs-string">&quot;string&quot;</span>+<span class="hljs-number">1</span>+<span class="hljs-number">99</span> <span class="hljs-comment">//&quot;string199&quot;，从左往右计算</span><br></code></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动类型转换：把小范围的变量赋值给大范围的变量</p><p>数据范围从小到大：</p><p><img src="https://s1.328888.xyz/2022/04/14/iX6sR.png" alt="DataTypeRange"></p><p>算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。</p><p>强制类型转换：赋值运算符中隐含。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> s=<span class="hljs-number">10</span>;<br>s+=<span class="hljs-number">10</span>;<span class="hljs-comment">//正常</span><br>s=s+<span class="hljs-number">10</span>;<span class="hljs-comment">//错，因为右边发生了自动类型转换，变成了int型</span><br>s=(<span class="hljs-type">short</span>)(s+<span class="hljs-number">10</span>);<span class="hljs-comment">//也可以</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HelloWorld-案例&quot;&gt;&lt;a href=&quot;#HelloWorld-案例&quot; class=&quot;headerlink&quot; title=&quot;HelloWorld 案例&quot;&gt;&lt;/a&gt;HelloWorld 案例&lt;/h2&gt;&lt;p&gt;学习的时候除了直接用记事本编辑，推荐使用 Notep</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="study" scheme="http://example.com/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>微信开发者工具和gitee实现多人协作</title>
    <link href="http://example.com/2022/03/27/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%92%8Cgitee%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
    <id>http://example.com/2022/03/27/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%92%8Cgitee%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/</id>
    <published>2022-03-26T16:00:00.000Z</published>
    <updated>2022-04-18T03:36:46.885Z</updated>
    
    <content type="html"><![CDATA[<p>将代码上传到码云实现多人合作开发。</p><h1>1. gitee</h1><p>首先进入gitee，注册一个账号。</p><p>新建一个仓库：</p><p><img src="https://img-blog.csdnimg.cn/5abc8daf23a342a3906c4111e0b2d950.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327012843219"></p><p>输入仓库名称，设置为私有，初始化、模板、分支模型都可以不添加。</p><p>点击创建，就建好了一个新的仓库。</p><p><img src="https://img-blog.csdnimg.cn/0f17a2379dd44d23a084ad3df7373c6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327013057263"></p><p>这里可以看到仓库的https地址，一会会用到。</p><p>因为一会直接将小程序代码文件放进来，暂时先不用添加文件。</p><h1>2. git</h1><p>git是一个开源的分布式版本控制系统，可以高效地实现版本控制。</p><h2>下载</h2><p><a href="https://git-scm.com/downloads">从官网上下载git</a>。</p><h2>注册</h2><p>下载完成后在任意目录下右键，都会出现git GUI here和git Bash here.</p><p>点击git Bash here，在当前目录下开启命令行：</p><p><img src="https://img-blog.csdnimg.cn/2896c2473b5c4d428995b6deb13f0e81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327013749178"></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git config --global user.name &#x27;要注册的git用户名，不可以是中文&#x27;<br>git config --global user.email &#x27;gitee的邮箱&#x27;<br></code></pre></td></tr></table></figure><p>注册完成。</p><h2>克隆远程仓库</h2><p>首先新建一个想要放克隆下来的仓库内容的文件夹，进入该文件夹下。可以直接双击打开文件夹后右键git Bash here，也可以在命令行中使用cd进入文件夹目录下。</p><p>复制新建仓库的https地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git clong &#x27;仓库的https地址，如https://github.com/username/try.git&#x27;<br></code></pre></td></tr></table></figure><p>如果克隆的是有内容的仓库，这时就应该可以看到文件夹内出现了仓库里的文件。</p><p>仓库是空，可能会出现warning字样，问题不大。</p><p>然后就可以对内容进行一些修改，项目的开发。</p><h2>推送</h2><p>修改完后要将本地的代码推送到远程仓库。首先提交到本地仓库。通过add添加要提交的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git add .<br></code></pre></td></tr></table></figure><p>add后面加.的意思是把所有做过修改的文件都添加。如果只想添加部分新修改的文件，add后面根具体的文件名即可。</p><p>再将添加的文件提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git commit -m &#x27;备注，如：提交了app.json文件&#x27;<br></code></pre></td></tr></table></figure><p>若出现<code>1 file changed</code>之类的字样，说明成功提交到了本地仓库。</p><p>最后输入以下代码提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">git push origin master<br></code></pre></td></tr></table></figure><p>gitee默认分支是master，github默认分支是main，需要先修改分支为main后提交<code>git branch -M main</code></p><p>出现’done’的字样说明成功。</p><p>回到码云仓库，刷新一下，就可以看到新增的文件，以及还会显示commit的内容。</p><p><img src="https://img-blog.csdnimg.cn/97f5848e7a34432fbc24d38f3846595c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327015550566"></p><p><em>这里出现了不同的commit，是博主在不同时间做的不同修改。</em></p><h1>3. 微信开发者工具</h1><p>通过微信开发者工具，可以不使用命令行操作，直接拉取、推送代码。</p><p>打开对应小程序文件夹，点击右上角版本管理，左侧栏如下：</p><p><img src="https://img-blog.csdnimg.cn/d0e8f12d8b954f11bdd936a70434fe2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_7,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327015735281"></p><p>首先要在设置中进行认证。点击设置–网络和认证</p><p><img src="https://img-blog.csdnimg.cn/ab9f812446f34fab95604669296032c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327015821950"></p><p>输入码云的gitee账号和密码。</p><p>博主和朋友尝试将代码上传到github上时，一直在这里有问题。明明用户名和密码正确，推送却会卡住或者显示认证失败。而换成码云就非常顺利。因此更建议使用码云新建仓库、上传代码。</p><p>然后在 远程 中新建仓库信息</p><p><img src="https://img-blog.csdnimg.cn/812100ec678b42e1985baf1e9357ab2d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327020101940"></p><p>名称就是仓库名称，url是https的仓库地址。</p><p>设置完成后就可以点击左上角抓取远程仓库内容到本地仓库。</p><p>对于修改后的文件以及提交，在工作区进行：</p><p><img src="https://img-blog.csdnimg.cn/d24162c54f604021b31b77586716a8c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327020242959"></p><p>这里右边上面勾选文件，就相当于git里的add添加文件。下面的提交就相当于commit。输入信息后点击提交，就上传到本地仓库了。</p><p>然后点击左上角推送，<strong>不要推送到新的分支，勾选中间项：推送到一下远程分支</strong>。这一部相当于git的push。</p><p><img src="https://img-blog.csdnimg.cn/ec5c7bc3581a457cb4ccf654aa10e995.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="image-20220327020458850"></p><p>点击确定，出现对号就说明成功。接着可以在仓库中刷新看到新的修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;将代码上传到码云实现多人合作开发。&lt;/p&gt;
&lt;h1&gt;1. gitee&lt;/h1&gt;

&lt;p&gt;首先进入gitee，注册一个账号。&lt;/p&gt;
&lt;p&gt;新建一个仓库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/5abc8daf23a342a</summary>
      
    
    
    
    <category term="projects" scheme="http://example.com/categories/projects/"/>
    
    
    <category term="problems" scheme="http://example.com/tags/problems/"/>
    
  </entry>
  
</feed>
