<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="黑马程序员 Java 入门课程学习笔记" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title>技术学习：黑马程序员 Java |  灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-技术学习：黑马程序员 Java"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  技术学习：黑马程序员 Java
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/05/02/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Java/" class="article-date">
  <time datetime="2022-05-01T23:00:00.000Z" itemprop="datePublished">2022-05-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">15.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">60 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18J411W7cE?p=1">黑马程序员全套Java教程</a>网课为主。</p>
<h1 id="Java-介绍"><a href="#Java-介绍" class="headerlink" title="Java 介绍"></a>Java 介绍</h1><p>Java是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。</p>
<p>JVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。</p>
<p>JRE: Java Runtime Environment，运行只需要 JRE 就够了。</p>
<p>JDK: Java Development Kit，Java 程序开发工具包。</p>
<pre class="mermaid"> graph LR
 A[JDK] -->B[开发人员使用的工具, JDK 的 bin 目录下]
   A --> C[JRE]
   C -->D[JVM, JRE 的 bin 目录下]
   C -->E[运行所需要的核心类库, JRE 的 lib 目录下]</pre>

<p>尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~</p>
<p>JDK 的安装目录如下：</p>
<table>
<thead>
<tr>
<th>JDK目录名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>存放工具命令，如：javac, java, etc.</td>
</tr>
<tr>
<td>conf</td>
<td>配置文件</td>
</tr>
<tr>
<td>include</td>
<td>某些平台特定的头文件</td>
</tr>
<tr>
<td>jmods</td>
<td>模块</td>
</tr>
<tr>
<td>legal</td>
<td>授权文档</td>
</tr>
<tr>
<td>lib</td>
<td>补充 JAR 包</td>
</tr>
<tr>
<td>其他</td>
<td>说明型文档</td>
</tr>
</tbody></table>
<p>环境配置等就不多赘述了，网上好的教程太多太多。总之就是终端 javac 和 java 可以执行，最好使用 IDEA 作为 IDE。</p>
<h2 id="IDEA-环境介绍"><a href="#IDEA-环境介绍" class="headerlink" title="IDEA 环境介绍"></a>IDEA 环境介绍</h2><p>集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。</p>
<p>创建项目-项目内创建模块（实现不同的功能）-模块 src 下创建包（类似文件夹，用于归纳区分不同的类）-包下创建类-类中编写代码。</p>
<p>其中，.class 文件都会放在模块同级的 out 文件夹中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201224741.png" alt="AJdw2.png"></p>
<h1 id="基础语法（重点比较与C的区别）"><a href="#基础语法（重点比较与C的区别）" class="headerlink" title="基础语法（重点比较与C的区别）"></a>基础语法（重点比较与C的区别）</h1><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p><em>使用 Notepad++ 前需要设置：<code>设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI</code>。</em></p>
<p>新建一个 <code>HelloWorld.java</code> 文件，编辑内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123; <span class="comment">// class 类名必须和文件名一致</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">//main 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">// 单独输出一行的意思。注意大小写不可以出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在DOS窗口中进入当前文件所在目录，输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java //编译，得到 .class 字节码文件，可以在任何支持 java 的平台上运行</span><br><span class="line">java HelloWorld // .class 文件被解释执行，转化为可以直接在本地对应平台上运行的机器码文件</span><br></pre></td></tr></table></figure>

<p>java 和 C、C++ 一样，属于<strong>编译型语言</strong>（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释 <code>//</code> 、多行注释 <code>/* */</code> 都和C一样。还有一个文件注释 <code>/** */</code>暂时用不到，之后了解。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>字母全部小写。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>整数型：byte, short, int, long</p>
<p>浮点型：float, double</p>
<p>字符型：char</p>
<p>布尔型：boolean</p>
<p>变量的定义和 c 相似，<code>int a=10;</code> 不能重复定义和未初始化就使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> l=<span class="number">1000000L</span>;</span><br><span class="line"><span class="type">float</span> f=<span class="number">1.235F</span>; <span class="comment">//防止 long 类型和 float 类型不兼容</span></span><br></pre></td></tr></table></figure>

<p>标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。</p>
<p><em>命名规范：</em></p>
<p><em>方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法</em></p>
<p><em>类名：大驼峰命名法</em></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>+，-，*，&#x2F;，%，</p>
<p>+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;（隐含了强制类型转换）</p>
<p>++，–</p>
<p>&#x3D;&#x3D;，&gt;&#x3D;，&lt;&#x3D;，&gt;，&lt;，!&#x3D;</p>
<p>? : </p>
<p>&amp;，|，^，!（逻辑运算符）</p>
<p>&amp;&amp;，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）</p>
<p>与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="number">99</span>+<span class="string">&quot;string&quot;</span> <span class="comment">//&quot;100string&quot;</span></span><br><span class="line"><span class="string">&quot;string&quot;</span>+<span class="number">1</span>+<span class="number">99</span> <span class="comment">//&quot;string199&quot;，从左往右计算</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动类型转换：把小范围的变量赋值给大范围的变量</p>
<p>数据范围从小到大：</p>
<pre class="mermaid">graph LR
A[byte]-->B[short]
B-->C[int]
D[char]-->C
C-->E[long]
E-->F[float]
F-->G[double]</pre>



<p>算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。</p>
<p>强制类型转换：赋值运算符中隐含。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> s=<span class="number">10</span>;		</span><br><span class="line">s+=<span class="number">10</span>;			<span class="comment">// 正常</span></span><br><span class="line">s=s+<span class="number">10</span>;			<span class="comment">// 错，因为右边发生了自动类型转换，变成了int型</span></span><br><span class="line">s=(<span class="type">short</span>)(s+<span class="number">10</span>);<span class="comment">// 也可以</span></span><br></pre></td></tr></table></figure>

<h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><p>输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//导包</span></span><br><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。</span></span><br><span class="line"><span class="type">int</span> i=sc.nextInt();<span class="comment">//接收数据</span></span><br><span class="line">String s=sc.nextLine();</span><br></pre></td></tr></table></figure>

<h2 id="分支、循环语句"><a href="#分支、循环语句" class="headerlink" title="分支、循环语句"></a>分支、循环语句</h2><p>if - else 语句：和 C 语言一样。</p>
<p>switch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。</p>
<p>for, while, do - while 语句，及 break continue 和 C 一样。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>Random 类，在 java.util 包下，需要导包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line">Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> n=r.nextInt(<span class="number">10</span>);<span class="comment">//[0,10)的范围内取随机数</span></span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一次性声明大量<strong>同类型</strong>变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr;<span class="comment">//推荐。定义了一个 int 型的数组，数组名是 arr</span></span><br><span class="line"><span class="type">int</span> arr[];<span class="comment">//定义了一个 int 型变量，变量名是 arr 数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//静态初始化简化版</span></span><br><span class="line"><span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//动态初始化，只申请了空间，系统赋予初始值</span></span><br><span class="line"><span class="comment">//数字类型：初始值为0.0</span></span><br><span class="line"><span class="comment">//布尔类型：初始值为 false</span></span><br><span class="line"><span class="comment">//字符串类型：初始值为&quot;&quot;</span></span><br><span class="line"><span class="comment">//引用类型：初始值为 null</span></span><br></pre></td></tr></table></figure>

<p>java 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。</p>
<h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>定义的方法中的变量放在栈内存中，使用完直接消失。</p>
<p>如<code>int a</code>，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。</p>
<p>如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]&#x3D;1, arr[1]&#x3D;2……）</p>
<p>访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。</p>
<p>因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2=arr1;</span><br><span class="line">arr2[<span class="number">0</span>]=<span class="number">11</span>;</span><br><span class="line">arr2[<span class="number">1</span>]=<span class="number">22</span>;</span><br><span class="line">arr2[<span class="number">2</span>]=<span class="number">33</span>;<span class="comment">//这时访问 arr1[]，发现其中的数据也变成了11,22,33</span></span><br></pre></td></tr></table></figure>

<h3 id="数组常见异常"><a href="#数组常见异常" class="headerlink" title="数组常见异常"></a>数组常见异常</h3><ol>
<li>数组越界问题，ArrayIndexOutOfException。</li>
<li>空指针异常问题，NullPointerException。（<code>arr=null</code>，表示数组不指向任何有效对象）</li>
</ol>
<h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>数组自带属性 length，通过<code>arr.length</code>就能获得数组长度。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h2 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h2><p>查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">String line=sc.nextLine();</span><br><span class="line"><span class="comment">//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。</span></span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 类型代表字符串。其内容都是被双引号引住的。</p>
<p>在 java.lang 包下，不用导包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;abc&quot;</span>;<span class="comment">//直接赋值</span></span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] c=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(c);<span class="comment">//根据字符数组创建字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b=&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;<span class="comment">//a, b, c 对应的 ascii 码</span></span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br></pre></td></tr></table></figure>

<p>字符串一旦创建不能再修改。不过多个字符串的值可以共享<code>s1=s2;</code></p>
<p><em>字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。</em></p>
<h3 id="字符串比较：-和-equals"><a href="#字符串比较：-和-equals" class="headerlink" title="字符串比较：&#x3D;&#x3D; 和 equals()"></a>字符串比较：&#x3D;&#x3D; 和 equals()</h3><p>用&#x3D;&#x3D;判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。</p>
<p>基本类型 &#x3D;&#x3D; 比较的是数据值是否相同，引用类型 <strong>&#x3D;&#x3D;</strong> 比较的是<strong>地址</strong>是否相同。</p>
<p>用字符串的成员方法 <strong>equals()</strong> 判断，是比较字符串<strong>内容</strong>是否相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] c=&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(c);</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//输出 false，因为 s1 s2 地址不同，只有内容是一样的</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line">String s3=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s4=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s3==s4);<span class="comment">//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。</span></span><br><span class="line">System.out.println(s3.equals(s4));<span class="comment">//输出 true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1==s3);<span class="comment">//输出 false</span></span><br><span class="line">System.out.println(s1.equals(s3));<span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历字符串：成员方法-length-和-charAt"><a href="#遍历字符串：成员方法-length-和-charAt" class="headerlink" title="遍历字符串：成员方法 length() 和 charAt()"></a>遍历字符串：成员方法 length() 和 charAt()</h3><p><code>s.length()</code>可以获取字符串长度。<strong>这里注意是有括号的，和数组长度 length 区分开！</strong> </p>
<p>s.charAt(i) 可以获取索引为 i 处的字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    System.out.println(s.charAt(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>字符串可以直接用 + 号拼接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;World&quot;</span>;</span><br><span class="line">s1=s1+s2;<span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure>

<p>在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有”Hello “，”World”，”Hello World”三个字符串，而不是直接在”Hello “的位置上拼接”World”）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。</p>
<h3 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith()"></a>endsWith()</h3><p>查看字符串是否以指定子串结尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">s1.endsWith(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h3><p>与 String 类相比，最主要的特点在于内容可变。</p>
<p>在 java.lang 包下，不用导包。</p>
<p>构造方法：</p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuilder()</td>
<td>无参构造方法</td>
</tr>
<tr>
<td>StringBuilder(String s)</td>
<td>把给定的 String 字符串转换成 StringBuilder 类型的</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>append(String s)</td>
<td>在结尾拼接上字符串 s</td>
</tr>
<tr>
<td>StringBuilder reverse()</td>
<td>反转字符串</td>
</tr>
<tr>
<td>String toString()</td>
<td>把 StringBuilder 类型转换为 String 类型并返回</td>
</tr>
</tbody></table>
<p>用 StringBuilder 完成字符串拼接操作：</p>
<ol>
<li>String 类型转换为 StringBuilder 类型</li>
<li>StringBuilder 类型通过 append() 成员方法拼接字符串</li>
<li>StringBuilder 类型通过 toString() 成员方法转换为 String 类型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);<span class="comment">//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举</span></span><br><span class="line">sb.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">String s1=sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用</span></span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).append(<span class="string">&quot;World&quot;</span>).toString();</span><br></pre></td></tr></table></figure>

<p>用 StringBuilder 完成字符串反转操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">String sr=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s).reverse().toString();</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>java 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。</p>
<p>像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名(形参)&#123;<span class="comment">//和 main 方法同级</span></span><br><span class="line">    方法体</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;<span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line">方法名(实参);<span class="comment">//在 main 方法中调用。有返回值类型的方法建议用变量接收调用</span></span><br></pre></td></tr></table></figure>

<p>方法不能嵌套定义。</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>多个方法在一个类中，有相同的方法名，但参数不完全相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：返回值不能作为判断方法是否重载的标准！</strong>只有方法名和参数可以。</p>
<p>调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。</p>
<p><strong>形参值修改不会对实参造成影响。</strong>main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201224438.png" alt="A8wxg.png"></p>
<p>但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201223885.png" alt="A8Kh1.png"></p>
<p>如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。</p>
<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠</p>
<p>类是对象的数据类型，是一个抽象的概念。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名&#123;</span><br><span class="line">    数据类型 变量;</span><br><span class="line">    数据类型 变量;</span><br><span class="line">    数据类型 变量;</span><br><span class="line">    </span><br><span class="line">    方法<span class="number">1</span>;</span><br><span class="line">    方法<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">    String name;<span class="comment">//初始值为null或0或false或&quot;&quot;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">boolean</span> tail;</span><br><span class="line">    String color;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Eat &quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>类的实体化。比如罗小黑，是猫类的一个实体化。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）</p>
<h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p>对象能执行的动作，如猫可以叫，可以跑。</p>
<h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 main 方法中</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">c.name=<span class="string">&quot;小黑&quot;</span>;<span class="comment">//c 的名字</span></span><br><span class="line">c.age=<span class="number">2</span>;<span class="comment">//2岁了</span></span><br><span class="line">c.tail=<span class="literal">false</span>;<span class="comment">//有尾巴</span></span><br><span class="line">System.out.println(c.age);</span><br><span class="line">c.meow();<span class="comment">//行为：猫叫</span></span><br><span class="line">c.eat(<span class="string">&quot;猫粮&quot;</span>)<span class="comment">//行为：吃饭</span></span><br></pre></td></tr></table></figure>

<p>在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。</p>
<p>对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的<strong>属性</strong>等具体内容存储在<strong>堆内存</strong>中。对象中的<strong>方法</strong>调用时则加载到<strong>栈内存</strong>中，执行完毕后出栈。</p>
<h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><p>成员变量：类中在方法外的变量（如上例中的属性变量）</p>
<p>局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类中方法外</td>
<td>方法中，或方法声明上</td>
</tr>
<tr>
<td>堆内存中</td>
<td>栈内存中</td>
</tr>
<tr>
<td>对象消失时随之消失</td>
<td>方法调用完毕而消失</td>
</tr>
<tr>
<td>有默认的初始值</td>
<td>没有默认的初始值，必须先定义、赋值才能使用</td>
</tr>
</tbody></table>
<h2 id="对象内存图介绍"><a href="#对象内存图介绍" class="headerlink" title="对象内存图介绍"></a>对象内存图介绍</h2><p>首先老师汇总介绍了一下所有内存空间。当我们运行 Java 文件的时候系统分配一片内存空间给 JDK，里面具体是这样细分的：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505281457686.png" alt="image-20250528145755552" style="zoom:50%;" />

<p>元空间，或者叫方法区，负责加载字节码文件，是 JDK 8 及以后的版本从堆空间中划分出来的。</p>
<p>栈一般是方法，变量运行时进入。</p>
<p>堆是我们 new() 出来的对象的存储区域，并产生地址。</p>
<h3 id="单个对象的内存图"><a href="#单个对象的内存图" class="headerlink" title="单个对象的内存图"></a>单个对象的内存图</h3><p>比如：<code>Student s=new Student();</code></p>
<p>在这个过程中内存至少会执行以下七个步骤：</p>
<ol>
<li>加载 class 文件</li>
<li>声明局部变量</li>
<li>在堆内存中开辟一片空间</li>
<li>默认初始化（将对象中的局部变量值赋值为默认值，如 <code>String name</code> 赋值就是 null, <code>int age</code> 赋值就是0）</li>
<li>显示初始化（如果在类定义中我们做了赋值，如 <code>int age=19;</code> 显示初始化就会重新赋值成这个我们给定的默认值）</li>
<li>构造方法初始化（通过构造方法中的参数赋值）</li>
<li>将堆空间中的地址值赋值给左边的局部变量</li>
</ol>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505281511260.png" alt="image-20250528151133023" style="zoom: 33%;" />

<p>当方法执行完毕撤出栈空间的时候，没有引用堆内存中对应对象的变量时，堆内存中的对象就没有存在必要了就也被清理了。</p>
<h1 id="封装-packaging"><a href="#封装-packaging" class="headerlink" title="封装 packaging"></a>封装 packaging</h1><p>Java 的三大特性：封装、继承、多态。</p>
<p>之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age&#x3D;-30）</p>
<p>因此我们要添加一些限制。</p>
<h2 id="private-修饰符"><a href="#private-修饰符" class="headerlink" title="private 修饰符"></a>private 修饰符</h2><p>可以修饰成员变量、成员方法不<strong>直接</strong>被其他类使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br></pre></td></tr></table></figure>

<p>被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get &#x2F; set 方法。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>写在类中，作为类的方法。主要用于对象初始化。声明变量时<code>Cat c=new Cat();</code>Cat() 就是一种无参构造方法。</p>
<p>每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。<strong>建议无论是否用到构造方法，都写一个无参构造方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span>&#123;&#125;<span class="comment">//我们自己加的无参构造方法，会覆盖系统默认的</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span>&#123;<span class="comment">//写一部分参数的构造方法也可以</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;<span class="comment">//通过 this 赋给成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;<span class="comment">//写全参数的构造方法也可以</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main 中构造对象：</span></span><br><span class="line">Cat c1=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">Cat c2=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">Cat c3=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;小白&quot;</span>,<span class="number">2</span>);<span class="comment">//这些都可以，与自己写的构造方法的参数相对应。</span></span><br></pre></td></tr></table></figure>

<p>this被哪个对象调用，就代表哪个对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201256813.png" alt="AlrRQ.png"></p>
<p>然后把”林青霞” 字符串类型传入堆内存中。</p>
<h2 id="get-set"><a href="#get-set" class="headerlink" title="get &#x2F; set"></a>get &#x2F; set</h2><p>无参构造方法后用 setXxx() 方法创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;<span class="comment">//赋值</span></span><br><span class="line">	<span class="built_in">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age&gt;=<span class="number">0</span>&amp;&amp;age&lt;=<span class="number">20</span>)<span class="comment">//在 set 中可以添加一些限制处理</span></span><br><span class="line">	<span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getName</span><span class="params">()</span>&#123;<span class="comment">//获取值</span></span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 main 方法中赋值并获取值示例：</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">c.setName(<span class="string">&quot;小黑&quot;</span>);</span><br><span class="line">System.out.print(c.getName);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。</p>
<pre class="mermaid">graph TB
C[Collection]-->L[List]-->A[ArrayList]
C-->S[Set]-->H[HashSet]
C-->Q[Queue]</pre>



<p>ArrayList 就是集合的一种。</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList&lt;E&gt;"></a>ArrayList&lt;E&gt;</h2><p>在 java.util 包下，需要导包。</p>
<p>&lt;E&gt; 表示泛型，限制数组中的元素只能是某一种类型（或者其子类，多态），可以在编译阶段约束操作的数据类型并进行检查（下面左边的 String）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; array=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>泛型只能使用引用数据类型（比如包装类 Integer, Character… 或者我们自己定义的对象 Student，但是不可以使用基本数据类型 int char 这些，具体原因后面还会深入讲解）。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList&lt;E&gt;()</td>
<td>无参构造方法</td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td>结尾添加一个元素，成功返回true</td>
</tr>
<tr>
<td>void add(index i, E e)</td>
<td>在指定索引处添加一个元素（不能越界！）</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>删除指定对象，成功返回 true</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>删除指定索引处的值，返回该值</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>修改指定索引处值，返回修改后的值</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>返回指定索引处元素</td>
</tr>
<tr>
<td>int size()</td>
<td>返回集合元素个数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array.add(<span class="number">1</span>);</span><br><span class="line">array.add(<span class="number">3</span>);</span><br><span class="line">array.add(<span class="number">4</span>);</span><br><span class="line">array.add(<span class="number">1</span>,<span class="number">2</span>);	 <span class="comment">// 1下标位置插入2这个元素</span></span><br><span class="line">System.out.println(array);<span class="comment">//输出 array：1，2，3，4</span></span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123; <span class="comment">// 父类，基类，超类</span></span><br><span class="line">    String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">boolean</span> tail;</span><br><span class="line">	String color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123; <span class="comment">// 子类，派生类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meow</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bark!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。</p>
<p>当子类属于父类的一种时，可以使用继承。</p>
<h2 id="变量访问特点"><a href="#变量访问特点" class="headerlink" title="变量访问特点"></a>变量访问特点</h2><p>范围越小，权限越高。</p>
<p>访问优先级：子类中局部变量&gt;子类中成员变量&gt;父类中成员变量&gt;找不到就报错</p>
<p>如果想优先访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201821077.png" alt="AmPt7.png"></p>
<h2 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h2><p>构造方法的访问优先级和变量相反。即使访问子类的构造方法，也会优先访问<strong>父类的无参构造方法</strong>，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。</p>
<p>而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。</p>
<p>因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）</p>
<p>解决方法：1. 父类中补上无参构造方法</p>
<ol start="2">
<li>在子类构造方法中手动访问父类的带参构造方法来代替</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">super</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(age);<span class="comment">// 子类的带参构造方法就这样传递给父类即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不支持一个子类继承多个父类，但是允许多层基层（爷-&gt;父-&gt;子）</span></span><br></pre></td></tr></table></figure>

<h2 id="成员方法的访问特点"><a href="#成员方法的访问特点" class="headerlink" title="成员方法的访问特点"></a>成员方法的访问特点</h2><p>先在子类中寻找，找不到再去父类中寻找。</p>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>public &gt; protected &gt; 默认 &gt; private</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201821429.png" alt="Awiam.png"></p>
<h2 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h2><p>有 final 和 static。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>成员变量和成员方法被 final 修饰后，不可以被重新赋值 &#x2F; 重写。</p>
<p>类被 final 修饰后，也不可以作为父类。</p>
<p><em>引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容也不可以改变）</em></p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>被 static 修饰的成员变量在所有对象里值都是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String university;<span class="comment">//在学生类中的静态成员变量</span></span><br><span class="line"></span><br><span class="line">Student.unievrsity=<span class="string">&quot;北大&quot;</span>;<span class="comment">//统一赋值</span></span><br><span class="line">Strudent s1=<span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//university 变量的值是 &quot;北大&quot;</span></span><br><span class="line">Strudent s2=<span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//university 变量的值是 &quot;北大&quot;</span></span><br></pre></td></tr></table></figure>

<p>静态成员方法则是与类本身相关（非静态的方法是和类的具体实例对象有关，静态方法是和整个类有关），调用方式也是 <code>类名.静态方法名</code>。静态方法中不能使用 this 关键字（因为没有具体的实例对象）。此外，<strong>静态成员方法只能访问静态成员变量 &#x2F; 方法！</strong></p>
<h2 id="包-Package"><a href="#包-Package" class="headerlink" title="包 Package"></a>包 Package</h2><p>文件夹，用于存放编译后生成的 class 文件，方便管理。</p>
<p>在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ithema;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令行根据路径建包</span></span><br><span class="line">javac -d . HelloWorld.java</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line">javac HelloWorld.java</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行</span></span><br><span class="line">java com.ithema.HelloWorld</span><br></pre></td></tr></table></figure>

<h2 id="导包-import"><a href="#导包-import" class="headerlink" title="导包 import"></a>导包 import</h2><p>如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用</p>
<p><code>import B文件夹.要调用的类名;</code></p>
<p>之前对于权限的学习，我们知道：只有 public 的类可以被其他跨包无关类访问；被 protected 修饰的父类对跨包的子类可见。</p>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>之前学过方法重载，是函数名相同但是参数设置不同的函数。</p>
<p>方法重写是子类中重新定义了父类中的方法。</p>
<p>子类如果想访问父类中的方法，可以通过 super 来指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span><span class="comment">//注解，可以检查方法重写的正确性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;子类中重写方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。</li>
<li>子类的重写方法权限必须高于父类方法。（public &gt; protected &gt; 默认 &gt; private）</li>
</ol>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>同一个对象在不同时刻表现出的形态也不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//父类引用指向子类对象</span></span><br></pre></td></tr></table></figure>

<p>a 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。</p>
<h2 id="多态中成员的访问特点"><a href="#多态中成员的访问特点" class="headerlink" title="多态中成员的访问特点"></a>多态中成员的访问特点</h2><p>访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。<em>因为成员变量不会被重写</em></p>
<p>访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。</p>
<p>例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalOperator</span>(Animal a)</span><br><span class="line">&#123;</span><br><span class="line">    a.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">Dog d=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">Pig p=<span class="keyword">new</span> <span class="title class_">Pig</span>();</span><br><span class="line">AnimalOperator(c);<span class="comment">// 多态</span></span><br><span class="line">AnimalOperator(d);<span class="comment">// 多态</span></span><br><span class="line">AnimalOperator(p);<span class="comment">// 多态</span></span><br></pre></td></tr></table></figure>

<p>调用的都是子类中重写的方法。</p>
<p>多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类接口就能访问（无论子类具体是哪一种）。</p>
<p>但是多态无法访问子类中特有的方法。</p>
<p>解决这一弊端的方法就是转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//向上转型，a 不能访问 Cat 类中特有的方法</span></span><br><span class="line">Cat c=(Cat)a;<span class="comment">//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。</span></span><br></pre></td></tr></table></figure>

<p>使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。<em>ClassCastException</em></p>
<h1 id="Abstract-接口"><a href="#Abstract-接口" class="headerlink" title="Abstract, 接口"></a>Abstract, 接口</h1><p>抽象方法：没有方法体的方法，待补全，请输入文本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>抽象类：含有抽象方法的类。</p>
<p>（没有抽象方法的类也可以是抽象类，但是意义何在）</p>
<p>抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象类。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Jumpping</span>&#123; <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">Jump</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Jumpping</span>&#123; <span class="comment">// 实现</span></span><br><span class="line">    <span class="comment">// 重写 Jump() 方法。如果不重写， Cat 就是一个抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。</p>
<p>接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。</p>
<p>（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）</p>
<p>接口是抽象的，不能直接实例化，可以借助多态的方法实例化。</p>
<p>相较类与类之间不能多继承，只能层层继承：接口可以多实现 <code>implements interface1, interface2</code></p>
<p>接口和接口之间也可以多继承 <code>interface1 extends interface2, interface3</code></p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505201836142.png" alt="在这里插入图片描述"></p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。</p>
<p>但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。</p>
<p>例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。但并不是“是人就该会说英语，是运动员和教练就该会说英语”。所以说英语应当作为接口而不是人里面的抽象方法。</p>
<pre class="mermaid">graph TB
A[人]-->B[运动员]
A-->C[教练]
B-->D[篮球运动员]
B-->E[乒乓球运动员]
H[说英语]-->E
H-->G
C-->G[乒乓球教练]
C-->F[篮球教练]</pre>

<p>其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。</p>
<h2 id="抽象类-接口作为形参-返回值"><a href="#抽象类-接口作为形参-返回值" class="headerlink" title="抽象类 &#x2F; 接口作为形参 &#x2F; 返回值"></a>抽象类 &#x2F; 接口作为形参 &#x2F; 返回值</h2><p>类也可以作为形式参数或函数的返回值。</p>
<p>抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要传递的是实现了该抽象类的子类的实例对象。</p>
<p>如函数形参是Animal，实际需要通过多态的方法Animal a&#x3D;new Cat();然后把a传给函数。</p>
<p>接口作为形参&#x2F;函数返回值，和抽象类一样，实际需要的是实现了该接口的类的实例对象。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在类中定义一个类。</p>
<h2 id="内部类和外部类的互相使用"><a href="#内部类和外部类的互相使用" class="headerlink" title="内部类和外部类的互相使用"></a>内部类和外部类的互相使用</h2><p>无论外部类的成员变量的权限修饰符是什么（private, public……）因为都在同一个类中，所以即使权限修饰符是 private 也可以相互访问。</p>
<p>内部类都可以<strong>直接</strong>访问外部类的全部成员变量。</p>
<p>而外部类如果想访问内部类的成员，需要<strong>先创建一个内部类对象再访问</strong>。</p>
<h2 id="外界使用内部类"><a href="#外界使用内部类" class="headerlink" title="外界使用内部类"></a>外界使用内部类</h2><p>外界使用内部类：<code>Outer.Inner oi=new Outer().new Inner();</code></p>
<p>如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。<strong>封装</strong></p>
<h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><p>在类的成员位置定义：成员内部类</p>
<p>在类的局部定义：局部内部类。</p>
<p>局部内部类不能从外界直接创建对象，只能通过调用方法来创建类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(num);<span class="comment">//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner i=<span class="keyword">new</span> <span class="title class_">Inner</span>();<span class="comment">//在方法中创建内部对象</span></span><br><span class="line">        i.show();<span class="comment">//创建对象之后，记得调用内部方法的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>继承了另一个类，或实现了接口的子类匿名对象。</p>
<p>首先有一个父类&#x2F;接口，其中有具体的&#x2F;抽象的方法，然后匿名内部类对其进行重写&#x2F;实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口文件 inter.java 中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类文件 Outer.java 中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">inter</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.show();<span class="comment">// 创建匿名对象之后，记得调用成员变量</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//另一种方法：</span></span><br><span class="line">        inter i=<span class="keyword">new</span> <span class="title class_">inter</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行 j 的 jump 。</p>
<p>我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；</p>
<p>然后用多态的方式<code>jump c=new cat(); jump d=new dog();</code> 新建对象并传给 method 方法。</p>
<p>但是可以通过匿名内部类的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jo.method(<span class="keyword">new</span> <span class="title class_">jump</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫跳高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">jo.method(<span class="keyword">new</span> <span class="title class_">jump</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗跳高&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>直接传一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。</p>
<h1 id="一些常用类"><a href="#一些常用类" class="headerlink" title="一些常用类"></a>一些常用类</h1><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int abs(int a)</td>
<td>绝对值，支持 double  float int long 类型</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>向上取整，返回一个 double 值</td>
</tr>
<tr>
<td>public static double floor(double a)</td>
<td>向下取整，返回一个 double 值</td>
</tr>
<tr>
<td>public static int round(float a)</td>
<td>四舍五入</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td></td>
</tr>
<tr>
<td>public static int min(int a,int b)</td>
<td></td>
</tr>
<tr>
<td>public static double pow(double a,double b)</td>
<td>a 的 b 次幂</td>
</tr>
<tr>
<td>public static double random()</td>
<td>随机数，范围 [0.0,1.0)</td>
</tr>
</tbody></table>
<p>随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用<code>random()*100</code>。</p>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>不用导包，不能实例化，static</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static void exit(int status)</td>
<td>终止运行 JVM，非零表示非正常终止</td>
</tr>
<tr>
<td>public static long currentTimeMillis()</td>
<td>返回当前时间到1970年1月1日的时间间隔，以毫秒为单位</td>
</tr>
</tbody></table>
<p>currentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object 类是所有类的根类。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>返回对象的字符串表示形式。建议子类全部重写该方法</td>
</tr>
<tr>
<td>public boolean equals(Object obj)</td>
<td>比较对象是否相等（默认比较地址）。重写可以比较对象内容</td>
</tr>
</tbody></table>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><p>Object 中包含 toString 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出类名@+一串哈希值。</p>
<p>一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter &#x2F; setter 一样自动生成。类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动实现</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&#123; Person:name=&quot;</span> + name +<span class="string">&quot; age=&quot;</span> + age+<span class="string">&quot;&#125;&quot;</span>;<span class="comment">// name 和 age 都是本类中的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p><code>s1.equals(s2)</code>本质上是比较两个对象的地址，肯定是 false。</p>
<p>一般也会重写&#x2F;自动生成可以比较两个对象内容是否一致的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>==o) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//同一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(o==<span class="literal">null</span>||getClass()!=o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//o是空对象，或这两个对象不属于一个类</span></span><br><span class="line">    Student student=(Student) o;<span class="comment">//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来</span></span><br><span class="line">    <span class="keyword">if</span> (age!=student.age)<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">return</span> name!=<span class="literal">null</span>?name.equals(student.name):student.name==<span class="literal">null</span>;<span class="comment">//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>需要导包 <code>java.util.Arrays</code>，不能创建对象，成员是 static的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static String toString(int[] a)</td>
<td>返回形如 “[a, b, c]” 的字符串形式</td>
</tr>
<tr>
<td>public static void sort(int[] a)</td>
<td>按数字顺序排列指定的数组</td>
</tr>
</tbody></table>
<h2 id="补充：工具类"><a href="#补充：工具类" class="headerlink" title="补充：工具类"></a>补充：工具类</h2><p>以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。比如 <code>Arrays.sort(arr);</code></p>
<p>以下这些方法不能创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Math</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Arrays</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">System</span><span class="params">()</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>因为这些类自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。</p>
<h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>其中有一些方法能更好地处理基本数据类型。</p>
<p>包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p>
<h3 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static Integer valueOf(int i)</td>
<td>把 int 转换为 Integer 类型</td>
</tr>
<tr>
<td>public static Integer valueOf(String s)</td>
<td>把 String 转换为 Integer 类型</td>
</tr>
</tbody></table>
<p>public String[] split(String regex) 把给定字符串用 regex 分隔开。</p>
<p>如给定字符串 s 是”1 2 3 4”，<code>s.split(&quot; &quot;)</code>就会得到4个字符串：”1””2””3””4”。</p>
<h3 id="基本类型转换"><a href="#基本类型转换" class="headerlink" title="基本类型转换"></a>基本类型转换</h3><p>int -&gt; String：</p>
<p>① 空字符串+int 类型 <code>&quot;&quot;+123</code></p>
<p>② <code>String s=String.valueOf(i);</code></p>
<p>String -&gt; int：</p>
<p>① <code>Integer in=Integer.valueOf(s);</code></p>
<p><code>int i=intValue(in);</code></p>
<p>② <code>int i=Integer.parseInt(s);</code></p>
<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>装箱：基本类型-&gt;对应的包装类型</p>
<p>拆箱：包装类型-&gt;基本类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer i=Integer.valueOf(<span class="number">100</span>);<span class="comment">//装箱</span></span><br><span class="line">Integer ii=<span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line"></span><br><span class="line">ii=ii.intValue()+<span class="number">200</span>;<span class="comment">//拆箱</span></span><br><span class="line">ii+=<span class="number">200</span>;<span class="comment">//自动拆箱</span></span><br><span class="line"></span><br><span class="line">Integer i3=<span class="literal">null</span>;</span><br><span class="line">i3+=<span class="number">300</span>;<span class="comment">//NullPointerException。因此对象使用之前最好先判断是否为 null</span></span><br></pre></td></tr></table></figure>

<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>Date 类，需要导包。<strong>注意是 java.util 下的，而不是 java.sql 下的！</strong>java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒</td>
</tr>
<tr>
<td>public Date(long Date)</td>
<td>分配一个 Date 对象，值为从标准时间起指定的毫秒数</td>
</tr>
<tr>
<td>public long getTime()</td>
<td>获取日期对象从标准时间到现在的毫秒数</td>
</tr>
<tr>
<td>public void setTime(long time)</td>
<td>设置时间，单位为毫秒</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> d=<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>;</span><br><span class="line">Date da=<span class="keyword">new</span> <span class="title class_">Date</span>(d);<span class="comment">//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> time=System.currentTimeMillis();<span class="comment">//可以这样获取当前时间，然后传给 Date() 或 setTime()</span></span><br></pre></td></tr></table></figure>

<h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>可以自己设置日期格式。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public SimpleDateFormat()</td>
<td>构造方法，并使用系统默认的 Date 格式</td>
</tr>
<tr>
<td>public SimpleDateFormat(String pattern)</td>
<td>构造方法，并使用自己规定的格式</td>
</tr>
<tr>
<td>public final String format(Date d)</td>
<td>将日期对象转换为相应格式的字符串</td>
</tr>
<tr>
<td>public final Date parse(String s)</td>
<td>将字符串转换为日期</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Parse Exception&#123;<span class="comment">//结尾要加一些东西，在 IDEA 中可以自动补全</span></span><br><span class="line">    Date d=<span class="keyword">new</span> <span class="title class_">Date</span>;<span class="comment">//被分配时的时间</span></span><br><span class="line">    SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年-MM月-dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">    String s=sdf.format(d);</span><br><span class="line">    System.out.println(s);<span class="comment">//输出格式就形如 2022年-05月-05日 10:24:00</span></span><br><span class="line">    </span><br><span class="line">    String ss=<span class="string">&quot;2022-05-05 10:24:00&quot;</span>;</span><br><span class="line">    SimpleDateFormat sdf1=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    Date d1=sdf1.parse(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>y 年 M 月 d 日</p>
<p>H 时 m 分 s 秒</p>
<p>（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把 Date 转换为 String 和把String转换为Date；这两个方法可以设置两个传入参数：</p>
<p><code>public static String dateToString(Date d, String format)</code></p>
<p><code>public static String StringTodate(String s, String format)</code></p>
<p>在方法内根据传入的字符串格式，利用 SimpleDateFormat 的方法进行转换。）</p>
<h3 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h3><p>需要导包<code>java.util.Calendar</code>，是一个抽象类。</p>
<p>为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。</p>
<p>Calendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar rightnow=Calendar.getInstance();</span><br></pre></td></tr></table></figure>

<p>其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int get(int field)</td>
<td>获取给定日历字段的值</td>
</tr>
<tr>
<td>public abstract void add(int field, int amount)</td>
<td>添加&#x2F;减去给定的日历字段</td>
</tr>
<tr>
<td>public final void set(int year, int month, int date)</td>
<td>设置日历的年月日</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">y=c.get(Calendar.YEAR);</span><br><span class="line">m=c.get(Calendar.MONTH)+<span class="number">1</span>;<span class="comment">//month 是从0开始的，所以要+1</span></span><br><span class="line">d=c.get(Calendar.DATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例：求2020年2月有多少天?</span></span><br><span class="line">Calendar c=Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">2020</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//设置为3月1日</span></span><br><span class="line">c.add(Calendar.DATE,-<span class="number">1</span>);<span class="comment">//倒退1天，就是2月的最后一天</span></span><br><span class="line">System.out.println(<span class="string">&quot;2020年2月有&quot;</span>+c.get(Calendar.DATE)+<span class="string">&quot;天&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。</p>
<h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>Throwable 是所有错误、异常的父类。</p>
<pre class="mermaid">graph LR
A[Throwable]-->B[Error]
A-->C[异常]
C-->R[RuntimeException <br> 运行型异常]
C-->O[其他 <br> 编译型异常]</pre>

<p>Error 程序无法处理，而异常程序可以处理。</p>
<p>RuntimeException：运行时异常，非受检异常， 可以先不处理，等到真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。比如数组越界。</p>
<p>编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。</p>
<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>JVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。</p>
<p>程序员还可以有自己的处理异常方法，如 try…catch 和 throw。</p>
<h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能出现异常的代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">    出现异常后的处理代码;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s=<span class="string">&quot;2022-05-07&quot;</span>;</span><br><span class="line">SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line">sdf.parse(s);<span class="comment">// 这个方法不能直接用，必须要加异常处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    sdf.parse(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ParseException e)&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;parseException!&quot;</span>);<span class="comment">//不管会不会发生异常，都要写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，<strong>处理完成后可以继续执行。</strong></p>
<p>如果异常变量命名为 e ,调用 e 的成员方法 <code>e.printStackTrace()</code> 就会输出平时出现异常时系统默认提示的信息：<code>java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... </code></p>
<p>但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。</p>
<h3 id="Throwable-的成员方法"><a href="#Throwable-的成员方法" class="headerlink" title="Throwable 的成员方法"></a>Throwable 的成员方法</h3><p>Throwable 作为超类，其所有子类都可以使用他的成员方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String getMessage()</td>
<td>返回此 Throwable 的详细消息字符串</td>
</tr>
<tr>
<td>public String toString()</td>
<td>返回此可抛出的简短描述</td>
</tr>
<tr>
<td>public void printStackTrace()</td>
<td>把异常的错误信息输出到控制台</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.getMessage():  Index 3 out of bounds for length 3</span><br><span class="line">e.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span><br><span class="line">e.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....</span><br></pre></td></tr></table></figure>

<p>利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Throwable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String detailMessage;<span class="comment">//Throwable 类中的一个成员方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Throwable</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        detailMessage=message;<span class="comment">//构造方法。出现异常时，会通过这种方法构造一个异常对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> detailMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Throws"><a href="#Throws" class="headerlink" title="Throws"></a>Throws</h2><p>可以抛出异常给 try catch 处理，但是自身不能解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throws</span> 异常类名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行开始&quot;</span>);</span><br><span class="line">    method1();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        method2();<span class="comment">//抛出给了 try catch 处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ParseException e)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;运行结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfException&#123;</span><br><span class="line">    <span class="type">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);<span class="comment">//会报错并停止运行，throws 并没有解决数组越界这个异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">    String s=<span class="string">&quot;2022-05-07&quot;</span>;</span><br><span class="line">	SimpleDateFormat sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line">	sdf.parse(s);<span class="comment">//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    无参构造</span><br><span class="line">    带参构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScoreException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">(message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);<span class="comment">//把 message 传给父类处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异常类的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">throws</span> ScoreException&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">0</span>||score&gt;<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScoreException</span>(<span class="string">&quot;输入分数有误！请重新输入&quot;</span>);<span class="comment">//throw 不是 throws!</span></span><br><span class="line">            <span class="comment">/*throw 写在方法体内，throws 写在类定义里。</span></span><br><span class="line"><span class="comment">            throws 不一定有异常，而 throw 一定是抛出了异常。*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">&quot;分数正常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> score=sc.nextInt();</span><br><span class="line">    Teacher t=<span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//调用方法时，要处理抛过来的异常</span></span><br><span class="line">        t.checkScore(score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ScoreException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常时就会输出：异常类型 ScoreException，异常原因&quot;输入分数有误！请重新输入&quot;，异常位置。</span></span><br></pre></td></tr></table></figure>

<h1 id="集合进阶"><a href="#集合进阶" class="headerlink" title="集合进阶"></a>集合进阶</h1><pre class="mermaid">graph LR
A[集合]-->C[Collection]
A-->M[Map]
C-->L[List]
C-->S[Set]
L-->AL(ArrayList)
L-->LL(LinkedList)
S-->HS(HashSet)
S-->TS(TreeSet)
M-->HM(HashMap)</pre>

<p>其中方形的是接口，圆角的是实现类。</p>
<p>因此先学习 Collection 和 Map 接口后，只需要学习下一级的特有的部分。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p>栈：后入先出 FILO。</p>
</li>
<li><p>队列：先入先出 FIFO。</p>
</li>
<li><p>数组：可以根据索引查找，查找效率高；增删效率低。</p>
</li>
<li><p>链表：每个结点存储数据和下一个结点的地址值。最后一个结点地址值为空。相比数组，增删只需要修改增删处前后结点的地址值，效率更高。但是查询必须从头开始，效率低。</p>
</li>
<li><p>树。</p>
</li>
<li><p>红黑树。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505291037431.png" alt="image-20250529103715199"></p>
<p>添加节点优先是添加红色的（不影响简单路径的黑色节点数，调整次数少）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505291106468.png" alt="image-20250529110638118"></p>
<p>红黑树对平衡要求性低一些（最长路径不超过最短路径的2倍），所以插入数据的时候需要的旋转次数平均下来更少。适用于频繁插入删除操作。</p>
</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>java.util.Collection</p>
<p>Collection 是单例集合的最高级接口。他表示一组对象，这些对象也被称为 Collection 的元素。</p>
<p>无法直接实现。可以用多态的方式实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; c=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//add(E e) 方法添加元素</span></span><br><span class="line">c.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">System.out.println(c);<span class="comment">//输出[&#x27;Hello&#x27;,&#x27;World&#x27;]，因为 ArrayList 中重写了 toString 方法，所以得到的不是一串地址</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(E e)</td>
<td>添加元素，永远返回 true</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从集合中移除指定的元素，成功移除返回 true</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合中的元素</td>
</tr>
<tr>
<td>boolean contains(Object o)</td>
<td>判断集合中是否存在指定的元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td>int size()</td>
<td>集合长度</td>
</tr>
</tbody></table>
<p>快捷键：Alt+7，能看到类的所有信息</p>
<h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h3><p>java.util.Iterator</p>
<p>Iterator 是一个接口。使用 Iterator 迭代器遍历集合元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it=c.iterator();<span class="comment">//通过集合对象中的迭代方法获取对象</span></span><br></pre></td></tr></table></figure>

<p>追根溯源可以得知，Collection.iterator()方法返回的是一个实现了 Iterator 接口的类：Itr.</p>
<p>所以实际上是通过多态的方式实例化的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>E next()</td>
<td>返回下一个元素（越界访问：NoSuchElementException，被请求的元素不存在）并移动指针到下一个位置</td>
</tr>
<tr>
<td>boolean hasNext()</td>
<td>如果存在下一个元素，返回 true</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s=it.next();<span class="comment">//这样更好一些，因为元素可能还要做其他操作</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>it.next() 像指针一样从0开始遍历。</p>
<h3 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h3><p>当不允许这样的修改时，会抛出此方法。</p>
<p>如：在使用 iterator 遍历过程中，在集合中添加了新的元素。</p>
<p>iterator 调用 next() 方法时，会先调用 checkForComodification() 方法。</p>
<p>checkForComodification() 会检验 modCount 修改集合的次数和expectedModCount 预期修改集合的次数是否相等。</p>
<p>modCount 来自于 ArrayList 的父类：AbstractList，初始值为0.每次使用 add() 方法时，modCount 就会++。</p>
<p>expectedCount 来自于 Itr 类，且初始值为 <code>expectedCount=modCount</code>.</p>
<p>每次实例化一个 Iterator 类，都会调用其子类 Itr 类，使得 expectedCount 等于当前的 modCount。</p>
<p>然后遍历过程中每次调用 next() 方法时，都会先检查一下<code>expectedCount==modCount</code>，即集合有没有被修改。如果没有修改就可以顺利地返回下一个元素；如果有异常 checkForComodificationException，就会终止运行。</p>
<pre class="mermaid">graph TB
C[Collection]-->|获取迭代对象|I[iterator]
C-->|多态|Arr[Arraylist]
I-->|多态|Itr[Itr]
A-->W{"iterator.hasNext()==true"}
Itr-->A(expectedCount=modCount)
W-->|no|en(遍历结束)
W-->|yes|N("iterator.next()")
N-->cf("checkForComodification()")
cf-->cfe{"expectedCount==modCount"}

X-->W
cfe-->|no|Y(checkForComodificationException)
cfe-->|yes|X("集合没有被修改,继续遍历")</pre>

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505282318767.png" alt="image-20250528231810569"></p>
<p>但是通过 for 循环遍历集合，在遍历过程中对集合进行修改，不会报异常。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>java.util.List</p>
<p>继承自 Collection 类，可以使用其中的方法。</p>
<p>List 是有序、有索引的。相较于集合 Set，List 中的元素可以重复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">l.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">l.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">System.out.println(l);<span class="comment">//按存储的顺序输出，[&quot;Hello&quot;,&quot;World&quot;]</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index,E element)</td>
<td>感觉并不用解释</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td></td>
</tr>
<tr>
<td>E set(int index,E element)</td>
<td></td>
</tr>
<tr>
<td>E get(int index)</td>
<td></td>
</tr>
</tbody></table>
<p>越界报错 IndexOutOfException。</p>
<p>另一种遍历集合的方法是 for 循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l.size();i++)System.out.println(l.get(i));</span><br></pre></td></tr></table></figure>

<h3 id="List-Interator"><a href="#List-Interator" class="headerlink" title="List Interator"></a>List Interator</h3><p>通过 List 中的 listInterator() 方法得到。可以从各个方向遍历，迭代期间可以修改列表，还可以获取列表迭代器的当前位置。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td></td>
</tr>
<tr>
<td>E next()</td>
<td></td>
</tr>
<tr>
<td>boolean hasPrevious()</td>
<td>反向遍历用到</td>
</tr>
<tr>
<td>E previous()</td>
<td>反向遍历用到</td>
</tr>
<tr>
<td>void add(E e)</td>
<td>添加元素，<strong>注意是通过 listInterator 添加的，不是通过集合添加的！</strong></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">l.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">l.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">l.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">ListInterator&lt;String&gt; li=l.listInterator();<span class="comment">//实际上是 listItr 类作为 listInterator 类的子类，通过多态实现</span></span><br><span class="line"><span class="keyword">while</span>(li.hasNext())&#123;</span><br><span class="line">    System.out.println(l.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(li.hasPrevious())&#123;</span><br><span class="line">    System.out.println(l.previous());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(li.hasNext())&#123;</span><br><span class="line">    String s=l.next();</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;World&quot;</span>))&#123;</span><br><span class="line">        li.add(<span class="string">&quot;!!!&quot;</span>);<span class="comment">//特别注意，并不是调用了l的 add() 方法，而是 li 的 add() 方法！</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 listItr 类中的 add() 方法，添加完元素之后，有一句<code>expectedModCount=modCount;</code>重新把实际修改值赋给了预期修改值。因此 next() 方法中判断<code>expectedModCount==modCount</code>，即使添加了新元素也仍然是 true. 不会发生并发修改异常。这就是为什么要特殊强调这里的 add 和 List 自身的 add 不一样。</p>
<h3 id="增强-for"><a href="#增强-for" class="headerlink" title="增强 for"></a>增强 for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(E e:数组或 Collection 的集合)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在这里使用变量e，把其当做集合元素来用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:list)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部是一个 iterator 迭代器，不可以中途修改数据，会引发并发修改异常。</span></span><br></pre></td></tr></table></figure>

<h3 id="几种遍历方式的选择"><a href="#几种遍历方式的选择" class="headerlink" title="几种遍历方式的选择"></a>几种遍历方式的选择</h3><p>单纯的遍历：增强 for 最简单。</p>
<p>需要用到索引：普通 for。</p>
<p>迭代器也要会用。</p>
<p>ArrayList 底层数据结构是数组，LinkedList 底层数据结构是双向链表。</p>
<p>用法一模一样，查询效率高就用 ArrayList，增删效率高用 LinkedList。</p>
<h3 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>实现原理：</p>
<p>底层先创建一个长度为0的数组。</p>
<p>添加第一个元素的时候底层扩容为一个长度为10的连续存储区域的数组。指针指向下一个要存入的数据的位置。</p>
<p>后续继续添加元素，直到装满的时候，整个数组扩容1.5倍（在其他地方开辟一片1.5倍原数组长度的区域，并且把原来的数据全部拷贝进去）。</p>
<p>如果一次添加多个元素超过扩容后的1.5倍的数量，则按照新添加元素数量来扩容数组。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505282253668.png" alt="image-20250528225349267"></p>
<p>方法的话没什么特殊的。</p>
<h3 id="LinkList"><a href="#LinkList" class="headerlink" title="LinkList"></a>LinkList</h3><p>双向链表，有很多操作首尾元素的特殊方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void addFirst(E e)</td>
<td>这些含义都比较明显就不多赘述了</td>
</tr>
<tr>
<td>public void addLast(E e)</td>
<td></td>
</tr>
<tr>
<td>public E getFirst()</td>
<td></td>
</tr>
<tr>
<td>public E getLast()</td>
<td></td>
</tr>
<tr>
<td>public void removeFirst()</td>
<td></td>
</tr>
<tr>
<td>public void removeLast()</td>
<td></td>
</tr>
</tbody></table>
<p>工作原理：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505282306108.png" alt="image-20250528230629720"></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>之前在介绍 ArrayList 的时候简单介绍过，泛型用于编译阶段约束操作的数据类型，如 <code>ArrayList&lt;String&gt; arrayList=new ArrayList&lt;&gt;();</code> 就只能存入 String 包装类型了。只能存入指定的泛型数据类型或者其子类（多态）。</p>
<p>如果集合没有限制泛型类型，那么传入什么类型的对象都可以，<code>ArrayList arrayList=new ArrayList&lt;&gt;();</code> 传一个 Integer，传一个 String，传一个 Student……（默认 Object 类型，多态）</p>
<p>但是多态的弊端在于没法使用子类中的特有自定义方法。迭代器的类型也和泛型定义的一样。</p>
<p>但是其实 java 中的泛型是伪泛型。就是只在编译阶段检查，其实泛型检查相当于一个保安大爷。编译阶段会简单判断一下你传入的数据是否都符合泛型数据类型，符合才让存；但是存进去的时候还是按照 Object 类型存入的。只不过取出数据准备处理的时候多做了一步操作，就是将 Object 类型的数据再转化为对应的泛型数据类型。</p>
<p>为什么这样做？因为泛型的概念是 JDK 1.5 才提出的，在之前的集合是没有泛型的，而新版本要尽可能向下兼容（因为之前已经诞生了很多 java 代码了，如果全部改成按指定泛型存入数据类型，之前很多旧版本的代码就用不了了，都要改）。</p>
<p><em>其实这也解释了为什么泛型不能设定为基本数据类型如 <code>int</code> <code>char</code> 这些，因为这些类型存入的时候无法转换为 <code>Object</code> 类型）</em></p>
<h3 id="泛型的几种应用场景"><a href="#泛型的几种应用场景" class="headerlink" title="泛型的几种应用场景"></a>泛型的几种应用场景</h3><p>泛型类：当不确定数据类型的时候使用。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505282339799.png" alt="image-20250528233910636"></p>
<p><em>字母写什么都行，不过上面这四个比较常见。</em></p>
<p>比如下面这个是一个自定义的泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    Object[] obj = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * E：表示是不确定的类型。该类型在定义类的时候已经定义过了。</span></span><br><span class="line"><span class="comment">     * e：形参的名字，变量名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        obj[size] = e;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E) obj[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型方法：如果类里面只有一个方法要用到泛型变量，推荐使用这种方法。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505282350835.png" alt="image-20250528235035645"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数一：集合</span></span><br><span class="line"><span class="comment"> * 参数二~最后：要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;E&gt; list, E e1, E e2, E e3, E e4)</span> &#123;</span><br><span class="line">    list.add(e1);</span><br><span class="line">    list.add(e2);</span><br><span class="line">    list.add(e3);</span><br><span class="line">    list.add(e4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传入该数据类型的集合变量后，后续几个变量都会自动检测是否和集合变量同类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ListUtil.addAll(list, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;ddd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其实也可以传入可变参数 (E… e) 不限制传入参数个数。</p>
<p>泛型接口：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505282356283.png" alt="image-20250528235630079"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList2</span> <span class="keyword">implements</span> <span class="title class_">List</span>&lt;String&gt;&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList3</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型不具备继承性"><a href="#泛型不具备继承性" class="headerlink" title="泛型不具备继承性"></a>泛型不具备继承性</h3><p>但是数据具备继承性。</p>
<p>比如定义了 <code>public static void method(ArrayList&lt;Ye&gt; arrayList)</code>，Ye 是 Fu 的父类，Fu 是 Zi 的子类，那么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建集合的对象</span></span><br><span class="line">ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 method 方法</span></span><br><span class="line"><span class="comment">// method(list1);</span></span><br><span class="line"><span class="comment">// 下面这些方法报错，泛型方法必须传入完全一样数据类型的变量</span></span><br><span class="line"><span class="comment">// method(list2);</span></span><br><span class="line"><span class="comment">// method(list3);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种使用方法不报错，数据具有继承性</span></span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Ye</span>());</span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Fu</span>());</span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Zi</span>());</span><br></pre></td></tr></table></figure>

<p>那么怎么传入多种数据类型的变量呢？method 定义成 <code>method(ArrayList&lt;E&gt; arrayList)</code> 这样就什么数据类型都能传了。但是我们没法只限制某一类特殊的类，比如“我只想接收 Ye Fu Zi 类的集合”，办不到，只能所有引用类型都接收。</p>
<p>要想限制成部分类，需要使用泛型通配符。</p>
<p><code>public static void method(ArrayList&lt;? extends Ye&gt; arrayList</code> 是继承自爷的所有类包括爷可以传入。</p>
<p><code>public static void method(ArrayList&lt;? super Ye&gt; arrayList</code> 是 Fu 的所有父类包括 Fu 可以传入。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>List 有序，可重复，有索引。Set 无序（存取顺序不一定一样），不重复，无索引。</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>增删改查性能都不错。</p>
<p>JDK8 之前的版本底层是数组+链表实现。JDK8 之后是数组+链表+红黑树实现，做了优化。</p>
<p>添加元素时存储位置参考哈希值：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505291200685.png" alt="image-20250529120015332"></p>
<p>加载因子用于判断数组什么时候扩容，比如上例是存入了 16*0.75&#x3D;12 个元素之后扩容。</p>
<p>这也解释了为什么 Set 遍历无序（按数组顺序遍历，但是对应的是哈希值从小到大遍历，不一定是存入顺序）</p>
<p>默认是使用 Object 里面的 hashCode() 方法，利用对象的地址计算哈希值（不同的对象哈希值一定不同），一般会重写 hashCode 方法，根据对象属性计算哈希值（可以 IDEA 快捷生成），使得只要对象的属性相同，计算得到的哈希值就相同。</p>
<p><em>不同的地址值或者对象属性值计算哈希值也有小概率会相等，这叫做哈希碰撞。</em></p>
<p><em>String 和 Integer 类型 在 Java 里面已经重写好了 equals 和 hashCode 方法，不需要重写。</em></p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>有序（存取顺序一致），无重复，无索引。</p>
<p>额外用一个双链表记录元素存储顺序。</p>
<p>数据去重默认使用 HashSet，如果还有有序需求再使用 LinkedHashSet.</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>不重复，无索引，可排序。</p>
<p>数据存进去就默认被排序了。数值类型从小到大排序，字符类型按 ASCII 码升序排序。</p>
<p>但是如果是自定义的对象，直接传入 TreeSet 是无法传入的会报错，因为默认没有写比较方法，尝试使用排序函数也会获得一样的结果。</p>
<p>第一种排序方式：</p>
<p>首先要让自定义类 <code>implements Comparable</code> ，如 <code>public Student implements Comparable&lt;Student&gt;</code> 因为这里我们已经确定了要比较的类型就是 Student 类型所以不用泛型 E。</p>
<p>比较方法重写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">    <span class="comment">// 指定排序的规则</span></span><br><span class="line">    <span class="comment">// 只看年龄，我想要按照年龄的升序进行排列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getAge() - o.getAge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以排序了。当然也可以自己修改逻辑规则比如先按照姓名字符串排序，相等的话再按年龄……</p>
<p>排序的话只重写 compareTo 就可以了，不需要重写 hashCode 和 equals 方法。这两个方法是用于 HashSet 的。</p>
<p>排序结构是红黑树。</p>
<p>第二种排序方式：</p>
<p>创建集合对象的时候，传递比较器进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求：请自行选择比较器排序和自然排序两种方式；</span></span><br><span class="line"><span class="comment">要求：存入四个字符串 “c”, “ab”, “df”, “qwer”</span></span><br><span class="line"><span class="comment">按照长度排序，如果一样长则按照首字母排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">采取第二种排序方式：比较器排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建集合</span></span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 按照长度排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> o1.length() - o2.length();</span><br><span class="line">        <span class="comment">// 如果一样长则按字母顺序</span></span><br><span class="line">        i = i == <span class="number">0</span> ? o1.compareTo(o2) : i;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者 lambda 表达式：</span></span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 按照长度排序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> o1.length() - o2.length();</span><br><span class="line">    <span class="comment">// 如果一样长则按照首字母排序</span></span><br><span class="line">    i = i == <span class="number">0</span> ? o1.compareTo(o2) : i;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Comparator 优先级高于 compareTo，对于 Integer 和 String java 已经定义好 compareTo 的情况我们又不想修改源码，就可以使用 Comparator 来重新设置排序方法。</p>
<h2 id="List-Set-集合使用场景总结"><a href="#List-Set-集合使用场景总结" class="headerlink" title="List Set 集合使用场景总结"></a>List Set 集合使用场景总结</h2><p>ArrayList：元素可重复，随机存取。</p>
<p>LinkedList：元素可重复，且增删操作数量明显多于查询。</p>
<p>HashSet：对集合中的元素去重。</p>
<p>LinkedHashSet：去重，而且保证存取顺序。</p>
<p>TreeSet：去重，且排序。</p>
<p><em>后续也可以使用 List + 排序方法实现排序。</em></p>
<h2 id="Map-双列集合"><a href="#Map-双列集合" class="headerlink" title="Map 双列集合"></a>Map 双列集合</h2><p>双列指的是键值对，添加一条数据需要同时添加键和值两个数据。键不能重复。键和值一一对应。在 Java 中键值对整体被称作”Entry 对象“。</p>
<p>Set 的底层源码都和 Map 有关。</p>
<p>Map 常用 API 一览：</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>V put(K key, V value)</code></td>
<td>添加元素. 默认返回 null，如果该键已经存在则会覆盖旧值，返回旧值</td>
</tr>
<tr>
<td><code>V remove(Object key)</code></td>
<td>根据键删除键值对元素</td>
</tr>
<tr>
<td><code>void clear()</code></td>
<td>移除所有的键值对元素</td>
</tr>
<tr>
<td><code>boolean containsKey(Object key)</code></td>
<td>判断集合是否包含指定的键</td>
</tr>
<tr>
<td><code>boolean containsValue(Object value)</code></td>
<td>判断集合是否包含指定的值</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code></td>
<td>判断集合是否为空</td>
</tr>
<tr>
<td><code>int size()</code></td>
<td>集合的长度，即键值对的个数</td>
</tr>
</tbody></table>
<p>和集合有些区别，比如 add 变成了 put，contains 变得复杂了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Contact Me
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://jingqing3948.github.io/2022/05/02/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Java/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/05/12/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E9%A1%B9%E7%9B%AE%EF%BC%9AWeb%20%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%20%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%87%E7%82%B9%E5%9C%B0%E5%9B%BE/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            北邮国院项目：Web 开发实践 小程序标点地图
          
        </div>
      </a>
    
    
      <a href="/2021/10/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AData%20Structure%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">北邮国院笔记：Data Structure 数据结构</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=1357960253&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>