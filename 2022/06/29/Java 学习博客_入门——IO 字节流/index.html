<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> | Jingqing3948 的博客</title><script>var config = </script><script>window.onload = ()=>{};</script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.4.0/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Jingqing3948 的博客" type="application/atom+xml">
</head><body style="background-image:url(https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg);"><div id="cursor-container"><div id="cursor-outer"></div><div id="cursor-effect"></div></div><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1></h1><div id="post-info"><span>First Post:<div style="display:inline-block;width:90px"><time datetime="2022-06-29T02:49:50.632Z" id="date"> 2022-06-29</time></div></span><br><span>Last Update:<div style="display:inline-block;width:90px"><time datetime="2022-05-23T18:56:52.903Z" id="updated"> 2022-05-24</time></div></span></div></div><hr><div id="post-content"><h1 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h1><p>在 java.io 包下。</p>
<p>File 是文件和目录（文件夹）的路径名的抽象表示。</p>
<h2 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h2><p>绝对路径是完整的路径名，不需要其他信息就能定位其所表示的文件。如<code>D:\\文件夹\\java.txt</code>。</p>
<p>相对路径：必须使用取自其他路径名的信息进行解释。如从源文件目录下开始写：<code>myFile\\java.txt</code>。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>File(String pathname)</td>
<td>通过将给定的路径名字符串转换为抽象路径名创建对象</td>
</tr>
<tr>
<td>File(String parent, String child)</td>
<td>父子两个路径名字符串</td>
</tr>
<tr>
<td>File(File parent, String child)</td>
<td></td>
</tr>
</tbody></table>
<p>路径形如：<code>D:\\文件夹\\java.txt</code>。也可以拆分成父<code>D:\\文件夹</code>和子<code>java.txt</code>。也可以第一个 File 对象的路径是<code>D:\\文件夹</code>，子 File 补充<code>java.txt</code>。</p>
<p>如果直接输出 File 类型，会得到路径。说明 File 类重写了 toString 方法。</p>
<h2 id="创建功能"><a href="#创建功能" class="headerlink" title="创建功能"></a>创建功能</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile()</td>
<td>若此文件名的文件不存在，则创建一个空的</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>创建目录</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>创建目录，包括任何必须的父目录</td>
</tr>
</tbody></table>
<p>创建成功返回 true，创建失败（如已存在）返回 false。</p>
<p>如果调错方法了，可能会创建一个名为 java.txt 的文件夹！一定要正确使用创建文件的方法。</p>
<h2 id="创建获取功能"><a href="#创建获取功能" class="headerlink" title="创建获取功能"></a>创建获取功能</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isDirectory()</td>
<td>是否是个目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>是否是个文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>是否存在</td>
</tr>
<tr>
<td>public String getAbsolutePath()</td>
<td>获取其绝对路径</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>获取其相对路径</td>
</tr>
<tr>
<td>public String getName()</td>
<td>获取该文件或目录名</td>
</tr>
<tr>
<td>public String[] list()</td>
<td>返回此抽象路径名表示的<strong>目录</strong>中的所有文件和目录的名称字符串数组</td>
</tr>
<tr>
<td>public File[] listFiles()</td>
<td>返回此抽象路径名表示的<strong>目录</strong>中的文件和目录的 File 对象数组</td>
</tr>
</tbody></table>
<h2 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h2><p>public boolean delete()</p>
<p>如果目录中有内容，不能直接删目录。要先删空内容。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>)+f(n-<span class="hljs-number">2</span>);<span class="hljs-comment">//斐波那契数列</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果未能跳出递归，方法不断压入堆栈空间，导致内存溢出。</p>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><p>IO 表示输入输出，流是对数据传输的统称。</p>
<p>常见应用：文件复制、上传、下载。</p>
<p>分为字节、字符两种数据类型的输入、输出流。（如果通过记事本打开，你看的懂内容，就是字符流；如果一串乱码，就是字节流）</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>java.io.InputStream，抽象类，是所有输入字节流的类的超类。</p>
<p>java.io.OutputStream，抽象类，是所有输出字节流的类的超类。</p>
<p>子类名称都是以父类作为后缀。</p>
<h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>数据写入 Stream。</p>
<p><strong>使用时需要抛出异常，main() throws FileNotFoundException。</strong></p>
<ol>
<li><p>创建字节输出流对象</p>
<p>FileOutputStream(String name) 创建文件输出流，以指定的名称写入文件。name 是路径。如果没有该文件，会创建一个。</p>
<ol>
<li>检查有无该文件，若没有自动创建；</li>
<li>创建 FileOutputStream 对象；</li>
<li>FileOutputStream 对象指向该文件。</li>
</ol>
</li>
<li><p>调用写数据方法</p>
<p>写入： void write(int b)。如b=97，就会写入一个字母a。</p>
<p>void write(byte[] b) 将 b.length 字节从指定的字节数组中写入此文件输入流。（可以通过 String.getBytes() 方法获取字符串对应的字节数组）</p>
<p>void write(byte[] b, int off, int len) 将从指定偏移量开始处指定长度的字节写入。</p>
</li>
<li><p>释放资源</p>
<p><strong>使用完后要 close()！</strong>关闭该文件输出流并释放相关系统资源。</p>
</li>
</ol>
<p><em>1. 想添加换行内容就在字符串里加 \n 即可。但是 windows 中的换行是 \r\n，Linux 中的是 \n，Mac 中的是 \r.而 idea 直接打开文本文档，则这几种类型的换行都能识别。</em></p>
<p><em>2. 这种写法每次运行，不是在文档尾追加写入，而是覆盖。想要追加写入，就在创建 FileOutputStream 对象时加一个 boolean 类型的 append 的 true 值：FileOutputStream(String s, boolean append)，就表示追加写入。</em></p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>异常类： IOException</p>
<p>finally: 在异常处理时提供 finally 执行所有清除操作。其中的内容一定会执行，除非虚拟机退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream f=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">catch</span>()&#123;<br>    <br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-comment">//执行清除操作</span><br>    <span class="hljs-keyword">if</span>(f!=<span class="hljs-literal">null</span>)f.close();<span class="hljs-comment">//这里可能还会生成一个 try catch</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><ol>
<li><p>创建字节输入流对象</p>
<p>构造方法： FileInputStream(File 或 String)</p>
<ol>
<li>检查有无该文件，若没有自动创建；</li>
<li>创建 FileOutputStream 对象；</li>
<li>FileOutputStream 对象指向该文件。</li>
</ol>
</li>
<li><p>调用读数据方法</p>
<p>int read() 读取第一个数据。如果到达文档末尾，返回-1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>((by=f.read())!=-<span class="hljs-number">1</span>)&#123;<br>    System.out.println((<span class="hljs-type">char</span>)by);<br>&#125;<span class="hljs-comment">//读取文件中所有内容，包括换行符</span><br></code></pre></td></tr></table></figure>

<p>int read(byte[] b)返回读入缓冲区的字节总数。如果到达文档末尾，返回-1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-comment">//一次读取一个字节数组</span><br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>((len=fis.read(bys))!=-<span class="hljs-number">1</span>)&#123;<br>    System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bys,<span class="hljs-number">0</span>,len));<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>释放资源</p>
</li>
</ol>
<h4 id="复制文本文档"><a href="#复制文本文档" class="headerlink" title="复制文本文档"></a>复制文本文档</h4><p>写一个循环，读取复制文件中每个字节的同时，将每个字节写入粘贴文件中。</p>
<h3 id="复制图像"><a href="#复制图像" class="headerlink" title="复制图像"></a>复制图像</h3><p>复制图像：建议一次读取/写入一个字节数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">FileInputStream fis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;要复制的图片路径\\文件名&quot;</span>);<br>FileOutputStream fos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;要粘贴的文件路径\\文件名&quot;</span>);<br><span class="hljs-type">byte</span>[] bys=<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>((len=fis.read(bys))!=-<span class="hljs-number">1</span>)<br>&#123;<br>    fos.write(bys);<br>&#125;<br>fis.close();<br>fos.close();<br></code></pre></td></tr></table></figure>

<h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>java.io.BufferedOutputStream</p>
<p>之前 FileOutputStream 每次写入都会导致底层系统的调用，而字节缓冲流可以直接向底层输出流写入字节。实现时间更短。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">BufferedOutputStream bos=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>));<br><span class="hljs-comment">//读写数据方法和之前一样。但是还得靠 File</span><br>bos.write(<span class="hljs-string">&quot;String&quot;</span>.getBytes());<br><span class="hljs-comment">//记得释放资源</span><br>bos.close();<br><br>BufferedInputStream bis=<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>));<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span>((len=bis.read(bys)!=-<span class="hljs-number">1</span>))&#123;<br>    System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bys,<span class="hljs-number">0</span>,len));<br>&#125;<br></code></pre></td></tr></table></figure>



<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div id="footer-link" style="right: calc(50% - 1px);order: 1;border-right: 1px solid #fe2;padding-left: unset;max-width: calc(50% - 4px);"><a href="/2022/06/29/Java%20%E5%AD%A6%E4%B9%A0%E5%8D%9A%E5%AE%A2_%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94IO%20%E5%AD%97%E7%AC%A6%E6%B5%81/">← Next </a></div><div id="footer-link" style="left: 50%;order: 0;border-left: 1px solid #fe2;padding-right: unset;max-width: calc(50% - 5px);"><a href="/2022/06/29/Java%20%E5%AD%A6%E4%B9%A0%E6%92%AD%E5%AE%A2_%20%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%20GUI_1/"> Prev →</a></div></div></div><details id="reward"><summary>打赏</summary><div id="alipay"><span>支付宝 | Alipay</span><br><img src="/img/Alipay.png"></div><div id="wechat"><span>微信 | WeChat</span><br><img src="/img/WeChat.png"></div></details></div><div id="bottom-btn"><a id="to-top" onClick="index.scrolltop();" title="to top">∧</a></div></article><div class="aside-box"><aside><div id="aside-top"><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">Jing Qing</a></h1><div id="description"><p></p></div><!--if page.published === undefined--><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">48</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">3</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">10</span></div></section></div><div id="aside-block"><h1>INDEX</h1><div id="toc-div"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#File-%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.</span> <span class="toc-text">绝对路径和相对路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.</span> <span class="toc-text">创建功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.</span> <span class="toc-text">创建获取功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">1.5.</span> <span class="toc-text">删除功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.6.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">2.1.1.</span> <span class="toc-text">FileOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">异常处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileInputStream"><span class="toc-number">2.2.</span> <span class="toc-text">FileInputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">复制文本文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%9B%BE%E5%83%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">复制图像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text">字节缓冲流</span></a></li></ol></li></ol></div></div></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><br><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><br><text>published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></text><text> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight</a></text><wbr><text>by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></text></footer></aside></div><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="//unpkg.com/@highlightjs/cdn-assets@11.4.0/highlight.min.js"></script></main></body></html>