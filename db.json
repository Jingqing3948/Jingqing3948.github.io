{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-arknights/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/README.md","path":"README.md","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/cursor-inner.png","path":"cursor-inner.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/css/arknights.css","path":"css/arknights.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/css/arknights.sass","path":"css/arknights.sass","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/css/orz.txt","path":"css/orz.txt","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/img/Alipay.png","path":"img/Alipay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/img/WeChat.png","path":"img/WeChat.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/img/bk.jpg","path":"img/bk.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/font/BenderLight.ttf","path":"font/BenderLight.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/font/JetBrainsMono-Regular.woff2","path":"font/JetBrainsMono-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/js/arknights.js","path":"js/arknights.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/js/arknights.ts","path":"js/arknights.ts","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-arknights/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/新建文本文档.txt","hash":"acaa0e897a717af5e634670c92e29d6ac7b7ec7e","modified":1645804482685},{"_id":"source/_posts/hello-world.md","hash":"bed95b53864595048aa43274024706b21c597c30","modified":1645886753870},{"_id":"source/_posts/大一C语言大作业 函数动画.md","hash":"1ed4668b5b1459a498ac8d150ddf7219babb6d2a","modified":1650252986046},{"_id":"themes/hexo-theme-arknights/.editorconfig","hash":"57f50fc69fdc98a28c9bb04c338865a8b267b4bc","modified":1645794356529},{"_id":"themes/hexo-theme-arknights/LICENSE","hash":"438ccc3597948b7577b003ccff330f40f8e9987b","modified":1645794356529},{"_id":"themes/hexo-theme-arknights/.gitignore","hash":"213618a702e4a2029e93c53f893d973a57bc593f","modified":1645794356529},{"_id":"themes/hexo-theme-arknights/README-Ja.md","hash":"9483798d80ff263072b5b510cb4ccf8334cbd9d6","modified":1645794356530},{"_id":"themes/hexo-theme-arknights/_config.yml","hash":"3b28666b15de640438333897f5585d81d75a93c7","modified":1645794356530},{"_id":"themes/hexo-theme-arknights/README.md","hash":"7ea2e5933cf4c82a512c5141d401f5bb88702096","modified":1645794356530},{"_id":"themes/hexo-theme-arknights/package.json","hash":"4c53ad02822158ee63684bb60a5486e021838824","modified":1645794356534},{"_id":"themes/hexo-theme-arknights/layout/archive.pug","hash":"418aeceb34be64890250ed6e56ee3f9c3cc77151","modified":1645794356532},{"_id":"themes/hexo-theme-arknights/layout/category.pug","hash":"ce359c7c25abbcbd8e7f057f9a0a60e30c66ee53","modified":1645794356532},{"_id":"themes/hexo-theme-arknights/layout/index.pug","hash":"56b7ed9b68646c865797fa17319fc2a48c3a1350","modified":1645794356533},{"_id":"themes/hexo-theme-arknights/layout/page.pug","hash":"6777ef19665cc9b7d974ad26fc7e392980cd8c85","modified":1645794356533},{"_id":"themes/hexo-theme-arknights/layout/tag.pug","hash":"70032991a6232156da02567dc7e793e3033069c4","modified":1645794356533},{"_id":"themes/hexo-theme-arknights/layout/post.pug","hash":"20d65034f2000d4b598380c7ab74053dcebfd39c","modified":1645794356533},{"_id":"themes/hexo-theme-arknights/source/404.html","hash":"526399fe5be55ed75ae9fea90e7b2e38658fc55a","modified":1645794356534},{"_id":"themes/hexo-theme-arknights/source/README.md","hash":"b16955f9769cf1a2a8dd06137939a0ab61db379c","modified":1645794356535},{"_id":"themes/hexo-theme-arknights/source/CNAME","hash":"bdbbd81fa4b69a523c7ac18567a8f68978babcf9","modified":1645794356534},{"_id":"themes/hexo-theme-arknights/source/favicon.ico","hash":"10adaea9ed613e955bf761962db4af2931cf97ee","modified":1645794356540},{"_id":"themes/hexo-theme-arknights/source/cursor-inner.png","hash":"aec3f5d5924c8fa1abe503c59dc42ffa80b3afe7","modified":1645794356540},{"_id":"themes/hexo-theme-arknights/layout/includes/layout.pug","hash":"48f179b80dc69bf40b758436203c436d5aede57f","modified":1645794356532},{"_id":"themes/hexo-theme-arknights/layout/includes/recent-posts.pug","hash":"c26a4212fc729f988286bca9298159be69f8dcb4","modified":1645794356532},{"_id":"themes/hexo-theme-arknights/source/css/arknights.css","hash":"a3c9a039319af12360cef97b2f18f8c91dfa141e","modified":1645794356535},{"_id":"themes/hexo-theme-arknights/source/css/arknights.sass","hash":"ff85bdadc687354f9938fd9ba15fdf4c85f3af85","modified":1645794356535},{"_id":"themes/hexo-theme-arknights/source/css/gitalk.css","hash":"3712d4a175831b43a89c1b4e55f2d9eb87a0b3b3","modified":1645794356536},{"_id":"themes/hexo-theme-arknights/source/css/orz.txt","hash":"f2e3aeb7c5f7cefc07fcd6e749538134dbee7fa9","modified":1645794356536},{"_id":"themes/hexo-theme-arknights/source/img/Alipay.png","hash":"d0d388f8b3c98a0f229acec14e638093152e0b08","modified":1646128150458},{"_id":"themes/hexo-theme-arknights/source/img/bg.jpg","hash":"463cfbcfd68886be8564a532c38cb32d180edba4","modified":1645794356544},{"_id":"themes/hexo-theme-arknights/source/img/WeChat.png","hash":"c2d22c30cf4b4a2a7256656f0b4cfb7e7cc35d17","modified":1646128119570},{"_id":"themes/hexo-theme-arknights/source/img/logo.png","hash":"50cb3653f6406b4e936aa0ba21dc573928016a94","modified":1645794356549},{"_id":"themes/hexo-theme-arknights/source/font/JetBrainsMono-Regular.woff2","hash":"23f70e45de896a9e12798db1d1f1ce5197f33ca4","modified":1645794356542},{"_id":"themes/hexo-theme-arknights/source/js/arknights.ts","hash":"b35e8ba353d2e4b453f49411e3291c7eee2fb0b4","modified":1645794356550},{"_id":"themes/hexo-theme-arknights/source/js/arknights.js","hash":"d649a464cd50cbcb44929254a8eb74ebb29c7363","modified":1645794356550},{"_id":"themes/hexo-theme-arknights/source/js/search.js","hash":"621b44d8f023c723130cfeae25179641e36867a4","modified":1645794356555},{"_id":"themes/hexo-theme-arknights/source/css/sass/_class_style.sass","hash":"b3d3642e8036802b5cf23d6613fcf0b4b177c171","modified":1645794356537},{"_id":"themes/hexo-theme-arknights/source/css/sass/_flex_layout.sass","hash":"b70d52bf9baaf3713aa7a47149d94651885a83f6","modified":1645794356537},{"_id":"themes/hexo-theme-arknights/source/css/sass/_base_style.sass","hash":"eda9b66e448a570b9ded04b6712626c98962bab6","modified":1645794356536},{"_id":"themes/hexo-theme-arknights/source/css/sass/_font.sass","hash":"34af1a0ada35d1c68c419156a17d33d084fca3d4","modified":1645794356537},{"_id":"themes/hexo-theme-arknights/source/css/sass/_search.sass","hash":"f5300af0f922f635dfba98cc8af3646896d98c0b","modified":1645794356538},{"_id":"themes/hexo-theme-arknights/source/css/sass/layout/__main.sass","hash":"aae8630f0dfb52d0c2f4b6fcb404ea934f41aeac","modified":1645794356538},{"_id":"themes/hexo-theme-arknights/source/css/sass/layout/__main_article.sass","hash":"96ff9af5a32b04f8e33217317d4fd2044c793b0a","modified":1645794356538},{"_id":"themes/hexo-theme-arknights/source/css/sass/layout/__main_aside.sass","hash":"f012df1067637c1b794712fa140acbfcfcbf1331","modified":1645794356539},{"_id":"themes/hexo-theme-arknights/source/css/sass/layout/_post.sass","hash":"5554d2ab7fa0aa4b4a57d1caf6c8b10b43746578","modified":1645794356539},{"_id":"themes/hexo-theme-arknights/source/css/sass/layout/_archive.sass","hash":"c4c25086e218e3c535435d126acff3d287755473","modified":1645794356539},{"_id":"themes/hexo-theme-arknights/support.jpg","hash":"9ca7c5e40123bc51da82f3a01d13c32ab2b5edc3","modified":1645794356556},{"_id":"themes/hexo-theme-arknights/source/font/BenderLight.ttf","hash":"5b500dbf6f2b95adff8861c76692562d70ca7b14","modified":1645794356541},{"_id":"themes/hexo-theme-arknights/demo.png","hash":"381cacd14c50017155067930b33ece892c27cd32","modified":1645794356531},{"_id":"themes/hexo-theme-arknights/source/js/gitalk.js","hash":"aef1ac4b42ebefaafe34707b68386484aad7d325","modified":1645794356554},{"_id":"themes/hexo-theme-arknights/source/img/bk.jpg","hash":"2146714c7429ca673a38469e7f74a412dc0ef09e","modified":1645794356549},{"_id":"public/atom.xml","hash":"eb75aa855ecf6a6646c33c616fc85c34e9c87720","modified":1652027257964},{"_id":"public/sitemap.xml","hash":"82a9719c50c0ec6d4177aa94737e5677c1c194b8","modified":1652027257964},{"_id":"public/2022/02/25/hello-world/index.html","hash":"2ae6ba2ef912e0703bd3a4a650f9fc733a3955ba","modified":1645869623706},{"_id":"public/archives/index.html","hash":"0e019fff0c726500eaf440c38e6cc30a0c76935b","modified":1652027257964},{"_id":"public/archives/2022/index.html","hash":"f69c8b5161f9de043e3f88c69d1ffb49bca522fb","modified":1652027257964},{"_id":"public/archives/2022/02/index.html","hash":"4562f285387cc0f1931ac074264d826fc6d09b14","modified":1652027257964},{"_id":"public/index.html","hash":"a15ac86c0bd65a5d3fcb2adc2455bd748886ef63","modified":1652027257964},{"_id":"public/2022/02/25/大一C语言大作业 函数动画/index.html","hash":"fa71c12b494cadbdc43063dd4873e5e89336568d","modified":1652027257964},{"_id":"public/css/arknights.sass","hash":"ff85bdadc687354f9938fd9ba15fdf4c85f3af85","modified":1645805549124},{"_id":"public/新建文本文档.txt","hash":"acaa0e897a717af5e634670c92e29d6ac7b7ec7e","modified":1645805549124},{"_id":"public/css/orz.txt","hash":"f2e3aeb7c5f7cefc07fcd6e749538134dbee7fa9","modified":1645805549124},{"_id":"public/img/Alipay.png","hash":"529d851d55de77e40cedf39620e34be11e3fd710","modified":1645805549124},{"_id":"public/img/WeChat.png","hash":"46b03d7f8800e6b9c4bb47a37ab7afadd798706f","modified":1645805549124},{"_id":"public/cursor-inner.png","hash":"aec3f5d5924c8fa1abe503c59dc42ffa80b3afe7","modified":1645805549124},{"_id":"public/CNAME","hash":"bdbbd81fa4b69a523c7ac18567a8f68978babcf9","modified":1645805549124},{"_id":"public/favicon.ico","hash":"10adaea9ed613e955bf761962db4af2931cf97ee","modified":1645805549124},{"_id":"public/img/bg.jpg","hash":"463cfbcfd68886be8564a532c38cb32d180edba4","modified":1645805549124},{"_id":"public/img/logo.png","hash":"50cb3653f6406b4e936aa0ba21dc573928016a94","modified":1645805549124},{"_id":"public/js/arknights.ts","hash":"b35e8ba353d2e4b453f49411e3291c7eee2fb0b4","modified":1645805549124},{"_id":"public/font/JetBrainsMono-Regular.woff2","hash":"23f70e45de896a9e12798db1d1f1ce5197f33ca4","modified":1645805549124},{"_id":"public/font/BenderLight.ttf","hash":"5b500dbf6f2b95adff8861c76692562d70ca7b14","modified":1645805549124},{"_id":"public/404.html","hash":"72ac49fc2b61ad4fac410e856852f1d7bf1628d8","modified":1645805549124},{"_id":"public/README.html","hash":"16c7c0b44736434dfc0026fb83b67b6a4898aab0","modified":1645805549124},{"_id":"public/css/gitalk.css","hash":"758bdeb5fcc89b850ba8885fec65397fb7db044b","modified":1645805549124},{"_id":"public/js/arknights.js","hash":"d649a464cd50cbcb44929254a8eb74ebb29c7363","modified":1645805549124},{"_id":"public/js/search.js","hash":"94a621627e8445fca6e1d41be1b9923675fa56a1","modified":1645805549124},{"_id":"public/css/arknights.css","hash":"c3dcb562e669b1825b3051855112c7b2f07efd16","modified":1645805549124},{"_id":"public/js/gitalk.js","hash":"8a190691362a21a145e35bff693058bbc5c33e3e","modified":1645805549124},{"_id":"public/img/bk.jpg","hash":"2146714c7429ca673a38469e7f74a412dc0ef09e","modified":1645805549124},{"_id":"source/CNAME","hash":"acaa0e897a717af5e634670c92e29d6ac7b7ec7e","modified":1645804482685},{"_id":"source/_posts/大一C语言大作业 五子棋（总结）.md","hash":"4b9b83b6b345fa54a4765ea29a4fcd22ba7f05ad","modified":1650252965639},{"_id":"public/2022/02/26/大一C语言大作业 五子棋（总结）/index.html","hash":"e0fcaa3c98afd71ce6692ba645997986aea33bb3","modified":1652027257964},{"_id":"public/2022/02/24/hello-world/index.html","hash":"d0879d71e3a829bcccfdf180b6a6ed186e646e54","modified":1652027257964},{"_id":"public/categories/homework/index.html","hash":"8117f341878ae57b57ab756499612c6e32ec35cd","modified":1650252585820},{"_id":"public/tags/code/index.html","hash":"0f102a3c612d19f37342cfbb4884e0cbdcd3492b","modified":1650252585820},{"_id":"source/_posts/gets()和scanf()处理空白字符的问题.md","hash":"58fed00d67b73c8ae74e1bcdd74c84ff3809389e","modified":1650253020729},{"_id":"source/_posts/结构体指针在函数中的应用.md","hash":"a1ed5436f382ce8c56d53e2607d2b6d1abb2104e","modified":1650252998917},{"_id":"public/2022/02/26/gets()和scanf()处理空白字符的问题/index.html","hash":"8c9cb979b4d9fa5c70b899af54a4ed8b63a478ba","modified":1651223958588},{"_id":"public/2022/02/26/结构体指针在函数中的应用/index.html","hash":"5b59e9c9fc354e5f8804e51390eaabfa5f7db35c","modified":1651223958588},{"_id":"public/categories/problems/index.html","hash":"f776b3562d4a8720f2d5bf3817349951472a97b7","modified":1650252585820},{"_id":"source/_posts/大二C语言大作业 订餐系统.md","hash":"d4acc81919418c877e3348ccf6fa2eaceb8c658f","modified":1645891078569},{"_id":"source/_posts/大二C语言大作业 订餐系统（总结）.md","hash":"06a0ad524e653e546df420af3ebe2c8eec911394","modified":1650252977718},{"_id":"public/2022/02/27/大二C语言大作业 订餐系统（总结）/index.html","hash":"95fbdd09742bf003f7dfd41f65ddda808b9ed6f2","modified":1652027257964},{"_id":"source/_posts/微信开发者工具和gitee实现多人协作.md","hash":"c46ce645616dda20a9905e177aec0a56d24df59a","modified":1650253006885},{"_id":"public/2022/03/27/微信开发者工具和gitee实现多人协作/index.html","hash":"d0689f4d23b22a125f3c28b96b34409a9056b8f7","modified":1652027257964},{"_id":"public/archives/2022/03/index.html","hash":"f4731a0cb6e9f20f45fd5e39a35ff3f3c13d1e19","modified":1652027257964},{"_id":"public/tags/projects/index.html","hash":"6d7123aa02792167bdb19eca9c59f54a013548e2","modified":1650252585820},{"_id":"source/_posts/Java(1).md","hash":"6ec14300679efd9043f1ea80d3d7a25d3d30cb70","modified":1649870462665},{"_id":"source/_posts/Java 学习博客_1 介绍与安装.md","hash":"58a6c4918fd9c271748043759d64968b1a041154","modified":1650253031098},{"_id":"source/_posts/Java 学习博客_2 入门——基础语法.md","hash":"80c5475b33bbefddd9980fc775d5a69ea2aa726c","modified":1651736979831},{"_id":"public/2022/04/14/Java 学习博客_2 入门——基础语法/index.html","hash":"6ec136fbb0171463cd94660c24a99ec47f0f687e","modified":1652027257964},{"_id":"public/2022/04/14/Java 学习博客_1 介绍与安装/index.html","hash":"27e4ae3e13badcad0bc2d2dd7d32ba1fad42b975","modified":1652027257964},{"_id":"public/archives/2022/04/index.html","hash":"3b5d0d20466c4b1a6541e0643d37f08f28b21d33","modified":1652027257964},{"_id":"public/categories/study/index.html","hash":"1dcde4fa0cb4e086d06c292db3ad37b51b66697c","modified":1650252585820},{"_id":"source/_posts/ER 和 EER 模型.md","hash":"ca0d3455581fa90278e5f08e873be7399db3e80a","modified":1650528084456},{"_id":"source/_posts/Mysql Command Line Client 的使用，及常用命令.md","hash":"fd118b5b858eed8c8c068c5bd3feaa73a5dc7f96","modified":1651457299037},{"_id":"public/2022/04/18/Mysql Command Line Client 的使用，及常用命令/index.html","hash":"d696187efbe2c57fa0ec369626d4d5552f28320a","modified":1652027257964},{"_id":"public/2022/04/18/ER 和 EER 模型/index.html","hash":"b3a7fb913c2542feaf51f201a5b908922dfc6476","modified":1651223958588},{"_id":"public/categories/database/index.html","hash":"8ebda8c90d82ae7d715c57fa5f15734b530b668e","modified":1652027257964},{"_id":"public/categories/java/index.html","hash":"6f6c16fc316112d46492209c3bf5f284ea8887ec","modified":1652027257964},{"_id":"public/categories/clanguage/index.html","hash":"6009b65cd29121904de514a6b15a13756878c1a6","modified":1652027257964},{"_id":"public/categories/tools/index.html","hash":"d4077778fcb2d4f2136ef30f249e569b5ff56819","modified":1651424093742},{"_id":"public/categories/course/index.html","hash":"8591e86f4a9948f2763d6a0b5b4b8ae0a99c191b","modified":1652027257964},{"_id":"public/categories/projects/index.html","hash":"872d57962edc85885ba6684e2d1e9db0a8b2b0ef","modified":1652027257964},{"_id":"public/archives/page/2/index.html","hash":"6d64308c56bcedfeac26ff09477c413f8585b1ba","modified":1652027257964},{"_id":"public/archives/2022/page/2/index.html","hash":"e6554a6df5b8231de19e2f65d24f2e129c398ee5","modified":1652027257964},{"_id":"public/page/2/index.html","hash":"364e2675b1025198c744e9f06405cb6cccaf5205","modified":1652027257964},{"_id":"public/tags/problems/index.html","hash":"329910c511f1038f57bb0e353536b9651d647e9a","modified":1652027257964},{"_id":"public/tags/study/index.html","hash":"fafe9422ec330eb255a2108d9d846addade74a98","modified":1652027257964},{"_id":"public/tags/homework/index.html","hash":"8e5a056b265a79d021e05b11de8e9d0fa7a34cda","modified":1652027257964},{"_id":"source/_posts/SQL 语句——DDL.md","hash":"c8c09274d09e2f58c2da375a915c952ea13dcbae","modified":1650643897245},{"_id":"public/2022/04/19/SQL 语句——DDL/index.html","hash":"b7c67ec09ec15b4ce7c900372c3961c44fc11105","modified":1652027257964},{"_id":"source/_posts/SQL 语句——DML.md","hash":"945b2d66b31f001a9ec55ab56ab02db5f522d310","modified":1650943592253},{"_id":"public/2022/04/20/SQL 语句——DML/index.html","hash":"f1aa689349c4630427c8cf887aabfca8c94dc7c8","modified":1650687966551},{"_id":"source/_posts/Mysql 数据类型.md","hash":"26760b57f232e19edec5f594c5ae156b5acdb44b","modified":1650943592251},{"_id":"public/2022/04/23/SQL 语句——DML/index.html","hash":"b961267d3613587d9f2c15da9db5103341f9baa6","modified":1652027257964},{"_id":"public/2022/04/19/Mysql 数据类型/index.html","hash":"4cb81e456678047aabf4a8f8497ffdbfe9de760f","modified":1652027257964},{"_id":"source/_posts/SQL 语句——DCL.md","hash":"5d400e8ef262e0768245076989bc401bebae90ab","modified":1650961341479},{"_id":"public/2022/04/26/SQL 语句——DCL/index.html","hash":"eaa32580acd6dba8ac905f2a5676c73a0a3b188b","modified":1652027257964},{"_id":"source/_posts/SQL 语句——DQL.md","hash":"cc468c9428b9ca6eadf00f24118454bf195da469","modified":1651720326937},{"_id":"public/2022/04/25/SQL 语句——DQL/index.html","hash":"8181bdf2c843128f2a2dff206b67bf139299bc4c","modified":1652027257964},{"_id":"source/_posts/Python——语法基础1.md","hash":"bae66eeca5ec7c3950672bf84e3116cee23661f9","modified":1651146291361},{"_id":"public/categories/Python/index.html","hash":"de7795ca506104f2be3dab26c9ffd8e89c4efecd","modified":1652027257964},{"_id":"public/2022/04/28/Python——语法基础1/index.html","hash":"0472a8a501fb54a1f4f80aa792b5763f04d6f958","modified":1652027257964},{"_id":"source/_posts/Java 学习博客_3 入门——基础语法.md","hash":"5553328e60093804c9450555ffc0ee91215d8203","modified":1651223598957},{"_id":"public/archives/2022/04/page/2/index.html","hash":"d592a85128d5f169b0fb52321a576ed28d3051ed","modified":1652027257964},{"_id":"public/2022/04/29/Java 学习博客_3 入门——基础语法/index.html","hash":"8c05cceda90d16c94cf229efbf9c758869fd4c95","modified":1652027257964},{"_id":"source/_posts/C gets()和scanf()处理空白字符的问题.md","hash":"0893a010b5e7a3651b48ef08ea3b1bffa0d2e195","modified":1651423923072},{"_id":"source/_posts/C 结构体指针在函数中的应用问题.md","hash":"976f7b687e57b29e5610ea0fd253e9daafae6332","modified":1651423988748},{"_id":"source/_posts/Git_1 版本控制介绍.md","hash":"a96e314adf94226104c990a3ce3638708376b907","modified":1651423551490},{"_id":"source/_posts/Java 学习博客_10 入门——抽象类、抽象方法、接口.md","hash":"8d53db0bc01aaae3bd2dc59f8b8ad385d59ac78f","modified":1651423835968},{"_id":"source/_posts/Java 学习博客_4 入门——类和对象.md","hash":"f5c96e41b260ec2994a791583401a8b22e818921","modified":1651423762870},{"_id":"source/_posts/Java 学习博客_6 入门——字符串类.md","hash":"7ed20aa1a8d4c32debced9f4dae6ba60391ab454","modified":1651423777296},{"_id":"source/_posts/Java 学习博客_5 入门——封装.md","hash":"656088463b76b4c8f166658e4b36af8623f9f84f","modified":1651423760454},{"_id":"source/_posts/Java 学习博客_8 入门——继承.md","hash":"ac1abe109589e1e8502424857d7f7e5ad9adbf8e","modified":1651423807142},{"_id":"source/_posts/Java 学习博客_7 入门——集合类.md","hash":"703fe9a732d6ee969a82230f83a1d7ab300cbf40","modified":1651423793751},{"_id":"source/_posts/Java 学习博客_9 入门——多态.md","hash":"c2417dfc7c63cd10a9b7f7ad1566726851631c2e","modified":1651423820885},{"_id":"source/_posts/Mysql ER 和 EER 模型.md","hash":"f13cc13ceebcf6bec53b1426f9e53d2a918a7e72","modified":1651729613987},{"_id":"public/2022/05/02/Git_1 版本控制介绍/index.html","hash":"10487857a63349505409a1e52a82336aeae918d5","modified":1651424093742},{"_id":"public/2022/05/02/Java 学习博客_10 入门——抽象类、抽象方法、接口/index.html","hash":"9efacb9a679aa59848c5a58499d9d3dfb97ba70f","modified":1652027257964},{"_id":"public/2022/05/01/Java 学习博客_9 入门——多态/index.html","hash":"172c5d0907bcdfc68b8dc4643dbb7f6f87330603","modified":1652027257964},{"_id":"public/2022/04/30/Java 学习博客_4 入门——类和对象/index.html","hash":"f5986d9a2fef2f7acf7c1f3ab79442699a35677b","modified":1652027257964},{"_id":"public/2022/04/30/Java 学习博客_5 入门——封装/index.html","hash":"5b719ab2d4e3c87be63bd67edeff91b4452628cf","modified":1652027257964},{"_id":"public/2022/04/30/Java 学习博客_7 入门——集合类/index.html","hash":"79a10668e87ab6a387dc22cc5390519d589902a6","modified":1652027257964},{"_id":"public/2022/04/18/Mysql ER 和 EER 模型/index.html","hash":"6230f38ff2247200a7ac1771996e605308119861","modified":1652027257964},{"_id":"public/2022/02/26/C gets()和scanf()处理空白字符的问题/index.html","hash":"2e25957edf537d8a7057cb3270a6d3a83fe97bef","modified":1652027257964},{"_id":"public/2022/02/26/C 结构体指针在函数中的应用问题/index.html","hash":"6b7ef906cf0ab8c5be63bdc982037dcc2acd8b64","modified":1652027257964},{"_id":"public/categories/git/index.html","hash":"f2c4eddd1440204a139c6bfeb6261e603b7f19f3","modified":1652027257964},{"_id":"public/archives/page/3/index.html","hash":"bb6986792b0fc962dfe64e163a84e8b56884e5b2","modified":1652027257964},{"_id":"public/archives/2022/page/3/index.html","hash":"6d906e6a91f0102fb10f053bc528b63984ed02f3","modified":1652027257964},{"_id":"public/archives/2022/05/index.html","hash":"05fdf63dce173eda70bf8150f15d48a0d609657a","modified":1652027257964},{"_id":"public/page/3/index.html","hash":"6df0a7e608e9caf3c03a339179e123a641f5b148","modified":1652027257964},{"_id":"public/tags/study/page/2/index.html","hash":"2b47e1b7a42dac3983f34947dc2e316157db5a4f","modified":1652027257964},{"_id":"public/2022/05/01/Java 学习博客_8 入门——继承/index.html","hash":"1acb74e54f8ba1b453dedff9cf9ca2876039fcdc","modified":1652027257964},{"_id":"public/2022/04/30/Java 学习博客_6 入门——字符串类/index.html","hash":"6aec46f3c1d90fbd81288edf1cb5117a9b352456","modified":1652027257964},{"_id":"source/_posts/SQL 语句——DQL 例题及注意事项.md","hash":"9701ec727354225d7ca4ee9258bcb8c263090eb3","modified":1651468998879},{"_id":"source/_posts/git_2 命令行添加、提交操作.md","hash":"b8cdc81031c2aca0c521b7df61f0f76e7b29d9fd","modified":1651468595383},{"_id":"source/_posts/git_1 版本控制介绍.md","hash":"e371c4c5b472fe0d6660d19c86120705f011ba28","modified":1651468633167},{"_id":"public/2022/05/02/git_2 命令行添加、提交操作/index.html","hash":"72d8e24f952053547845b06e9b870e809881899b","modified":1652027257964},{"_id":"public/2022/05/02/git_1 版本控制介绍/index.html","hash":"9d07d223e344e4a1184f02b2ae099cea08dfafc6","modified":1652027257964},{"_id":"public/2022/04/25/SQL 语句——DQL 例题及注意事项/index.html","hash":"69e914ce6060f8f78cad4eb0148a3b6824cd5f02","modified":1652027257964},{"_id":"public/categories/mysql/index.html","hash":"8dac79941163f1f20ef29a288922ec7dab89fa17","modified":1652027257964},{"_id":"source/_posts/git_3 版本控制.md","hash":"c04faafba62065aca4a05be04951b1415b3e1377","modified":1651638221174},{"_id":"source/_posts/html css_案例_1 Header.md","hash":"53a0d8f1ed605f54d8596a0977f12c3eacf34a28","modified":1651638247600},{"_id":"public/2022/05/03/git_3 版本控制/index.html","hash":"71e3c466494053d7be3a2ea596cec686ca75d9db","modified":1652027257964},{"_id":"public/2022/05/04/html css_案例_1 Header/index.html","hash":"32e9efd0d7d2489d57fd2c72a5525ca215a9a06b","modified":1652027257964},{"_id":"public/categories/html-css/index.html","hash":"964acd1c2d3092096f41edbd7eb92335b1960883","modified":1652027257964},{"_id":"public/tags/study/page/3/index.html","hash":"8a2db84d42706aec94853ccda803facaebd0678b","modified":1652027257964},{"_id":"source/_posts/Java 学习博客_11 入门——内部类.md","hash":"01454cbed526d6804dab2448c1d5078c75a2fe5c","modified":1651718996316},{"_id":"source/_posts/Java 学习博客_12 入门——常用 API.md","hash":"8d79d45fadff9b581fa70e2880537809a6734ed4","modified":1651719022594},{"_id":"public/2022/05/05/Java 学习博客_11 入门——内部类/index.html","hash":"7e2b0061defa1f0dcf97422e5ec3ddc9e9350b97","modified":1652027257964},{"_id":"public/archives/page/4/index.html","hash":"f2ac966498d7b6eccd865020db4a8d964cbfa981","modified":1652027257964},{"_id":"public/archives/2022/page/4/index.html","hash":"c40b7f38de17d35d713a762bc8870987bd707a3a","modified":1652027257964},{"_id":"public/categories/java/page/2/index.html","hash":"117f913f8539c00410095691ff832f59607aa39d","modified":1652027257964},{"_id":"public/page/4/index.html","hash":"3b63aa06bd15ced949c9e9e20d05d4ba8b45dde8","modified":1652027257964},{"_id":"public/2022/05/05/Java 学习博客_12 入门——常用 API/index.html","hash":"0c53259f972a07bbd1bb517c87aab5dd00d01fd9","modified":1652027257964},{"_id":"source/_posts/Java 学习博客_13 入门——异常.md","hash":"a97d811d4ef88e81417371c68859f201d2de3a8e","modified":1651909910045},{"_id":"public/2022/05/07/Java 学习博客_13 入门——异常/index.html","hash":"e2de0ff606f28de166921da3439a17aeab68e610","modified":1652027257964},{"_id":"source/_posts/Java 学习博客_14 入门——集合进阶1.md","hash":"28ad9fe40e0d9bc852050e952c498b3bbdc406b2","modified":1651989800506},{"_id":"public/2022/05/08/Java 学习博客_14 入门——集合进阶1/index.html","hash":"d4d4e98f68b5981c6ed526b47cde178de6234988","modified":1652027257964},{"_id":"public/archives/2022/05/page/2/index.html","hash":"c1f09712b91890946ff1c7ff34cfa58eaf409ffc","modified":1652027257964},{"_id":"source/_posts/正则表达式_1.md","hash":"0775f440c2a7daa02b06ab43ff5c8b8f13f44b69","modified":1652026892523},{"_id":"public/2022/05/09/正则表达式_1/index.html","hash":"134676aa33f62021f3d149833494ee48aac592a5","modified":1652027257964},{"_id":"public/categories/regex/index.html","hash":"0d42ec6088f6a182f1911f89801ab1f4d33c99bb","modified":1652027257964}],"Category":[{"name":"homework","_id":"cl03y1b0d00013wv2e9xof90f"},{"name":"problems","_id":"cl040g0kv0002r8v2fhkh87ol"},{"name":"study","_id":"cl1xua8el000060v2ahv2033d"},{"name":"database","_id":"cl2462ezy0001cov23z9kghje"},{"name":"java","_id":"cl2462f070004cov2f9020e3s"},{"name":"clanguage","_id":"cl2462f0g000ccov2hjrr11h0"},{"name":"tools","_id":"cl2462f0j000hcov2hcphgv5i"},{"name":"course","_id":"cl2462f0k000mcov26it14oyd"},{"name":"projects","_id":"cl2462f0n000xcov207lw48bg"},{"name":"Python","_id":"cl2ixwnid00012cv27a2o8hjm"},{"name":"git","_id":"cl2nj9ryz0007w0v2ddxzgl4t"},{"name":"mysql","_id":"cl2oa3oue0001p0v2efkf3hm4"},{"name":"html+css","_id":"cl2r2wk5100031gv2deyvhpiu"},{"name":"regex","_id":"cl2xidk2v000164v2ff603h5y"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","date":"2022-02-23T16:00:00.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2022-02-24\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2022-02-26T14:45:53.870Z","_id":"cl02m4pyk0000fsv2d545f9jn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"大一C语言大作业：函数动画","date":"2022-02-24T16:00:00.000Z","_content":"\n# 绘制一个函数动画。\n\n要求：1.碰到边界反弹；\n2.会像贪吃蛇一样消失。\n\n老师已给出提示代码：三个辅助函数\n\n```c\n#include<stdio.h>\n#include<windows.h>\n#include<math.h>\n// two functions to clear screen and set cursor position for printing.\n// one function to take a rest in 10 microseconds.\n\n// use this function to clear screen\nvoid clear()//清屏\n{\n#if defined _WIN32\n    system(\"cls\");\n#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)\n    system(\"clear\");\n#elif defined (__APPLE__)\n    system(\"clear\");\n#endif\n}\n\n#if defined _WIN32\n    #include <conio.h>\n    #include <windows.h>\n    void setcursor(int x, int y)\n    {\n        HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);\n        COORD setps;\n        setps.X = x; setps.Y = y;\n        SetConsoleCursorPosition(hCon, setps);\n    }\n#endif\n\n\n// use this function to positioning before calling printf  \nvoid gotoxy(int x, int y)//光标移动到x,y处\n{\n#if defined _WIN32\n    setcursor(y - 1, x - 1);\n#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)\n    printf(\"\\033[%d;%dH\", x, y);\n#elif defined (__APPLE__)\n    printf(\"\\033[%d;%dH\", x, y);\n#endif\n}\n\nint factor = 10;\n\n// rest msec * 10 microseconds\nvoid rest(int msec)//当前画面静止一定时间\n{\n#if defined _WIN32\n    Sleep(msec * factor);\n#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)\n    usleep(msec * 1000 * factor);\n#elif defined (__APPLE__)\n    usleep(msec * 1000* factor);\n#endif\n}\n```\n其中`clear()`函数清屏；`gotoxy()`函数使光标移动到指定位置；`rest()`当前画面静止。\n\n## 思路\n1.动画绘制\n动画的原理是一帧帧的图片有短暂的时间间隔，连起来放映之后就产生了会动的感觉。我们可以每打印一个点之后`rest()`一小段时间来形成动画的效果。\n\n2.边界反弹\n即为碰到边界反向输出。我想的方法是纵坐标y1不变，只需要设计分段函数让x反向即可。\n\n3.延时消失\n要求的消失是像贪吃蛇一样，前面一边画着点，后面尾巴一边消失。但自己怎么想都只能做到全部绘制完成之后再让它开始消失。\n请教助教与Mc大佬之后得知他的思路是保留点数。屏幕中最多出现50个点，第51个点之后，打印第x个点时，x-50号点打印空格覆盖，让他消失。\n\n## 注意事项\n1.审题。给定的`gotoxy()`函数的横纵坐标是反着的，而且从左上角开始为(1,1)。\n2.`rest()`的用法非常灵活，比如高人指点：用户可以输入打印速度speed，rest(100-speed)。（妙啊）\n3.程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。所以比起重复一段好多遍，使用函数会更好。\n\n感谢Mc、fOrever_jAckY、olinr1222、--_--等人指点！\n\n```c\nint zong(int i)//纵坐标y1\n{\n\tdouble x=(i-51);\n\tdouble y=12.0*sin(x/7);\n\tint y1=(int)(15-y);\n\treturn y1;\n}\n\nint heng(int i)//横坐标j\n{\n\tint j=i;\n\tif(i>101&&i<=202)j=203-i;\n\telse if(i>202&&i<=303)j=i-202;\n\telse if(i>303&&i<=404)j=405-i;\n\treturn j;\n}\n\nvoid dayin(char ch,int j,int y1)//在(y1,j)处输出给定字符\n{\n\t\tgotoxy(y1,j);\n\t\tif(ch==' ')\n\t\t{\n\t\t\tif(y1==15)printf(\"-\");\n\t\t\telse if(j==51)printf(\"|\");\n\t\t\telse printf(\" \");\n\t\t}\n\t\telse printf(\"#\");\n\t\tgotoxy(29-y1,102-j);\n\t\tif(ch==' ')//防止坐标点和坐标轴被空格覆盖\n\t\t{\n\t\t\tif(29-y1==15)printf(\"-\");\n\t\t\telse if(102-j==51)printf(\"|\");\n\t\t\telse if(29-y1==26&&102-j==49)printf(\"-\");\n\t\t\telse if((29-y1==26&&102-j==50)||(29-y1==3&&102-j==50))printf(\"1\");\n\t\t\telse if(29-y1==16&&102-j==100)printf(\"X\");\n\t\t\telse printf(\" \");\n\t\t}\n\t\telse printf(\"#\");\n\t\tgotoxy(1,1);\n}\n\n\n\n\nint main()\n{\n\tfloat x,y;\n\tint tim=20;\n\tsystem(\"color F0\");\n\tsystem(\"mode con cols=101 lines=30\");\n\tclear();\n\t\n\tfor(int i=0;i<=100;i++)//打印x轴 \n\t{\n\t\tgotoxy(15,i+1);\n\t\tif(i!=50)printf(\"-\");\n\t\telse printf(\"+\");\n\t\tgotoxy(1,1);\n\t\trest(1);\n\t}\n\t\n\tfor(int i=29;i>=0;i--)//打印y轴 \n\t{\n\t\tgotoxy(i+1,51);\n\t\tif(i!=14)printf(\"|\");\n\t\tgotoxy(1,1); \n\t\trest(1);\n\t}\n\t//打印轴上的点\n\tgotoxy(16,52); printf(\"O\");\n\t\n\tgotoxy(16,100);printf(\"X\");\n\t\n\tgotoxy(1,49);printf(\"Y\");\n\t\n\tgotoxy(3,50);printf(\"1\");\n\t\n\tgotoxy(26,49);printf(\"-1\");\n\t\n\t\n\t\n\t\n\tint i=0,j,y1;\n\n\tfor(i=52;i<=404;i++)//打印函数 \n\t{\n\t\tj=heng(i),y1=zong(i);\n\t\tdayin('#',j,y1);\n\t\trest(4);\n\t\t\n\t\tif(i-51-tim>0)\n\t\t{\n\t\t\ty1=zong(i-tim);\n\t\t\tj=heng(i-tim);\n\t\t\tdayin(' ',j,y1);\n\t\t}\n\t}\t\n\tfor(int r=i-tim;r<=i;r++)\n\t{\n\t\tj=heng(r);\n\t\ty1=zong(r);\n\t\tdayin(' ',j,y1);\n\t\trest(4);\n\t} \n\tgotoxy(1,1);\n\trest(1000);\n\treturn 0;\n}\n```","source":"_posts/大一C语言大作业 函数动画.md","raw":"---\ntitle: 大一C语言大作业：函数动画\ndate: 2022-02-25\ntags: homework\ncategory: clanguage\n---\n\n# 绘制一个函数动画。\n\n要求：1.碰到边界反弹；\n2.会像贪吃蛇一样消失。\n\n老师已给出提示代码：三个辅助函数\n\n```c\n#include<stdio.h>\n#include<windows.h>\n#include<math.h>\n// two functions to clear screen and set cursor position for printing.\n// one function to take a rest in 10 microseconds.\n\n// use this function to clear screen\nvoid clear()//清屏\n{\n#if defined _WIN32\n    system(\"cls\");\n#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)\n    system(\"clear\");\n#elif defined (__APPLE__)\n    system(\"clear\");\n#endif\n}\n\n#if defined _WIN32\n    #include <conio.h>\n    #include <windows.h>\n    void setcursor(int x, int y)\n    {\n        HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);\n        COORD setps;\n        setps.X = x; setps.Y = y;\n        SetConsoleCursorPosition(hCon, setps);\n    }\n#endif\n\n\n// use this function to positioning before calling printf  \nvoid gotoxy(int x, int y)//光标移动到x,y处\n{\n#if defined _WIN32\n    setcursor(y - 1, x - 1);\n#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)\n    printf(\"\\033[%d;%dH\", x, y);\n#elif defined (__APPLE__)\n    printf(\"\\033[%d;%dH\", x, y);\n#endif\n}\n\nint factor = 10;\n\n// rest msec * 10 microseconds\nvoid rest(int msec)//当前画面静止一定时间\n{\n#if defined _WIN32\n    Sleep(msec * factor);\n#elif defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)\n    usleep(msec * 1000 * factor);\n#elif defined (__APPLE__)\n    usleep(msec * 1000* factor);\n#endif\n}\n```\n其中`clear()`函数清屏；`gotoxy()`函数使光标移动到指定位置；`rest()`当前画面静止。\n\n## 思路\n1.动画绘制\n动画的原理是一帧帧的图片有短暂的时间间隔，连起来放映之后就产生了会动的感觉。我们可以每打印一个点之后`rest()`一小段时间来形成动画的效果。\n\n2.边界反弹\n即为碰到边界反向输出。我想的方法是纵坐标y1不变，只需要设计分段函数让x反向即可。\n\n3.延时消失\n要求的消失是像贪吃蛇一样，前面一边画着点，后面尾巴一边消失。但自己怎么想都只能做到全部绘制完成之后再让它开始消失。\n请教助教与Mc大佬之后得知他的思路是保留点数。屏幕中最多出现50个点，第51个点之后，打印第x个点时，x-50号点打印空格覆盖，让他消失。\n\n## 注意事项\n1.审题。给定的`gotoxy()`函数的横纵坐标是反着的，而且从左上角开始为(1,1)。\n2.`rest()`的用法非常灵活，比如高人指点：用户可以输入打印速度speed，rest(100-speed)。（妙啊）\n3.程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。所以比起重复一段好多遍，使用函数会更好。\n\n感谢Mc、fOrever_jAckY、olinr1222、--_--等人指点！\n\n```c\nint zong(int i)//纵坐标y1\n{\n\tdouble x=(i-51);\n\tdouble y=12.0*sin(x/7);\n\tint y1=(int)(15-y);\n\treturn y1;\n}\n\nint heng(int i)//横坐标j\n{\n\tint j=i;\n\tif(i>101&&i<=202)j=203-i;\n\telse if(i>202&&i<=303)j=i-202;\n\telse if(i>303&&i<=404)j=405-i;\n\treturn j;\n}\n\nvoid dayin(char ch,int j,int y1)//在(y1,j)处输出给定字符\n{\n\t\tgotoxy(y1,j);\n\t\tif(ch==' ')\n\t\t{\n\t\t\tif(y1==15)printf(\"-\");\n\t\t\telse if(j==51)printf(\"|\");\n\t\t\telse printf(\" \");\n\t\t}\n\t\telse printf(\"#\");\n\t\tgotoxy(29-y1,102-j);\n\t\tif(ch==' ')//防止坐标点和坐标轴被空格覆盖\n\t\t{\n\t\t\tif(29-y1==15)printf(\"-\");\n\t\t\telse if(102-j==51)printf(\"|\");\n\t\t\telse if(29-y1==26&&102-j==49)printf(\"-\");\n\t\t\telse if((29-y1==26&&102-j==50)||(29-y1==3&&102-j==50))printf(\"1\");\n\t\t\telse if(29-y1==16&&102-j==100)printf(\"X\");\n\t\t\telse printf(\" \");\n\t\t}\n\t\telse printf(\"#\");\n\t\tgotoxy(1,1);\n}\n\n\n\n\nint main()\n{\n\tfloat x,y;\n\tint tim=20;\n\tsystem(\"color F0\");\n\tsystem(\"mode con cols=101 lines=30\");\n\tclear();\n\t\n\tfor(int i=0;i<=100;i++)//打印x轴 \n\t{\n\t\tgotoxy(15,i+1);\n\t\tif(i!=50)printf(\"-\");\n\t\telse printf(\"+\");\n\t\tgotoxy(1,1);\n\t\trest(1);\n\t}\n\t\n\tfor(int i=29;i>=0;i--)//打印y轴 \n\t{\n\t\tgotoxy(i+1,51);\n\t\tif(i!=14)printf(\"|\");\n\t\tgotoxy(1,1); \n\t\trest(1);\n\t}\n\t//打印轴上的点\n\tgotoxy(16,52); printf(\"O\");\n\t\n\tgotoxy(16,100);printf(\"X\");\n\t\n\tgotoxy(1,49);printf(\"Y\");\n\t\n\tgotoxy(3,50);printf(\"1\");\n\t\n\tgotoxy(26,49);printf(\"-1\");\n\t\n\t\n\t\n\t\n\tint i=0,j,y1;\n\n\tfor(i=52;i<=404;i++)//打印函数 \n\t{\n\t\tj=heng(i),y1=zong(i);\n\t\tdayin('#',j,y1);\n\t\trest(4);\n\t\t\n\t\tif(i-51-tim>0)\n\t\t{\n\t\t\ty1=zong(i-tim);\n\t\t\tj=heng(i-tim);\n\t\t\tdayin(' ',j,y1);\n\t\t}\n\t}\t\n\tfor(int r=i-tim;r<=i;r++)\n\t{\n\t\tj=heng(r);\n\t\ty1=zong(r);\n\t\tdayin(' ',j,y1);\n\t\trest(4);\n\t} \n\tgotoxy(1,1);\n\trest(1000);\n\treturn 0;\n}\n```","slug":"大一C语言大作业 函数动画","published":1,"updated":"2022-04-18T03:36:26.046Z","_id":"cl02m4pyp0001fsv2bf156buq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"绘制一个函数动画。\"><a href=\"#绘制一个函数动画。\" class=\"headerlink\" title=\"绘制一个函数动画。\"></a>绘制一个函数动画。</h1><p>要求：1.碰到边界反弹；<br>2.会像贪吃蛇一样消失。</p>\n<p>老师已给出提示代码：三个辅助函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;windows.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;math.h&gt;</span></span><br><span class=\"hljs-comment\">// two functions to clear screen and set cursor position for printing.</span><br><span class=\"hljs-comment\">// one function to take a rest in 10 microseconds.</span><br><br><span class=\"hljs-comment\">// use this function to clear screen</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">clear</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//清屏</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    system(<span class=\"hljs-string\">&quot;cls&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span><br>    system(<span class=\"hljs-string\">&quot;clear&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__APPLE__)</span><br>    system(<span class=\"hljs-string\">&quot;clear&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;conio.h&gt;</span></span><br>    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;windows.h&gt;</span></span><br>    <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">setcursor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span><br>    &#123;<br>        HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);<br>        COORD setps;<br>        setps.X = x; setps.Y = y;<br>        SetConsoleCursorPosition(hCon, setps);<br>    &#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><br><span class=\"hljs-comment\">// use this function to positioning before calling printf  </span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">gotoxy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span><span class=\"hljs-comment\">//光标移动到x,y处</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    setcursor(y - <span class=\"hljs-number\">1</span>, x - <span class=\"hljs-number\">1</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\033[%d;%dH&quot;</span>, x, y);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__APPLE__)</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\033[%d;%dH&quot;</span>, x, y);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><br><span class=\"hljs-type\">int</span> factor = <span class=\"hljs-number\">10</span>;<br><br><span class=\"hljs-comment\">// rest msec * 10 microseconds</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> msec)</span><span class=\"hljs-comment\">//当前画面静止一定时间</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    Sleep(msec * factor);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span><br>    usleep(msec * <span class=\"hljs-number\">1000</span> * factor);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__APPLE__)</span><br>    usleep(msec * <span class=\"hljs-number\">1000</span>* factor);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中<code>clear()</code>函数清屏；<code>gotoxy()</code>函数使光标移动到指定位置；<code>rest()</code>当前画面静止。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>1.动画绘制<br>动画的原理是一帧帧的图片有短暂的时间间隔，连起来放映之后就产生了会动的感觉。我们可以每打印一个点之后<code>rest()</code>一小段时间来形成动画的效果。</p>\n<p>2.边界反弹<br>即为碰到边界反向输出。我想的方法是纵坐标y1不变，只需要设计分段函数让x反向即可。</p>\n<p>3.延时消失<br>要求的消失是像贪吃蛇一样，前面一边画着点，后面尾巴一边消失。但自己怎么想都只能做到全部绘制完成之后再让它开始消失。<br>请教助教与Mc大佬之后得知他的思路是保留点数。屏幕中最多出现50个点，第51个点之后，打印第x个点时，x-50号点打印空格覆盖，让他消失。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1.审题。给定的<code>gotoxy()</code>函数的横纵坐标是反着的，而且从左上角开始为(1,1)。<br>2.<code>rest()</code>的用法非常灵活，比如高人指点：用户可以输入打印速度speed，rest(100-speed)。（妙啊）<br>3.程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。所以比起重复一段好多遍，使用函数会更好。</p>\n<p>感谢Mc、fOrever_jAckY、olinr1222、–_–等人指点！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">zong</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span><span class=\"hljs-comment\">//纵坐标y1</span><br>&#123;<br>\t<span class=\"hljs-type\">double</span> x=(i<span class=\"hljs-number\">-51</span>);<br>\t<span class=\"hljs-type\">double</span> y=<span class=\"hljs-number\">12.0</span>*<span class=\"hljs-built_in\">sin</span>(x/<span class=\"hljs-number\">7</span>);<br>\t<span class=\"hljs-type\">int</span> y1=(<span class=\"hljs-type\">int</span>)(<span class=\"hljs-number\">15</span>-y);<br>\t<span class=\"hljs-keyword\">return</span> y1;<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">heng</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span><span class=\"hljs-comment\">//横坐标j</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> j=i;<br>\t<span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">101</span>&amp;&amp;i&lt;=<span class=\"hljs-number\">202</span>)j=<span class=\"hljs-number\">203</span>-i;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">202</span>&amp;&amp;i&lt;=<span class=\"hljs-number\">303</span>)j=i<span class=\"hljs-number\">-202</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">303</span>&amp;&amp;i&lt;=<span class=\"hljs-number\">404</span>)j=<span class=\"hljs-number\">405</span>-i;<br>\t<span class=\"hljs-keyword\">return</span> j;<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">dayin</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> ch,<span class=\"hljs-type\">int</span> j,<span class=\"hljs-type\">int</span> y1)</span><span class=\"hljs-comment\">//在(y1,j)处输出给定字符</span><br>&#123;<br>\t\tgotoxy(y1,j);<br>\t\t<span class=\"hljs-keyword\">if</span>(ch==<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(y1==<span class=\"hljs-number\">15</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(j==<span class=\"hljs-number\">51</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;#&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">29</span>-y1,<span class=\"hljs-number\">102</span>-j);<br>\t\t<span class=\"hljs-keyword\">if</span>(ch==<span class=\"hljs-string\">&#x27; &#x27;</span>)<span class=\"hljs-comment\">//防止坐标点和坐标轴被空格覆盖</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">15</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">51</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">26</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">49</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">26</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">50</span>)||(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">3</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">50</span>))<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">16</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">100</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;X&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;#&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><br><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-type\">float</span> x,y;<br>\t<span class=\"hljs-type\">int</span> tim=<span class=\"hljs-number\">20</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;color F0&quot;</span>);<br>\tsystem(<span class=\"hljs-string\">&quot;mode con cols=101 lines=30&quot;</span>);<br>\tclear();<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=<span class=\"hljs-number\">100</span>;i++)<span class=\"hljs-comment\">//打印x轴 </span><br>\t&#123;<br>\t\tgotoxy(<span class=\"hljs-number\">15</span>,i+<span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">50</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;+&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);<br>\t\trest(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">29</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)<span class=\"hljs-comment\">//打印y轴 </span><br>\t&#123;<br>\t\tgotoxy(i+<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">51</span>);<br>\t\t<span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">14</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>); <br>\t\trest(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">//打印轴上的点</span><br>\tgotoxy(<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">52</span>); <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;O&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">100</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;X&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">49</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Y&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">50</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">26</span>,<span class=\"hljs-number\">49</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-1&quot;</span>);<br>\t<br>\t<br>\t<br>\t<br>\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>,j,y1;<br><br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">52</span>;i&lt;=<span class=\"hljs-number\">404</span>;i++)<span class=\"hljs-comment\">//打印函数 </span><br>\t&#123;<br>\t\tj=heng(i),y1=zong(i);<br>\t\tdayin(<span class=\"hljs-string\">&#x27;#&#x27;</span>,j,y1);<br>\t\trest(<span class=\"hljs-number\">4</span>);<br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span>(i<span class=\"hljs-number\">-51</span>-tim&gt;<span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\ty1=zong(i-tim);<br>\t\t\tj=heng(i-tim);<br>\t\t\tdayin(<span class=\"hljs-string\">&#x27; &#x27;</span>,j,y1);<br>\t\t&#125;<br>\t&#125;\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> r=i-tim;r&lt;=i;r++)<br>\t&#123;<br>\t\tj=heng(r);<br>\t\ty1=zong(r);<br>\t\tdayin(<span class=\"hljs-string\">&#x27; &#x27;</span>,j,y1);<br>\t\trest(<span class=\"hljs-number\">4</span>);<br>\t&#125; <br>\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);<br>\trest(<span class=\"hljs-number\">1000</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"绘制一个函数动画。\"><a href=\"#绘制一个函数动画。\" class=\"headerlink\" title=\"绘制一个函数动画。\"></a>绘制一个函数动画。</h1><p>要求：1.碰到边界反弹；<br>2.会像贪吃蛇一样消失。</p>\n<p>老师已给出提示代码：三个辅助函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;windows.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span><span class=\"hljs-string\">&lt;math.h&gt;</span></span><br><span class=\"hljs-comment\">// two functions to clear screen and set cursor position for printing.</span><br><span class=\"hljs-comment\">// one function to take a rest in 10 microseconds.</span><br><br><span class=\"hljs-comment\">// use this function to clear screen</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">clear</span><span class=\"hljs-params\">()</span><span class=\"hljs-comment\">//清屏</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    system(<span class=\"hljs-string\">&quot;cls&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span><br>    system(<span class=\"hljs-string\">&quot;clear&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__APPLE__)</span><br>    system(<span class=\"hljs-string\">&quot;clear&quot;</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;conio.h&gt;</span></span><br>    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;windows.h&gt;</span></span><br>    <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">setcursor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span><br>    &#123;<br>        HANDLE hCon = GetStdHandle(STD_OUTPUT_HANDLE);<br>        COORD setps;<br>        setps.X = x; setps.Y = y;<br>        SetConsoleCursorPosition(hCon, setps);<br>    &#125;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><br><span class=\"hljs-comment\">// use this function to positioning before calling printf  </span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">gotoxy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span><span class=\"hljs-comment\">//光标移动到x,y处</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    setcursor(y - <span class=\"hljs-number\">1</span>, x - <span class=\"hljs-number\">1</span>);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\033[%d;%dH&quot;</span>, x, y);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__APPLE__)</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\033[%d;%dH&quot;</span>, x, y);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br><br><span class=\"hljs-type\">int</span> factor = <span class=\"hljs-number\">10</span>;<br><br><span class=\"hljs-comment\">// rest msec * 10 microseconds</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">rest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> msec)</span><span class=\"hljs-comment\">//当前画面静止一定时间</span><br>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined _WIN32</span><br>    Sleep(msec * factor);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__LINUX__) || defined(__gnu_linux__) || defined(__linux__)</span><br>    usleep(msec * <span class=\"hljs-number\">1000</span> * factor);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined (__APPLE__)</span><br>    usleep(msec * <span class=\"hljs-number\">1000</span>* factor);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中<code>clear()</code>函数清屏；<code>gotoxy()</code>函数使光标移动到指定位置；<code>rest()</code>当前画面静止。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>1.动画绘制<br>动画的原理是一帧帧的图片有短暂的时间间隔，连起来放映之后就产生了会动的感觉。我们可以每打印一个点之后<code>rest()</code>一小段时间来形成动画的效果。</p>\n<p>2.边界反弹<br>即为碰到边界反向输出。我想的方法是纵坐标y1不变，只需要设计分段函数让x反向即可。</p>\n<p>3.延时消失<br>要求的消失是像贪吃蛇一样，前面一边画着点，后面尾巴一边消失。但自己怎么想都只能做到全部绘制完成之后再让它开始消失。<br>请教助教与Mc大佬之后得知他的思路是保留点数。屏幕中最多出现50个点，第51个点之后，打印第x个点时，x-50号点打印空格覆盖，让他消失。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1.审题。给定的<code>gotoxy()</code>函数的横纵坐标是反着的，而且从左上角开始为(1,1)。<br>2.<code>rest()</code>的用法非常灵活，比如高人指点：用户可以输入打印速度speed，rest(100-speed)。（妙啊）<br>3.程序中出现几段几乎完全相似的代码（除了字母不同），“代码复制”是程序不良的表现。因为将来做修改、维护的时候要维护很多处。所以比起重复一段好多遍，使用函数会更好。</p>\n<p>感谢Mc、fOrever_jAckY、olinr1222、–_–等人指点！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">zong</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span><span class=\"hljs-comment\">//纵坐标y1</span><br>&#123;<br>\t<span class=\"hljs-type\">double</span> x=(i<span class=\"hljs-number\">-51</span>);<br>\t<span class=\"hljs-type\">double</span> y=<span class=\"hljs-number\">12.0</span>*<span class=\"hljs-built_in\">sin</span>(x/<span class=\"hljs-number\">7</span>);<br>\t<span class=\"hljs-type\">int</span> y1=(<span class=\"hljs-type\">int</span>)(<span class=\"hljs-number\">15</span>-y);<br>\t<span class=\"hljs-keyword\">return</span> y1;<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">heng</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span><span class=\"hljs-comment\">//横坐标j</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> j=i;<br>\t<span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">101</span>&amp;&amp;i&lt;=<span class=\"hljs-number\">202</span>)j=<span class=\"hljs-number\">203</span>-i;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">202</span>&amp;&amp;i&lt;=<span class=\"hljs-number\">303</span>)j=i<span class=\"hljs-number\">-202</span>;<br>\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(i&gt;<span class=\"hljs-number\">303</span>&amp;&amp;i&lt;=<span class=\"hljs-number\">404</span>)j=<span class=\"hljs-number\">405</span>-i;<br>\t<span class=\"hljs-keyword\">return</span> j;<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">dayin</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> ch,<span class=\"hljs-type\">int</span> j,<span class=\"hljs-type\">int</span> y1)</span><span class=\"hljs-comment\">//在(y1,j)处输出给定字符</span><br>&#123;<br>\t\tgotoxy(y1,j);<br>\t\t<span class=\"hljs-keyword\">if</span>(ch==<span class=\"hljs-string\">&#x27; &#x27;</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(y1==<span class=\"hljs-number\">15</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(j==<span class=\"hljs-number\">51</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;#&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">29</span>-y1,<span class=\"hljs-number\">102</span>-j);<br>\t\t<span class=\"hljs-keyword\">if</span>(ch==<span class=\"hljs-string\">&#x27; &#x27;</span>)<span class=\"hljs-comment\">//防止坐标点和坐标轴被空格覆盖</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">15</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">51</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">26</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">49</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>((<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">26</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">50</span>)||(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">3</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">50</span>))<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-number\">29</span>-y1==<span class=\"hljs-number\">16</span>&amp;&amp;<span class=\"hljs-number\">102</span>-j==<span class=\"hljs-number\">100</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;X&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot; &quot;</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;#&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);<br>&#125;<br><br><br><br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-type\">float</span> x,y;<br>\t<span class=\"hljs-type\">int</span> tim=<span class=\"hljs-number\">20</span>;<br>\tsystem(<span class=\"hljs-string\">&quot;color F0&quot;</span>);<br>\tsystem(<span class=\"hljs-string\">&quot;mode con cols=101 lines=30&quot;</span>);<br>\tclear();<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=<span class=\"hljs-number\">100</span>;i++)<span class=\"hljs-comment\">//打印x轴 </span><br>\t&#123;<br>\t\tgotoxy(<span class=\"hljs-number\">15</span>,i+<span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">50</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;+&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);<br>\t\trest(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">29</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)<span class=\"hljs-comment\">//打印y轴 </span><br>\t&#123;<br>\t\tgotoxy(i+<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">51</span>);<br>\t\t<span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">14</span>)<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>); <br>\t\trest(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">//打印轴上的点</span><br>\tgotoxy(<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">52</span>); <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;O&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">16</span>,<span class=\"hljs-number\">100</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;X&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">49</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Y&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">50</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;1&quot;</span>);<br>\t<br>\tgotoxy(<span class=\"hljs-number\">26</span>,<span class=\"hljs-number\">49</span>);<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-1&quot;</span>);<br>\t<br>\t<br>\t<br>\t<br>\t<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>,j,y1;<br><br>\t<span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">52</span>;i&lt;=<span class=\"hljs-number\">404</span>;i++)<span class=\"hljs-comment\">//打印函数 </span><br>\t&#123;<br>\t\tj=heng(i),y1=zong(i);<br>\t\tdayin(<span class=\"hljs-string\">&#x27;#&#x27;</span>,j,y1);<br>\t\trest(<span class=\"hljs-number\">4</span>);<br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span>(i<span class=\"hljs-number\">-51</span>-tim&gt;<span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\ty1=zong(i-tim);<br>\t\t\tj=heng(i-tim);<br>\t\t\tdayin(<span class=\"hljs-string\">&#x27; &#x27;</span>,j,y1);<br>\t\t&#125;<br>\t&#125;\t<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> r=i-tim;r&lt;=i;r++)<br>\t&#123;<br>\t\tj=heng(r);<br>\t\ty1=zong(r);<br>\t\tdayin(<span class=\"hljs-string\">&#x27; &#x27;</span>,j,y1);<br>\t\trest(<span class=\"hljs-number\">4</span>);<br>\t&#125; <br>\tgotoxy(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);<br>\trest(<span class=\"hljs-number\">1000</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"大一C语言大作业：五子棋（总结）","date":"2022-02-25T16:00:00.000Z","_content":"\n# 计算与设计思维大作业\n\n这次看了几位大佬的做法，我们也做了很多修改尝试。算是第一次尝试合作完成项目。\n我认为学到的东西：\n\n1. 第一次尝试写项目，把函数分到不同的.c文件中后更好看了一些。\n2. 在研究过程中应该分清主次。代码正确运行才是基础要求，其他什么美化界面，调字体调颜色都并非重点。（8月4日更新：评价算法的五个特性，正确性，简明性，健壮性，效率，最优性）\n3. 从代码中学到的，①是采用落子数来判断该轮到黑方下还是白方下（落子数为2的倍数时黑方下，否则白方下），这样也能判断出是哪一方胜利，而且落子数还可以判断棋盘是否下满（==16*16时棋盘落满，平局） ②是胜利条件的判断，以中间子为参考，看两边的四个子是否和他颜色相同。\n4. 8月4日更新：在这次尝试中在文件中使用了全局变量，不同文件中用extern调用。但是在后来学习中意识到全局变量最好不要写在文件里，会增加耦合性。以后多人合作写不同函数的时候也要注意，尽量不要出现。\n\n## 规则\n\n在一个16\\*16的棋盘上，黑白双方交替落子，每次落下子后如果棋盘上出现了五个同色棋子横向/竖向/斜向连接，则该方胜利。如果在棋盘下满后（即下了16\\*16个子后）仍未分出胜负，则为平局。\n\n## 逻辑\n\n初始化棋盘，是一个`16*16`的二维数组（定义宏 N=16），一开始每一格都初始化为0。用一个不断++的落子数变量%2来判断本回合是黑方下还是白方下，；每次玩家输入横纵坐标，该处的变量值改变（黑子为1，白子为2）。每次落子判断全盘是否有五子连珠，如果有则结束游戏，如果没有则继续下。当落子数达到`N*N`即棋盘下满，还没有出现五子连珠时，则判断为平局，结束游戏。\n\n## 五子棋胜负条件判断\n\n判断原理 :\n胜负的判断是在每颗棋子落下之后进行，所以用这一子的坐标为基准前后左右斜各个方向来看是否取胜。\n具体思想:\n按照五子棋规则，当一方的棋子，在横向，纵向或斜向连续五个均为同一用户的棋子时，代表胜利。\n另外，胜利判断只需要在一个新子落子时判断，且仅需要判断新子所在的四条线上(纵横加两个斜线)是否满足条件即可。\n所以，可以以新子坐标为基准点，判断四次。\n比如横向的，需要判断左侧和右侧连续的同类棋子个数，如果左侧+右侧+1（自身）总数>=5，则为胜利。\n在判断胜利的时候,首先我们要排除空子的情况,然后当两个斜线的时候, 无胜情况下，判断直线,当为两斜线及直线无胜情况下，判断横线。\n参考代码如下：\n\n```c\nint win()\n{\n\textern int arr[100][100];\n\tint k = 0,l = 0;\n\tint flag = 0; \n\tfor(k=2;k<N-2;k++) \n\t\tfor(l=2;l<N-2;l++)\n\t\t{\n\t\t\tif(arr[k][l]!=0&&arr[k-2][l-2]==arr[k][l]&&arr[k-1][l-1]==arr[k][l]&&arr[k+1][l+1]==arr[k][l]&&arr[k+2][l+2]==arr[k][l])\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(arr[k][l]!=0&&arr[k+2][l-2]==arr[k][l]&&arr[k+1][l-1]==arr[k][l]&&arr[k-1][l+1]==arr[k][l]&&arr[k-2][l+2]==arr[k][l])\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif(flag==0) \n\t\tfor(k=0;k<N;k++)\n\t\t\tfor(l=2;l<N-2;l++)\n\t\t\t{\n\t\t\t\tif(arr[k][l]!=0&&arr[k][l-2]==arr[k][l]&&arr[k][l-1]==arr[k][l]&&arr[k][l+1]==arr[k][l]&&arr[k][l+2]==arr[k][l])\n\t\t\t\t{\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\tif(flag==0) \n\t\tfor(k=2;k<N-2;k++)\n\t\t\tfor(l=0;l<N;l++)\n\t\t\t{\n\t\t\t\tif(arr[k][l]!=0&&arr[k+2][l]==arr[k][l]&&arr[k+1][l]==arr[k][l]&&arr[k-1][l]==arr[k][l]&&arr[k-2][l]==arr[k][l])\n\t\t\t\t{\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\treturn flag; \n}\n```\n\n注:\n1.\t中的arr[k][l]!=0是排除空子的情况。\n2.\t最后返回判断结果时, 有胜为1,无为0,谁胜无必要判断，因为，谁尾手了的一定是胜的。\n### 演示\n开始\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/ae0a75087855494bbde21f978da69805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n\n\n输入坐标\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/d5998cff325649e6b674ed2a6051b673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n\n\n\n\n\n第二回合\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20f9995d17b04e17979f8fdc73b65363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n\n游戏结束\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/500ed64c7833490abfece68802bb8c84.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)","source":"_posts/大一C语言大作业 五子棋（总结）.md","raw":"---\ntitle: 大一C语言大作业：五子棋（总结）\ndate: 2022-02-26\ntags: homework\ncategory: course\n---\n\n# 计算与设计思维大作业\n\n这次看了几位大佬的做法，我们也做了很多修改尝试。算是第一次尝试合作完成项目。\n我认为学到的东西：\n\n1. 第一次尝试写项目，把函数分到不同的.c文件中后更好看了一些。\n2. 在研究过程中应该分清主次。代码正确运行才是基础要求，其他什么美化界面，调字体调颜色都并非重点。（8月4日更新：评价算法的五个特性，正确性，简明性，健壮性，效率，最优性）\n3. 从代码中学到的，①是采用落子数来判断该轮到黑方下还是白方下（落子数为2的倍数时黑方下，否则白方下），这样也能判断出是哪一方胜利，而且落子数还可以判断棋盘是否下满（==16*16时棋盘落满，平局） ②是胜利条件的判断，以中间子为参考，看两边的四个子是否和他颜色相同。\n4. 8月4日更新：在这次尝试中在文件中使用了全局变量，不同文件中用extern调用。但是在后来学习中意识到全局变量最好不要写在文件里，会增加耦合性。以后多人合作写不同函数的时候也要注意，尽量不要出现。\n\n## 规则\n\n在一个16\\*16的棋盘上，黑白双方交替落子，每次落下子后如果棋盘上出现了五个同色棋子横向/竖向/斜向连接，则该方胜利。如果在棋盘下满后（即下了16\\*16个子后）仍未分出胜负，则为平局。\n\n## 逻辑\n\n初始化棋盘，是一个`16*16`的二维数组（定义宏 N=16），一开始每一格都初始化为0。用一个不断++的落子数变量%2来判断本回合是黑方下还是白方下，；每次玩家输入横纵坐标，该处的变量值改变（黑子为1，白子为2）。每次落子判断全盘是否有五子连珠，如果有则结束游戏，如果没有则继续下。当落子数达到`N*N`即棋盘下满，还没有出现五子连珠时，则判断为平局，结束游戏。\n\n## 五子棋胜负条件判断\n\n判断原理 :\n胜负的判断是在每颗棋子落下之后进行，所以用这一子的坐标为基准前后左右斜各个方向来看是否取胜。\n具体思想:\n按照五子棋规则，当一方的棋子，在横向，纵向或斜向连续五个均为同一用户的棋子时，代表胜利。\n另外，胜利判断只需要在一个新子落子时判断，且仅需要判断新子所在的四条线上(纵横加两个斜线)是否满足条件即可。\n所以，可以以新子坐标为基准点，判断四次。\n比如横向的，需要判断左侧和右侧连续的同类棋子个数，如果左侧+右侧+1（自身）总数>=5，则为胜利。\n在判断胜利的时候,首先我们要排除空子的情况,然后当两个斜线的时候, 无胜情况下，判断直线,当为两斜线及直线无胜情况下，判断横线。\n参考代码如下：\n\n```c\nint win()\n{\n\textern int arr[100][100];\n\tint k = 0,l = 0;\n\tint flag = 0; \n\tfor(k=2;k<N-2;k++) \n\t\tfor(l=2;l<N-2;l++)\n\t\t{\n\t\t\tif(arr[k][l]!=0&&arr[k-2][l-2]==arr[k][l]&&arr[k-1][l-1]==arr[k][l]&&arr[k+1][l+1]==arr[k][l]&&arr[k+2][l+2]==arr[k][l])\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(arr[k][l]!=0&&arr[k+2][l-2]==arr[k][l]&&arr[k+1][l-1]==arr[k][l]&&arr[k-1][l+1]==arr[k][l]&&arr[k-2][l+2]==arr[k][l])\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif(flag==0) \n\t\tfor(k=0;k<N;k++)\n\t\t\tfor(l=2;l<N-2;l++)\n\t\t\t{\n\t\t\t\tif(arr[k][l]!=0&&arr[k][l-2]==arr[k][l]&&arr[k][l-1]==arr[k][l]&&arr[k][l+1]==arr[k][l]&&arr[k][l+2]==arr[k][l])\n\t\t\t\t{\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\tif(flag==0) \n\t\tfor(k=2;k<N-2;k++)\n\t\t\tfor(l=0;l<N;l++)\n\t\t\t{\n\t\t\t\tif(arr[k][l]!=0&&arr[k+2][l]==arr[k][l]&&arr[k+1][l]==arr[k][l]&&arr[k-1][l]==arr[k][l]&&arr[k-2][l]==arr[k][l])\n\t\t\t\t{\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\treturn flag; \n}\n```\n\n注:\n1.\t中的arr[k][l]!=0是排除空子的情况。\n2.\t最后返回判断结果时, 有胜为1,无为0,谁胜无必要判断，因为，谁尾手了的一定是胜的。\n### 演示\n开始\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/ae0a75087855494bbde21f978da69805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n\n\n输入坐标\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/d5998cff325649e6b674ed2a6051b673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n\n\n\n\n\n第二回合\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20f9995d17b04e17979f8fdc73b65363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n\n游戏结束\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/500ed64c7833490abfece68802bb8c84.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)","slug":"大一C语言大作业 五子棋（总结）","published":1,"updated":"2022-04-18T03:36:05.639Z","_id":"cl03y1b0800003wv2hx8mg9y2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"计算与设计思维大作业\"><a href=\"#计算与设计思维大作业\" class=\"headerlink\" title=\"计算与设计思维大作业\"></a>计算与设计思维大作业</h1><p>这次看了几位大佬的做法，我们也做了很多修改尝试。算是第一次尝试合作完成项目。<br>我认为学到的东西：</p>\n<ol>\n<li>第一次尝试写项目，把函数分到不同的.c文件中后更好看了一些。</li>\n<li>在研究过程中应该分清主次。代码正确运行才是基础要求，其他什么美化界面，调字体调颜色都并非重点。（8月4日更新：评价算法的五个特性，正确性，简明性，健壮性，效率，最优性）</li>\n<li>从代码中学到的，①是采用落子数来判断该轮到黑方下还是白方下（落子数为2的倍数时黑方下，否则白方下），这样也能判断出是哪一方胜利，而且落子数还可以判断棋盘是否下满（==16*16时棋盘落满，平局） ②是胜利条件的判断，以中间子为参考，看两边的四个子是否和他颜色相同。</li>\n<li>8月4日更新：在这次尝试中在文件中使用了全局变量，不同文件中用extern调用。但是在后来学习中意识到全局变量最好不要写在文件里，会增加耦合性。以后多人合作写不同函数的时候也要注意，尽量不要出现。</li>\n</ol>\n<h2 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h2><p>在一个16*16的棋盘上，黑白双方交替落子，每次落下子后如果棋盘上出现了五个同色棋子横向/竖向/斜向连接，则该方胜利。如果在棋盘下满后（即下了16*16个子后）仍未分出胜负，则为平局。</p>\n<h2 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h2><p>初始化棋盘，是一个<code>16*16</code>的二维数组（定义宏 N=16），一开始每一格都初始化为0。用一个不断++的落子数变量%2来判断本回合是黑方下还是白方下，；每次玩家输入横纵坐标，该处的变量值改变（黑子为1，白子为2）。每次落子判断全盘是否有五子连珠，如果有则结束游戏，如果没有则继续下。当落子数达到<code>N*N</code>即棋盘下满，还没有出现五子连珠时，则判断为平局，结束游戏。</p>\n<h2 id=\"五子棋胜负条件判断\"><a href=\"#五子棋胜负条件判断\" class=\"headerlink\" title=\"五子棋胜负条件判断\"></a>五子棋胜负条件判断</h2><p>判断原理 :<br>胜负的判断是在每颗棋子落下之后进行，所以用这一子的坐标为基准前后左右斜各个方向来看是否取胜。<br>具体思想:<br>按照五子棋规则，当一方的棋子，在横向，纵向或斜向连续五个均为同一用户的棋子时，代表胜利。<br>另外，胜利判断只需要在一个新子落子时判断，且仅需要判断新子所在的四条线上(纵横加两个斜线)是否满足条件即可。<br>所以，可以以新子坐标为基准点，判断四次。<br>比如横向的，需要判断左侧和右侧连续的同类棋子个数，如果左侧+右侧+1（自身）总数&gt;=5，则为胜利。<br>在判断胜利的时候,首先我们要排除空子的情况,然后当两个斜线的时候, 无胜情况下，判断直线,当为两斜线及直线无胜情况下，判断横线。<br>参考代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">win</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">100</span>][<span class=\"hljs-number\">100</span>];<br>\t<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>,l = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> flag = <span class=\"hljs-number\">0</span>; <br>\t<span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">2</span>;k&lt;N<span class=\"hljs-number\">-2</span>;k++) <br>\t\t<span class=\"hljs-keyword\">for</span>(l=<span class=\"hljs-number\">2</span>;l&lt;N<span class=\"hljs-number\">-2</span>;l++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k<span class=\"hljs-number\">-2</span>][l<span class=\"hljs-number\">-2</span>]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-1</span>][l<span class=\"hljs-number\">-1</span>]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">1</span>][l+<span class=\"hljs-number\">1</span>]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">2</span>][l+<span class=\"hljs-number\">2</span>]==arr[k][l])<br>\t\t\t&#123;<br>\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k+<span class=\"hljs-number\">2</span>][l<span class=\"hljs-number\">-2</span>]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">1</span>][l<span class=\"hljs-number\">-1</span>]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-1</span>][l+<span class=\"hljs-number\">1</span>]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-2</span>][l+<span class=\"hljs-number\">2</span>]==arr[k][l])<br>\t\t\t&#123;<br>\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag==<span class=\"hljs-number\">0</span>) <br>\t\t<span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span>;k&lt;N;k++)<br>\t\t\t<span class=\"hljs-keyword\">for</span>(l=<span class=\"hljs-number\">2</span>;l&lt;N<span class=\"hljs-number\">-2</span>;l++)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k][l<span class=\"hljs-number\">-2</span>]==arr[k][l]&amp;&amp;arr[k][l<span class=\"hljs-number\">-1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class=\"hljs-number\">1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class=\"hljs-number\">2</span>]==arr[k][l])<br>\t\t\t\t&#123;<br>\t\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag==<span class=\"hljs-number\">0</span>) <br>\t\t<span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">2</span>;k&lt;N<span class=\"hljs-number\">-2</span>;k++)<br>\t\t\t<span class=\"hljs-keyword\">for</span>(l=<span class=\"hljs-number\">0</span>;l&lt;N;l++)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k+<span class=\"hljs-number\">2</span>][l]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-2</span>][l]==arr[k][l])<br>\t\t\t\t&#123;<br>\t\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> flag; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注:</p>\n<ol>\n<li>   中的arr[k][l]!=0是排除空子的情况。</li>\n<li>最后返回判断结果时, 有胜为1,无为0,谁胜无必要判断，因为，谁尾手了的一定是胜的。<h3 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h3>开始<br><img src=\"https://img-blog.csdnimg.cn/ae0a75087855494bbde21f978da69805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<p>输入坐标<br> <img src=\"https://img-blog.csdnimg.cn/d5998cff325649e6b674ed2a6051b673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>第二回合<br> <img src=\"https://img-blog.csdnimg.cn/20f9995d17b04e17979f8fdc73b65363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>游戏结束<br> <img src=\"https://img-blog.csdnimg.cn/500ed64c7833490abfece68802bb8c84.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"计算与设计思维大作业\"><a href=\"#计算与设计思维大作业\" class=\"headerlink\" title=\"计算与设计思维大作业\"></a>计算与设计思维大作业</h1><p>这次看了几位大佬的做法，我们也做了很多修改尝试。算是第一次尝试合作完成项目。<br>我认为学到的东西：</p>\n<ol>\n<li>第一次尝试写项目，把函数分到不同的.c文件中后更好看了一些。</li>\n<li>在研究过程中应该分清主次。代码正确运行才是基础要求，其他什么美化界面，调字体调颜色都并非重点。（8月4日更新：评价算法的五个特性，正确性，简明性，健壮性，效率，最优性）</li>\n<li>从代码中学到的，①是采用落子数来判断该轮到黑方下还是白方下（落子数为2的倍数时黑方下，否则白方下），这样也能判断出是哪一方胜利，而且落子数还可以判断棋盘是否下满（==16*16时棋盘落满，平局） ②是胜利条件的判断，以中间子为参考，看两边的四个子是否和他颜色相同。</li>\n<li>8月4日更新：在这次尝试中在文件中使用了全局变量，不同文件中用extern调用。但是在后来学习中意识到全局变量最好不要写在文件里，会增加耦合性。以后多人合作写不同函数的时候也要注意，尽量不要出现。</li>\n</ol>\n<h2 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h2><p>在一个16*16的棋盘上，黑白双方交替落子，每次落下子后如果棋盘上出现了五个同色棋子横向/竖向/斜向连接，则该方胜利。如果在棋盘下满后（即下了16*16个子后）仍未分出胜负，则为平局。</p>\n<h2 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h2><p>初始化棋盘，是一个<code>16*16</code>的二维数组（定义宏 N=16），一开始每一格都初始化为0。用一个不断++的落子数变量%2来判断本回合是黑方下还是白方下，；每次玩家输入横纵坐标，该处的变量值改变（黑子为1，白子为2）。每次落子判断全盘是否有五子连珠，如果有则结束游戏，如果没有则继续下。当落子数达到<code>N*N</code>即棋盘下满，还没有出现五子连珠时，则判断为平局，结束游戏。</p>\n<h2 id=\"五子棋胜负条件判断\"><a href=\"#五子棋胜负条件判断\" class=\"headerlink\" title=\"五子棋胜负条件判断\"></a>五子棋胜负条件判断</h2><p>判断原理 :<br>胜负的判断是在每颗棋子落下之后进行，所以用这一子的坐标为基准前后左右斜各个方向来看是否取胜。<br>具体思想:<br>按照五子棋规则，当一方的棋子，在横向，纵向或斜向连续五个均为同一用户的棋子时，代表胜利。<br>另外，胜利判断只需要在一个新子落子时判断，且仅需要判断新子所在的四条线上(纵横加两个斜线)是否满足条件即可。<br>所以，可以以新子坐标为基准点，判断四次。<br>比如横向的，需要判断左侧和右侧连续的同类棋子个数，如果左侧+右侧+1（自身）总数&gt;=5，则为胜利。<br>在判断胜利的时候,首先我们要排除空子的情况,然后当两个斜线的时候, 无胜情况下，判断直线,当为两斜线及直线无胜情况下，判断横线。<br>参考代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">win</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-keyword\">extern</span> <span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">100</span>][<span class=\"hljs-number\">100</span>];<br>\t<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>,l = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> flag = <span class=\"hljs-number\">0</span>; <br>\t<span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">2</span>;k&lt;N<span class=\"hljs-number\">-2</span>;k++) <br>\t\t<span class=\"hljs-keyword\">for</span>(l=<span class=\"hljs-number\">2</span>;l&lt;N<span class=\"hljs-number\">-2</span>;l++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k<span class=\"hljs-number\">-2</span>][l<span class=\"hljs-number\">-2</span>]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-1</span>][l<span class=\"hljs-number\">-1</span>]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">1</span>][l+<span class=\"hljs-number\">1</span>]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">2</span>][l+<span class=\"hljs-number\">2</span>]==arr[k][l])<br>\t\t\t&#123;<br>\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k+<span class=\"hljs-number\">2</span>][l<span class=\"hljs-number\">-2</span>]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">1</span>][l<span class=\"hljs-number\">-1</span>]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-1</span>][l+<span class=\"hljs-number\">1</span>]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-2</span>][l+<span class=\"hljs-number\">2</span>]==arr[k][l])<br>\t\t\t&#123;<br>\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag==<span class=\"hljs-number\">0</span>) <br>\t\t<span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">0</span>;k&lt;N;k++)<br>\t\t\t<span class=\"hljs-keyword\">for</span>(l=<span class=\"hljs-number\">2</span>;l&lt;N<span class=\"hljs-number\">-2</span>;l++)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k][l<span class=\"hljs-number\">-2</span>]==arr[k][l]&amp;&amp;arr[k][l<span class=\"hljs-number\">-1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class=\"hljs-number\">1</span>]==arr[k][l]&amp;&amp;arr[k][l+<span class=\"hljs-number\">2</span>]==arr[k][l])<br>\t\t\t\t&#123;<br>\t\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>(flag==<span class=\"hljs-number\">0</span>) <br>\t\t<span class=\"hljs-keyword\">for</span>(k=<span class=\"hljs-number\">2</span>;k&lt;N<span class=\"hljs-number\">-2</span>;k++)<br>\t\t\t<span class=\"hljs-keyword\">for</span>(l=<span class=\"hljs-number\">0</span>;l&lt;N;l++)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(arr[k][l]!=<span class=\"hljs-number\">0</span>&amp;&amp;arr[k+<span class=\"hljs-number\">2</span>][l]==arr[k][l]&amp;&amp;arr[k+<span class=\"hljs-number\">1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-1</span>][l]==arr[k][l]&amp;&amp;arr[k<span class=\"hljs-number\">-2</span>][l]==arr[k][l])<br>\t\t\t\t&#123;<br>\t\t\t\t\tflag=<span class=\"hljs-number\">1</span>;<br>\t\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> flag; <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注:</p>\n<ol>\n<li>   中的arr[k][l]!=0是排除空子的情况。</li>\n<li>最后返回判断结果时, 有胜为1,无为0,谁胜无必要判断，因为，谁尾手了的一定是胜的。<h3 id=\"演示\"><a href=\"#演示\" class=\"headerlink\" title=\"演示\"></a>演示</h3>开始<br><img src=\"https://img-blog.csdnimg.cn/ae0a75087855494bbde21f978da69805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></li>\n</ol>\n<p>输入坐标<br> <img src=\"https://img-blog.csdnimg.cn/d5998cff325649e6b674ed2a6051b673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>第二回合<br> <img src=\"https://img-blog.csdnimg.cn/20f9995d17b04e17979f8fdc73b65363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>游戏结束<br> <img src=\"https://img-blog.csdnimg.cn/500ed64c7833490abfece68802bb8c84.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n"},{"title":"大二C语言大作业：订餐系统（总结）","date":"2022-02-26T16:00:00.000Z","_content":"\n尽管快半年没有学c了，好在回顾起来还是蛮快的。而且也发现比去年的自己熟练了许多。\n小学期要求5人合作，用C语言做一个订餐系统，能够实现用户的登录、选择餐馆、订餐、按各种规则查询与排序、修改个人信息，管理员的登录、添加菜品、按各种规则查询与排序、修改个人信息。\n首先，我们调研了几个流行的订餐系统，~~并解决了午饭~~分析其页面逻辑顺序，借此设定了我们自己的订餐系统的逻辑顺序。\n感谢blue、peppa、214、Mar鼎力相助！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d8feaa5c8fab43efb78c7dd073d37419.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16)\n至于写法，主要尝试了两个新知识点：**文件操作与链表**。\n想要实现这样的订餐系统，必须有地方可以存储其数据。不能说放在程序里吧，每次一关一开又恢复原状了。我们使用FILE文件操作，对存放在指定位置的txt进行读写操作，读取其中的数据。\n至于数据结构采用结构体数组还是链表，在之前学习翁恺老师的网课时我们认识到了结构体数组的一些弊端。数组大小固定，一旦初始化无法修改，少了可能越界，多了浪费内存空间，链表就可以想用一个结点开辟一个结点。而且对于插入、删除等操作还是链表香啊，数组中间插入或删除一个，后面的都要跟着动。\n至于如何实现多人合作，可参考翁恺老师网课12.3.1多个源代码文件用devc++创建项目的方法。我们每人负责了几个函数，最后对好接口和返回值合并。其实就像同学说的，在合并之前是最没底的，也没法测试知道自己写的什么样。好在最终完成的还算顺利。\n\n链表中嵌套链表，是这回我们做的一个非常有意思的尝试。我们发现每次订单中所点的菜品及其数量，和每次订单结束后推荐的菜品数量都是不固定的。对于数据结构还没开始学的我们来说有些困难。后来去问了老师，老师给出了“那你们只能在链表里套一个链表了吧”的解决方案。没想到这个方案真的能做，虽然这铁不是最佳方案。但是也非常有趣。\n```c\ntypedef struct list_dish //订单中的菜品链表\n{\n\tint dish_id; //菜品号\n\tint number;\t //该菜品数量\n\tstruct list_dish *next;\n} LISTDISH;\ntypedef struct recommend_d\n{\n\tchar dish_name[len]; //推荐的菜品名称\n\tstruct recommend_d *next;\n} RECOMMEND;\ntypedef struct list //订单链表\n{\n\tint number;\t\t\t\t//订单号\n\tchar user_id[len];\t\t//用户id，据此可以找到用户地址\n\tint restaurant_id;\t\t//餐馆id\n\tint score;\t\t\t\t//本次订单对餐馆的打分\n\tint price;\t\t\t\t//本次订单的总价格\n\tTIME delivery_time_s;\t//起始配送时间。TIME是一个包含月、日、时、分成员的结构体\n\tTIME delivery_time_e;\t//结束配送时间\n\tRECOMMEND *recommend_d; //本次用户推荐菜品头结点指针 \n\tLISTDISH *head_ld;\t\t//本次订单的菜品链表头结点指针\n\tstruct list *next;\n} LIST;\n```\n如上，在订单链表的每个结点中，都包含着一个listdish（存储本次订单所选菜品及其数量）链表的头结点和一个recommend（存储本次订单推荐的菜品）链表的头结点。访问的时候可以通过list->recommend->dish_name这样的方法直接得到本次订单中推荐菜品的菜品名称。\n这样的结构，如何从文件中读取？\n其他的链表都还好办。至于这三个链表，我们建立了3个txt文件（虽然listdish和recommend有许多链表，但是最好还是都存在一个txt里，不然每次新点订单还要新建txt文件。）其中listdish和recommend文本文档是这样的：![在这里插入图片描述](https://img-blog.csdnimg.cn/bcd7964a59194715921f1261517f5d50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16)\n每一行代表第几个订单。每两个数字为一组，第一个数字为菜品号，第二个数字为该菜品所点数量。由于不固定长度，我们采用两个-1作为结尾，当读到-1时本订单结束。\n```c\nLIST *read_inf_l()\n{\n\tLIST *head = (LIST *)malloc(sizeof(LIST))\n\t, *last = head, *p, *temp = (LIST *)malloc(sizeof(LIST));\n\thead->next = NULL;\n\tFILE *fp_l = fopen(\"D:\\\\小学期\\\\list.txt\", \"r\");\n\twhile (fscanf(fp_l, \"%d %s %d %d %d %d %d %d %d %d %d %d %d \"\n\t, &temp->number, temp->user_id, &temp->restaurant_id\n\t, &temp->score, &temp->price\n\t, &temp->delivery_time_s.month, &temp->delivery_time_s.day\n\t, &temp->delivery_time_s.hour, &temp->delivery_time_s.minute\n\t, &temp->delivery_time_e.month, &temp->delivery_time_e.day\n\t, &temp->delivery_time_e.hour, &temp->delivery_time_e.minute) != EOF)\n\t{\n\t\tp = (LIST *)malloc(sizeof(LIST));\n\t\tp->next = NULL;\n\t\tp->head_ld = read_inf_ld(temp->number);//跳转到read_inf_ld(int number)函数中获得本次订单listdish链表的头结点，number是订单号\n\t\tp->recommend_d = read_inf_recommend(temp->number);//跳转到read_inf_recommend(int number)函数中获得本次订单recommend链表的头结点，number是订单号\n\t\tp->number = temp->number;\n\t\tstrcpy(p->user_id, temp->user_id);\n\t\tp->restaurant_id = temp->restaurant_id;\n\t\tp->score = temp->score;\n\t\tp->price = temp->price;\n\t\tp->delivery_time_s.month = temp->delivery_time_s.month;\n\t\tp->delivery_time_s.day = temp->delivery_time_s.day;\n\t\tp->delivery_time_s.hour = temp->delivery_time_s.hour;\n\t\tp->delivery_time_s.minute = temp->delivery_time_s.minute;\n\t\tp->delivery_time_e.month = temp->delivery_time_e.month;\n\t\tp->delivery_time_e.day = temp->delivery_time_e.day;\n\t\tp->delivery_time_e.hour = temp->delivery_time_e.hour;\n\t\tp->delivery_time_e.minute = temp->delivery_time_e.minute;\n\t\tlast->next = p;\n\t\tlast = last->next;\n\t\tlast->next = NULL;\n\t}\n\tfclose(fp_l);\n\treturn head;\n}\n```\n```c\nLISTDISH *read_inf_ld(int id) //Read the Information of List-Dish linklist\n{\n\tLISTDISH *head = (LISTDISH *)malloc(sizeof(LISTDISH))\n\t, *last = head, *p, *temp = (LISTDISH *)malloc(sizeof(LISTDISH));\n\thead->next = NULL;\n\tFILE *fp_ld;\n\tfp_ld = fopen(\"D:\\\\小学期\\\\listdish.txt\", \"r\");\n\tint cnt = 1;\n\tif (id != 0)\n\t\twhile (cnt != id)\n\t\t{\n\n\t\t\ttemp->dish_id = 0;\n\t\t\twhile (temp->dish_id != -1)\n\t\t\t{\n\t\t\t\tfscanf(fp_ld, \"%d %d \", &temp->dish_id, &temp->number);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\tfscanf(fp_ld, \"%d %d \", &temp->dish_id, &temp->number);\n\twhile (temp->dish_id != -1)\n\t{\n\t\tp = (LISTDISH *)malloc(sizeof(LISTDISH));\n\t\tp->dish_id = temp->dish_id;\n\t\tp->number = temp->number;\n\t\tlast->next = p;\n\t\tlast = last->next;\n\t\tlast->next = NULL;\n\t\tfscanf(fp_ld, \"%d %d \", &temp->dish_id, &temp->number);\n\t}\n\tfclose(fp_ld);\n\treturn head;\n}\n```\n比如要读取第三个订单所点菜品信息，传入read_inf_ld()的number订单号为3.`int cnt = 1`代表当前文件指针读取的订单号，从1开始计数，每次读到-1 -1证明又读完了一单，cnt++，直到cnt == number为止。然后读取接下来的这个链表，最后返回头结点，作为该订单中的一个成员。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b66117ee8b641998ea580f57da912ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16)\n```c\nRECOMMEND *read_inf_recommend(int id)\n{\n\tRECOMMEND *head = (RECOMMEND *)malloc(sizeof(RECOMMEND)),*last=head\n\t,*p,*temp = (RECOMMEND *)malloc(sizeof(RECOMMEND));\n\thead->next=NULL;\n\tFILE *fp_recommend = fopen(\"D:\\\\小学期\\\\recommend.txt\", \"r\"); \n\tint cnt = 1;\n    if (id != 0)\n        while (cnt != id)\n        {\n            strcpy(temp->dish_name,\"0\");\n            while (strcmp(temp->dish_name , \"-1\")!=0)\n            {\n                fscanf(fp_recommend, \"%s \", temp->dish_name);\n            }\n            cnt++;\n        }\n    fscanf(fp_recommend, \"%s \", temp->dish_name);\n    while (strcmp(temp->dish_name ,\"-1\")!=0)\n    {\n        p = (RECOMMEND *)malloc(sizeof(RECOMMEND));\n        strcpy(p->dish_name, temp->dish_name);\n        last->next = p;\n        last = last->next;\n        last->next=NULL;\n        fscanf(fp_recommend, \"%s \", temp->dish_name);\n    }\n\tfclose(fp_recommend);\n\treturn head;\n}\n```\n读取推荐菜品链表也是类似。\n得到的链表全都包括头结点（里链表也是），不包含结尾的-1，只要通过->->就能访问hh。\n总之，结束了~","source":"_posts/大二C语言大作业 订餐系统（总结）.md","raw":"---\ntitle: 大二C语言大作业：订餐系统（总结）\ndate: 2022-02-27\ntags: homework\ncategory: clanguage\n---\n\n尽管快半年没有学c了，好在回顾起来还是蛮快的。而且也发现比去年的自己熟练了许多。\n小学期要求5人合作，用C语言做一个订餐系统，能够实现用户的登录、选择餐馆、订餐、按各种规则查询与排序、修改个人信息，管理员的登录、添加菜品、按各种规则查询与排序、修改个人信息。\n首先，我们调研了几个流行的订餐系统，~~并解决了午饭~~分析其页面逻辑顺序，借此设定了我们自己的订餐系统的逻辑顺序。\n感谢blue、peppa、214、Mar鼎力相助！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d8feaa5c8fab43efb78c7dd073d37419.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16)\n至于写法，主要尝试了两个新知识点：**文件操作与链表**。\n想要实现这样的订餐系统，必须有地方可以存储其数据。不能说放在程序里吧，每次一关一开又恢复原状了。我们使用FILE文件操作，对存放在指定位置的txt进行读写操作，读取其中的数据。\n至于数据结构采用结构体数组还是链表，在之前学习翁恺老师的网课时我们认识到了结构体数组的一些弊端。数组大小固定，一旦初始化无法修改，少了可能越界，多了浪费内存空间，链表就可以想用一个结点开辟一个结点。而且对于插入、删除等操作还是链表香啊，数组中间插入或删除一个，后面的都要跟着动。\n至于如何实现多人合作，可参考翁恺老师网课12.3.1多个源代码文件用devc++创建项目的方法。我们每人负责了几个函数，最后对好接口和返回值合并。其实就像同学说的，在合并之前是最没底的，也没法测试知道自己写的什么样。好在最终完成的还算顺利。\n\n链表中嵌套链表，是这回我们做的一个非常有意思的尝试。我们发现每次订单中所点的菜品及其数量，和每次订单结束后推荐的菜品数量都是不固定的。对于数据结构还没开始学的我们来说有些困难。后来去问了老师，老师给出了“那你们只能在链表里套一个链表了吧”的解决方案。没想到这个方案真的能做，虽然这铁不是最佳方案。但是也非常有趣。\n```c\ntypedef struct list_dish //订单中的菜品链表\n{\n\tint dish_id; //菜品号\n\tint number;\t //该菜品数量\n\tstruct list_dish *next;\n} LISTDISH;\ntypedef struct recommend_d\n{\n\tchar dish_name[len]; //推荐的菜品名称\n\tstruct recommend_d *next;\n} RECOMMEND;\ntypedef struct list //订单链表\n{\n\tint number;\t\t\t\t//订单号\n\tchar user_id[len];\t\t//用户id，据此可以找到用户地址\n\tint restaurant_id;\t\t//餐馆id\n\tint score;\t\t\t\t//本次订单对餐馆的打分\n\tint price;\t\t\t\t//本次订单的总价格\n\tTIME delivery_time_s;\t//起始配送时间。TIME是一个包含月、日、时、分成员的结构体\n\tTIME delivery_time_e;\t//结束配送时间\n\tRECOMMEND *recommend_d; //本次用户推荐菜品头结点指针 \n\tLISTDISH *head_ld;\t\t//本次订单的菜品链表头结点指针\n\tstruct list *next;\n} LIST;\n```\n如上，在订单链表的每个结点中，都包含着一个listdish（存储本次订单所选菜品及其数量）链表的头结点和一个recommend（存储本次订单推荐的菜品）链表的头结点。访问的时候可以通过list->recommend->dish_name这样的方法直接得到本次订单中推荐菜品的菜品名称。\n这样的结构，如何从文件中读取？\n其他的链表都还好办。至于这三个链表，我们建立了3个txt文件（虽然listdish和recommend有许多链表，但是最好还是都存在一个txt里，不然每次新点订单还要新建txt文件。）其中listdish和recommend文本文档是这样的：![在这里插入图片描述](https://img-blog.csdnimg.cn/bcd7964a59194715921f1261517f5d50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16)\n每一行代表第几个订单。每两个数字为一组，第一个数字为菜品号，第二个数字为该菜品所点数量。由于不固定长度，我们采用两个-1作为结尾，当读到-1时本订单结束。\n```c\nLIST *read_inf_l()\n{\n\tLIST *head = (LIST *)malloc(sizeof(LIST))\n\t, *last = head, *p, *temp = (LIST *)malloc(sizeof(LIST));\n\thead->next = NULL;\n\tFILE *fp_l = fopen(\"D:\\\\小学期\\\\list.txt\", \"r\");\n\twhile (fscanf(fp_l, \"%d %s %d %d %d %d %d %d %d %d %d %d %d \"\n\t, &temp->number, temp->user_id, &temp->restaurant_id\n\t, &temp->score, &temp->price\n\t, &temp->delivery_time_s.month, &temp->delivery_time_s.day\n\t, &temp->delivery_time_s.hour, &temp->delivery_time_s.minute\n\t, &temp->delivery_time_e.month, &temp->delivery_time_e.day\n\t, &temp->delivery_time_e.hour, &temp->delivery_time_e.minute) != EOF)\n\t{\n\t\tp = (LIST *)malloc(sizeof(LIST));\n\t\tp->next = NULL;\n\t\tp->head_ld = read_inf_ld(temp->number);//跳转到read_inf_ld(int number)函数中获得本次订单listdish链表的头结点，number是订单号\n\t\tp->recommend_d = read_inf_recommend(temp->number);//跳转到read_inf_recommend(int number)函数中获得本次订单recommend链表的头结点，number是订单号\n\t\tp->number = temp->number;\n\t\tstrcpy(p->user_id, temp->user_id);\n\t\tp->restaurant_id = temp->restaurant_id;\n\t\tp->score = temp->score;\n\t\tp->price = temp->price;\n\t\tp->delivery_time_s.month = temp->delivery_time_s.month;\n\t\tp->delivery_time_s.day = temp->delivery_time_s.day;\n\t\tp->delivery_time_s.hour = temp->delivery_time_s.hour;\n\t\tp->delivery_time_s.minute = temp->delivery_time_s.minute;\n\t\tp->delivery_time_e.month = temp->delivery_time_e.month;\n\t\tp->delivery_time_e.day = temp->delivery_time_e.day;\n\t\tp->delivery_time_e.hour = temp->delivery_time_e.hour;\n\t\tp->delivery_time_e.minute = temp->delivery_time_e.minute;\n\t\tlast->next = p;\n\t\tlast = last->next;\n\t\tlast->next = NULL;\n\t}\n\tfclose(fp_l);\n\treturn head;\n}\n```\n```c\nLISTDISH *read_inf_ld(int id) //Read the Information of List-Dish linklist\n{\n\tLISTDISH *head = (LISTDISH *)malloc(sizeof(LISTDISH))\n\t, *last = head, *p, *temp = (LISTDISH *)malloc(sizeof(LISTDISH));\n\thead->next = NULL;\n\tFILE *fp_ld;\n\tfp_ld = fopen(\"D:\\\\小学期\\\\listdish.txt\", \"r\");\n\tint cnt = 1;\n\tif (id != 0)\n\t\twhile (cnt != id)\n\t\t{\n\n\t\t\ttemp->dish_id = 0;\n\t\t\twhile (temp->dish_id != -1)\n\t\t\t{\n\t\t\t\tfscanf(fp_ld, \"%d %d \", &temp->dish_id, &temp->number);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\tfscanf(fp_ld, \"%d %d \", &temp->dish_id, &temp->number);\n\twhile (temp->dish_id != -1)\n\t{\n\t\tp = (LISTDISH *)malloc(sizeof(LISTDISH));\n\t\tp->dish_id = temp->dish_id;\n\t\tp->number = temp->number;\n\t\tlast->next = p;\n\t\tlast = last->next;\n\t\tlast->next = NULL;\n\t\tfscanf(fp_ld, \"%d %d \", &temp->dish_id, &temp->number);\n\t}\n\tfclose(fp_ld);\n\treturn head;\n}\n```\n比如要读取第三个订单所点菜品信息，传入read_inf_ld()的number订单号为3.`int cnt = 1`代表当前文件指针读取的订单号，从1开始计数，每次读到-1 -1证明又读完了一单，cnt++，直到cnt == number为止。然后读取接下来的这个链表，最后返回头结点，作为该订单中的一个成员。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b66117ee8b641998ea580f57da912ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16)\n```c\nRECOMMEND *read_inf_recommend(int id)\n{\n\tRECOMMEND *head = (RECOMMEND *)malloc(sizeof(RECOMMEND)),*last=head\n\t,*p,*temp = (RECOMMEND *)malloc(sizeof(RECOMMEND));\n\thead->next=NULL;\n\tFILE *fp_recommend = fopen(\"D:\\\\小学期\\\\recommend.txt\", \"r\"); \n\tint cnt = 1;\n    if (id != 0)\n        while (cnt != id)\n        {\n            strcpy(temp->dish_name,\"0\");\n            while (strcmp(temp->dish_name , \"-1\")!=0)\n            {\n                fscanf(fp_recommend, \"%s \", temp->dish_name);\n            }\n            cnt++;\n        }\n    fscanf(fp_recommend, \"%s \", temp->dish_name);\n    while (strcmp(temp->dish_name ,\"-1\")!=0)\n    {\n        p = (RECOMMEND *)malloc(sizeof(RECOMMEND));\n        strcpy(p->dish_name, temp->dish_name);\n        last->next = p;\n        last = last->next;\n        last->next=NULL;\n        fscanf(fp_recommend, \"%s \", temp->dish_name);\n    }\n\tfclose(fp_recommend);\n\treturn head;\n}\n```\n读取推荐菜品链表也是类似。\n得到的链表全都包括头结点（里链表也是），不包含结尾的-1，只要通过->->就能访问hh。\n总之，结束了~","slug":"大二C语言大作业 订餐系统（总结）","published":1,"updated":"2022-04-18T03:36:17.718Z","_id":"cl04122ju0001pgv2ah9oewd6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>尽管快半年没有学c了，好在回顾起来还是蛮快的。而且也发现比去年的自己熟练了许多。<br>小学期要求5人合作，用C语言做一个订餐系统，能够实现用户的登录、选择餐馆、订餐、按各种规则查询与排序、修改个人信息，管理员的登录、添加菜品、按各种规则查询与排序、修改个人信息。<br>首先，我们调研了几个流行的订餐系统，<del>并解决了午饭</del>分析其页面逻辑顺序，借此设定了我们自己的订餐系统的逻辑顺序。<br>感谢blue、peppa、214、Mar鼎力相助！<br><img src=\"https://img-blog.csdnimg.cn/d8feaa5c8fab43efb78c7dd073d37419.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"><br>至于写法，主要尝试了两个新知识点：<strong>文件操作与链表</strong>。<br>想要实现这样的订餐系统，必须有地方可以存储其数据。不能说放在程序里吧，每次一关一开又恢复原状了。我们使用FILE文件操作，对存放在指定位置的txt进行读写操作，读取其中的数据。<br>至于数据结构采用结构体数组还是链表，在之前学习翁恺老师的网课时我们认识到了结构体数组的一些弊端。数组大小固定，一旦初始化无法修改，少了可能越界，多了浪费内存空间，链表就可以想用一个结点开辟一个结点。而且对于插入、删除等操作还是链表香啊，数组中间插入或删除一个，后面的都要跟着动。<br>至于如何实现多人合作，可参考翁恺老师网课12.3.1多个源代码文件用devc++创建项目的方法。我们每人负责了几个函数，最后对好接口和返回值合并。其实就像同学说的，在合并之前是最没底的，也没法测试知道自己写的什么样。好在最终完成的还算顺利。</p>\n<p>链表中嵌套链表，是这回我们做的一个非常有意思的尝试。我们发现每次订单中所点的菜品及其数量，和每次订单结束后推荐的菜品数量都是不固定的。对于数据结构还没开始学的我们来说有些困难。后来去问了老师，老师给出了“那你们只能在链表里套一个链表了吧”的解决方案。没想到这个方案真的能做，虽然这铁不是最佳方案。但是也非常有趣。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_dish</span> //订单中的菜品链表</span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-type\">int</span> dish_id; <span class=\"hljs-comment\">//菜品号</span><br>\t<span class=\"hljs-type\">int</span> number;\t <span class=\"hljs-comment\">//该菜品数量</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_dish</span> *<span class=\"hljs-title\">next</span>;</span><br>&#125; LISTDISH;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">recommend_d</span></span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-type\">char</span> dish_name[len]; <span class=\"hljs-comment\">//推荐的菜品名称</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">recommend_d</span> *<span class=\"hljs-title\">next</span>;</span><br>&#125; RECOMMEND;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list</span> //订单链表</span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-type\">int</span> number;\t\t\t\t<span class=\"hljs-comment\">//订单号</span><br>\t<span class=\"hljs-type\">char</span> user_id[len];\t\t<span class=\"hljs-comment\">//用户id，据此可以找到用户地址</span><br>\t<span class=\"hljs-type\">int</span> restaurant_id;\t\t<span class=\"hljs-comment\">//餐馆id</span><br>\t<span class=\"hljs-type\">int</span> score;\t\t\t\t<span class=\"hljs-comment\">//本次订单对餐馆的打分</span><br>\t<span class=\"hljs-type\">int</span> price;\t\t\t\t<span class=\"hljs-comment\">//本次订单的总价格</span><br>\tTIME delivery_time_s;\t<span class=\"hljs-comment\">//起始配送时间。TIME是一个包含月、日、时、分成员的结构体</span><br>\tTIME delivery_time_e;\t<span class=\"hljs-comment\">//结束配送时间</span><br>\tRECOMMEND *recommend_d; <span class=\"hljs-comment\">//本次用户推荐菜品头结点指针 </span><br>\tLISTDISH *head_ld;\t\t<span class=\"hljs-comment\">//本次订单的菜品链表头结点指针</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list</span> *<span class=\"hljs-title\">next</span>;</span><br>&#125; LIST;<br></code></pre></td></tr></table></figure>\n<p>如上，在订单链表的每个结点中，都包含着一个listdish（存储本次订单所选菜品及其数量）链表的头结点和一个recommend（存储本次订单推荐的菜品）链表的头结点。访问的时候可以通过list-&gt;recommend-&gt;dish_name这样的方法直接得到本次订单中推荐菜品的菜品名称。<br>这样的结构，如何从文件中读取？<br>其他的链表都还好办。至于这三个链表，我们建立了3个txt文件（虽然listdish和recommend有许多链表，但是最好还是都存在一个txt里，不然每次新点订单还要新建txt文件。）其中listdish和recommend文本文档是这样的：<img src=\"https://img-blog.csdnimg.cn/bcd7964a59194715921f1261517f5d50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"><br>每一行代表第几个订单。每两个数字为一组，第一个数字为菜品号，第二个数字为该菜品所点数量。由于不固定长度，我们采用两个-1作为结尾，当读到-1时本订单结束。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">LIST *<span class=\"hljs-title function_\">read_inf_l</span><span class=\"hljs-params\">()</span><br>&#123;<br>\tLIST *head = (LIST *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LIST))<br>\t, *last = head, *p, *temp = (LIST *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LIST));<br>\thead-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\tFILE *fp_l = fopen(<span class=\"hljs-string\">&quot;D:\\\\小学期\\\\list.txt&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>);<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">fscanf</span>(fp_l, <span class=\"hljs-string\">&quot;%d %s %d %d %d %d %d %d %d %d %d %d %d &quot;</span><br>\t, &amp;temp-&gt;number, temp-&gt;user_id, &amp;temp-&gt;restaurant_id<br>\t, &amp;temp-&gt;score, &amp;temp-&gt;price<br>\t, &amp;temp-&gt;delivery_time_s.month, &amp;temp-&gt;delivery_time_s.day<br>\t, &amp;temp-&gt;delivery_time_s.hour, &amp;temp-&gt;delivery_time_s.minute<br>\t, &amp;temp-&gt;delivery_time_e.month, &amp;temp-&gt;delivery_time_e.day<br>\t, &amp;temp-&gt;delivery_time_e.hour, &amp;temp-&gt;delivery_time_e.minute) != EOF)<br>\t&#123;<br>\t\tp = (LIST *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LIST));<br>\t\tp-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t\tp-&gt;head_ld = read_inf_ld(temp-&gt;number);<span class=\"hljs-comment\">//跳转到read_inf_ld(int number)函数中获得本次订单listdish链表的头结点，number是订单号</span><br>\t\tp-&gt;recommend_d = read_inf_recommend(temp-&gt;number);<span class=\"hljs-comment\">//跳转到read_inf_recommend(int number)函数中获得本次订单recommend链表的头结点，number是订单号</span><br>\t\tp-&gt;number = temp-&gt;number;<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(p-&gt;user_id, temp-&gt;user_id);<br>\t\tp-&gt;restaurant_id = temp-&gt;restaurant_id;<br>\t\tp-&gt;score = temp-&gt;score;<br>\t\tp-&gt;price = temp-&gt;price;<br>\t\tp-&gt;delivery_time_s.month = temp-&gt;delivery_time_s.month;<br>\t\tp-&gt;delivery_time_s.day = temp-&gt;delivery_time_s.day;<br>\t\tp-&gt;delivery_time_s.hour = temp-&gt;delivery_time_s.hour;<br>\t\tp-&gt;delivery_time_s.minute = temp-&gt;delivery_time_s.minute;<br>\t\tp-&gt;delivery_time_e.month = temp-&gt;delivery_time_e.month;<br>\t\tp-&gt;delivery_time_e.day = temp-&gt;delivery_time_e.day;<br>\t\tp-&gt;delivery_time_e.hour = temp-&gt;delivery_time_e.hour;<br>\t\tp-&gt;delivery_time_e.minute = temp-&gt;delivery_time_e.minute;<br>\t\tlast-&gt;next = p;<br>\t\tlast = last-&gt;next;<br>\t\tlast-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\tfclose(fp_l);<br>\t<span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">LISTDISH *<span class=\"hljs-title function_\">read_inf_ld</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> id)</span> <span class=\"hljs-comment\">//Read the Information of List-Dish linklist</span><br>&#123;<br>\tLISTDISH *head = (LISTDISH *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LISTDISH))<br>\t, *last = head, *p, *temp = (LISTDISH *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LISTDISH));<br>\thead-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\tFILE *fp_ld;<br>\tfp_ld = fopen(<span class=\"hljs-string\">&quot;D:\\\\小学期\\\\listdish.txt&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>);<br>\t<span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">if</span> (id != <span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-keyword\">while</span> (cnt != id)<br>\t\t&#123;<br><br>\t\t\ttemp-&gt;dish_id = <span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">while</span> (temp-&gt;dish_id != <span class=\"hljs-number\">-1</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">fscanf</span>(fp_ld, <span class=\"hljs-string\">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);<br>\t\t\t&#125;<br>\t\t\tcnt++;<br>\t\t&#125;<br>\t<span class=\"hljs-built_in\">fscanf</span>(fp_ld, <span class=\"hljs-string\">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);<br>\t<span class=\"hljs-keyword\">while</span> (temp-&gt;dish_id != <span class=\"hljs-number\">-1</span>)<br>\t&#123;<br>\t\tp = (LISTDISH *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LISTDISH));<br>\t\tp-&gt;dish_id = temp-&gt;dish_id;<br>\t\tp-&gt;number = temp-&gt;number;<br>\t\tlast-&gt;next = p;<br>\t\tlast = last-&gt;next;<br>\t\tlast-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t\t<span class=\"hljs-built_in\">fscanf</span>(fp_ld, <span class=\"hljs-string\">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);<br>\t&#125;<br>\tfclose(fp_ld);<br>\t<span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>比如要读取第三个订单所点菜品信息，传入read_inf_ld()的number订单号为3.<code>int cnt = 1</code>代表当前文件指针读取的订单号，从1开始计数，每次读到-1 -1证明又读完了一单，cnt++，直到cnt == number为止。然后读取接下来的这个链表，最后返回头结点，作为该订单中的一个成员。<br><img src=\"https://img-blog.csdnimg.cn/6b66117ee8b641998ea580f57da912ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">RECOMMEND *<span class=\"hljs-title function_\">read_inf_recommend</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> id)</span><br>&#123;<br>\tRECOMMEND *head = (RECOMMEND *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(RECOMMEND)),*last=head<br>\t,*p,*temp = (RECOMMEND *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(RECOMMEND));<br>\thead-&gt;next=<span class=\"hljs-literal\">NULL</span>;<br>\tFILE *fp_recommend = fopen(<span class=\"hljs-string\">&quot;D:\\\\小学期\\\\recommend.txt&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>); <br>\t<span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (id != <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">while</span> (cnt != id)<br>        &#123;<br>            <span class=\"hljs-built_in\">strcpy</span>(temp-&gt;dish_name,<span class=\"hljs-string\">&quot;0&quot;</span>);<br>            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">strcmp</span>(temp-&gt;dish_name , <span class=\"hljs-string\">&quot;-1&quot;</span>)!=<span class=\"hljs-number\">0</span>)<br>            &#123;<br>                <span class=\"hljs-built_in\">fscanf</span>(fp_recommend, <span class=\"hljs-string\">&quot;%s &quot;</span>, temp-&gt;dish_name);<br>            &#125;<br>            cnt++;<br>        &#125;<br>    <span class=\"hljs-built_in\">fscanf</span>(fp_recommend, <span class=\"hljs-string\">&quot;%s &quot;</span>, temp-&gt;dish_name);<br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">strcmp</span>(temp-&gt;dish_name ,<span class=\"hljs-string\">&quot;-1&quot;</span>)!=<span class=\"hljs-number\">0</span>)<br>    &#123;<br>        p = (RECOMMEND *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(RECOMMEND));<br>        <span class=\"hljs-built_in\">strcpy</span>(p-&gt;dish_name, temp-&gt;dish_name);<br>        last-&gt;next = p;<br>        last = last-&gt;next;<br>        last-&gt;next=<span class=\"hljs-literal\">NULL</span>;<br>        <span class=\"hljs-built_in\">fscanf</span>(fp_recommend, <span class=\"hljs-string\">&quot;%s &quot;</span>, temp-&gt;dish_name);<br>    &#125;<br>\tfclose(fp_recommend);<br>\t<span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>读取推荐菜品链表也是类似。<br>得到的链表全都包括头结点（里链表也是），不包含结尾的-1，只要通过-&gt;-&gt;就能访问hh。<br>总之，结束了~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>尽管快半年没有学c了，好在回顾起来还是蛮快的。而且也发现比去年的自己熟练了许多。<br>小学期要求5人合作，用C语言做一个订餐系统，能够实现用户的登录、选择餐馆、订餐、按各种规则查询与排序、修改个人信息，管理员的登录、添加菜品、按各种规则查询与排序、修改个人信息。<br>首先，我们调研了几个流行的订餐系统，<del>并解决了午饭</del>分析其页面逻辑顺序，借此设定了我们自己的订餐系统的逻辑顺序。<br>感谢blue、peppa、214、Mar鼎力相助！<br><img src=\"https://img-blog.csdnimg.cn/d8feaa5c8fab43efb78c7dd073d37419.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"><br>至于写法，主要尝试了两个新知识点：<strong>文件操作与链表</strong>。<br>想要实现这样的订餐系统，必须有地方可以存储其数据。不能说放在程序里吧，每次一关一开又恢复原状了。我们使用FILE文件操作，对存放在指定位置的txt进行读写操作，读取其中的数据。<br>至于数据结构采用结构体数组还是链表，在之前学习翁恺老师的网课时我们认识到了结构体数组的一些弊端。数组大小固定，一旦初始化无法修改，少了可能越界，多了浪费内存空间，链表就可以想用一个结点开辟一个结点。而且对于插入、删除等操作还是链表香啊，数组中间插入或删除一个，后面的都要跟着动。<br>至于如何实现多人合作，可参考翁恺老师网课12.3.1多个源代码文件用devc++创建项目的方法。我们每人负责了几个函数，最后对好接口和返回值合并。其实就像同学说的，在合并之前是最没底的，也没法测试知道自己写的什么样。好在最终完成的还算顺利。</p>\n<p>链表中嵌套链表，是这回我们做的一个非常有意思的尝试。我们发现每次订单中所点的菜品及其数量，和每次订单结束后推荐的菜品数量都是不固定的。对于数据结构还没开始学的我们来说有些困难。后来去问了老师，老师给出了“那你们只能在链表里套一个链表了吧”的解决方案。没想到这个方案真的能做，虽然这铁不是最佳方案。但是也非常有趣。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_dish</span> //订单中的菜品链表</span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-type\">int</span> dish_id; <span class=\"hljs-comment\">//菜品号</span><br>\t<span class=\"hljs-type\">int</span> number;\t <span class=\"hljs-comment\">//该菜品数量</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list_dish</span> *<span class=\"hljs-title\">next</span>;</span><br>&#125; LISTDISH;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">recommend_d</span></span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-type\">char</span> dish_name[len]; <span class=\"hljs-comment\">//推荐的菜品名称</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">recommend_d</span> *<span class=\"hljs-title\">next</span>;</span><br>&#125; RECOMMEND;<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list</span> //订单链表</span><br><span class=\"hljs-class\">&#123;</span><br>\t<span class=\"hljs-type\">int</span> number;\t\t\t\t<span class=\"hljs-comment\">//订单号</span><br>\t<span class=\"hljs-type\">char</span> user_id[len];\t\t<span class=\"hljs-comment\">//用户id，据此可以找到用户地址</span><br>\t<span class=\"hljs-type\">int</span> restaurant_id;\t\t<span class=\"hljs-comment\">//餐馆id</span><br>\t<span class=\"hljs-type\">int</span> score;\t\t\t\t<span class=\"hljs-comment\">//本次订单对餐馆的打分</span><br>\t<span class=\"hljs-type\">int</span> price;\t\t\t\t<span class=\"hljs-comment\">//本次订单的总价格</span><br>\tTIME delivery_time_s;\t<span class=\"hljs-comment\">//起始配送时间。TIME是一个包含月、日、时、分成员的结构体</span><br>\tTIME delivery_time_e;\t<span class=\"hljs-comment\">//结束配送时间</span><br>\tRECOMMEND *recommend_d; <span class=\"hljs-comment\">//本次用户推荐菜品头结点指针 </span><br>\tLISTDISH *head_ld;\t\t<span class=\"hljs-comment\">//本次订单的菜品链表头结点指针</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">list</span> *<span class=\"hljs-title\">next</span>;</span><br>&#125; LIST;<br></code></pre></td></tr></table></figure>\n<p>如上，在订单链表的每个结点中，都包含着一个listdish（存储本次订单所选菜品及其数量）链表的头结点和一个recommend（存储本次订单推荐的菜品）链表的头结点。访问的时候可以通过list-&gt;recommend-&gt;dish_name这样的方法直接得到本次订单中推荐菜品的菜品名称。<br>这样的结构，如何从文件中读取？<br>其他的链表都还好办。至于这三个链表，我们建立了3个txt文件（虽然listdish和recommend有许多链表，但是最好还是都存在一个txt里，不然每次新点订单还要新建txt文件。）其中listdish和recommend文本文档是这样的：<img src=\"https://img-blog.csdnimg.cn/bcd7964a59194715921f1261517f5d50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"><br>每一行代表第几个订单。每两个数字为一组，第一个数字为菜品号，第二个数字为该菜品所点数量。由于不固定长度，我们采用两个-1作为结尾，当读到-1时本订单结束。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">LIST *<span class=\"hljs-title function_\">read_inf_l</span><span class=\"hljs-params\">()</span><br>&#123;<br>\tLIST *head = (LIST *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LIST))<br>\t, *last = head, *p, *temp = (LIST *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LIST));<br>\thead-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\tFILE *fp_l = fopen(<span class=\"hljs-string\">&quot;D:\\\\小学期\\\\list.txt&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>);<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">fscanf</span>(fp_l, <span class=\"hljs-string\">&quot;%d %s %d %d %d %d %d %d %d %d %d %d %d &quot;</span><br>\t, &amp;temp-&gt;number, temp-&gt;user_id, &amp;temp-&gt;restaurant_id<br>\t, &amp;temp-&gt;score, &amp;temp-&gt;price<br>\t, &amp;temp-&gt;delivery_time_s.month, &amp;temp-&gt;delivery_time_s.day<br>\t, &amp;temp-&gt;delivery_time_s.hour, &amp;temp-&gt;delivery_time_s.minute<br>\t, &amp;temp-&gt;delivery_time_e.month, &amp;temp-&gt;delivery_time_e.day<br>\t, &amp;temp-&gt;delivery_time_e.hour, &amp;temp-&gt;delivery_time_e.minute) != EOF)<br>\t&#123;<br>\t\tp = (LIST *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LIST));<br>\t\tp-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t\tp-&gt;head_ld = read_inf_ld(temp-&gt;number);<span class=\"hljs-comment\">//跳转到read_inf_ld(int number)函数中获得本次订单listdish链表的头结点，number是订单号</span><br>\t\tp-&gt;recommend_d = read_inf_recommend(temp-&gt;number);<span class=\"hljs-comment\">//跳转到read_inf_recommend(int number)函数中获得本次订单recommend链表的头结点，number是订单号</span><br>\t\tp-&gt;number = temp-&gt;number;<br>\t\t<span class=\"hljs-built_in\">strcpy</span>(p-&gt;user_id, temp-&gt;user_id);<br>\t\tp-&gt;restaurant_id = temp-&gt;restaurant_id;<br>\t\tp-&gt;score = temp-&gt;score;<br>\t\tp-&gt;price = temp-&gt;price;<br>\t\tp-&gt;delivery_time_s.month = temp-&gt;delivery_time_s.month;<br>\t\tp-&gt;delivery_time_s.day = temp-&gt;delivery_time_s.day;<br>\t\tp-&gt;delivery_time_s.hour = temp-&gt;delivery_time_s.hour;<br>\t\tp-&gt;delivery_time_s.minute = temp-&gt;delivery_time_s.minute;<br>\t\tp-&gt;delivery_time_e.month = temp-&gt;delivery_time_e.month;<br>\t\tp-&gt;delivery_time_e.day = temp-&gt;delivery_time_e.day;<br>\t\tp-&gt;delivery_time_e.hour = temp-&gt;delivery_time_e.hour;<br>\t\tp-&gt;delivery_time_e.minute = temp-&gt;delivery_time_e.minute;<br>\t\tlast-&gt;next = p;<br>\t\tlast = last-&gt;next;<br>\t\tlast-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\tfclose(fp_l);<br>\t<span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">LISTDISH *<span class=\"hljs-title function_\">read_inf_ld</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> id)</span> <span class=\"hljs-comment\">//Read the Information of List-Dish linklist</span><br>&#123;<br>\tLISTDISH *head = (LISTDISH *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LISTDISH))<br>\t, *last = head, *p, *temp = (LISTDISH *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LISTDISH));<br>\thead-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\tFILE *fp_ld;<br>\tfp_ld = fopen(<span class=\"hljs-string\">&quot;D:\\\\小学期\\\\listdish.txt&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>);<br>\t<span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">if</span> (id != <span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-keyword\">while</span> (cnt != id)<br>\t\t&#123;<br><br>\t\t\ttemp-&gt;dish_id = <span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-keyword\">while</span> (temp-&gt;dish_id != <span class=\"hljs-number\">-1</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">fscanf</span>(fp_ld, <span class=\"hljs-string\">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);<br>\t\t\t&#125;<br>\t\t\tcnt++;<br>\t\t&#125;<br>\t<span class=\"hljs-built_in\">fscanf</span>(fp_ld, <span class=\"hljs-string\">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);<br>\t<span class=\"hljs-keyword\">while</span> (temp-&gt;dish_id != <span class=\"hljs-number\">-1</span>)<br>\t&#123;<br>\t\tp = (LISTDISH *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(LISTDISH));<br>\t\tp-&gt;dish_id = temp-&gt;dish_id;<br>\t\tp-&gt;number = temp-&gt;number;<br>\t\tlast-&gt;next = p;<br>\t\tlast = last-&gt;next;<br>\t\tlast-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t\t<span class=\"hljs-built_in\">fscanf</span>(fp_ld, <span class=\"hljs-string\">&quot;%d %d &quot;</span>, &amp;temp-&gt;dish_id, &amp;temp-&gt;number);<br>\t&#125;<br>\tfclose(fp_ld);<br>\t<span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>比如要读取第三个订单所点菜品信息，传入read_inf_ld()的number订单号为3.<code>int cnt = 1</code>代表当前文件指针读取的订单号，从1开始计数，每次读到-1 -1证明又读完了一单，cnt++，直到cnt == number为止。然后读取接下来的这个链表，最后返回头结点，作为该订单中的一个成员。<br><img src=\"https://img-blog.csdnimg.cn/6b66117ee8b641998ea580f57da912ee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">RECOMMEND *<span class=\"hljs-title function_\">read_inf_recommend</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> id)</span><br>&#123;<br>\tRECOMMEND *head = (RECOMMEND *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(RECOMMEND)),*last=head<br>\t,*p,*temp = (RECOMMEND *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(RECOMMEND));<br>\thead-&gt;next=<span class=\"hljs-literal\">NULL</span>;<br>\tFILE *fp_recommend = fopen(<span class=\"hljs-string\">&quot;D:\\\\小学期\\\\recommend.txt&quot;</span>, <span class=\"hljs-string\">&quot;r&quot;</span>); <br>\t<span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (id != <span class=\"hljs-number\">0</span>)<br>        <span class=\"hljs-keyword\">while</span> (cnt != id)<br>        &#123;<br>            <span class=\"hljs-built_in\">strcpy</span>(temp-&gt;dish_name,<span class=\"hljs-string\">&quot;0&quot;</span>);<br>            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">strcmp</span>(temp-&gt;dish_name , <span class=\"hljs-string\">&quot;-1&quot;</span>)!=<span class=\"hljs-number\">0</span>)<br>            &#123;<br>                <span class=\"hljs-built_in\">fscanf</span>(fp_recommend, <span class=\"hljs-string\">&quot;%s &quot;</span>, temp-&gt;dish_name);<br>            &#125;<br>            cnt++;<br>        &#125;<br>    <span class=\"hljs-built_in\">fscanf</span>(fp_recommend, <span class=\"hljs-string\">&quot;%s &quot;</span>, temp-&gt;dish_name);<br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">strcmp</span>(temp-&gt;dish_name ,<span class=\"hljs-string\">&quot;-1&quot;</span>)!=<span class=\"hljs-number\">0</span>)<br>    &#123;<br>        p = (RECOMMEND *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(RECOMMEND));<br>        <span class=\"hljs-built_in\">strcpy</span>(p-&gt;dish_name, temp-&gt;dish_name);<br>        last-&gt;next = p;<br>        last = last-&gt;next;<br>        last-&gt;next=<span class=\"hljs-literal\">NULL</span>;<br>        <span class=\"hljs-built_in\">fscanf</span>(fp_recommend, <span class=\"hljs-string\">&quot;%s &quot;</span>, temp-&gt;dish_name);<br>    &#125;<br>\tfclose(fp_recommend);<br>\t<span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>读取推荐菜品链表也是类似。<br>得到的链表全都包括头结点（里链表也是），不包含结尾的-1，只要通过-&gt;-&gt;就能访问hh。<br>总之，结束了~</p>\n"},{"title":"微信开发者工具和gitee实现多人协作","date":"2022-03-26T16:00:00.000Z","_content":"\n将代码上传到码云实现多人合作开发。\n\n<h1>1. gitee</h1>\n\n首先进入gitee，注册一个账号。\n\n新建一个仓库：\n\n![image-20220327012843219](https://img-blog.csdnimg.cn/5abc8daf23a342a3906c4111e0b2d950.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n输入仓库名称，设置为私有，初始化、模板、分支模型都可以不添加。\n\n点击创建，就建好了一个新的仓库。\n\n![image-20220327013057263](https://img-blog.csdnimg.cn/0f17a2379dd44d23a084ad3df7373c6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n这里可以看到仓库的https地址，一会会用到。\n\n因为一会直接将小程序代码文件放进来，暂时先不用添加文件。\n\n<h1>2. git</h1>\n\ngit是一个开源的分布式版本控制系统，可以高效地实现版本控制。\n\n<h2>下载</h2>\n\n[从官网上下载git](https://git-scm.com/downloads)。\n\n<h2>注册</h2>\n\n下载完成后在任意目录下右键，都会出现git GUI here和git Bash here.\n\n点击git Bash here，在当前目录下开启命令行：\n\n![image-20220327013749178](https://img-blog.csdnimg.cn/2896c2473b5c4d428995b6deb13f0e81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n输入：\n\n```\ngit config --global user.name '要注册的git用户名，不可以是中文'\ngit config --global user.email 'gitee的邮箱'\n```\n\n注册完成。\n\n<h2>克隆远程仓库</h2>\n\n首先新建一个想要放克隆下来的仓库内容的文件夹，进入该文件夹下。可以直接双击打开文件夹后右键git Bash here，也可以在命令行中使用cd进入文件夹目录下。\n\n复制新建仓库的https地址：\n\n```\ngit clong '仓库的https地址，如https://github.com/username/try.git'\n```\n\n如果克隆的是有内容的仓库，这时就应该可以看到文件夹内出现了仓库里的文件。\n\n仓库是空，可能会出现warning字样，问题不大。\n\n然后就可以对内容进行一些修改，项目的开发。\n\n<h2>推送</h2>\n\n修改完后要将本地的代码推送到远程仓库。首先提交到本地仓库。通过add添加要提交的文件：\n\n```\ngit add .\n```\n\nadd后面加.的意思是把所有做过修改的文件都添加。如果只想添加部分新修改的文件，add后面根具体的文件名即可。\n\n再将添加的文件提交：\n\n```\ngit commit -m '备注，如：提交了app.json文件'\n```\n\n若出现`1 file changed`之类的字样，说明成功提交到了本地仓库。\n\n最后输入以下代码提交：\n\n```\ngit push origin master\n```\n\ngitee默认分支是master，github默认分支是main，需要先修改分支为main后提交`git branch -M main`\n\n出现'done'的字样说明成功。\n\n回到码云仓库，刷新一下，就可以看到新增的文件，以及还会显示commit的内容。\n\n![image-20220327015550566](https://img-blog.csdnimg.cn/97f5848e7a34432fbc24d38f3846595c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n*这里出现了不同的commit，是博主在不同时间做的不同修改。*\n\n<h1>3. 微信开发者工具</h1>\n\n通过微信开发者工具，可以不使用命令行操作，直接拉取、推送代码。\n\n打开对应小程序文件夹，点击右上角版本管理，左侧栏如下：\n\n![image-20220327015735281](https://img-blog.csdnimg.cn/d0e8f12d8b954f11bdd936a70434fe2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_7,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n首先要在设置中进行认证。点击设置--网络和认证\n\n![image-20220327015821950](https://img-blog.csdnimg.cn/ab9f812446f34fab95604669296032c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n输入码云的gitee账号和密码。\n\n博主和朋友尝试将代码上传到github上时，一直在这里有问题。明明用户名和密码正确，推送却会卡住或者显示认证失败。而换成码云就非常顺利。因此更建议使用码云新建仓库、上传代码。\n\n然后在 远程 中新建仓库信息\n\n![image-20220327020101940](https://img-blog.csdnimg.cn/812100ec678b42e1985baf1e9357ab2d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n名称就是仓库名称，url是https的仓库地址。\n\n设置完成后就可以点击左上角抓取远程仓库内容到本地仓库。\n\n\n\n对于修改后的文件以及提交，在工作区进行：\n\n![image-20220327020242959](https://img-blog.csdnimg.cn/d24162c54f604021b31b77586716a8c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n这里右边上面勾选文件，就相当于git里的add添加文件。下面的提交就相当于commit。输入信息后点击提交，就上传到本地仓库了。\n\n然后点击左上角推送，**不要推送到新的分支，勾选中间项：推送到一下远程分支**。这一部相当于git的push。\n\n![image-20220327020458850](https://img-blog.csdnimg.cn/ec5c7bc3581a457cb4ccf654aa10e995.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n点击确定，出现对号就说明成功。接着可以在仓库中刷新看到新的修改。\n\n","source":"_posts/微信开发者工具和gitee实现多人协作.md","raw":"---\ntitle: 微信开发者工具和gitee实现多人协作\ndate: 2022-03-27\ntags: problems\ncategory: projects\n---\n\n将代码上传到码云实现多人合作开发。\n\n<h1>1. gitee</h1>\n\n首先进入gitee，注册一个账号。\n\n新建一个仓库：\n\n![image-20220327012843219](https://img-blog.csdnimg.cn/5abc8daf23a342a3906c4111e0b2d950.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n输入仓库名称，设置为私有，初始化、模板、分支模型都可以不添加。\n\n点击创建，就建好了一个新的仓库。\n\n![image-20220327013057263](https://img-blog.csdnimg.cn/0f17a2379dd44d23a084ad3df7373c6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n这里可以看到仓库的https地址，一会会用到。\n\n因为一会直接将小程序代码文件放进来，暂时先不用添加文件。\n\n<h1>2. git</h1>\n\ngit是一个开源的分布式版本控制系统，可以高效地实现版本控制。\n\n<h2>下载</h2>\n\n[从官网上下载git](https://git-scm.com/downloads)。\n\n<h2>注册</h2>\n\n下载完成后在任意目录下右键，都会出现git GUI here和git Bash here.\n\n点击git Bash here，在当前目录下开启命令行：\n\n![image-20220327013749178](https://img-blog.csdnimg.cn/2896c2473b5c4d428995b6deb13f0e81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n输入：\n\n```\ngit config --global user.name '要注册的git用户名，不可以是中文'\ngit config --global user.email 'gitee的邮箱'\n```\n\n注册完成。\n\n<h2>克隆远程仓库</h2>\n\n首先新建一个想要放克隆下来的仓库内容的文件夹，进入该文件夹下。可以直接双击打开文件夹后右键git Bash here，也可以在命令行中使用cd进入文件夹目录下。\n\n复制新建仓库的https地址：\n\n```\ngit clong '仓库的https地址，如https://github.com/username/try.git'\n```\n\n如果克隆的是有内容的仓库，这时就应该可以看到文件夹内出现了仓库里的文件。\n\n仓库是空，可能会出现warning字样，问题不大。\n\n然后就可以对内容进行一些修改，项目的开发。\n\n<h2>推送</h2>\n\n修改完后要将本地的代码推送到远程仓库。首先提交到本地仓库。通过add添加要提交的文件：\n\n```\ngit add .\n```\n\nadd后面加.的意思是把所有做过修改的文件都添加。如果只想添加部分新修改的文件，add后面根具体的文件名即可。\n\n再将添加的文件提交：\n\n```\ngit commit -m '备注，如：提交了app.json文件'\n```\n\n若出现`1 file changed`之类的字样，说明成功提交到了本地仓库。\n\n最后输入以下代码提交：\n\n```\ngit push origin master\n```\n\ngitee默认分支是master，github默认分支是main，需要先修改分支为main后提交`git branch -M main`\n\n出现'done'的字样说明成功。\n\n回到码云仓库，刷新一下，就可以看到新增的文件，以及还会显示commit的内容。\n\n![image-20220327015550566](https://img-blog.csdnimg.cn/97f5848e7a34432fbc24d38f3846595c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n*这里出现了不同的commit，是博主在不同时间做的不同修改。*\n\n<h1>3. 微信开发者工具</h1>\n\n通过微信开发者工具，可以不使用命令行操作，直接拉取、推送代码。\n\n打开对应小程序文件夹，点击右上角版本管理，左侧栏如下：\n\n![image-20220327015735281](https://img-blog.csdnimg.cn/d0e8f12d8b954f11bdd936a70434fe2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_7,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n首先要在设置中进行认证。点击设置--网络和认证\n\n![image-20220327015821950](https://img-blog.csdnimg.cn/ab9f812446f34fab95604669296032c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n输入码云的gitee账号和密码。\n\n博主和朋友尝试将代码上传到github上时，一直在这里有问题。明明用户名和密码正确，推送却会卡住或者显示认证失败。而换成码云就非常顺利。因此更建议使用码云新建仓库、上传代码。\n\n然后在 远程 中新建仓库信息\n\n![image-20220327020101940](https://img-blog.csdnimg.cn/812100ec678b42e1985baf1e9357ab2d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n名称就是仓库名称，url是https的仓库地址。\n\n设置完成后就可以点击左上角抓取远程仓库内容到本地仓库。\n\n\n\n对于修改后的文件以及提交，在工作区进行：\n\n![image-20220327020242959](https://img-blog.csdnimg.cn/d24162c54f604021b31b77586716a8c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n这里右边上面勾选文件，就相当于git里的add添加文件。下面的提交就相当于commit。输入信息后点击提交，就上传到本地仓库了。\n\n然后点击左上角推送，**不要推送到新的分支，勾选中间项：推送到一下远程分支**。这一部相当于git的push。\n\n![image-20220327020458850](https://img-blog.csdnimg.cn/ec5c7bc3581a457cb4ccf654aa10e995.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n点击确定，出现对号就说明成功。接着可以在仓库中刷新看到新的修改。\n\n","slug":"微信开发者工具和gitee实现多人协作","published":1,"updated":"2022-04-18T03:36:46.885Z","_id":"cl186hpxq0000vgv2fovs52rg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>将代码上传到码云实现多人合作开发。</p>\n<h1>1. gitee</h1>\n\n<p>首先进入gitee，注册一个账号。</p>\n<p>新建一个仓库：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5abc8daf23a342a3906c4111e0b2d950.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327012843219\"></p>\n<p>输入仓库名称，设置为私有，初始化、模板、分支模型都可以不添加。</p>\n<p>点击创建，就建好了一个新的仓库。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0f17a2379dd44d23a084ad3df7373c6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327013057263\"></p>\n<p>这里可以看到仓库的https地址，一会会用到。</p>\n<p>因为一会直接将小程序代码文件放进来，暂时先不用添加文件。</p>\n<h1>2. git</h1>\n\n<p>git是一个开源的分布式版本控制系统，可以高效地实现版本控制。</p>\n<h2>下载</h2>\n\n<p><a href=\"https://git-scm.com/downloads\">从官网上下载git</a>。</p>\n<h2>注册</h2>\n\n<p>下载完成后在任意目录下右键，都会出现git GUI here和git Bash here.</p>\n<p>点击git Bash here，在当前目录下开启命令行：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2896c2473b5c4d428995b6deb13f0e81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327013749178\"></p>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git config --global user.name &#x27;要注册的git用户名，不可以是中文&#x27;<br>git config --global user.email &#x27;gitee的邮箱&#x27;<br></code></pre></td></tr></table></figure>\n\n<p>注册完成。</p>\n<h2>克隆远程仓库</h2>\n\n<p>首先新建一个想要放克隆下来的仓库内容的文件夹，进入该文件夹下。可以直接双击打开文件夹后右键git Bash here，也可以在命令行中使用cd进入文件夹目录下。</p>\n<p>复制新建仓库的https地址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git clong &#x27;仓库的https地址，如https://github.com/username/try.git&#x27;<br></code></pre></td></tr></table></figure>\n\n<p>如果克隆的是有内容的仓库，这时就应该可以看到文件夹内出现了仓库里的文件。</p>\n<p>仓库是空，可能会出现warning字样，问题不大。</p>\n<p>然后就可以对内容进行一些修改，项目的开发。</p>\n<h2>推送</h2>\n\n<p>修改完后要将本地的代码推送到远程仓库。首先提交到本地仓库。通过add添加要提交的文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git add .<br></code></pre></td></tr></table></figure>\n\n<p>add后面加.的意思是把所有做过修改的文件都添加。如果只想添加部分新修改的文件，add后面根具体的文件名即可。</p>\n<p>再将添加的文件提交：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git commit -m &#x27;备注，如：提交了app.json文件&#x27;<br></code></pre></td></tr></table></figure>\n\n<p>若出现<code>1 file changed</code>之类的字样，说明成功提交到了本地仓库。</p>\n<p>最后输入以下代码提交：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git push origin master<br></code></pre></td></tr></table></figure>\n\n<p>gitee默认分支是master，github默认分支是main，需要先修改分支为main后提交<code>git branch -M main</code></p>\n<p>出现’done’的字样说明成功。</p>\n<p>回到码云仓库，刷新一下，就可以看到新增的文件，以及还会显示commit的内容。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/97f5848e7a34432fbc24d38f3846595c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327015550566\"></p>\n<p><em>这里出现了不同的commit，是博主在不同时间做的不同修改。</em></p>\n<h1>3. 微信开发者工具</h1>\n\n<p>通过微信开发者工具，可以不使用命令行操作，直接拉取、推送代码。</p>\n<p>打开对应小程序文件夹，点击右上角版本管理，左侧栏如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d0e8f12d8b954f11bdd936a70434fe2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_7,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327015735281\"></p>\n<p>首先要在设置中进行认证。点击设置–网络和认证</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ab9f812446f34fab95604669296032c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327015821950\"></p>\n<p>输入码云的gitee账号和密码。</p>\n<p>博主和朋友尝试将代码上传到github上时，一直在这里有问题。明明用户名和密码正确，推送却会卡住或者显示认证失败。而换成码云就非常顺利。因此更建议使用码云新建仓库、上传代码。</p>\n<p>然后在 远程 中新建仓库信息</p>\n<p><img src=\"https://img-blog.csdnimg.cn/812100ec678b42e1985baf1e9357ab2d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327020101940\"></p>\n<p>名称就是仓库名称，url是https的仓库地址。</p>\n<p>设置完成后就可以点击左上角抓取远程仓库内容到本地仓库。</p>\n<p>对于修改后的文件以及提交，在工作区进行：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d24162c54f604021b31b77586716a8c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327020242959\"></p>\n<p>这里右边上面勾选文件，就相当于git里的add添加文件。下面的提交就相当于commit。输入信息后点击提交，就上传到本地仓库了。</p>\n<p>然后点击左上角推送，<strong>不要推送到新的分支，勾选中间项：推送到一下远程分支</strong>。这一部相当于git的push。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ec5c7bc3581a457cb4ccf654aa10e995.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327020458850\"></p>\n<p>点击确定，出现对号就说明成功。接着可以在仓库中刷新看到新的修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>将代码上传到码云实现多人合作开发。</p>\n<h1>1. gitee</h1>\n\n<p>首先进入gitee，注册一个账号。</p>\n<p>新建一个仓库：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5abc8daf23a342a3906c4111e0b2d950.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327012843219\"></p>\n<p>输入仓库名称，设置为私有，初始化、模板、分支模型都可以不添加。</p>\n<p>点击创建，就建好了一个新的仓库。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0f17a2379dd44d23a084ad3df7373c6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327013057263\"></p>\n<p>这里可以看到仓库的https地址，一会会用到。</p>\n<p>因为一会直接将小程序代码文件放进来，暂时先不用添加文件。</p>\n<h1>2. git</h1>\n\n<p>git是一个开源的分布式版本控制系统，可以高效地实现版本控制。</p>\n<h2>下载</h2>\n\n<p><a href=\"https://git-scm.com/downloads\">从官网上下载git</a>。</p>\n<h2>注册</h2>\n\n<p>下载完成后在任意目录下右键，都会出现git GUI here和git Bash here.</p>\n<p>点击git Bash here，在当前目录下开启命令行：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2896c2473b5c4d428995b6deb13f0e81.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327013749178\"></p>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git config --global user.name &#x27;要注册的git用户名，不可以是中文&#x27;<br>git config --global user.email &#x27;gitee的邮箱&#x27;<br></code></pre></td></tr></table></figure>\n\n<p>注册完成。</p>\n<h2>克隆远程仓库</h2>\n\n<p>首先新建一个想要放克隆下来的仓库内容的文件夹，进入该文件夹下。可以直接双击打开文件夹后右键git Bash here，也可以在命令行中使用cd进入文件夹目录下。</p>\n<p>复制新建仓库的https地址：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git clong &#x27;仓库的https地址，如https://github.com/username/try.git&#x27;<br></code></pre></td></tr></table></figure>\n\n<p>如果克隆的是有内容的仓库，这时就应该可以看到文件夹内出现了仓库里的文件。</p>\n<p>仓库是空，可能会出现warning字样，问题不大。</p>\n<p>然后就可以对内容进行一些修改，项目的开发。</p>\n<h2>推送</h2>\n\n<p>修改完后要将本地的代码推送到远程仓库。首先提交到本地仓库。通过add添加要提交的文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git add .<br></code></pre></td></tr></table></figure>\n\n<p>add后面加.的意思是把所有做过修改的文件都添加。如果只想添加部分新修改的文件，add后面根具体的文件名即可。</p>\n<p>再将添加的文件提交：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git commit -m &#x27;备注，如：提交了app.json文件&#x27;<br></code></pre></td></tr></table></figure>\n\n<p>若出现<code>1 file changed</code>之类的字样，说明成功提交到了本地仓库。</p>\n<p>最后输入以下代码提交：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git push origin master<br></code></pre></td></tr></table></figure>\n\n<p>gitee默认分支是master，github默认分支是main，需要先修改分支为main后提交<code>git branch -M main</code></p>\n<p>出现’done’的字样说明成功。</p>\n<p>回到码云仓库，刷新一下，就可以看到新增的文件，以及还会显示commit的内容。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/97f5848e7a34432fbc24d38f3846595c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327015550566\"></p>\n<p><em>这里出现了不同的commit，是博主在不同时间做的不同修改。</em></p>\n<h1>3. 微信开发者工具</h1>\n\n<p>通过微信开发者工具，可以不使用命令行操作，直接拉取、推送代码。</p>\n<p>打开对应小程序文件夹，点击右上角版本管理，左侧栏如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d0e8f12d8b954f11bdd936a70434fe2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_7,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327015735281\"></p>\n<p>首先要在设置中进行认证。点击设置–网络和认证</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ab9f812446f34fab95604669296032c3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327015821950\"></p>\n<p>输入码云的gitee账号和密码。</p>\n<p>博主和朋友尝试将代码上传到github上时，一直在这里有问题。明明用户名和密码正确，推送却会卡住或者显示认证失败。而换成码云就非常顺利。因此更建议使用码云新建仓库、上传代码。</p>\n<p>然后在 远程 中新建仓库信息</p>\n<p><img src=\"https://img-blog.csdnimg.cn/812100ec678b42e1985baf1e9357ab2d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_11,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327020101940\"></p>\n<p>名称就是仓库名称，url是https的仓库地址。</p>\n<p>设置完成后就可以点击左上角抓取远程仓库内容到本地仓库。</p>\n<p>对于修改后的文件以及提交，在工作区进行：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d24162c54f604021b31b77586716a8c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327020242959\"></p>\n<p>这里右边上面勾选文件，就相当于git里的add添加文件。下面的提交就相当于commit。输入信息后点击提交，就上传到本地仓库了。</p>\n<p>然后点击左上角推送，<strong>不要推送到新的分支，勾选中间项：推送到一下远程分支</strong>。这一部相当于git的push。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ec5c7bc3581a457cb4ccf654aa10e995.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6JCo56eR5aGU6LWE5rex5bmy5ZGY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image-20220327020458850\"></p>\n<p>点击确定，出现对号就说明成功。接着可以在仓库中刷新看到新的修改。</p>\n"},{"title":"Java 学习博客_1 介绍与安装","date":"2022-04-13T16:00:00.000Z","_content":"\n以黑马程序员网课为主。\n\n## 介绍\n\nJava是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。\n\nJVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。\n\nJRE: Java Runtime Environment，运行只需要 JRE 就够了。\n\nJDK: Java Development Kit，Java 程序开发工具包。\n\n![123](https://s1.328888.xyz/2022/04/14/iUcNe.png)\n\n尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~\n\nJDK 的安装目录如下：\n\n| JDK目录名称 | 说明                                |\n| ----------- | ----------------------------------- |\n| bin         | 存放工具命令，如：javac, java, etc. |\n| conf        | 配置文件                            |\n| include     | 某些平台特定的头文件                |\n| jmods       | 模块                                |\n| legal       | 授权文档                            |\n| lib         | 补充 JAR 包                         |\n| 其他        | 说明型文档                          |\n\n## 在 DOS 窗口下操作命令\n\n在一开始没有使用 IDEA 等集成开发环境的时候，直接在 DOS ( Disk Operating System ) 窗口运行。Windows 通过 `win+R` 打开运行窗口，输入 `cmd` 进入 DOS 窗口。\n\n常用的DOS窗口命令：\n\n| 操作                   | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| `盘符名称`+`:`，如`D:` | 切换到该盘                                                   |\n| `dir`                  | 查看当前路径下的内容                                         |\n| `cd 目录`，如`cd java` | 进入当前路径下的一个单级目录（cd 是 change directory 的意思） |\n| `cd ..`                | 回退到上一级目录                                             |\n| `cd 目录1\\目录2\\..`    | 一次性进入多级目录                                           |\n| `cd \\`                 | 回退到盘符目录                                               |\n| `cls`                  | 清屏                                                         |\n| `exit`                 | 退出 DOS 窗口                                                |\n\n## 配置 PATH 环境变量\n\n不得不说虽然之前学习其他语言的时候也做过很多次配置 PATH 环境变量的操作，但是这次才算理解一些意义。\n\n开发 Java 的时候是肯定会用到 JDK 里的开发工具的，比如编译的 `javac` ，运行的 `java`。\n\n但是没有配置环境变量的时候，cmd 无法直接使用 javac 文件，因为不知道 `javac.exe` 的路径。\n\n所以需要输入 `\"JDK文件的目录\\bin\\javac.exe\" 需要编译的文件的目录\\需要编译的文件.java` （可以把 javac 和 java 文件直接拖进去，就会自动生成目录）相当麻烦。\n\n配置环境变量之后，直接在 cmd 窗口里输入 `javac 需要编译的文件.java` 就能编译。\n\n配置方法：（ Windows 系统）\n\n① 此电脑 -- 属性 -- 高级系统设置 -- 环境变量，新建一个用户变量（建议命名和 Java 相关），并放入 JDK 文件夹的路径\n\n② 在下方系统变量中选中 Path 变量 -- 编辑 -- 新建 -- 命名（建议命名和 Java 相关），并放入 JDK 内 bin 文件夹的路径。\n\n最后在DOS中输入`javac`，如果显示使用 javac 的提示信息说明配置成功。","source":"_posts/Java 学习博客_1 介绍与安装.md","raw":"---\ntitle: Java 学习博客_1 介绍与安装\ndate: 2022-04-14\ntags: study\ncategory: java\n---\n\n以黑马程序员网课为主。\n\n## 介绍\n\nJava是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。\n\nJVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。\n\nJRE: Java Runtime Environment，运行只需要 JRE 就够了。\n\nJDK: Java Development Kit，Java 程序开发工具包。\n\n![123](https://s1.328888.xyz/2022/04/14/iUcNe.png)\n\n尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~\n\nJDK 的安装目录如下：\n\n| JDK目录名称 | 说明                                |\n| ----------- | ----------------------------------- |\n| bin         | 存放工具命令，如：javac, java, etc. |\n| conf        | 配置文件                            |\n| include     | 某些平台特定的头文件                |\n| jmods       | 模块                                |\n| legal       | 授权文档                            |\n| lib         | 补充 JAR 包                         |\n| 其他        | 说明型文档                          |\n\n## 在 DOS 窗口下操作命令\n\n在一开始没有使用 IDEA 等集成开发环境的时候，直接在 DOS ( Disk Operating System ) 窗口运行。Windows 通过 `win+R` 打开运行窗口，输入 `cmd` 进入 DOS 窗口。\n\n常用的DOS窗口命令：\n\n| 操作                   | 说明                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| `盘符名称`+`:`，如`D:` | 切换到该盘                                                   |\n| `dir`                  | 查看当前路径下的内容                                         |\n| `cd 目录`，如`cd java` | 进入当前路径下的一个单级目录（cd 是 change directory 的意思） |\n| `cd ..`                | 回退到上一级目录                                             |\n| `cd 目录1\\目录2\\..`    | 一次性进入多级目录                                           |\n| `cd \\`                 | 回退到盘符目录                                               |\n| `cls`                  | 清屏                                                         |\n| `exit`                 | 退出 DOS 窗口                                                |\n\n## 配置 PATH 环境变量\n\n不得不说虽然之前学习其他语言的时候也做过很多次配置 PATH 环境变量的操作，但是这次才算理解一些意义。\n\n开发 Java 的时候是肯定会用到 JDK 里的开发工具的，比如编译的 `javac` ，运行的 `java`。\n\n但是没有配置环境变量的时候，cmd 无法直接使用 javac 文件，因为不知道 `javac.exe` 的路径。\n\n所以需要输入 `\"JDK文件的目录\\bin\\javac.exe\" 需要编译的文件的目录\\需要编译的文件.java` （可以把 javac 和 java 文件直接拖进去，就会自动生成目录）相当麻烦。\n\n配置环境变量之后，直接在 cmd 窗口里输入 `javac 需要编译的文件.java` 就能编译。\n\n配置方法：（ Windows 系统）\n\n① 此电脑 -- 属性 -- 高级系统设置 -- 环境变量，新建一个用户变量（建议命名和 Java 相关），并放入 JDK 文件夹的路径\n\n② 在下方系统变量中选中 Path 变量 -- 编辑 -- 新建 -- 命名（建议命名和 Java 相关），并放入 JDK 内 bin 文件夹的路径。\n\n最后在DOS中输入`javac`，如果显示使用 javac 的提示信息说明配置成功。","slug":"Java 学习博客_1 介绍与安装","published":1,"updated":"2022-04-18T03:37:11.098Z","_id":"cl245sb4z0000s0v20g663k5p","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以黑马程序员网课为主。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Java是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。</p>\n<p>JVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。</p>\n<p>JRE: Java Runtime Environment，运行只需要 JRE 就够了。</p>\n<p>JDK: Java Development Kit，Java 程序开发工具包。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/14/iUcNe.png\" alt=\"123\"></p>\n<p>尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~</p>\n<p>JDK 的安装目录如下：</p>\n<table>\n<thead>\n<tr>\n<th>JDK目录名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bin</td>\n<td>存放工具命令，如：javac, java, etc.</td>\n</tr>\n<tr>\n<td>conf</td>\n<td>配置文件</td>\n</tr>\n<tr>\n<td>include</td>\n<td>某些平台特定的头文件</td>\n</tr>\n<tr>\n<td>jmods</td>\n<td>模块</td>\n</tr>\n<tr>\n<td>legal</td>\n<td>授权文档</td>\n</tr>\n<tr>\n<td>lib</td>\n<td>补充 JAR 包</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>说明型文档</td>\n</tr>\n</tbody></table>\n<h2 id=\"在-DOS-窗口下操作命令\"><a href=\"#在-DOS-窗口下操作命令\" class=\"headerlink\" title=\"在 DOS 窗口下操作命令\"></a>在 DOS 窗口下操作命令</h2><p>在一开始没有使用 IDEA 等集成开发环境的时候，直接在 DOS ( Disk Operating System ) 窗口运行。Windows 通过 <code>win+R</code> 打开运行窗口，输入 <code>cmd</code> 进入 DOS 窗口。</p>\n<p>常用的DOS窗口命令：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>盘符名称</code>+<code>:</code>，如<code>D:</code></td>\n<td>切换到该盘</td>\n</tr>\n<tr>\n<td><code>dir</code></td>\n<td>查看当前路径下的内容</td>\n</tr>\n<tr>\n<td><code>cd 目录</code>，如<code>cd java</code></td>\n<td>进入当前路径下的一个单级目录（cd 是 change directory 的意思）</td>\n</tr>\n<tr>\n<td><code>cd ..</code></td>\n<td>回退到上一级目录</td>\n</tr>\n<tr>\n<td><code>cd 目录1\\目录2\\..</code></td>\n<td>一次性进入多级目录</td>\n</tr>\n<tr>\n<td><code>cd \\</code></td>\n<td>回退到盘符目录</td>\n</tr>\n<tr>\n<td><code>cls</code></td>\n<td>清屏</td>\n</tr>\n<tr>\n<td><code>exit</code></td>\n<td>退出 DOS 窗口</td>\n</tr>\n</tbody></table>\n<h2 id=\"配置-PATH-环境变量\"><a href=\"#配置-PATH-环境变量\" class=\"headerlink\" title=\"配置 PATH 环境变量\"></a>配置 PATH 环境变量</h2><p>不得不说虽然之前学习其他语言的时候也做过很多次配置 PATH 环境变量的操作，但是这次才算理解一些意义。</p>\n<p>开发 Java 的时候是肯定会用到 JDK 里的开发工具的，比如编译的 <code>javac</code> ，运行的 <code>java</code>。</p>\n<p>但是没有配置环境变量的时候，cmd 无法直接使用 javac 文件，因为不知道 <code>javac.exe</code> 的路径。</p>\n<p>所以需要输入 <code>&quot;JDK文件的目录\\bin\\javac.exe&quot; 需要编译的文件的目录\\需要编译的文件.java</code> （可以把 javac 和 java 文件直接拖进去，就会自动生成目录）相当麻烦。</p>\n<p>配置环境变量之后，直接在 cmd 窗口里输入 <code>javac 需要编译的文件.java</code> 就能编译。</p>\n<p>配置方法：（ Windows 系统）</p>\n<p>① 此电脑 – 属性 – 高级系统设置 – 环境变量，新建一个用户变量（建议命名和 Java 相关），并放入 JDK 文件夹的路径</p>\n<p>② 在下方系统变量中选中 Path 变量 – 编辑 – 新建 – 命名（建议命名和 Java 相关），并放入 JDK 内 bin 文件夹的路径。</p>\n<p>最后在DOS中输入<code>javac</code>，如果显示使用 javac 的提示信息说明配置成功。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员网课为主。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Java是一个可以跨平台的语言，借助Java虚拟机（Java Virtual Machine, JVM）能够在任意操作系统（operating system, OS）上运行。</p>\n<p>JVM: Java Virtual Machine，在 JRE 的 bin 目录下。JVM 本质上是一个程序，使得 Java 在不同平台上运行时不需要重新编译，只需要执行保存在某字节码文件（.class）中的指令，不管什么平台，只要装有相应平台的 JVM ，字节码文件就可以在该平台上运行。</p>\n<p>JRE: Java Runtime Environment，运行只需要 JRE 就够了。</p>\n<p>JDK: Java Development Kit，Java 程序开发工具包。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/14/iUcNe.png\" alt=\"123\"></p>\n<p>尽管 JRE 对于运行 java 文件已经足够，作为学习肯定还是要下载 JDK 的~</p>\n<p>JDK 的安装目录如下：</p>\n<table>\n<thead>\n<tr>\n<th>JDK目录名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bin</td>\n<td>存放工具命令，如：javac, java, etc.</td>\n</tr>\n<tr>\n<td>conf</td>\n<td>配置文件</td>\n</tr>\n<tr>\n<td>include</td>\n<td>某些平台特定的头文件</td>\n</tr>\n<tr>\n<td>jmods</td>\n<td>模块</td>\n</tr>\n<tr>\n<td>legal</td>\n<td>授权文档</td>\n</tr>\n<tr>\n<td>lib</td>\n<td>补充 JAR 包</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>说明型文档</td>\n</tr>\n</tbody></table>\n<h2 id=\"在-DOS-窗口下操作命令\"><a href=\"#在-DOS-窗口下操作命令\" class=\"headerlink\" title=\"在 DOS 窗口下操作命令\"></a>在 DOS 窗口下操作命令</h2><p>在一开始没有使用 IDEA 等集成开发环境的时候，直接在 DOS ( Disk Operating System ) 窗口运行。Windows 通过 <code>win+R</code> 打开运行窗口，输入 <code>cmd</code> 进入 DOS 窗口。</p>\n<p>常用的DOS窗口命令：</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>盘符名称</code>+<code>:</code>，如<code>D:</code></td>\n<td>切换到该盘</td>\n</tr>\n<tr>\n<td><code>dir</code></td>\n<td>查看当前路径下的内容</td>\n</tr>\n<tr>\n<td><code>cd 目录</code>，如<code>cd java</code></td>\n<td>进入当前路径下的一个单级目录（cd 是 change directory 的意思）</td>\n</tr>\n<tr>\n<td><code>cd ..</code></td>\n<td>回退到上一级目录</td>\n</tr>\n<tr>\n<td><code>cd 目录1\\目录2\\..</code></td>\n<td>一次性进入多级目录</td>\n</tr>\n<tr>\n<td><code>cd \\</code></td>\n<td>回退到盘符目录</td>\n</tr>\n<tr>\n<td><code>cls</code></td>\n<td>清屏</td>\n</tr>\n<tr>\n<td><code>exit</code></td>\n<td>退出 DOS 窗口</td>\n</tr>\n</tbody></table>\n<h2 id=\"配置-PATH-环境变量\"><a href=\"#配置-PATH-环境变量\" class=\"headerlink\" title=\"配置 PATH 环境变量\"></a>配置 PATH 环境变量</h2><p>不得不说虽然之前学习其他语言的时候也做过很多次配置 PATH 环境变量的操作，但是这次才算理解一些意义。</p>\n<p>开发 Java 的时候是肯定会用到 JDK 里的开发工具的，比如编译的 <code>javac</code> ，运行的 <code>java</code>。</p>\n<p>但是没有配置环境变量的时候，cmd 无法直接使用 javac 文件，因为不知道 <code>javac.exe</code> 的路径。</p>\n<p>所以需要输入 <code>&quot;JDK文件的目录\\bin\\javac.exe&quot; 需要编译的文件的目录\\需要编译的文件.java</code> （可以把 javac 和 java 文件直接拖进去，就会自动生成目录）相当麻烦。</p>\n<p>配置环境变量之后，直接在 cmd 窗口里输入 <code>javac 需要编译的文件.java</code> 就能编译。</p>\n<p>配置方法：（ Windows 系统）</p>\n<p>① 此电脑 – 属性 – 高级系统设置 – 环境变量，新建一个用户变量（建议命名和 Java 相关），并放入 JDK 文件夹的路径</p>\n<p>② 在下方系统变量中选中 Path 变量 – 编辑 – 新建 – 命名（建议命名和 Java 相关），并放入 JDK 内 bin 文件夹的路径。</p>\n<p>最后在DOS中输入<code>javac</code>，如果显示使用 javac 的提示信息说明配置成功。</p>\n"},{"title":"Java 学习博客_2 入门——基础语法","date":"2022-04-13T16:00:00.000Z","_content":"\n## HelloWorld 案例\n\n学习的时候除了直接用记事本编辑，推荐使用 Notepad++ 。使用 Notepad++ 前需要设置：`设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI`。\n\n新建一个 HelloWorld.java 文件，通过记事本或 Notepad++ 编辑内容：\n\n```java\npublic class HelloWorld { //这里的 class 类名必须和文件名一致\n    public static void main(String[] args) { //main 方法\n        System.out.println(\"Hello World!\"); // 单独输出一行的意思。注意大小写不可以出错\n    }\n}\n```\n\n然后在DOS窗口中进入当前文件所在目录，输入命令：\n\n```\njavac HelloWorld.java //编译\njava HelloWorld //运行\n```\n\n这里可见，java 和 C、C++ 一样，属于编译型语言（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。\n\n如果顺利运行，就会输出 `Hello World!`。\n\n## Java 基础语法——主要与C语言比较有哪些不同\n\n### 注释\n\n单行注释 `//` 、多行注释 `/* */` 都和C一样。还有一个文件注释 `/** */`暂时用不到，之后了解。\n\n### 关键字\n\n字母全部小写。\n\n###### 数据类型：\n\n整数型：byte, short, int, long\n\n浮点型：float, double\n\n字符型：char\n\n布尔型：boolean\n\n变量的定义和 c 相似，`int a=10;` 不能重复定义和未初始化就使用。\n\n```java\nlong l=1000000L;\nfloat f=1.235F; //防止 long 类型和 float 类型不兼容\n```\n\n标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。\n\n*命名规范：*\n\n*方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法*\n\n*类名：大驼峰命名法*\n\n### 运算符\n\n+，-，*，/，%，\n\n+=，-=，*=，/=，%=（隐含了强制类型转换）\n\n++，--（和 C 不太一样！最好单独写，不要写在表达式中）\n\n==，>=，<=，>，<，!=\n\n? : \n\n&，|，^，!（逻辑运算符）\n\n&&，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）\n\n与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。\n\n```java\n1+99+\"string\" //\"100string\"\n\"string\"+1+99 //\"string199\"，从左往右计算\n```\n\n\n\n## 类型转换\n\n自动类型转换：把小范围的变量赋值给大范围的变量\n\n数据范围从小到大：\n\n![DataTypeRange](https://s1.328888.xyz/2022/04/14/iX6sR.png)\n\n算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。\n\n强制类型转换：赋值运算符中隐含。\n\n```java\nshort s=10;\t\t\ns+=10;\t\t\t//正常\ns=s+10;\t\t\t//错，因为右边发生了自动类型转换，变成了int型\ns=(short)(s+10);//也可以\n```\n\n\n\n\n\n","source":"_posts/Java 学习博客_2 入门——基础语法.md","raw":"---\ntitle: Java 学习博客_2 入门——基础语法\ndate: 2022-04-14\ntags: study\ncategory: java\n---\n\n## HelloWorld 案例\n\n学习的时候除了直接用记事本编辑，推荐使用 Notepad++ 。使用 Notepad++ 前需要设置：`设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI`。\n\n新建一个 HelloWorld.java 文件，通过记事本或 Notepad++ 编辑内容：\n\n```java\npublic class HelloWorld { //这里的 class 类名必须和文件名一致\n    public static void main(String[] args) { //main 方法\n        System.out.println(\"Hello World!\"); // 单独输出一行的意思。注意大小写不可以出错\n    }\n}\n```\n\n然后在DOS窗口中进入当前文件所在目录，输入命令：\n\n```\njavac HelloWorld.java //编译\njava HelloWorld //运行\n```\n\n这里可见，java 和 C、C++ 一样，属于编译型语言（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。\n\n如果顺利运行，就会输出 `Hello World!`。\n\n## Java 基础语法——主要与C语言比较有哪些不同\n\n### 注释\n\n单行注释 `//` 、多行注释 `/* */` 都和C一样。还有一个文件注释 `/** */`暂时用不到，之后了解。\n\n### 关键字\n\n字母全部小写。\n\n###### 数据类型：\n\n整数型：byte, short, int, long\n\n浮点型：float, double\n\n字符型：char\n\n布尔型：boolean\n\n变量的定义和 c 相似，`int a=10;` 不能重复定义和未初始化就使用。\n\n```java\nlong l=1000000L;\nfloat f=1.235F; //防止 long 类型和 float 类型不兼容\n```\n\n标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。\n\n*命名规范：*\n\n*方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法*\n\n*类名：大驼峰命名法*\n\n### 运算符\n\n+，-，*，/，%，\n\n+=，-=，*=，/=，%=（隐含了强制类型转换）\n\n++，--（和 C 不太一样！最好单独写，不要写在表达式中）\n\n==，>=，<=，>，<，!=\n\n? : \n\n&，|，^，!（逻辑运算符）\n\n&&，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）\n\n与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。\n\n```java\n1+99+\"string\" //\"100string\"\n\"string\"+1+99 //\"string199\"，从左往右计算\n```\n\n\n\n## 类型转换\n\n自动类型转换：把小范围的变量赋值给大范围的变量\n\n数据范围从小到大：\n\n![DataTypeRange](https://s1.328888.xyz/2022/04/14/iX6sR.png)\n\n算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。\n\n强制类型转换：赋值运算符中隐含。\n\n```java\nshort s=10;\t\t\ns+=10;\t\t\t//正常\ns=s+10;\t\t\t//错，因为右边发生了自动类型转换，变成了int型\ns=(short)(s+10);//也可以\n```\n\n\n\n\n\n","slug":"Java 学习博客_2 入门——基础语法","published":1,"updated":"2022-05-05T07:49:39.831Z","_id":"cl245sb560001s0v2bzx12eg8","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"HelloWorld-案例\"><a href=\"#HelloWorld-案例\" class=\"headerlink\" title=\"HelloWorld 案例\"></a>HelloWorld 案例</h2><p>学习的时候除了直接用记事本编辑，推荐使用 Notepad++ 。使用 Notepad++ 前需要设置：<code>设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI</code>。</p>\n<p>新建一个 HelloWorld.java 文件，通过记事本或 Notepad++ 编辑内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloWorld</span> &#123; <span class=\"hljs-comment\">//这里的 class 类名必须和文件名一致</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123; <span class=\"hljs-comment\">//main 方法</span><br>        System.out.println(<span class=\"hljs-string\">&quot;Hello World!&quot;</span>); <span class=\"hljs-comment\">// 单独输出一行的意思。注意大小写不可以出错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后在DOS窗口中进入当前文件所在目录，输入命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">javac HelloWorld.java //编译<br>java HelloWorld //运行<br></code></pre></td></tr></table></figure>\n\n<p>这里可见，java 和 C、C++ 一样，属于编译型语言（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。</p>\n<p>如果顺利运行，就会输出 <code>Hello World!</code>。</p>\n<h2 id=\"Java-基础语法——主要与C语言比较有哪些不同\"><a href=\"#Java-基础语法——主要与C语言比较有哪些不同\" class=\"headerlink\" title=\"Java 基础语法——主要与C语言比较有哪些不同\"></a>Java 基础语法——主要与C语言比较有哪些不同</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>单行注释 <code>//</code> 、多行注释 <code>/* */</code> 都和C一样。还有一个文件注释 <code>/** */</code>暂时用不到，之后了解。</p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>字母全部小写。</p>\n<h6 id=\"数据类型：\"><a href=\"#数据类型：\" class=\"headerlink\" title=\"数据类型：\"></a>数据类型：</h6><p>整数型：byte, short, int, long</p>\n<p>浮点型：float, double</p>\n<p>字符型：char</p>\n<p>布尔型：boolean</p>\n<p>变量的定义和 c 相似，<code>int a=10;</code> 不能重复定义和未初始化就使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> l=<span class=\"hljs-number\">1000000L</span>;<br><span class=\"hljs-type\">float</span> f=<span class=\"hljs-number\">1.235F</span>; <span class=\"hljs-comment\">//防止 long 类型和 float 类型不兼容</span><br></code></pre></td></tr></table></figure>\n\n<p>标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。</p>\n<p><em>命名规范：</em></p>\n<p><em>方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法</em></p>\n<p><em>类名：大驼峰命名法</em></p>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><p>+，-，*，/，%，</p>\n<p>+=，-=，*=，/=，%=（隐含了强制类型转换）</p>\n<p>++，–（和 C 不太一样！最好单独写，不要写在表达式中）</p>\n<p>==，&gt;=，&lt;=，&gt;，&lt;，!=</p>\n<p>? : </p>\n<p>&amp;，|，^，!（逻辑运算符）</p>\n<p>&amp;&amp;，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）</p>\n<p>与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">99</span>+<span class=\"hljs-string\">&quot;string&quot;</span> <span class=\"hljs-comment\">//&quot;100string&quot;</span><br><span class=\"hljs-string\">&quot;string&quot;</span>+<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">99</span> <span class=\"hljs-comment\">//&quot;string199&quot;，从左往右计算</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>自动类型转换：把小范围的变量赋值给大范围的变量</p>\n<p>数据范围从小到大：</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/14/iX6sR.png\" alt=\"DataTypeRange\"></p>\n<p>算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。</p>\n<p>强制类型转换：赋值运算符中隐含。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">short</span> s=<span class=\"hljs-number\">10</span>;\t\t<br>s+=<span class=\"hljs-number\">10</span>;\t\t\t<span class=\"hljs-comment\">//正常</span><br>s=s+<span class=\"hljs-number\">10</span>;\t\t\t<span class=\"hljs-comment\">//错，因为右边发生了自动类型转换，变成了int型</span><br>s=(<span class=\"hljs-type\">short</span>)(s+<span class=\"hljs-number\">10</span>);<span class=\"hljs-comment\">//也可以</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HelloWorld-案例\"><a href=\"#HelloWorld-案例\" class=\"headerlink\" title=\"HelloWorld 案例\"></a>HelloWorld 案例</h2><p>学习的时候除了直接用记事本编辑，推荐使用 Notepad++ 。使用 Notepad++ 前需要设置：<code>设置 -- 首选项 -- 新建 -- 默认语言：Java -- 编码 ANSI</code>。</p>\n<p>新建一个 HelloWorld.java 文件，通过记事本或 Notepad++ 编辑内容：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloWorld</span> &#123; <span class=\"hljs-comment\">//这里的 class 类名必须和文件名一致</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> &#123; <span class=\"hljs-comment\">//main 方法</span><br>        System.out.println(<span class=\"hljs-string\">&quot;Hello World!&quot;</span>); <span class=\"hljs-comment\">// 单独输出一行的意思。注意大小写不可以出错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后在DOS窗口中进入当前文件所在目录，输入命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">javac HelloWorld.java //编译<br>java HelloWorld //运行<br></code></pre></td></tr></table></figure>\n\n<p>这里可见，java 和 C、C++ 一样，属于编译型语言（一次性翻译全部源程序，然后执行机器语言程序），而不是解释型语言（源程序逐条翻译并执行）。</p>\n<p>如果顺利运行，就会输出 <code>Hello World!</code>。</p>\n<h2 id=\"Java-基础语法——主要与C语言比较有哪些不同\"><a href=\"#Java-基础语法——主要与C语言比较有哪些不同\" class=\"headerlink\" title=\"Java 基础语法——主要与C语言比较有哪些不同\"></a>Java 基础语法——主要与C语言比较有哪些不同</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>单行注释 <code>//</code> 、多行注释 <code>/* */</code> 都和C一样。还有一个文件注释 <code>/** */</code>暂时用不到，之后了解。</p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>字母全部小写。</p>\n<h6 id=\"数据类型：\"><a href=\"#数据类型：\" class=\"headerlink\" title=\"数据类型：\"></a>数据类型：</h6><p>整数型：byte, short, int, long</p>\n<p>浮点型：float, double</p>\n<p>字符型：char</p>\n<p>布尔型：boolean</p>\n<p>变量的定义和 c 相似，<code>int a=10;</code> 不能重复定义和未初始化就使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">long</span> l=<span class=\"hljs-number\">1000000L</span>;<br><span class=\"hljs-type\">float</span> f=<span class=\"hljs-number\">1.235F</span>; <span class=\"hljs-comment\">//防止 long 类型和 float 类型不兼容</span><br></code></pre></td></tr></table></figure>\n\n<p>标识符命名：数字、字母（区分大小写）、_、$ 组成，数字不能开头。</p>\n<p><em>命名规范：</em></p>\n<p><em>方法和变量：一个单词时，首字母大写；标识符由多个单词组成时：小驼峰命名法</em></p>\n<p><em>类名：大驼峰命名法</em></p>\n<h3 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h3><p>+，-，*，/，%，</p>\n<p>+=，-=，*=，/=，%=（隐含了强制类型转换）</p>\n<p>++，–（和 C 不太一样！最好单独写，不要写在表达式中）</p>\n<p>==，&gt;=，&lt;=，&gt;，&lt;，!=</p>\n<p>? : </p>\n<p>&amp;，|，^，!（逻辑运算符）</p>\n<p>&amp;&amp;，||（短路逻辑运算符，如果左边足以判断表达式的结果，右边就不会执行）</p>\n<p>与 C 不同的是，Java 里的 + 号可以进行字符串拼接。字符串变量碰到其他类型变量就会拼接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">99</span>+<span class=\"hljs-string\">&quot;string&quot;</span> <span class=\"hljs-comment\">//&quot;100string&quot;</span><br><span class=\"hljs-string\">&quot;string&quot;</span>+<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">99</span> <span class=\"hljs-comment\">//&quot;string199&quot;，从左往右计算</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><p>自动类型转换：把小范围的变量赋值给大范围的变量</p>\n<p>数据范围从小到大：</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/14/iX6sR.png\" alt=\"DataTypeRange\"></p>\n<p>算术表达式中包含多个基本数据类型的值时，整个算术表达式的类型就会自动提升。</p>\n<p>强制类型转换：赋值运算符中隐含。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">short</span> s=<span class=\"hljs-number\">10</span>;\t\t<br>s+=<span class=\"hljs-number\">10</span>;\t\t\t<span class=\"hljs-comment\">//正常</span><br>s=s+<span class=\"hljs-number\">10</span>;\t\t\t<span class=\"hljs-comment\">//错，因为右边发生了自动类型转换，变成了int型</span><br>s=(<span class=\"hljs-type\">short</span>)(s+<span class=\"hljs-number\">10</span>);<span class=\"hljs-comment\">//也可以</span><br></code></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"Mysql Command Line Client 的使用，及常用命令","Date":"2022-04-17T16:00:00.000Z","_content":"\nMysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。\n\n## 安装\n\nMYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。\n\n## 配置\n\n由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。\n\n## 常用命令\n\n其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。\n\n开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。\n\n| 命令                             | 作用                                                |\n| -------------------------------- | --------------------------------------------------- |\n| \\h, \\?, ?                        | 获取帮助                                            |\n| \\c                               | 清除前面输入的内容（内容输入有误时使用）            |\n| \\R                               | 修改 每次输入命令前左侧的提示样式（默认：'mysql>'） |\n| ? 需要查看帮助的命令;            | 显示该命令的帮助（如：? show）                      |\n| show databases;                  | 查看所有数据库                                      |\n| use '数据库名';                  | 选中某个数据库                                      |\n| （选中某个数据库后）show tables; | 查看当前数据库中所有表                              |\n| exit / quit                      | 退出                                                |","source":"_posts/Mysql Command Line Client 的使用，及常用命令.md","raw":"---\ntitle: Mysql Command Line Client 的使用，及常用命令\nDate: 2022-04-18\ntags: study\ncategory: mysql\n---\n\nMysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。\n\n## 安装\n\nMYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。\n\n## 配置\n\n由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。\n\n## 常用命令\n\n其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。\n\n开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。\n\n| 命令                             | 作用                                                |\n| -------------------------------- | --------------------------------------------------- |\n| \\h, \\?, ?                        | 获取帮助                                            |\n| \\c                               | 清除前面输入的内容（内容输入有误时使用）            |\n| \\R                               | 修改 每次输入命令前左侧的提示样式（默认：'mysql>'） |\n| ? 需要查看帮助的命令;            | 显示该命令的帮助（如：? show）                      |\n| show databases;                  | 查看所有数据库                                      |\n| use '数据库名';                  | 选中某个数据库                                      |\n| （选中某个数据库后）show tables; | 查看当前数据库中所有表                              |\n| exit / quit                      | 退出                                                |","slug":"Mysql Command Line Client 的使用，及常用命令","published":1,"date":"2022-04-18T03:31:43.820Z","updated":"2022-05-02T02:08:19.037Z","_id":"cl2462f060003cov2fahrfq16","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Mysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>MYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。</p>\n<p>开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\h, ?, ?</td>\n<td>获取帮助</td>\n</tr>\n<tr>\n<td>\\c</td>\n<td>清除前面输入的内容（内容输入有误时使用）</td>\n</tr>\n<tr>\n<td>\\R</td>\n<td>修改 每次输入命令前左侧的提示样式（默认：’mysql&gt;’）</td>\n</tr>\n<tr>\n<td>? 需要查看帮助的命令;</td>\n<td>显示该命令的帮助（如：? show）</td>\n</tr>\n<tr>\n<td>show databases;</td>\n<td>查看所有数据库</td>\n</tr>\n<tr>\n<td>use ‘数据库名’;</td>\n<td>选中某个数据库</td>\n</tr>\n<tr>\n<td>（选中某个数据库后）show tables;</td>\n<td>查看当前数据库中所有表</td>\n</tr>\n<tr>\n<td>exit / quit</td>\n<td>退出</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>Mysql Command Line Client 是官方提供的客户端。之前一直直接用 Windows 的命令提示符窗口输入 Mysql 语句，不知道两者具体区别在哪里。不过还是重新安装了一个尝试一下。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>MYSQL 文件夹里自带有 Installer，在里面选中对应电脑版本的 Mysql Server 下载即可。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>由于安装目录和 Mysql 不一致，缺少配置文件 my.ini 导致 Mysql Command Line Client 一开始无法使用。直接把 Mysql 里的 my.ini 复制到 Mysql Server 目录下就可以了。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><p>其实在 cmd 窗口中登录 mysql 时也会给出相应的命令提示，只是当时没有仔细研究。正好借使用 Mysql Command Line Client 的机会了解一下常用的命令。</p>\n<p>开始菜单中出现了两种不同的 Mysql Command Line Client 窗口，其中一种支持 Unicode ，一种不支持。打开后即会提示输入登录密码，登录后就和 cmd 窗口中操作基本一致。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\h, ?, ?</td>\n<td>获取帮助</td>\n</tr>\n<tr>\n<td>\\c</td>\n<td>清除前面输入的内容（内容输入有误时使用）</td>\n</tr>\n<tr>\n<td>\\R</td>\n<td>修改 每次输入命令前左侧的提示样式（默认：’mysql&gt;’）</td>\n</tr>\n<tr>\n<td>? 需要查看帮助的命令;</td>\n<td>显示该命令的帮助（如：? show）</td>\n</tr>\n<tr>\n<td>show databases;</td>\n<td>查看所有数据库</td>\n</tr>\n<tr>\n<td>use ‘数据库名’;</td>\n<td>选中某个数据库</td>\n</tr>\n<tr>\n<td>（选中某个数据库后）show tables;</td>\n<td>查看当前数据库中所有表</td>\n</tr>\n<tr>\n<td>exit / quit</td>\n<td>退出</td>\n</tr>\n</tbody></table>\n"},{"title":"SQL 语句——DDL","date":"2022-04-18T16:00:00.000Z","_content":"\n学习于：b站 骆昊jackfrued 老师的网课\n\n| SQL 语句 | 作用                | 使用示例                                                     |\n| -------- | ------------------- | ------------------------------------------------------------ |\n| create   | 创建数据库 / 表     | create database \\`数据库名\\`; / create table \\`表名\\` ( 字段描述 ); |\n| drop     | 删除数据库 / 表     | drop database \\`数据库名\\`; / drop table \\`表名\\`;           |\n| use      | 选中数据库          | use \\`数据库名\\`;                                            |\n| alter    | 更改数据库 / 表信息 | alter table \\`表名\\` add constraint \\`约束名\\` unique (\\`字段名\\`); |\n\nPS： \n\n1. 修改表的引擎 / 更改自增约束初始值是在 create table \\`表名\\` () 后面添加的。\n\n   ```mysql\n   create table `表名`(\n   \n   )engine = innodb auto_increment=2 comment '表示例';\n   ```\n\n   \n\n## 约束\n\n### 主键约束\n\n```mysql\nprimary key (`列名`),\n```\n\n*复合主键语法上没错，但是开发使用时非常不好用，需要至少两条字段才能唯一确定一条记录。一般不会用。*\n\n*如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。*\n\n### 自增约束、非空约束\n\n都在字段描述后面写即可\n\n```mysql\n`col_name` int auto_increment not null comment '列名',\n```\n\n以下三种可以在创建表时写，也可以之后写`alter table 表名 add constraint...`。\n\n### 唯一约束\n\n```mysql\nconstraint `uk_col_name` unique (`col_name`),\n```\n\n类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）\n\n### 检查约束\n\n检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。\n\n```mysql\nconstraint `ck_col_sex` check (`col_sex`='M' or `col_sex`='F'),\n```\n\n### 外键约束\n\n首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。\n\n外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。\n\n```mysql\nconstraint `fk_col_id` foreign key (`在本表中的字段名`) references `另一个表名` (`在该表中的主键名`),\n```\n\n结尾其实还有一句默认的话：`on delete restrict on update restrict` ，就是限制不要随便删除或修改的意思，因为会牵连到别的表。\n\n如果改成 `on delete cascade on update cascade` ，修改时就会发生级联，如果删除这个表中的记录中某一字段的数据另一个表中用到了，就会把另一个表中对应记录也删除。\n\n如果改成 `on delete set null` ，就是删除这个记录时，在另一个表中对应字段的记录不会删除，而只是把这格子短的位置变成空（**当然，前提是该字段数据可以为空！**）\n\n最好还是使用默认的 restrict 。\n\n*一对多时，多的一方需要加外键约束。*\n\n删除约束：\n\n```mysql\nalter table `表名` drop constraint `要删除的约束名`;\n```\n\n","source":"_posts/SQL 语句——DDL.md","raw":"---\ntitle: SQL 语句——DDL\ndate: 2022-04-19\ntags: study\ncategories: database\n---\n\n学习于：b站 骆昊jackfrued 老师的网课\n\n| SQL 语句 | 作用                | 使用示例                                                     |\n| -------- | ------------------- | ------------------------------------------------------------ |\n| create   | 创建数据库 / 表     | create database \\`数据库名\\`; / create table \\`表名\\` ( 字段描述 ); |\n| drop     | 删除数据库 / 表     | drop database \\`数据库名\\`; / drop table \\`表名\\`;           |\n| use      | 选中数据库          | use \\`数据库名\\`;                                            |\n| alter    | 更改数据库 / 表信息 | alter table \\`表名\\` add constraint \\`约束名\\` unique (\\`字段名\\`); |\n\nPS： \n\n1. 修改表的引擎 / 更改自增约束初始值是在 create table \\`表名\\` () 后面添加的。\n\n   ```mysql\n   create table `表名`(\n   \n   )engine = innodb auto_increment=2 comment '表示例';\n   ```\n\n   \n\n## 约束\n\n### 主键约束\n\n```mysql\nprimary key (`列名`),\n```\n\n*复合主键语法上没错，但是开发使用时非常不好用，需要至少两条字段才能唯一确定一条记录。一般不会用。*\n\n*如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。*\n\n### 自增约束、非空约束\n\n都在字段描述后面写即可\n\n```mysql\n`col_name` int auto_increment not null comment '列名',\n```\n\n以下三种可以在创建表时写，也可以之后写`alter table 表名 add constraint...`。\n\n### 唯一约束\n\n```mysql\nconstraint `uk_col_name` unique (`col_name`),\n```\n\n类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）\n\n### 检查约束\n\n检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。\n\n```mysql\nconstraint `ck_col_sex` check (`col_sex`='M' or `col_sex`='F'),\n```\n\n### 外键约束\n\n首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。\n\n外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。\n\n```mysql\nconstraint `fk_col_id` foreign key (`在本表中的字段名`) references `另一个表名` (`在该表中的主键名`),\n```\n\n结尾其实还有一句默认的话：`on delete restrict on update restrict` ，就是限制不要随便删除或修改的意思，因为会牵连到别的表。\n\n如果改成 `on delete cascade on update cascade` ，修改时就会发生级联，如果删除这个表中的记录中某一字段的数据另一个表中用到了，就会把另一个表中对应记录也删除。\n\n如果改成 `on delete set null` ，就是删除这个记录时，在另一个表中对应字段的记录不会删除，而只是把这格子短的位置变成空（**当然，前提是该字段数据可以为空！**）\n\n最好还是使用默认的 restrict 。\n\n*一对多时，多的一方需要加外键约束。*\n\n删除约束：\n\n```mysql\nalter table `表名` drop constraint `要删除的约束名`;\n```\n\n","slug":"SQL 语句——DDL","published":1,"updated":"2022-04-22T16:11:37.245Z","_id":"cl2772w3z00004sv21bda7355","comments":1,"layout":"post","photos":[],"link":"","content":"<p>学习于：b站 骆昊jackfrued 老师的网课</p>\n<table>\n<thead>\n<tr>\n<th>SQL 语句</th>\n<th>作用</th>\n<th>使用示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>create</td>\n<td>创建数据库 / 表</td>\n<td>create database `数据库名`; / create table `表名` ( 字段描述 );</td>\n</tr>\n<tr>\n<td>drop</td>\n<td>删除数据库 / 表</td>\n<td>drop database `数据库名`; / drop table `表名`;</td>\n</tr>\n<tr>\n<td>use</td>\n<td>选中数据库</td>\n<td>use `数据库名`;</td>\n</tr>\n<tr>\n<td>alter</td>\n<td>更改数据库 / 表信息</td>\n<td>alter table `表名` add constraint `约束名` unique (`字段名`);</td>\n</tr>\n</tbody></table>\n<p>PS： </p>\n<ol>\n<li><p>修改表的引擎 / 更改自增约束初始值是在 create table `表名` () 后面添加的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table `表名`(<br><br>)engine = innodb auto_increment=2 comment &#x27;表示例&#x27;;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h2><h3 id=\"主键约束\"><a href=\"#主键约束\" class=\"headerlink\" title=\"主键约束\"></a>主键约束</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">primary key (`列名`),<br></code></pre></td></tr></table></figure>\n\n<p><em>复合主键语法上没错，但是开发使用时非常不好用，需要至少两条字段才能唯一确定一条记录。一般不会用。</em></p>\n<p><em>如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。</em></p>\n<h3 id=\"自增约束、非空约束\"><a href=\"#自增约束、非空约束\" class=\"headerlink\" title=\"自增约束、非空约束\"></a>自增约束、非空约束</h3><p>都在字段描述后面写即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">`col_name` int auto_increment not null comment &#x27;列名&#x27;,<br></code></pre></td></tr></table></figure>\n\n<p>以下三种可以在创建表时写，也可以之后写<code>alter table 表名 add constraint...</code>。</p>\n<h3 id=\"唯一约束\"><a href=\"#唯一约束\" class=\"headerlink\" title=\"唯一约束\"></a>唯一约束</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">constraint `uk_col_name` unique (`col_name`),<br></code></pre></td></tr></table></figure>\n\n<p>类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）</p>\n<h3 id=\"检查约束\"><a href=\"#检查约束\" class=\"headerlink\" title=\"检查约束\"></a>检查约束</h3><p>检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">constraint `ck_col_sex` check (`col_sex`=&#x27;M&#x27; or `col_sex`=&#x27;F&#x27;),<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"外键约束\"><a href=\"#外键约束\" class=\"headerlink\" title=\"外键约束\"></a>外键约束</h3><p>首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。</p>\n<p>外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">constraint `fk_col_id` foreign key (`在本表中的字段名`) references `另一个表名` (`在该表中的主键名`),<br></code></pre></td></tr></table></figure>\n\n<p>结尾其实还有一句默认的话：<code>on delete restrict on update restrict</code> ，就是限制不要随便删除或修改的意思，因为会牵连到别的表。</p>\n<p>如果改成 <code>on delete cascade on update cascade</code> ，修改时就会发生级联，如果删除这个表中的记录中某一字段的数据另一个表中用到了，就会把另一个表中对应记录也删除。</p>\n<p>如果改成 <code>on delete set null</code> ，就是删除这个记录时，在另一个表中对应字段的记录不会删除，而只是把这格子短的位置变成空（<strong>当然，前提是该字段数据可以为空！</strong>）</p>\n<p>最好还是使用默认的 restrict 。</p>\n<p><em>一对多时，多的一方需要加外键约束。</em></p>\n<p>删除约束：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table `表名` drop constraint `要删除的约束名`;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>学习于：b站 骆昊jackfrued 老师的网课</p>\n<table>\n<thead>\n<tr>\n<th>SQL 语句</th>\n<th>作用</th>\n<th>使用示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>create</td>\n<td>创建数据库 / 表</td>\n<td>create database `数据库名`; / create table `表名` ( 字段描述 );</td>\n</tr>\n<tr>\n<td>drop</td>\n<td>删除数据库 / 表</td>\n<td>drop database `数据库名`; / drop table `表名`;</td>\n</tr>\n<tr>\n<td>use</td>\n<td>选中数据库</td>\n<td>use `数据库名`;</td>\n</tr>\n<tr>\n<td>alter</td>\n<td>更改数据库 / 表信息</td>\n<td>alter table `表名` add constraint `约束名` unique (`字段名`);</td>\n</tr>\n</tbody></table>\n<p>PS： </p>\n<ol>\n<li><p>修改表的引擎 / 更改自增约束初始值是在 create table `表名` () 后面添加的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table `表名`(<br><br>)engine = innodb auto_increment=2 comment &#x27;表示例&#x27;;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h2><h3 id=\"主键约束\"><a href=\"#主键约束\" class=\"headerlink\" title=\"主键约束\"></a>主键约束</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">primary key (`列名`),<br></code></pre></td></tr></table></figure>\n\n<p><em>复合主键语法上没错，但是开发使用时非常不好用，需要至少两条字段才能唯一确定一条记录。一般不会用。</em></p>\n<p><em>如选课表，有课程号和学生学号字段，合在一起作为复合主键可以唯一确定记录。但是一般会在新建一个选课id之类的可以唯一确定所有选课记录的字段作为主键。</em></p>\n<h3 id=\"自增约束、非空约束\"><a href=\"#自增约束、非空约束\" class=\"headerlink\" title=\"自增约束、非空约束\"></a>自增约束、非空约束</h3><p>都在字段描述后面写即可</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">`col_name` int auto_increment not null comment &#x27;列名&#x27;,<br></code></pre></td></tr></table></figure>\n\n<p>以下三种可以在创建表时写，也可以之后写<code>alter table 表名 add constraint...</code>。</p>\n<h3 id=\"唯一约束\"><a href=\"#唯一约束\" class=\"headerlink\" title=\"唯一约束\"></a>唯一约束</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">constraint `uk_col_name` unique (`col_name`),<br></code></pre></td></tr></table></figure>\n\n<p>类似主键约束，唯一约束也可以设定多个字段，再括号里多写几个字段就行（如选课记录，一个学生不能重复选课，学生学号和课程编号不能重复）</p>\n<h3 id=\"检查约束\"><a href=\"#检查约束\" class=\"headerlink\" title=\"检查约束\"></a>检查约束</h3><p>检查约束可以帮忙检查数据合法性，但是相对的，肯定对性能有损耗。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">constraint `ck_col_sex` check (`col_sex`=&#x27;M&#x27; or `col_sex`=&#x27;F&#x27;),<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"外键约束\"><a href=\"#外键约束\" class=\"headerlink\" title=\"外键约束\"></a>外键约束</h3><p>首先在需要加外键的表中添加和另一个表的主键一样格式（名称可以不一样）的字段。</p>\n<p>外键约束也会损耗性能，要检查对应表中对应字段是否对应。很多公司都不用外键约束，会通过其他方法确定两表特定字段是否对应。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">constraint `fk_col_id` foreign key (`在本表中的字段名`) references `另一个表名` (`在该表中的主键名`),<br></code></pre></td></tr></table></figure>\n\n<p>结尾其实还有一句默认的话：<code>on delete restrict on update restrict</code> ，就是限制不要随便删除或修改的意思，因为会牵连到别的表。</p>\n<p>如果改成 <code>on delete cascade on update cascade</code> ，修改时就会发生级联，如果删除这个表中的记录中某一字段的数据另一个表中用到了，就会把另一个表中对应记录也删除。</p>\n<p>如果改成 <code>on delete set null</code> ，就是删除这个记录时，在另一个表中对应字段的记录不会删除，而只是把这格子短的位置变成空（<strong>当然，前提是该字段数据可以为空！</strong>）</p>\n<p>最好还是使用默认的 restrict 。</p>\n<p><em>一对多时，多的一方需要加外键约束。</em></p>\n<p>删除约束：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">alter table `表名` drop constraint `要删除的约束名`;<br></code></pre></td></tr></table></figure>\n\n"},{"title":"SQL 语句——DML","date":"2022-04-22T16:00:00.000Z","_content":"\n## 插入\n\n```mysql\ninsert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行\ninsert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的\n```\n\n注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 `default` ，不然系统也难以分辨哪一项使用默认值。\n\n*日期可以写字符串 2002-01-01，会自动转换*\n\n插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。\n\n**如果主键、unique 的记录重复会报错。**报错显示： `duplicate key for key '定义的约束键名称'`\n\n**填写了规定的 check 以外的内容会报错。**报错显示：`check constraint '定义的约束键名称' is violated.` 不过字符串不区分大小写，规定性别只能填 'F' 'M' 的话，填 'f' 'm' 也行。\n\n**如果对应的外键在原表中没有对应的记录会报错。** 报错显示：`cannot add or update a child row: a foreign constraint fails` 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。\n\n**如果没有给 NOT NULL且没有默认值的字段赋值时会报错。** 报错显示：`Field '字段名' doesn't have a default value.` 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。\n\n## 删除\n\n```mysql\ndelete from `表名`;//这可不兴用啊！\ndelete from `表名` where `字段名`='要删除的记录的对应字段值';//不等于可以用<>，有的 DBMS 支持!=\ndelete from `表名` where `字段名` = '字段值' or `字段名` = '字段值';//删除多条语句\ndelete from `表名` where `字段名` in ('字段值','字段值');//删除多条语句\n```\n\n但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： `Cannot delete or update a parent row` 。\n\n删除了外键约束之后就可以随意修改两个表对应的值而不报错了。\n\n另一种删除表的方式是：\n\n```mysql\ntruncate table `表名`;\n```\n\n截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。\n\n## 更新\n\n```mysql\nupdate `表名` set `列名` = '值';//把这一列的数据全都改成这个值，不常用\nupdate `表名` set `列名` = '值',`列名` = '值',`列名` = '值' where `字段`='值';//限制条件，只修改某几个记录\n```\n\n","source":"_posts/SQL 语句——DML.md","raw":"---\ntitle: SQL 语句——DML\ndate: 2022-04-23\ntags: study\ncategories: database\n---\n\n## 插入\n\n```mysql\ninsert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行\ninsert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的\n```\n\n注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 `default` ，不然系统也难以分辨哪一项使用默认值。\n\n*日期可以写字符串 2002-01-01，会自动转换*\n\n插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。\n\n**如果主键、unique 的记录重复会报错。**报错显示： `duplicate key for key '定义的约束键名称'`\n\n**填写了规定的 check 以外的内容会报错。**报错显示：`check constraint '定义的约束键名称' is violated.` 不过字符串不区分大小写，规定性别只能填 'F' 'M' 的话，填 'f' 'm' 也行。\n\n**如果对应的外键在原表中没有对应的记录会报错。** 报错显示：`cannot add or update a child row: a foreign constraint fails` 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。\n\n**如果没有给 NOT NULL且没有默认值的字段赋值时会报错。** 报错显示：`Field '字段名' doesn't have a default value.` 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。\n\n## 删除\n\n```mysql\ndelete from `表名`;//这可不兴用啊！\ndelete from `表名` where `字段名`='要删除的记录的对应字段值';//不等于可以用<>，有的 DBMS 支持!=\ndelete from `表名` where `字段名` = '字段值' or `字段名` = '字段值';//删除多条语句\ndelete from `表名` where `字段名` in ('字段值','字段值');//删除多条语句\n```\n\n但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： `Cannot delete or update a parent row` 。\n\n删除了外键约束之后就可以随意修改两个表对应的值而不报错了。\n\n另一种删除表的方式是：\n\n```mysql\ntruncate table `表名`;\n```\n\n截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。\n\n## 更新\n\n```mysql\nupdate `表名` set `列名` = '值';//把这一列的数据全都改成这个值，不常用\nupdate `表名` set `列名` = '值',`列名` = '值',`列名` = '值' where `字段`='值';//限制条件，只修改某几个记录\n```\n\n","slug":"SQL 语句——DML","published":1,"updated":"2022-04-26T03:26:32.253Z","_id":"cl2bd00s80000pkv21osde9l8","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">insert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行<br>insert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的<br></code></pre></td></tr></table></figure>\n\n<p>注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 <code>default</code> ，不然系统也难以分辨哪一项使用默认值。</p>\n<p><em>日期可以写字符串 2002-01-01，会自动转换</em></p>\n<p>插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。</p>\n<p><strong>如果主键、unique 的记录重复会报错。</strong>报错显示： <code>duplicate key for key &#39;定义的约束键名称&#39;</code></p>\n<p><strong>填写了规定的 check 以外的内容会报错。</strong>报错显示：<code>check constraint &#39;定义的约束键名称&#39; is violated.</code> 不过字符串不区分大小写，规定性别只能填 ‘F’ ‘M’ 的话，填 ‘f’ ‘m’ 也行。</p>\n<p><strong>如果对应的外键在原表中没有对应的记录会报错。</strong> 报错显示：<code>cannot add or update a child row: a foreign constraint fails</code> 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。</p>\n<p><strong>如果没有给 NOT NULL且没有默认值的字段赋值时会报错。</strong> 报错显示：<code>Field &#39;字段名&#39; doesn&#39;t have a default value.</code> 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">delete from `表名`;//这可不兴用啊！<br>delete from `表名` where `字段名`=&#x27;要删除的记录的对应字段值&#x27;;//不等于可以用&lt;&gt;，有的 DBMS 支持!=<br>delete from `表名` where `字段名` = &#x27;字段值&#x27; or `字段名` = &#x27;字段值&#x27;;//删除多条语句<br>delete from `表名` where `字段名` in (&#x27;字段值&#x27;,&#x27;字段值&#x27;);//删除多条语句<br></code></pre></td></tr></table></figure>\n\n<p>但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： <code>Cannot delete or update a parent row</code> 。</p>\n<p>删除了外键约束之后就可以随意修改两个表对应的值而不报错了。</p>\n<p>另一种删除表的方式是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">truncate table `表名`;<br></code></pre></td></tr></table></figure>\n\n<p>截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。</p>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">update `表名` set `列名` = &#x27;值&#x27;;//把这一列的数据全都改成这个值，不常用<br>update `表名` set `列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27; where `字段`=&#x27;值&#x27;;//限制条件，只修改某几个记录<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">insert into `表名` values (对应字段值)(对应字段值)(对应字段值);//写多个括号，可以一次填写多行<br>insert into `表名` (要填写的字段) values (对应字段值); //省略不写的一定是有默认值的或者可以非空的<br></code></pre></td></tr></table></figure>\n\n<p>注意：对应字段值一定要和字段相匹配。如果有默认值的字段也不要省略不写，要写上 <code>default</code> ，不然系统也难以分辨哪一项使用默认值。</p>\n<p><em>日期可以写字符串 2002-01-01，会自动转换</em></p>\n<p>插入完后显示：1 row(s) affected（如果写了多个括号，一次插入多行，会显示多个 row(s) affected）是影响了几行的意思。</p>\n<p><strong>如果主键、unique 的记录重复会报错。</strong>报错显示： <code>duplicate key for key &#39;定义的约束键名称&#39;</code></p>\n<p><strong>填写了规定的 check 以外的内容会报错。</strong>报错显示：<code>check constraint &#39;定义的约束键名称&#39; is violated.</code> 不过字符串不区分大小写，规定性别只能填 ‘F’ ‘M’ 的话，填 ‘f’ ‘m’ 也行。</p>\n<p><strong>如果对应的外键在原表中没有对应的记录会报错。</strong> 报错显示：<code>cannot add or update a child row: a foreign constraint fails</code> 比如学生表的学院号参照了学院表，但是有学院表中不存在的学院号时。</p>\n<p><strong>如果没有给 NOT NULL且没有默认值的字段赋值时会报错。</strong> 报错显示：<code>Field &#39;字段名&#39; doesn&#39;t have a default value.</code> 尽量不要出现空列，之后处理空值会带来很多麻烦。哪怕用空字符串、0、1代替也更好一些。</p>\n<h2 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">delete from `表名`;//这可不兴用啊！<br>delete from `表名` where `字段名`=&#x27;要删除的记录的对应字段值&#x27;;//不等于可以用&lt;&gt;，有的 DBMS 支持!=<br>delete from `表名` where `字段名` = &#x27;字段值&#x27; or `字段名` = &#x27;字段值&#x27;;//删除多条语句<br>delete from `表名` where `字段名` in (&#x27;字段值&#x27;,&#x27;字段值&#x27;);//删除多条语句<br></code></pre></td></tr></table></figure>\n\n<p>但是如果要删除的这条记录在其他表里是外键，就无法删除。报错显示： <code>Cannot delete or update a parent row</code> 。</p>\n<p>删除了外键约束之后就可以随意修改两个表对应的值而不报错了。</p>\n<p>另一种删除表的方式是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">truncate table `表名`;<br></code></pre></td></tr></table></figure>\n\n<p>截断表，这个比 delete 还要危险。delete 了表之后，如果有日志，还是可以找回原数据的。截断就算有日志也没法恢复。</p>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">update `表名` set `列名` = &#x27;值&#x27;;//把这一列的数据全都改成这个值，不常用<br>update `表名` set `列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27;,`列名` = &#x27;值&#x27; where `字段`=&#x27;值&#x27;;//限制条件，只修改某几个记录<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Mysql 数据类型","date":"2022-04-18T16:00:00.000Z","_content":"\n数据类型可以通过 `? data types` 查看说明，每种数据类型也可以通过 `? 数据类型` 查看。\n\n*除了data types 其他可以用?查看的内容可以输入 `? contents` 查看。*\n\n| 数据类型                                            | 作用                                                         |\n| --------------------------------------------------- | ------------------------------------------------------------ |\n| 整数 (tinyint, smallint, mediumint, int, bigint)    | 都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）   |\n| 字符串 (char(位数), varchar(位数), text)            | char 长度固定，varchar 长度可变                              |\n| 小数 (float, double, decimal(总位数, 小数点后位数)) | 不要用 float, double！                                       |\n| 时间日期 (year, date, time, datetime, timestamp)    | date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数 |\n| Mysql 中的枚举类型 (enum, boolean)                  |                                                              |\n\nPS: \n\n1. 虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。\n\n2. 金额等小数一般不会用小数的数据类型存储，而是整数类型/100使用。因为小数形式有误差，比如0.1+0.2=0.30000000004.\n\n3. decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。\n\n4. 时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。\n\n   > 这里了解到了一个很有趣的[“千年虫”问题]([漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/305603895))。\n   >\n   > Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。\n   >\n   > 早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022/04/19，就是22/04/19）\n   >\n   > 尽管节约了内存空间，但是40年后1999->2000年时，问题就出现了……对计算机来说，相当于99->00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。\n   >\n   > 如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：\n   >\n   > 1. 只修改核心关键的医疗、航空、金融、军事领域的程序；\n   > 2. 对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。\n\n   回到刚才的话题，因此时间戳也并不推荐使用。\n\n5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符串。\n","source":"_posts/Mysql 数据类型.md","raw":"---\ntitle: Mysql 数据类型\ndate: 2022-04-19\ntags: study\ncategory: database\n---\n\n数据类型可以通过 `? data types` 查看说明，每种数据类型也可以通过 `? 数据类型` 查看。\n\n*除了data types 其他可以用?查看的内容可以输入 `? contents` 查看。*\n\n| 数据类型                                            | 作用                                                         |\n| --------------------------------------------------- | ------------------------------------------------------------ |\n| 整数 (tinyint, smallint, mediumint, int, bigint)    | 都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）   |\n| 字符串 (char(位数), varchar(位数), text)            | char 长度固定，varchar 长度可变                              |\n| 小数 (float, double, decimal(总位数, 小数点后位数)) | 不要用 float, double！                                       |\n| 时间日期 (year, date, time, datetime, timestamp)    | date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数 |\n| Mysql 中的枚举类型 (enum, boolean)                  |                                                              |\n\nPS: \n\n1. 虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。\n\n2. 金额等小数一般不会用小数的数据类型存储，而是整数类型/100使用。因为小数形式有误差，比如0.1+0.2=0.30000000004.\n\n3. decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。\n\n4. 时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。\n\n   > 这里了解到了一个很有趣的[“千年虫”问题]([漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/305603895))。\n   >\n   > Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。\n   >\n   > 早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022/04/19，就是22/04/19）\n   >\n   > 尽管节约了内存空间，但是40年后1999->2000年时，问题就出现了……对计算机来说，相当于99->00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。\n   >\n   > 如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：\n   >\n   > 1. 只修改核心关键的医疗、航空、金融、军事领域的程序；\n   > 2. 对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。\n\n   回到刚才的话题，因此时间戳也并不推荐使用。\n\n5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符串。\n","slug":"Mysql 数据类型","published":1,"updated":"2022-04-26T03:26:32.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2flbwhu0000bkv2236dfg6l","content":"<p>数据类型可以通过 <code>? data types</code> 查看说明，每种数据类型也可以通过 <code>? 数据类型</code> 查看。</p>\n<p><em>除了data types 其他可以用?查看的内容可以输入 <code>? contents</code> 查看。</em></p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>整数 (tinyint, smallint, mediumint, int, bigint)</td>\n<td>都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）</td>\n</tr>\n<tr>\n<td>字符串 (char(位数), varchar(位数), text)</td>\n<td>char 长度固定，varchar 长度可变</td>\n</tr>\n<tr>\n<td>小数 (float, double, decimal(总位数, 小数点后位数))</td>\n<td>不要用 float, double！</td>\n</tr>\n<tr>\n<td>时间日期 (year, date, time, datetime, timestamp)</td>\n<td>date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数</td>\n</tr>\n<tr>\n<td>Mysql 中的枚举类型 (enum, boolean)</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>PS: </p>\n<ol>\n<li><p>虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。</p>\n</li>\n<li><p>金额等小数一般不会用小数的数据类型存储，而是整数类型/100使用。因为小数形式有误差，比如0.1+0.2=0.30000000004.</p>\n</li>\n<li><p>decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。</p>\n</li>\n<li><p>时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。</p>\n<blockquote>\n<p>这里了解到了一个很有趣的[“千年虫”问题](<a href=\"https://zhuanlan.zhihu.com/p/305603895\">漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)</a>)。</p>\n<p>Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。</p>\n<p>早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022/04/19，就是22/04/19）</p>\n<p>尽管节约了内存空间，但是40年后1999-&gt;2000年时，问题就出现了……对计算机来说，相当于99-&gt;00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。</p>\n<p>如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：</p>\n<ol>\n<li>只修改核心关键的医疗、航空、金融、军事领域的程序；</li>\n<li>对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。</li>\n</ol>\n</blockquote>\n<p>回到刚才的话题，因此时间戳也并不推荐使用。</p>\n</li>\n</ol>\n<p>5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符串。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>数据类型可以通过 <code>? data types</code> 查看说明，每种数据类型也可以通过 <code>? 数据类型</code> 查看。</p>\n<p><em>除了data types 其他可以用?查看的内容可以输入 <code>? contents</code> 查看。</em></p>\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>整数 (tinyint, smallint, mediumint, int, bigint)</td>\n<td>都是整数型，表示范围为1,2,3,4,8 B（结尾还可以加 unsigned）</td>\n</tr>\n<tr>\n<td>字符串 (char(位数), varchar(位数), text)</td>\n<td>char 长度固定，varchar 长度可变</td>\n</tr>\n<tr>\n<td>小数 (float, double, decimal(总位数, 小数点后位数))</td>\n<td>不要用 float, double！</td>\n</tr>\n<tr>\n<td>时间日期 (year, date, time, datetime, timestamp)</td>\n<td>date：年月日<br />time：时间<br />datetime：年月日时分秒<br />timestamp：时间戳，现在距离 1970-1-1 的毫秒数</td>\n</tr>\n<tr>\n<td>Mysql 中的枚举类型 (enum, boolean)</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>PS: </p>\n<ol>\n<li><p>虽然 text 等类型可以存储很大的数据，不过大数据一般还是不会直接往数据库里存储。如图片，数据库中一般存储其路径、链接。如果非要存储，有 blob (binary large object)。</p>\n</li>\n<li><p>金额等小数一般不会用小数的数据类型存储，而是整数类型/100使用。因为小数形式有误差，比如0.1+0.2=0.30000000004.</p>\n</li>\n<li><p>decimal 这种变长的数据，使用时速度比定长数据慢。而且 decimal 表示范围也有限，不如直接用 bigint。</p>\n</li>\n<li><p>时间戳是有表示范围的，毕竟是个有上限的数，到2038年左右就不好用了。</p>\n<blockquote>\n<p>这里了解到了一个很有趣的[“千年虫”问题](<a href=\"https://zhuanlan.zhihu.com/p/305603895\">漫画：什么是“千年虫”问题？ - 知乎 (zhihu.com)</a>)。</p>\n<p>Grace Murray Hopper，最早的现代编译器、商用编程语言发明者，Bug 和 Debug词汇的流行使用也与她有关。</p>\n<p>早期计算机资源十分稀缺，内存空间必须精打细算。Grace Murray Hopper 采用6位数字组合来存储日期信息 （比如2022/04/19，就是22/04/19）</p>\n<p>尽管节约了内存空间，但是40年后1999-&gt;2000年时，问题就出现了……对计算机来说，相当于99-&gt;00年，年份倒退了。小到银行存款利息变成负的，大到飞机、发电厂运作、核弹发射……都可能出现故障，后果不堪设想。</p>\n<p>如果修改所有程序，是改不过来的。于是程序员们主要采取两种方法：</p>\n<ol>\n<li>只修改核心关键的医疗、航空、金融、军事领域的程序；</li>\n<li>对于大多数不那么核心的程序，采用时间窗口的方式。1910年代表2010年，1920年代表2020年，暂缓问题。在这20年期间，大多数程序设备都已更新换代，现如今千年虫问题已经不那么严重了。</li>\n</ol>\n</blockquote>\n<p>回到刚才的话题，因此时间戳也并不推荐使用。</p>\n</li>\n</ol>\n<p>5.7 之后版本的 Mysql 支持 json 属性，以键值对的方式存储，内容相对灵活。因为虽然数据库结构相对严谨，但是很多时候并不是所有属性都能考虑得到（如二手交易平台，不同的售卖品属性差的很多，如自行车和冰箱）加入相对灵活的 json ，一定程度上就能解决这类问题。包括以前 Mysql 没有这个功能的时候，许多公司也会建一个 varchar() 字段来存储 json 字符串。</p>\n"},{"title":"SQL 语句——DCL","date":"2022-04-25T16:00:00.000Z","_content":"\n学习于：b站 骆昊jackfrued 老师的网课\n\nData Control Language，给用户授权，不同用户能操作数据权限也是不一样的。\n\n```mysql\ncreate user '人名'@'域名' identified by '密码';-- 添加一个用户，并且限制这个人只能通过这个域名访问\nalter user '人名'@'域名' identified by '密码';\ndrop user '人名'@'域名';\n```\n\n如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。\n\n授权：grant\n\n```mysql\ngrant select on hrs.* to '人名'@'%';-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改\ngrant insert, delete, update on hrs.* to '人名'@'%';\ngrant all privileges on *.* to '人名'@'%';-- 这个人对所有数据库所有对象拥有所有权限\ngrant all privileges on *.* to '人名'@'%' with grant option;-- 这个人不仅有所有权限，还能授予权限给别人\n```\n\n召回权限：revoke\n\n```mysql\nrevoke select on hrs.* to '人名'@'%';\n```\n\n添加权限之后最好 Reconnect 刷新一下。或者执行：\n\n```mysql\nflush privileges;\n```\n\nWorkbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。\n\n至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。\n","source":"_posts/SQL 语句——DCL.md","raw":"---\ntitle: SQL 语句——DCL\ndate: 2022-04-26\ntags: study\ncategory: database\n---\n\n学习于：b站 骆昊jackfrued 老师的网课\n\nData Control Language，给用户授权，不同用户能操作数据权限也是不一样的。\n\n```mysql\ncreate user '人名'@'域名' identified by '密码';-- 添加一个用户，并且限制这个人只能通过这个域名访问\nalter user '人名'@'域名' identified by '密码';\ndrop user '人名'@'域名';\n```\n\n如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。\n\n授权：grant\n\n```mysql\ngrant select on hrs.* to '人名'@'%';-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改\ngrant insert, delete, update on hrs.* to '人名'@'%';\ngrant all privileges on *.* to '人名'@'%';-- 这个人对所有数据库所有对象拥有所有权限\ngrant all privileges on *.* to '人名'@'%' with grant option;-- 这个人不仅有所有权限，还能授予权限给别人\n```\n\n召回权限：revoke\n\n```mysql\nrevoke select on hrs.* to '人名'@'%';\n```\n\n添加权限之后最好 Reconnect 刷新一下。或者执行：\n\n```mysql\nflush privileges;\n```\n\nWorkbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。\n\n至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。\n","slug":"SQL 语句——DCL","published":1,"updated":"2022-04-26T08:22:21.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2fvt0ng00009cv2f1zm4pr5","content":"<p>学习于：b站 骆昊jackfrued 老师的网课</p>\n<p>Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问<br>alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;<br>drop user &#x27;人名&#x27;@&#x27;域名&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。</p>\n<p>授权：grant</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">grant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改<br>grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人<br></code></pre></td></tr></table></figure>\n\n<p>召回权限：revoke</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">revoke select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>添加权限之后最好 Reconnect 刷新一下。或者执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">flush privileges;<br></code></pre></td></tr></table></figure>\n\n<p>Workbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。</p>\n<p>至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习于：b站 骆昊jackfrued 老师的网课</p>\n<p>Data Control Language，给用户授权，不同用户能操作数据权限也是不一样的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;-- 添加一个用户，并且限制这个人只能通过这个域名访问<br>alter user &#x27;人名&#x27;@&#x27;域名&#x27; identified by &#x27;密码&#x27;;<br>drop user &#x27;人名&#x27;@&#x27;域名&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>如果数据库本来就是在局域网里，那么即便改了权限，公网也是访问不到的。</p>\n<p>授权：grant</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">grant select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对 hrs 数据库下所有表都有查询权限，但是不能增删改<br>grant insert, delete, update on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27;;-- 这个人对所有数据库所有对象拥有所有权限<br>grant all privileges on *.* to &#x27;人名&#x27;@&#x27;%&#x27; with grant option;-- 这个人不仅有所有权限，还能授予权限给别人<br></code></pre></td></tr></table></figure>\n\n<p>召回权限：revoke</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">revoke select on hrs.* to &#x27;人名&#x27;@&#x27;%&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>添加权限之后最好 Reconnect 刷新一下。或者执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">flush privileges;<br></code></pre></td></tr></table></figure>\n\n<p>Workbench - Administration - Management - Users and privileges - 选中某个用户 - Schema Privileges，可以查看这个人的权限。</p>\n<p>至此，SQL 语句基本内容就已经学完啦~接下来涉及 Python 数据持久化的内容。</p>\n"},{"title":"SQL 语句——DQL","date":"2022-04-24T16:00:00.000Z","_content":"\n学习自b站骆昊jackfrued 老师的网课。\n\n查询语句。\n\n*本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）*\n\n*tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）*\n\n## Select\n\n查询所有学生的所有信息\n\n```mysql\nselect * from `表名`;-- * 号表示所有字段\n```\n\n但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。\n\n实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）\n\n```mysql\nselect `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;\n```\n\n如果只查询部分列，就只写那几列就行。\n\n## 别名\n\n给字段或表起别名—— alias，简写为 as。\n\n```mysql\nselect `stu_id` as `学号` from `tb_student`;\n```\n\nas 可以省略，不过还是写上可读性高一些。*一般字段不省略，表省略。具体还得看公司编程规范的要求，没有就看个人喜好了。*\n\n## 条件\n\n限制查询记录的条件——where（选择 Selection，只查询某几行）\n\n```mysql\nselect * from table where `stu_sex`='M' or `stu_name`='Jingqing';\n```\n\n多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。\n\n*性能问题，一般不用 or 而使用 union，结果取并集。*\n\n```mysql\nselect * from table where `stu_sex`='M' \nunion\nselect * from table where `stu_name`='Jingqing';\n```\n\n***如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。***\n\n类似 10<x<30 的形式不可以直接写两个等式，要拆成 x>10 and x<30 。\n\n这里的字段如果是数字类型的，也可以进行 + - * / % mod（也是取余）以及 < >  = >= <= <> 等形式的运算。\n\n还有一种条件写法是 `between …… and ……` \n\n```mysql\nselect * from table where `stu_age` between 10 and 30;-相当于 <=30 and >=10\n```\n\n## 分支结构\n\n如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？\n\n```mysql\nselect if(`stu_sex`,'男','女') as '性别' from `tb_student`;-- 有点类似三目运算符 ?:\n```\n\nif 中第一项可以是表达式，如 age > 10.\n\n**这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。**比如 Oracle 数据库中对应的函数是 decode，不能通用。\n\n通用的分支结构：\n\n```mysql\nselect case `sex` when 1 then '男' else '女' end as '性别' from `tb_student`;-- end 表示条件判断结束\n```\n\n## 模糊查询\n\n如：查询所有姓王的学生。\n\n```mysql\nselect * from `student` where `stu_name` like '王%';-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生\nselect * from `student` where `stu_name` like '王_';-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生\n```\n\n这里和正则表达式有一定联系，之后会单独学习。\n\n事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。\n\n```mysql\nselect * from `student` where `字段名` regexp '正则表达式';\n```\n\n模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。\n\n## 空值处理，以及三值逻辑\n\n**下面两种写法是错误的！**\n\n```mysql\nselect * from `student` where `stu_address` = null;\nselect * from `student` where `stu_address` <> null;\n```\n\n因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。\n\n正确做法：\n\n```mysql\nselect * from `student` where `stu_address` is null;\nselect * from `student` where `stu_address` is not null;\n```\n\n## 去重\n\n```mysql\nselect distinct `字段名` from `表名`;\n```\n\n## 排序\n\n```mysql\n select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序\n```\n\norder by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。\n\n## 当前日期\n\ncurdate()获取当前日期，使用 datediff() 函数可以和出生日期做差获取年龄。\n\nnow()获取当前年月日时分秒（datetime）。\n\n## 取整\n\nfloor() 函数是下取整。floor(3.99) = 3.\n\nceil() 函数是向上取整，ceil(3.1) = 4.\n\nround() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)=4\n\n```mysql\nselect floor(datediff(curdate(),`date`)/365) from `staff`;\n```\n\n*可以通过？ functions 查看函数一览。还会有相应的例子提示~*\n\n## 聚合函数\n\n描述性统计信息：包括集中趋势和离散趋势。\n\n集中趋势：平均值，中位数等。\n\n离散趋势：方差，标准差等。\n\n聚合函数属于 SQL 语句，所有 DBMS 都能用。\n\n- min(字段名)\n\n- max(字段名)\n\n- avg(字段名) *做计算的时候会忽略 null 值*\n\n- sum(字段名)\n\n- count(字段名) *做计算的时候会忽略 null 值*\n\n  ***如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。***\n\n  *比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) / count(stu_id) 就是错误的，因为是9个人的成绩 / 10.* \n\n  *如果成绩为空的学生视为 = 0，就要用 sum(score) / count(stu_id)，或者对 avg() 函数做如下处理：*\n\n  ```mysql\n  select avg(ifnull(`score`,0)) from student;\n  ```\n\n  *ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。*\n\n  coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。\n\n- std(字段名)，计算标准差，越小说明越稳定。\n\n  + std(), stddev() 和 stddev_pop()：所有数据总体的标准差\n  + stddev_samp()：样本标准差，抽样计算。\n\n- variance(字段名)，计算方差，标准差的平方。\n\n  - variance(), var_pop()\n  - var_samp()\n\n## 分组\n\n聚合函数通常和分组一起使用。分组是非常重要的操作。\n\n```mysql\nselect * from `student` group by `sex`;\n```\n\nPS： Excel 的数据透视表有同样功能：\n\n插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认\n\n行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。\n\n```mysql\nselect * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和\n```\n\ngroup by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。\n\n**如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.**\n\n```mysql\nselect `stu_id`,avg(score) from `Score` where avg(score)>90 group by `stu_id`; -- 错误\nselect `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)>90; -- 正确\n```\n\n分组以前的筛选： where, 写在分组后\n\n分组以后的筛选： having, 写在分组后。\n\n*其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：*\n\n```mysql\nselect `stu_id` from `tb_record` group by `stu_id` having avg(score)>90;\n```\n\n*也是没有问题的。*\n\n查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：\n\n```mysql\nselect `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)>90;\n```\n\n## 子查询\n\n子查询 (subquery) 的用途：\n\n- 集合成员资格，判断某一元素是否是某一个集合的成员\n- 集合之间的比较，某一个集合是否包含另一个集合等\n- 集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。\n\n查询年龄最大的学生的姓名。\n\n可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。\n\n一种方法是嵌套子查询：\n\n```mysql\nselect `stu_name` from `tb_student` \nwhere `stu_birth` = (\n    select min(`stu_birth`) from `tb_student`\n);\n```\n\n另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）\n\n```mysql\nset @a =(select min(`stu_birth`) from `tb_student`);\nselect @a; -- 可以查看一下 @a 的值。\n```\n\n如果子查询有很多结果，满足其中一个即可：不能用等号，要用 **in** 。\n\n```mysql\nselect `name` from `tb_student` \nwhere `stu_id` in (\n    select `stu_id` from `tb_record` group by `stu_id` where count(*)>=2\n); -- 查询出所有至少选了2门课的学生姓名\n```\n\n如果用了等号，报错： subquery returns more than 1 row.\n\n## 多表连接\n\n### 笛卡尔积\n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;\n```\n\n如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。\n\n本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。\n\n### 自然连接\n\n1. 有外键约束：利用外键连接，不用加条件，自动连接。\n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` \nfrom `tb_student` natural join `tb_college`;\n```\n\n2. 没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。*注意：不管有几个同名的列，所有列都会作为连接的条件！*\n3. 如果没有外键也没有同名列，就只会得到笛卡尔积的结果。\n\n### 内 / 外连接\n\n另一种连接方式是 inner join / outer join \n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` \nfrom `tb_student` inner join `tb_college` \non `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号\n```\n\ninner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。\n\nleft outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。\n\nright outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。\n\nfull outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。\n\n### θ 连接\n\n添加条件使得两个表中的数据相互对应：\n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` \nwhere `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号\n```\n\n### 三表连接\n\n链接条件用多个条件筛选。\n\n```mysql\nselect `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`\nwhere `tb_course`.`cou_id`=`tb_record`.`cou_id` \nand `tb_student`.`stu_id`=`tb_record`.`stu_id`;\n\nselect `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`\ninner join `tb_record`\non `tb_student`.`stu_id`=`tb_record`.`stu_id`\ninner join `tb_course`\non `tb_course`.`cou_id`=`tb_record`.`cou_id`\nwhere `tb_course`.`cou_name` is not null; -- where 写在最后\n\nselect `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`\nnatural join `tb_record`\nnatural join `tb_course`;\n```\n\n## 查询小技巧\n\n百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件\n\npython -推广链接 不想看到广告推送\n\nsite:zhihu.com python 只搜索知乎里的 python 内容\n\n## 分页查询\n\nlimit 是 mysql 的方言。\n\n```mysql\nselect * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。\nselect * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)\nselect * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)\n```\n\n## 派生表\n\nselect 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）\n\n查询学生姓名和平均成绩。\n\n查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？\n\n先通过一个查询，得到一个派生表：\n\n```mysql\nselect `stu_id`,avg(score) from `tb_record` group by `stu_id`;\n```\n\n然后把其结果作为一个新表，和学生表做关联。\n\n```mysql\nselect `stu_name`,`avg(score)`from `tb_student`\nnatural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思\n```\n\n**临时表必须要起别名！！！**不然报错。\n\n**注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！**因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，**没选课的学生就不会查出来。**\n\n如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。","source":"_posts/SQL 语句——DQL.md","raw":"---\ntitle: SQL 语句——DQL\ndate: 2022-04-25\ntags: study\ncategory: database\n---\n\n学习自b站骆昊jackfrued 老师的网课。\n\n查询语句。\n\n*本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）*\n\n*tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）*\n\n## Select\n\n查询所有学生的所有信息\n\n```mysql\nselect * from `表名`;-- * 号表示所有字段\n```\n\n但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。\n\n实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）\n\n```mysql\nselect `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;\n```\n\n如果只查询部分列，就只写那几列就行。\n\n## 别名\n\n给字段或表起别名—— alias，简写为 as。\n\n```mysql\nselect `stu_id` as `学号` from `tb_student`;\n```\n\nas 可以省略，不过还是写上可读性高一些。*一般字段不省略，表省略。具体还得看公司编程规范的要求，没有就看个人喜好了。*\n\n## 条件\n\n限制查询记录的条件——where（选择 Selection，只查询某几行）\n\n```mysql\nselect * from table where `stu_sex`='M' or `stu_name`='Jingqing';\n```\n\n多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。\n\n*性能问题，一般不用 or 而使用 union，结果取并集。*\n\n```mysql\nselect * from table where `stu_sex`='M' \nunion\nselect * from table where `stu_name`='Jingqing';\n```\n\n***如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。***\n\n类似 10<x<30 的形式不可以直接写两个等式，要拆成 x>10 and x<30 。\n\n这里的字段如果是数字类型的，也可以进行 + - * / % mod（也是取余）以及 < >  = >= <= <> 等形式的运算。\n\n还有一种条件写法是 `between …… and ……` \n\n```mysql\nselect * from table where `stu_age` between 10 and 30;-相当于 <=30 and >=10\n```\n\n## 分支结构\n\n如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？\n\n```mysql\nselect if(`stu_sex`,'男','女') as '性别' from `tb_student`;-- 有点类似三目运算符 ?:\n```\n\nif 中第一项可以是表达式，如 age > 10.\n\n**这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。**比如 Oracle 数据库中对应的函数是 decode，不能通用。\n\n通用的分支结构：\n\n```mysql\nselect case `sex` when 1 then '男' else '女' end as '性别' from `tb_student`;-- end 表示条件判断结束\n```\n\n## 模糊查询\n\n如：查询所有姓王的学生。\n\n```mysql\nselect * from `student` where `stu_name` like '王%';-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生\nselect * from `student` where `stu_name` like '王_';-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生\n```\n\n这里和正则表达式有一定联系，之后会单独学习。\n\n事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。\n\n```mysql\nselect * from `student` where `字段名` regexp '正则表达式';\n```\n\n模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。\n\n## 空值处理，以及三值逻辑\n\n**下面两种写法是错误的！**\n\n```mysql\nselect * from `student` where `stu_address` = null;\nselect * from `student` where `stu_address` <> null;\n```\n\n因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。\n\n正确做法：\n\n```mysql\nselect * from `student` where `stu_address` is null;\nselect * from `student` where `stu_address` is not null;\n```\n\n## 去重\n\n```mysql\nselect distinct `字段名` from `表名`;\n```\n\n## 排序\n\n```mysql\n select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序\n```\n\norder by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。\n\n## 当前日期\n\ncurdate()获取当前日期，使用 datediff() 函数可以和出生日期做差获取年龄。\n\nnow()获取当前年月日时分秒（datetime）。\n\n## 取整\n\nfloor() 函数是下取整。floor(3.99) = 3.\n\nceil() 函数是向上取整，ceil(3.1) = 4.\n\nround() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)=4\n\n```mysql\nselect floor(datediff(curdate(),`date`)/365) from `staff`;\n```\n\n*可以通过？ functions 查看函数一览。还会有相应的例子提示~*\n\n## 聚合函数\n\n描述性统计信息：包括集中趋势和离散趋势。\n\n集中趋势：平均值，中位数等。\n\n离散趋势：方差，标准差等。\n\n聚合函数属于 SQL 语句，所有 DBMS 都能用。\n\n- min(字段名)\n\n- max(字段名)\n\n- avg(字段名) *做计算的时候会忽略 null 值*\n\n- sum(字段名)\n\n- count(字段名) *做计算的时候会忽略 null 值*\n\n  ***如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。***\n\n  *比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) / count(stu_id) 就是错误的，因为是9个人的成绩 / 10.* \n\n  *如果成绩为空的学生视为 = 0，就要用 sum(score) / count(stu_id)，或者对 avg() 函数做如下处理：*\n\n  ```mysql\n  select avg(ifnull(`score`,0)) from student;\n  ```\n\n  *ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。*\n\n  coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。\n\n- std(字段名)，计算标准差，越小说明越稳定。\n\n  + std(), stddev() 和 stddev_pop()：所有数据总体的标准差\n  + stddev_samp()：样本标准差，抽样计算。\n\n- variance(字段名)，计算方差，标准差的平方。\n\n  - variance(), var_pop()\n  - var_samp()\n\n## 分组\n\n聚合函数通常和分组一起使用。分组是非常重要的操作。\n\n```mysql\nselect * from `student` group by `sex`;\n```\n\nPS： Excel 的数据透视表有同样功能：\n\n插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认\n\n行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。\n\n```mysql\nselect * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和\n```\n\ngroup by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。\n\n**如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.**\n\n```mysql\nselect `stu_id`,avg(score) from `Score` where avg(score)>90 group by `stu_id`; -- 错误\nselect `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)>90; -- 正确\n```\n\n分组以前的筛选： where, 写在分组后\n\n分组以后的筛选： having, 写在分组后。\n\n*其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：*\n\n```mysql\nselect `stu_id` from `tb_record` group by `stu_id` having avg(score)>90;\n```\n\n*也是没有问题的。*\n\n查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：\n\n```mysql\nselect `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)>90;\n```\n\n## 子查询\n\n子查询 (subquery) 的用途：\n\n- 集合成员资格，判断某一元素是否是某一个集合的成员\n- 集合之间的比较，某一个集合是否包含另一个集合等\n- 集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。\n\n查询年龄最大的学生的姓名。\n\n可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。\n\n一种方法是嵌套子查询：\n\n```mysql\nselect `stu_name` from `tb_student` \nwhere `stu_birth` = (\n    select min(`stu_birth`) from `tb_student`\n);\n```\n\n另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）\n\n```mysql\nset @a =(select min(`stu_birth`) from `tb_student`);\nselect @a; -- 可以查看一下 @a 的值。\n```\n\n如果子查询有很多结果，满足其中一个即可：不能用等号，要用 **in** 。\n\n```mysql\nselect `name` from `tb_student` \nwhere `stu_id` in (\n    select `stu_id` from `tb_record` group by `stu_id` where count(*)>=2\n); -- 查询出所有至少选了2门课的学生姓名\n```\n\n如果用了等号，报错： subquery returns more than 1 row.\n\n## 多表连接\n\n### 笛卡尔积\n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;\n```\n\n如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。\n\n本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。\n\n### 自然连接\n\n1. 有外键约束：利用外键连接，不用加条件，自动连接。\n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` \nfrom `tb_student` natural join `tb_college`;\n```\n\n2. 没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。*注意：不管有几个同名的列，所有列都会作为连接的条件！*\n3. 如果没有外键也没有同名列，就只会得到笛卡尔积的结果。\n\n### 内 / 外连接\n\n另一种连接方式是 inner join / outer join \n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` \nfrom `tb_student` inner join `tb_college` \non `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号\n```\n\ninner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。\n\nleft outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。\n\nright outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。\n\nfull outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。\n\n### θ 连接\n\n添加条件使得两个表中的数据相互对应：\n\n```mysql\nselect `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` \nwhere `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号\n```\n\n### 三表连接\n\n链接条件用多个条件筛选。\n\n```mysql\nselect `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`\nwhere `tb_course`.`cou_id`=`tb_record`.`cou_id` \nand `tb_student`.`stu_id`=`tb_record`.`stu_id`;\n\nselect `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`\ninner join `tb_record`\non `tb_student`.`stu_id`=`tb_record`.`stu_id`\ninner join `tb_course`\non `tb_course`.`cou_id`=`tb_record`.`cou_id`\nwhere `tb_course`.`cou_name` is not null; -- where 写在最后\n\nselect `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`\nnatural join `tb_record`\nnatural join `tb_course`;\n```\n\n## 查询小技巧\n\n百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件\n\npython -推广链接 不想看到广告推送\n\nsite:zhihu.com python 只搜索知乎里的 python 内容\n\n## 分页查询\n\nlimit 是 mysql 的方言。\n\n```mysql\nselect * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。\nselect * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)\nselect * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)\n```\n\n## 派生表\n\nselect 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）\n\n查询学生姓名和平均成绩。\n\n查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？\n\n先通过一个查询，得到一个派生表：\n\n```mysql\nselect `stu_id`,avg(score) from `tb_record` group by `stu_id`;\n```\n\n然后把其结果作为一个新表，和学生表做关联。\n\n```mysql\nselect `stu_name`,`avg(score)`from `tb_student`\nnatural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思\n```\n\n**临时表必须要起别名！！！**不然报错。\n\n**注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！**因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，**没选课的学生就不会查出来。**\n\n如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。","slug":"SQL 语句——DQL","published":1,"updated":"2022-05-05T03:12:06.937Z","_id":"cl2fwocup0000vkv2e2xxbmp8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>学习自b站骆昊jackfrued 老师的网课。</p>\n<p>查询语句。</p>\n<p><em>本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）</em></p>\n<p><em>tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）</em></p>\n<h2 id=\"Select\"><a href=\"#Select\" class=\"headerlink\" title=\"Select\"></a>Select</h2><p>查询所有学生的所有信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `表名`;-- * 号表示所有字段<br></code></pre></td></tr></table></figure>\n\n<p>但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。</p>\n<p>实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;<br></code></pre></td></tr></table></figure>\n\n<p>如果只查询部分列，就只写那几列就行。</p>\n<h2 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h2><p>给字段或表起别名—— alias，简写为 as。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id` as `学号` from `tb_student`;<br></code></pre></td></tr></table></figure>\n\n<p>as 可以省略，不过还是写上可读性高一些。<em>一般字段不省略，表省略。具体还得看公司编程规范的要求，没有就看个人喜好了。</em></p>\n<h2 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h2><p>限制查询记录的条件——where（选择 Selection，只查询某几行）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from table where `stu_sex`=&#x27;M&#x27; or `stu_name`=&#x27;Jingqing&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。</p>\n<p><em>性能问题，一般不用 or 而使用 union，结果取并集。</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from table where `stu_sex`=&#x27;M&#x27; <br>union<br>select * from table where `stu_name`=&#x27;Jingqing&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p><em><strong>如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。</strong></em></p>\n<p>类似 10&lt;x&lt;30 的形式不可以直接写两个等式，要拆成 x&gt;10 and x&lt;30 。</p>\n<p>这里的字段如果是数字类型的，也可以进行 + - * / % mod（也是取余）以及 &lt; &gt;  = &gt;= &lt;= &lt;&gt; 等形式的运算。</p>\n<p>还有一种条件写法是 <code>between …… and ……</code> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from table where `stu_age` between 10 and 30;-相当于 &lt;=30 and &gt;=10<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"分支结构\"><a href=\"#分支结构\" class=\"headerlink\" title=\"分支结构\"></a>分支结构</h2><p>如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select if(`stu_sex`,&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;性别&#x27; from `tb_student`;-- 有点类似三目运算符 ?:<br></code></pre></td></tr></table></figure>\n\n<p>if 中第一项可以是表达式，如 age &gt; 10.</p>\n<p><strong>这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。</strong>比如 Oracle 数据库中对应的函数是 decode，不能通用。</p>\n<p>通用的分支结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select case `sex` when 1 then &#x27;男&#x27; else &#x27;女&#x27; end as &#x27;性别&#x27; from `tb_student`;-- end 表示条件判断结束<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h2><p>如：查询所有姓王的学生。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `stu_name` like &#x27;王%&#x27;;-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生<br>select * from `student` where `stu_name` like &#x27;王_&#x27;;-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生<br></code></pre></td></tr></table></figure>\n\n<p>这里和正则表达式有一定联系，之后会单独学习。</p>\n<p>事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `字段名` regexp &#x27;正则表达式&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。</p>\n<h2 id=\"空值处理，以及三值逻辑\"><a href=\"#空值处理，以及三值逻辑\" class=\"headerlink\" title=\"空值处理，以及三值逻辑\"></a>空值处理，以及三值逻辑</h2><p><strong>下面两种写法是错误的！</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `stu_address` = null;<br>select * from `student` where `stu_address` &lt;&gt; null;<br></code></pre></td></tr></table></figure>\n\n<p>因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。</p>\n<p>正确做法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `stu_address` is null;<br>select * from `student` where `stu_address` is not null;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select distinct `字段名` from `表名`;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序<br></code></pre></td></tr></table></figure>\n\n<p>order by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。</p>\n<h2 id=\"当前日期\"><a href=\"#当前日期\" class=\"headerlink\" title=\"当前日期\"></a>当前日期</h2><p>curdate()获取当前日期，使用 datediff() 函数可以和出生日期做差获取年龄。</p>\n<p>now()获取当前年月日时分秒（datetime）。</p>\n<h2 id=\"取整\"><a href=\"#取整\" class=\"headerlink\" title=\"取整\"></a>取整</h2><p>floor() 函数是下取整。floor(3.99) = 3.</p>\n<p>ceil() 函数是向上取整，ceil(3.1) = 4.</p>\n<p>round() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)=4</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select floor(datediff(curdate(),`date`)/365) from `staff`;<br></code></pre></td></tr></table></figure>\n\n<p><em>可以通过？ functions 查看函数一览。还会有相应的例子提示~</em></p>\n<h2 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a>聚合函数</h2><p>描述性统计信息：包括集中趋势和离散趋势。</p>\n<p>集中趋势：平均值，中位数等。</p>\n<p>离散趋势：方差，标准差等。</p>\n<p>聚合函数属于 SQL 语句，所有 DBMS 都能用。</p>\n<ul>\n<li><p>min(字段名)</p>\n</li>\n<li><p>max(字段名)</p>\n</li>\n<li><p>avg(字段名) <em>做计算的时候会忽略 null 值</em></p>\n</li>\n<li><p>sum(字段名)</p>\n</li>\n<li><p>count(字段名) <em>做计算的时候会忽略 null 值</em></p>\n<p><em><strong>如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。</strong></em></p>\n<p><em>比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) / count(stu_id) 就是错误的，因为是9个人的成绩 / 10.</em> </p>\n<p><em>如果成绩为空的学生视为 = 0，就要用 sum(score) / count(stu_id)，或者对 avg() 函数做如下处理：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select avg(ifnull(`score`,0)) from student;<br></code></pre></td></tr></table></figure>\n\n<p><em>ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。</em></p>\n<p>coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。</p>\n</li>\n<li><p>std(字段名)，计算标准差，越小说明越稳定。</p>\n<ul>\n<li>std(), stddev() 和 stddev_pop()：所有数据总体的标准差</li>\n<li>stddev_samp()：样本标准差，抽样计算。</li>\n</ul>\n</li>\n<li><p>variance(字段名)，计算方差，标准差的平方。</p>\n<ul>\n<li>variance(), var_pop()</li>\n<li>var_samp()</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>聚合函数通常和分组一起使用。分组是非常重要的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` group by `sex`;<br></code></pre></td></tr></table></figure>\n\n<p>PS： Excel 的数据透视表有同样功能：</p>\n<p>插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认</p>\n<p>行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和<br></code></pre></td></tr></table></figure>\n\n<p>group by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。</p>\n<p><strong>如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,avg(score) from `Score` where avg(score)&gt;90 group by `stu_id`; -- 错误<br>select `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)&gt;90; -- 正确<br></code></pre></td></tr></table></figure>\n\n<p>分组以前的筛选： where, 写在分组后</p>\n<p>分组以后的筛选： having, 写在分组后。</p>\n<p><em>其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id` from `tb_record` group by `stu_id` having avg(score)&gt;90;<br></code></pre></td></tr></table></figure>\n\n<p><em>也是没有问题的。</em></p>\n<p>查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)&gt;90;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>子查询 (subquery) 的用途：</p>\n<ul>\n<li>集合成员资格，判断某一元素是否是某一个集合的成员</li>\n<li>集合之间的比较，某一个集合是否包含另一个集合等</li>\n<li>集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。</li>\n</ul>\n<p>查询年龄最大的学生的姓名。</p>\n<p>可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。</p>\n<p>一种方法是嵌套子查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name` from `tb_student` <br>where `stu_birth` = (<br>    select min(`stu_birth`) from `tb_student`<br>);<br></code></pre></td></tr></table></figure>\n\n<p>另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set @a =(select min(`stu_birth`) from `tb_student`);<br>select @a; -- 可以查看一下 @a 的值。<br></code></pre></td></tr></table></figure>\n\n<p>如果子查询有很多结果，满足其中一个即可：不能用等号，要用 <strong>in</strong> 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `name` from `tb_student` <br>where `stu_id` in (<br>    select `stu_id` from `tb_record` group by `stu_id` where count(*)&gt;=2<br>); -- 查询出所有至少选了2门课的学生姓名<br></code></pre></td></tr></table></figure>\n\n<p>如果用了等号，报错： subquery returns more than 1 row.</p>\n<h2 id=\"多表连接\"><a href=\"#多表连接\" class=\"headerlink\" title=\"多表连接\"></a>多表连接</h2><h3 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;<br></code></pre></td></tr></table></figure>\n\n<p>如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。</p>\n<p>本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。</p>\n<h3 id=\"自然连接\"><a href=\"#自然连接\" class=\"headerlink\" title=\"自然连接\"></a>自然连接</h3><ol>\n<li>有外键约束：利用外键连接，不用加条件，自动连接。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` <br>from `tb_student` natural join `tb_college`;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。<em>注意：不管有几个同名的列，所有列都会作为连接的条件！</em></li>\n<li>如果没有外键也没有同名列，就只会得到笛卡尔积的结果。</li>\n</ol>\n<h3 id=\"内-外连接\"><a href=\"#内-外连接\" class=\"headerlink\" title=\"内 / 外连接\"></a>内 / 外连接</h3><p>另一种连接方式是 inner join / outer join </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` <br>from `tb_student` inner join `tb_college` <br>on `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号<br></code></pre></td></tr></table></figure>\n\n<p>inner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。</p>\n<p>left outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。</p>\n<p>right outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。</p>\n<p>full outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。</p>\n<h3 id=\"θ-连接\"><a href=\"#θ-连接\" class=\"headerlink\" title=\"θ 连接\"></a>θ 连接</h3><p>添加条件使得两个表中的数据相互对应：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` <br>where `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"三表连接\"><a href=\"#三表连接\" class=\"headerlink\" title=\"三表连接\"></a>三表连接</h3><p>链接条件用多个条件筛选。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`<br>where `tb_course`.`cou_id`=`tb_record`.`cou_id` <br>and `tb_student`.`stu_id`=`tb_record`.`stu_id`;<br><br>select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`<br>inner join `tb_record`<br>on `tb_student`.`stu_id`=`tb_record`.`stu_id`<br>inner join `tb_course`<br>on `tb_course`.`cou_id`=`tb_record`.`cou_id`<br>where `tb_course`.`cou_name` is not null; -- where 写在最后<br><br>select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`<br>natural join `tb_record`<br>natural join `tb_course`;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"查询小技巧\"><a href=\"#查询小技巧\" class=\"headerlink\" title=\"查询小技巧\"></a>查询小技巧</h2><p>百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件</p>\n<p>python -推广链接 不想看到广告推送</p>\n<p>site:zhihu.com python 只搜索知乎里的 python 内容</p>\n<h2 id=\"分页查询\"><a href=\"#分页查询\" class=\"headerlink\" title=\"分页查询\"></a>分页查询</h2><p>limit 是 mysql 的方言。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。<br>select * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)<br>select * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"派生表\"><a href=\"#派生表\" class=\"headerlink\" title=\"派生表\"></a>派生表</h2><p>select 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）</p>\n<p>查询学生姓名和平均成绩。</p>\n<p>查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？</p>\n<p>先通过一个查询，得到一个派生表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,avg(score) from `tb_record` group by `stu_id`;<br></code></pre></td></tr></table></figure>\n\n<p>然后把其结果作为一个新表，和学生表做关联。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`avg(score)`from `tb_student`<br>natural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思<br></code></pre></td></tr></table></figure>\n\n<p><strong>临时表必须要起别名！！！</strong>不然报错。</p>\n<p><strong>注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！</strong>因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，<strong>没选课的学生就不会查出来。</strong></p>\n<p>如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习自b站骆昊jackfrued 老师的网课。</p>\n<p>查询语句。</p>\n<p><em>本节中使用到的例子：主要包含 tb_student 学生表（学号 stu_id，姓名 stu_name，地址 stu_address,所属学院号 col_id）</em></p>\n<p><em>tb_record 记录表，连接学生和所选的课 id 及课程成绩（学号 stu_id，课程号）</em></p>\n<h2 id=\"Select\"><a href=\"#Select\" class=\"headerlink\" title=\"Select\"></a>Select</h2><p>查询所有学生的所有信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `表名`;-- * 号表示所有字段<br></code></pre></td></tr></table></figure>\n\n<p>但是这样有一点影响效率，会先查出学生表中有哪些列，再查询这些列的数据。</p>\n<p>实际使用一般都是手动写上所有要查询的字段。（投影 Projection，只查询某几列）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,`stu_sex`,`stu_name`,`stu_address` from `tb_student`;<br></code></pre></td></tr></table></figure>\n\n<p>如果只查询部分列，就只写那几列就行。</p>\n<h2 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h2><p>给字段或表起别名—— alias，简写为 as。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id` as `学号` from `tb_student`;<br></code></pre></td></tr></table></figure>\n\n<p>as 可以省略，不过还是写上可读性高一些。<em>一般字段不省略，表省略。具体还得看公司编程规范的要求，没有就看个人喜好了。</em></p>\n<h2 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h2><p>限制查询记录的条件——where（选择 Selection，只查询某几行）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from table where `stu_sex`=&#x27;M&#x27; or `stu_name`=&#x27;Jingqing&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>多个条件之间用 or 连接就是或者的关系，满足一个即可；用 and 连接就是和的关系，同时满足。</p>\n<p><em>性能问题，一般不用 or 而使用 union，结果取并集。</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from table where `stu_sex`=&#x27;M&#x27; <br>union<br>select * from table where `stu_name`=&#x27;Jingqing&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p><em><strong>如果在 union 后面加 all，意思是并集不会去掉重复的部分，相交的部分会显示两遍。</strong></em></p>\n<p>类似 10&lt;x&lt;30 的形式不可以直接写两个等式，要拆成 x&gt;10 and x&lt;30 。</p>\n<p>这里的字段如果是数字类型的，也可以进行 + - * / % mod（也是取余）以及 &lt; &gt;  = &gt;= &lt;= &lt;&gt; 等形式的运算。</p>\n<p>还有一种条件写法是 <code>between …… and ……</code> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from table where `stu_age` between 10 and 30;-相当于 &lt;=30 and &gt;=10<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"分支结构\"><a href=\"#分支结构\" class=\"headerlink\" title=\"分支结构\"></a>分支结构</h2><p>如果 sex 是布尔值，1代表男，0代表女，怎么把0和1处理成对应的性别？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select if(`stu_sex`,&#x27;男&#x27;,&#x27;女&#x27;) as &#x27;性别&#x27; from `tb_student`;-- 有点类似三目运算符 ?:<br></code></pre></td></tr></table></figure>\n\n<p>if 中第一项可以是表达式，如 age &gt; 10.</p>\n<p><strong>这个是 Mysql 数据库的方言，只能在 Mysql 数据库中生效。</strong>比如 Oracle 数据库中对应的函数是 decode，不能通用。</p>\n<p>通用的分支结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select case `sex` when 1 then &#x27;男&#x27; else &#x27;女&#x27; end as &#x27;性别&#x27; from `tb_student`;-- end 表示条件判断结束<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"模糊查询\"><a href=\"#模糊查询\" class=\"headerlink\" title=\"模糊查询\"></a>模糊查询</h2><p>如：查询所有姓王的学生。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `stu_name` like &#x27;王%&#x27;;-- % 代表零个或多个任意字符，表示查询姓的且名字只有2个字的学生<br>select * from `student` where `stu_name` like &#x27;王_&#x27;;-- _ 代表一个任意字符，表示查询姓王的且名字只有2个字的学生<br></code></pre></td></tr></table></figure>\n\n<p>这里和正则表达式有一定联系，之后会单独学习。</p>\n<p>事实上 Mysql 语句也支持正则表达式的，正则表达式也比这两种模糊查询的通配符功能强大很多。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `字段名` regexp &#x27;正则表达式&#x27;;<br></code></pre></td></tr></table></figure>\n\n<p>模糊查询，特别是 % 在左侧的时候，性能还是比较差的，尽量避免。</p>\n<h2 id=\"空值处理，以及三值逻辑\"><a href=\"#空值处理，以及三值逻辑\" class=\"headerlink\" title=\"空值处理，以及三值逻辑\"></a>空值处理，以及三值逻辑</h2><p><strong>下面两种写法是错误的！</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `stu_address` = null;<br>select * from `student` where `stu_address` &lt;&gt; null;<br></code></pre></td></tr></table></figure>\n\n<p>因为表达式产生的值有三种（三值逻辑），true, false, unknown。和空值做运算的时候，就会得到 unknown 的结果。</p>\n<p>正确做法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` where `stu_address` is null;<br>select * from `student` where `stu_address` is not null;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select distinct `字段名` from `表名`;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `字段名` from `表名` order by `字段名1` asc, `字段名2` desc; -- asc: 默认，ascending，升序；desc：descending，降序<br></code></pre></td></tr></table></figure>\n\n<p>order by 后面跟多个字段，就是先按字段1排序，字段1相等时再按字段2排序。</p>\n<h2 id=\"当前日期\"><a href=\"#当前日期\" class=\"headerlink\" title=\"当前日期\"></a>当前日期</h2><p>curdate()获取当前日期，使用 datediff() 函数可以和出生日期做差获取年龄。</p>\n<p>now()获取当前年月日时分秒（datetime）。</p>\n<h2 id=\"取整\"><a href=\"#取整\" class=\"headerlink\" title=\"取整\"></a>取整</h2><p>floor() 函数是下取整。floor(3.99) = 3.</p>\n<p>ceil() 函数是向上取整，ceil(3.1) = 4.</p>\n<p>round() 函数是四舍五入，第二个参数是保留几位小数的意思，round(3.5,0)=4</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select floor(datediff(curdate(),`date`)/365) from `staff`;<br></code></pre></td></tr></table></figure>\n\n<p><em>可以通过？ functions 查看函数一览。还会有相应的例子提示~</em></p>\n<h2 id=\"聚合函数\"><a href=\"#聚合函数\" class=\"headerlink\" title=\"聚合函数\"></a>聚合函数</h2><p>描述性统计信息：包括集中趋势和离散趋势。</p>\n<p>集中趋势：平均值，中位数等。</p>\n<p>离散趋势：方差，标准差等。</p>\n<p>聚合函数属于 SQL 语句，所有 DBMS 都能用。</p>\n<ul>\n<li><p>min(字段名)</p>\n</li>\n<li><p>max(字段名)</p>\n</li>\n<li><p>avg(字段名) <em>做计算的时候会忽略 null 值</em></p>\n</li>\n<li><p>sum(字段名)</p>\n</li>\n<li><p>count(字段名) <em>做计算的时候会忽略 null 值</em></p>\n<p><em><strong>如果利用 sum()和count() 做除法求平均值，要考虑空值对结果的影响。</strong></em></p>\n<p><em>比如有10个学生，但有一个学生的成绩为空，如果忽略掉成绩为空的学生， sum(score) / count(stu_id) 就是错误的，因为是9个人的成绩 / 10.</em> </p>\n<p><em>如果成绩为空的学生视为 = 0，就要用 sum(score) / count(stu_id)，或者对 avg() 函数做如下处理：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select avg(ifnull(`score`,0)) from student;<br></code></pre></td></tr></table></figure>\n\n<p><em>ifnull() 函数也是 mysql 的方言，类似 if。在 Oracle 中就是 nvl。</em></p>\n<p>coalesce() 也可以处理空值，是标准数据库的函数，它会取第一个非空值。如：coalesce(score, 0)。</p>\n</li>\n<li><p>std(字段名)，计算标准差，越小说明越稳定。</p>\n<ul>\n<li>std(), stddev() 和 stddev_pop()：所有数据总体的标准差</li>\n<li>stddev_samp()：样本标准差，抽样计算。</li>\n</ul>\n</li>\n<li><p>variance(字段名)，计算方差，标准差的平方。</p>\n<ul>\n<li>variance(), var_pop()</li>\n<li>var_samp()</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>聚合函数通常和分组一起使用。分组是非常重要的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` group by `sex`;<br></code></pre></td></tr></table></figure>\n\n<p>PS： Excel 的数据透视表有同样功能：</p>\n<p>插入-数据透视表-选择所有数据范围（选中左上角的单元格，Ctrl + Shift + →，Ctrl + Shift + ↓选中所有有数据的单元格）-选择放置数据表的位置（选择某一列的第一行的单元格，如 J1 或 K1 ）-确认</p>\n<p>行里选择要分组的列（如：销售区域）值选择要分组运算的对应值（如：销售额），值默认做的就是求和运算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `student` group by `sex` with rollup; -- with rollup: 在最后一列求个总和<br></code></pre></td></tr></table></figure>\n\n<p>group by 后面也可以跟多个字段，先按第一个分组，然后在每个组里再按第二个分组。</p>\n<p><strong>如果进行了条件查询，用到了 group by 得到的结果，不能直接用 where，要使用 having.</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,avg(score) from `Score` where avg(score)&gt;90 group by `stu_id`; -- 错误<br>select `stu_id`,avg(score) from `Score` group by `stu_id` having avg(score)&gt;90; -- 正确<br></code></pre></td></tr></table></figure>\n\n<p>分组以前的筛选： where, 写在分组后</p>\n<p>分组以后的筛选： having, 写在分组后。</p>\n<p><em>其实这里个人有一个小误区：select 不用非得查出 avg() 才能做 having 条件判断。比如要查询平均成绩大于90分的学生学号，就可以改成：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id` from `tb_record` group by `stu_id` having avg(score)&gt;90;<br></code></pre></td></tr></table></figure>\n\n<p><em>也是没有问题的。</em></p>\n<p>查询 1111,2222,3333三门课程平均成绩大于90分的学生的平均成绩：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,avg(score) from `Score` where `cou_id` in (1111,2222,3333) group by `stu_id` having avg(score)&gt;90;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>子查询 (subquery) 的用途：</p>\n<ul>\n<li>集合成员资格，判断某一元素是否是某一个集合的成员</li>\n<li>集合之间的比较，某一个集合是否包含另一个集合等</li>\n<li>集合基数的测试，测试集合是否为空，测试集合是否存在重复元组。</li>\n</ul>\n<p>查询年龄最大的学生的姓名。</p>\n<p>可以先查询出最大年龄，再查询学生表中年龄等于这个值的学生姓名。</p>\n<p>一种方法是嵌套子查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name` from `tb_student` <br>where `stu_birth` = (<br>    select min(`stu_birth`) from `tb_student`<br>);<br></code></pre></td></tr></table></figure>\n\n<p>另一种方法是定义变量：mysql 定义变量，需要加@（但是不能把多个值赋给一个变量！）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set @a =(select min(`stu_birth`) from `tb_student`);<br>select @a; -- 可以查看一下 @a 的值。<br></code></pre></td></tr></table></figure>\n\n<p>如果子查询有很多结果，满足其中一个即可：不能用等号，要用 <strong>in</strong> 。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `name` from `tb_student` <br>where `stu_id` in (<br>    select `stu_id` from `tb_record` group by `stu_id` where count(*)&gt;=2<br>); -- 查询出所有至少选了2门课的学生姓名<br></code></pre></td></tr></table></figure>\n\n<p>如果用了等号，报错： subquery returns more than 1 row.</p>\n<h2 id=\"多表连接\"><a href=\"#多表连接\" class=\"headerlink\" title=\"多表连接\"></a>多表连接</h2><h3 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college`;<br></code></pre></td></tr></table></figure>\n\n<p>如果不加条件的从两个表中投影出数据，就会获得两个表中所有记录的笛卡尔积，即排列组合。</p>\n<p>本例中，学生表和学员表中都有学院号 col_id 字段，因此投影该字段的时候需要指明是从那个表中得到的，用 表名.字段 指定。</p>\n<h3 id=\"自然连接\"><a href=\"#自然连接\" class=\"headerlink\" title=\"自然连接\"></a>自然连接</h3><ol>\n<li>有外键约束：利用外键连接，不用加条件，自动连接。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` <br>from `tb_student` natural join `tb_college`;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>没有外键，但是两个表中有同名的列（如本例中两个表中都有 col_id 列）也可以进行自然连接。<em>注意：不管有几个同名的列，所有列都会作为连接的条件！</em></li>\n<li>如果没有外键也没有同名列，就只会得到笛卡尔积的结果。</li>\n</ol>\n<h3 id=\"内-外连接\"><a href=\"#内-外连接\" class=\"headerlink\" title=\"内 / 外连接\"></a>内 / 外连接</h3><p>另一种连接方式是 inner join / outer join </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` <br>from `tb_student` inner join `tb_college` <br>on `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号<br></code></pre></td></tr></table></figure>\n\n<p>inner join：只有左表中有的记录，而且在右表中能找到对应的记录才会呈现出来。</p>\n<p>left outer join：左表中所有内容都会呈现出来，右表中如果没有对应的内容补 null。</p>\n<p>right outer join：右表中所有内容都会呈现出来，左表中如果没有对应的内容补 null。</p>\n<p>full outer join：左右表数据全拿出来，没有对应的内容都补 null。但是 mysql 并不支持全外连接，可以用左外连接 union 右外连接代替。</p>\n<h3 id=\"θ-连接\"><a href=\"#θ-连接\" class=\"headerlink\" title=\"θ 连接\"></a>θ 连接</h3><p>添加条件使得两个表中的数据相互对应：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`stu_id`,`col_name`,`tb_college`.`col_id` from `tb_student`,`tb_college` <br>where `tb_student`.`col_id`=`tb_college`.`col_id`; -- 查询所有学生的姓名、学号、对应的学院名、学院号<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"三表连接\"><a href=\"#三表连接\" class=\"headerlink\" title=\"三表连接\"></a>三表连接</h3><p>链接条件用多个条件筛选。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`,`tb_course`, `tb_record`<br>where `tb_course`.`cou_id`=`tb_record`.`cou_id` <br>and `tb_student`.`stu_id`=`tb_record`.`stu_id`;<br><br>select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`<br>inner join `tb_record`<br>on `tb_student`.`stu_id`=`tb_record`.`stu_id`<br>inner join `tb_course`<br>on `tb_course`.`cou_id`=`tb_record`.`cou_id`<br>where `tb_course`.`cou_name` is not null; -- where 写在最后<br><br>select `stu_name`,`tb_student`.`stu_id`,`tb_course`.`cou_name`,`tb_course`.`cou_id` from `tb_student`<br>natural join `tb_record`<br>natural join `tb_course`;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"查询小技巧\"><a href=\"#查询小技巧\" class=\"headerlink\" title=\"查询小技巧\"></a>查询小技巧</h2><p>百度搜索：filetype:pdf python 搜索带 python 名的 pdf 文件</p>\n<p>python -推广链接 不想看到广告推送</p>\n<p>site:zhihu.com python 只搜索知乎里的 python 内容</p>\n<h2 id=\"分页查询\"><a href=\"#分页查询\" class=\"headerlink\" title=\"分页查询\"></a>分页查询</h2><p>limit 是 mysql 的方言。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from `tb_student` order by `stu_id` desc limit 5;-- 只显示前五条数据.如果不足5条，就有几条显示几条。<br>select * from `tb_student` order by `stu_id` desc limit 5 offset 3;-- 只显示4-8条数据(跳过前3条数据)<br>select * from `tb_student` order by `stu_id` desc limit (3,5);-- 只显示4-8条数据(跳过前3条数据)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"派生表\"><a href=\"#派生表\" class=\"headerlink\" title=\"派生表\"></a>派生表</h2><p>select 的返回值也是一个关系。（关系运算的封闭性，关系的运算仍然是关系）</p>\n<p>查询学生姓名和平均成绩。</p>\n<p>查询学生学号和平均成绩的话，可以在 tb_record 表里根据学生学号分组，然后投影出来。但查询学生姓名有需要拿着对应的学号去学生表里连接，要怎么把学生姓名和学生平均成绩关联起来呢？</p>\n<p>先通过一个查询，得到一个派生表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_id`,avg(score) from `tb_record` group by `stu_id`;<br></code></pre></td></tr></table></figure>\n\n<p>然后把其结果作为一个新表，和学生表做关联。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `stu_name`,`avg(score)`from `tb_student`<br>natural join (select `stu_id`,avg(score) from `tb_record` group by `stu_id`) `tb_derived`;-- 最后是起别名的意思<br></code></pre></td></tr></table></figure>\n\n<p><strong>临时表必须要起别名！！！</strong>不然报错。</p>\n<p><strong>注意：查询学生姓名和选课数 和 查询每个学生姓名和选课数的区别！</strong>因为有的同学没有选课，如果用 natural join，inner join，就只能查询到选了课的学生，<strong>没选课的学生就不会查出来。</strong></p>\n<p>如果要查询每个学生，就要用到外连接。没选课的学生选课数显示 null。（当然可以用 ifnull(字段, 0) 把 null 替换成 0。记得 ifnull 是 mysql 方言）。</p>\n"},{"title":"Python——语法基础1","date":"2022-04-27T16:00:00.000Z","_content":"\n今天开始跟着 Alex老师 [Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Z64y1S72C?p=1)的课程学习Python~\n\n关于编译器解释器的部分、Python 安装及 Path 配置就不再赘述了。从计算机三大件的部分开始学习。\n\n# 计算机三大件\n\n## 硬盘\n\n数据的永久存储。\n\n## 内存\n\n数据的临时存储。处理数据速度远快于硬盘，所以才有存在的意义。处理数据应该尽量避免对硬盘的直接读写。\n\n## CPU\n\n进行运算。计算数据来自于内存。\n\n计算时，数据从硬盘传到内存，再传给 CPU 进行运算。\n\n保存数据后，数据再保存到硬盘。\n\n# 变量\n\n先定义，后使用。\n\n定义规则和 C 一样，字母数字下划线，数字不能开头，不能是关键字。\n\n可以是中文名，但很 low~ 尽量不要用。\n\n```python\nname = \"Jingqing\"\nname = \"Rename\" #直接重新赋值，地址不变\n```\n\n可以通过 id(变量名) 方法获取变量地址。\n\n# 数据类型\n\n| 类型               | 含义     |\n| ------------------ | -------- |\n| int / long / float | 数字类型 |\n| str                | 字符串   |\n| list               | 列表     |\n| bool               | 布尔     |\n| set                | 集合     |\n| dict               | 字典     |\n| bytes              | 字节     |\n\n## 数字类型\n\npython 3之后没有 long 类型了，全是 int.\n\n字符串类型不可以修改。如果已经把字符串类型赋给了一个变量，再重新赋值成其他字符串值，会发现地址变了，说明没法对原来的字符串做修改。（`name[2]='A'`无效）\n\n## 字符串\n\n字符串像数组一样，可以依照从0开始的索引访问。也可以切片访问`name[2:4]`，取得[2]~[3]的字符串。\n\n多行字符串：'''三个单引号后输入的内容，如果包含回车，就会把回车内容记录在字符串内。\n\n字符串拼接：直接做加法。\n\n字符串外部连接：\n\n```python\nname = \"Jingqing\"\nmsg=\"%s\" % (name)\n```\n\n%s：字符串占位符\n\n%d：数字占位符\n\n%f：浮点占位符\n\n字符串中有几个%s，结尾的括号中就应该有几个变量。\n\npython 3 之后有另一种处理方法：\n\n```python\nmsg=f\"{name} is me.\"\n```\n\n在字符串开头输入 f，会把字符串中的大括号内容都替换成变量。\n\n## 列表\n\n相当于数组\n\n```python\nname_list=[\"Jingqing\",\"Fuwu\",\"Fugu\"]\nprint(name_list[1])\n```\n\n增：name_list.append(x) （在结尾插入） insert(i,x)（在第 i 位插入）\n\n删：del name_list 或del name_list[i] 或列表名.remove(x)\n\n改：name_list[i]=\"要修改的字符串\"\n\n查：name_list.index(x) 根据内容查索引号\n\n切片：第 i 到 j 位：name_list[i:j+1]，如果有一边省略，就是取到头。比如 name_list[0:] 就是取所有数据。\n\n（切片也可以倒着切。如最后两位：name_list[-2:]）\n\n步长：name_list[i:j:2]，最后一位表示每几个数切一次，默认是1，也就是每个数都取。2就是隔一个取一个。\n\n嵌套：列表里面的数据是个列表。name_list [0] [1] 访问嵌套的列表。\n\n## 常用运算符\n\n+、-、*、/（带小数）、//（整除）、**（幂）、%。\n\n<、>、<=、>=、==、!=、<>（在 python 3中取消了）。\n\n+=、-=、*=、/=、%=、//=、**=。\n\nand、or、not。（and 的优先级高于 or）\n\nin、not in（查找字符串中有无给定子串 / 列表中有无给定成员，子串 in / not in 总数据）（in 不能测试数字类型）\n\n# 输入\n\nname=input(\"请输入姓名：\")\n\ninput().strip()：去掉输入时两侧的空格\n\ninput() 接收的都是字符串形式，不能直接拿去做运算。可以通过 int(input()) 强制转换。\n\n```python\nif age.isdigit():\n    age=int(age)\nelse:\n    print(\"输入类型不是数字\")\n```\n\n# 条件控制\n\n```python\n# 单分支\nif 条件: # 顶级代码\n    表达式 # 必须缩进，属于子级代码\n    表达式 # 同一级代码缩进必须一致，尽量都是 Tab\n# 双分支\nif 条件:\n    表达式\nelse:\n    表达式\n# 多分支\nif 条件:\n    表达式\nelif 条件:\n    表达式\nelif 条件:\n    表达式\nelse:\n    表达式\n```\n\n这里很离谱的地方是：表达式必须缩进（大概是因为不像 C 和 Java 有大括号，可以确定范围）\n\n**if 可以嵌套，最好不要超过4层。**\n\n# 循环\n\n```python\nfor i in range(10) # 输出0~9\n\tprint(i)\nfor i in range(100,50,-1) # 从100输出到50，每次-1，左闭右开\n\tprint(i)\nfor i in [\"hello\",\"world\"] # 输出hello\\nworld\n\tprint(i)\nfor i in \"helloworld\" # 输出h\\ne\\nl\\nl\\no\\nw\\no\\nr\\nl\\nd\n\tprint(i)\n```\n\nprint() 默认参数：`print(end:\"\\n\")`，表示每次print输出后都会换行。如果把 end 的实参修改，就不会换行。\n\nfor 输出的内容必须是一个集合，比如字符串，列表。数字不行。\n\ni 的作用域只在 for 内。\n\nfor 循环体内的内容和 if 一样，需要缩进。\n\n**for 可以嵌套，最好不要超过4层。**\n\nbreak、continue、exit()（退出整个程序）\n\n输出时可以通过字符串*数字来输出指定次数。\n\n```python\nprint(\"*\"*3) # 输出3次 *\n```\n\nfor...else... 当循环正常结束时执行 else 后面的内容。即没有中途 break 或 exit()\n\n```python\nfor i in range(1,10):\n    print(i)\n    if(i==5)\n    \tbreak # 不会输出 else 里的内容\nelse\n\tprint(\"循环正常结束，i=10\")\n```\n\n例如，判断一个数字是否为素数，正常做法就是先定义一个 flag 变量，然后用小于该数的所有数整除它，看余数是否为0。如果出现了余数为0，就令 flag =1.最后循环结束时如果 flag==0，说明该数为素数。\n\n用 for else 或 while else 就可以判断循环是正常结束的还是中途跳出的。\n\n```python\nfor i in range(2,n-1):\n    if(n%i==0)\n    \tprint(\"n不是素数\")\n    \tbreak\nelse\n\tprint(\"n是素数\")\n```\n\n","source":"_posts/Python——语法基础1.md","raw":"---\ntitle: Python——语法基础1\ndate: 2022-04-28\ntags: study\ncategory: Python\n---\n\n今天开始跟着 Alex老师 [Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Z64y1S72C?p=1)的课程学习Python~\n\n关于编译器解释器的部分、Python 安装及 Path 配置就不再赘述了。从计算机三大件的部分开始学习。\n\n# 计算机三大件\n\n## 硬盘\n\n数据的永久存储。\n\n## 内存\n\n数据的临时存储。处理数据速度远快于硬盘，所以才有存在的意义。处理数据应该尽量避免对硬盘的直接读写。\n\n## CPU\n\n进行运算。计算数据来自于内存。\n\n计算时，数据从硬盘传到内存，再传给 CPU 进行运算。\n\n保存数据后，数据再保存到硬盘。\n\n# 变量\n\n先定义，后使用。\n\n定义规则和 C 一样，字母数字下划线，数字不能开头，不能是关键字。\n\n可以是中文名，但很 low~ 尽量不要用。\n\n```python\nname = \"Jingqing\"\nname = \"Rename\" #直接重新赋值，地址不变\n```\n\n可以通过 id(变量名) 方法获取变量地址。\n\n# 数据类型\n\n| 类型               | 含义     |\n| ------------------ | -------- |\n| int / long / float | 数字类型 |\n| str                | 字符串   |\n| list               | 列表     |\n| bool               | 布尔     |\n| set                | 集合     |\n| dict               | 字典     |\n| bytes              | 字节     |\n\n## 数字类型\n\npython 3之后没有 long 类型了，全是 int.\n\n字符串类型不可以修改。如果已经把字符串类型赋给了一个变量，再重新赋值成其他字符串值，会发现地址变了，说明没法对原来的字符串做修改。（`name[2]='A'`无效）\n\n## 字符串\n\n字符串像数组一样，可以依照从0开始的索引访问。也可以切片访问`name[2:4]`，取得[2]~[3]的字符串。\n\n多行字符串：'''三个单引号后输入的内容，如果包含回车，就会把回车内容记录在字符串内。\n\n字符串拼接：直接做加法。\n\n字符串外部连接：\n\n```python\nname = \"Jingqing\"\nmsg=\"%s\" % (name)\n```\n\n%s：字符串占位符\n\n%d：数字占位符\n\n%f：浮点占位符\n\n字符串中有几个%s，结尾的括号中就应该有几个变量。\n\npython 3 之后有另一种处理方法：\n\n```python\nmsg=f\"{name} is me.\"\n```\n\n在字符串开头输入 f，会把字符串中的大括号内容都替换成变量。\n\n## 列表\n\n相当于数组\n\n```python\nname_list=[\"Jingqing\",\"Fuwu\",\"Fugu\"]\nprint(name_list[1])\n```\n\n增：name_list.append(x) （在结尾插入） insert(i,x)（在第 i 位插入）\n\n删：del name_list 或del name_list[i] 或列表名.remove(x)\n\n改：name_list[i]=\"要修改的字符串\"\n\n查：name_list.index(x) 根据内容查索引号\n\n切片：第 i 到 j 位：name_list[i:j+1]，如果有一边省略，就是取到头。比如 name_list[0:] 就是取所有数据。\n\n（切片也可以倒着切。如最后两位：name_list[-2:]）\n\n步长：name_list[i:j:2]，最后一位表示每几个数切一次，默认是1，也就是每个数都取。2就是隔一个取一个。\n\n嵌套：列表里面的数据是个列表。name_list [0] [1] 访问嵌套的列表。\n\n## 常用运算符\n\n+、-、*、/（带小数）、//（整除）、**（幂）、%。\n\n<、>、<=、>=、==、!=、<>（在 python 3中取消了）。\n\n+=、-=、*=、/=、%=、//=、**=。\n\nand、or、not。（and 的优先级高于 or）\n\nin、not in（查找字符串中有无给定子串 / 列表中有无给定成员，子串 in / not in 总数据）（in 不能测试数字类型）\n\n# 输入\n\nname=input(\"请输入姓名：\")\n\ninput().strip()：去掉输入时两侧的空格\n\ninput() 接收的都是字符串形式，不能直接拿去做运算。可以通过 int(input()) 强制转换。\n\n```python\nif age.isdigit():\n    age=int(age)\nelse:\n    print(\"输入类型不是数字\")\n```\n\n# 条件控制\n\n```python\n# 单分支\nif 条件: # 顶级代码\n    表达式 # 必须缩进，属于子级代码\n    表达式 # 同一级代码缩进必须一致，尽量都是 Tab\n# 双分支\nif 条件:\n    表达式\nelse:\n    表达式\n# 多分支\nif 条件:\n    表达式\nelif 条件:\n    表达式\nelif 条件:\n    表达式\nelse:\n    表达式\n```\n\n这里很离谱的地方是：表达式必须缩进（大概是因为不像 C 和 Java 有大括号，可以确定范围）\n\n**if 可以嵌套，最好不要超过4层。**\n\n# 循环\n\n```python\nfor i in range(10) # 输出0~9\n\tprint(i)\nfor i in range(100,50,-1) # 从100输出到50，每次-1，左闭右开\n\tprint(i)\nfor i in [\"hello\",\"world\"] # 输出hello\\nworld\n\tprint(i)\nfor i in \"helloworld\" # 输出h\\ne\\nl\\nl\\no\\nw\\no\\nr\\nl\\nd\n\tprint(i)\n```\n\nprint() 默认参数：`print(end:\"\\n\")`，表示每次print输出后都会换行。如果把 end 的实参修改，就不会换行。\n\nfor 输出的内容必须是一个集合，比如字符串，列表。数字不行。\n\ni 的作用域只在 for 内。\n\nfor 循环体内的内容和 if 一样，需要缩进。\n\n**for 可以嵌套，最好不要超过4层。**\n\nbreak、continue、exit()（退出整个程序）\n\n输出时可以通过字符串*数字来输出指定次数。\n\n```python\nprint(\"*\"*3) # 输出3次 *\n```\n\nfor...else... 当循环正常结束时执行 else 后面的内容。即没有中途 break 或 exit()\n\n```python\nfor i in range(1,10):\n    print(i)\n    if(i==5)\n    \tbreak # 不会输出 else 里的内容\nelse\n\tprint(\"循环正常结束，i=10\")\n```\n\n例如，判断一个数字是否为素数，正常做法就是先定义一个 flag 变量，然后用小于该数的所有数整除它，看余数是否为0。如果出现了余数为0，就令 flag =1.最后循环结束时如果 flag==0，说明该数为素数。\n\n用 for else 或 while else 就可以判断循环是正常结束的还是中途跳出的。\n\n```python\nfor i in range(2,n-1):\n    if(n%i==0)\n    \tprint(\"n不是素数\")\n    \tbreak\nelse\n\tprint(\"n是素数\")\n```\n\n","slug":"Python——语法基础1","published":1,"updated":"2022-04-28T11:44:51.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2ixwni600002cv2gwl4d5dc","content":"<p>今天开始跟着 Alex老师 <a href=\"https://www.bilibili.com/video/BV1Z64y1S72C?p=1\">Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili</a>的课程学习Python~</p>\n<p>关于编译器解释器的部分、Python 安装及 Path 配置就不再赘述了。从计算机三大件的部分开始学习。</p>\n<h1 id=\"计算机三大件\"><a href=\"#计算机三大件\" class=\"headerlink\" title=\"计算机三大件\"></a>计算机三大件</h1><h2 id=\"硬盘\"><a href=\"#硬盘\" class=\"headerlink\" title=\"硬盘\"></a>硬盘</h2><p>数据的永久存储。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>数据的临时存储。处理数据速度远快于硬盘，所以才有存在的意义。处理数据应该尽量避免对硬盘的直接读写。</p>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p>进行运算。计算数据来自于内存。</p>\n<p>计算时，数据从硬盘传到内存，再传给 CPU 进行运算。</p>\n<p>保存数据后，数据再保存到硬盘。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>先定义，后使用。</p>\n<p>定义规则和 C 一样，字母数字下划线，数字不能开头，不能是关键字。</p>\n<p>可以是中文名，但很 low~ 尽量不要用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">name = <span class=\"hljs-string\">&quot;Jingqing&quot;</span><br>name = <span class=\"hljs-string\">&quot;Rename&quot;</span> <span class=\"hljs-comment\">#直接重新赋值，地址不变</span><br></code></pre></td></tr></table></figure>\n\n<p>可以通过 id(变量名) 方法获取变量地址。</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int / long / float</td>\n<td>数字类型</td>\n</tr>\n<tr>\n<td>str</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>list</td>\n<td>列表</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>布尔</td>\n</tr>\n<tr>\n<td>set</td>\n<td>集合</td>\n</tr>\n<tr>\n<td>dict</td>\n<td>字典</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>字节</td>\n</tr>\n</tbody></table>\n<h2 id=\"数字类型\"><a href=\"#数字类型\" class=\"headerlink\" title=\"数字类型\"></a>数字类型</h2><p>python 3之后没有 long 类型了，全是 int.</p>\n<p>字符串类型不可以修改。如果已经把字符串类型赋给了一个变量，再重新赋值成其他字符串值，会发现地址变了，说明没法对原来的字符串做修改。（<code>name[2]=&#39;A&#39;</code>无效）</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>字符串像数组一样，可以依照从0开始的索引访问。也可以切片访问<code>name[2:4]</code>，取得[2]~[3]的字符串。</p>\n<p>多行字符串：’’’三个单引号后输入的内容，如果包含回车，就会把回车内容记录在字符串内。</p>\n<p>字符串拼接：直接做加法。</p>\n<p>字符串外部连接：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">name = <span class=\"hljs-string\">&quot;Jingqing&quot;</span><br>msg=<span class=\"hljs-string\">&quot;%s&quot;</span> % (name)<br></code></pre></td></tr></table></figure>\n\n<p>%s：字符串占位符</p>\n<p>%d：数字占位符</p>\n<p>%f：浮点占位符</p>\n<p>字符串中有几个%s，结尾的括号中就应该有几个变量。</p>\n<p>python 3 之后有另一种处理方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">msg=<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">&#123;name&#125;</span> is me.&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>在字符串开头输入 f，会把字符串中的大括号内容都替换成变量。</p>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>相当于数组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">name_list=[<span class=\"hljs-string\">&quot;Jingqing&quot;</span>,<span class=\"hljs-string\">&quot;Fuwu&quot;</span>,<span class=\"hljs-string\">&quot;Fugu&quot;</span>]<br><span class=\"hljs-built_in\">print</span>(name_list[<span class=\"hljs-number\">1</span>])<br></code></pre></td></tr></table></figure>\n\n<p>增：name_list.append(x) （在结尾插入） insert(i,x)（在第 i 位插入）</p>\n<p>删：del name_list 或del name_list[i] 或列表名.remove(x)</p>\n<p>改：name_list[i]=”要修改的字符串”</p>\n<p>查：name_list.index(x) 根据内容查索引号</p>\n<p>切片：第 i 到 j 位：name_list[i:j+1]，如果有一边省略，就是取到头。比如 name_list[0:] 就是取所有数据。</p>\n<p>（切片也可以倒着切。如最后两位：name_list[-2:]）</p>\n<p>步长：name_list[i:j:2]，最后一位表示每几个数切一次，默认是1，也就是每个数都取。2就是隔一个取一个。</p>\n<p>嵌套：列表里面的数据是个列表。name_list [0] [1] 访问嵌套的列表。</p>\n<h2 id=\"常用运算符\"><a href=\"#常用运算符\" class=\"headerlink\" title=\"常用运算符\"></a>常用运算符</h2><p>+、-、*、/（带小数）、//（整除）、**（幂）、%。</p>\n<p>&lt;、&gt;、&lt;=、&gt;=、==、!=、&lt;&gt;（在 python 3中取消了）。</p>\n<p>+=、-=、*=、/=、%=、//=、**=。</p>\n<p>and、or、not。（and 的优先级高于 or）</p>\n<p>in、not in（查找字符串中有无给定子串 / 列表中有无给定成员，子串 in / not in 总数据）（in 不能测试数字类型）</p>\n<h1 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h1><p>name=input(“请输入姓名：”)</p>\n<p>input().strip()：去掉输入时两侧的空格</p>\n<p>input() 接收的都是字符串形式，不能直接拿去做运算。可以通过 int(input()) 强制转换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> age.isdigit():<br>    age=<span class=\"hljs-built_in\">int</span>(age)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;输入类型不是数字&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件控制\"><a href=\"#条件控制\" class=\"headerlink\" title=\"条件控制\"></a>条件控制</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 单分支</span><br><span class=\"hljs-keyword\">if</span> 条件: <span class=\"hljs-comment\"># 顶级代码</span><br>    表达式 <span class=\"hljs-comment\"># 必须缩进，属于子级代码</span><br>    表达式 <span class=\"hljs-comment\"># 同一级代码缩进必须一致，尽量都是 Tab</span><br><span class=\"hljs-comment\"># 双分支</span><br><span class=\"hljs-keyword\">if</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">else</span>:<br>    表达式<br><span class=\"hljs-comment\"># 多分支</span><br><span class=\"hljs-keyword\">if</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">elif</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">elif</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">else</span>:<br>    表达式<br></code></pre></td></tr></table></figure>\n\n<p>这里很离谱的地方是：表达式必须缩进（大概是因为不像 C 和 Java 有大括号，可以确定范围）</p>\n<p><strong>if 可以嵌套，最好不要超过4层。</strong></p>\n<h1 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\"># 输出0~9</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">50</span>,-<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># 从100输出到50，每次-1，左闭右开</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;hello&quot;</span>,<span class=\"hljs-string\">&quot;world&quot;</span>] <span class=\"hljs-comment\"># 输出hello\\nworld</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;helloworld&quot;</span> <span class=\"hljs-comment\"># 输出h\\ne\\nl\\nl\\no\\nw\\no\\nr\\nl\\nd</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br></code></pre></td></tr></table></figure>\n\n<p>print() 默认参数：<code>print(end:&quot;\\n&quot;)</code>，表示每次print输出后都会换行。如果把 end 的实参修改，就不会换行。</p>\n<p>for 输出的内容必须是一个集合，比如字符串，列表。数字不行。</p>\n<p>i 的作用域只在 for 内。</p>\n<p>for 循环体内的内容和 if 一样，需要缩进。</p>\n<p><strong>for 可以嵌套，最好不要超过4层。</strong></p>\n<p>break、continue、exit()（退出整个程序）</p>\n<p>输出时可以通过字符串*数字来输出指定次数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;*&quot;</span>*<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\"># 输出3次 *</span><br></code></pre></td></tr></table></figure>\n\n<p>for…else… 当循环正常结束时执行 else 后面的内容。即没有中途 break 或 exit()</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">10</span>):<br>    <span class=\"hljs-built_in\">print</span>(i)<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">5</span>)<br>    \t<span class=\"hljs-keyword\">break</span> <span class=\"hljs-comment\"># 不会输出 else 里的内容</span><br><span class=\"hljs-keyword\">else</span><br>\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;循环正常结束，i=10&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>例如，判断一个数字是否为素数，正常做法就是先定义一个 flag 变量，然后用小于该数的所有数整除它，看余数是否为0。如果出现了余数为0，就令 flag =1.最后循环结束时如果 flag==0，说明该数为素数。</p>\n<p>用 for else 或 while else 就可以判断循环是正常结束的还是中途跳出的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">2</span>,n-<span class=\"hljs-number\">1</span>):<br>    <span class=\"hljs-keyword\">if</span>(n%i==<span class=\"hljs-number\">0</span>)<br>    \t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;n不是素数&quot;</span>)<br>    \t<span class=\"hljs-keyword\">break</span><br><span class=\"hljs-keyword\">else</span><br>\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;n是素数&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>今天开始跟着 Alex老师 <a href=\"https://www.bilibili.com/video/BV1Z64y1S72C?p=1\">Python开发96天0基础到大神(2021最新，冲刺全网最佳教程)_哔哩哔哩_bilibili</a>的课程学习Python~</p>\n<p>关于编译器解释器的部分、Python 安装及 Path 配置就不再赘述了。从计算机三大件的部分开始学习。</p>\n<h1 id=\"计算机三大件\"><a href=\"#计算机三大件\" class=\"headerlink\" title=\"计算机三大件\"></a>计算机三大件</h1><h2 id=\"硬盘\"><a href=\"#硬盘\" class=\"headerlink\" title=\"硬盘\"></a>硬盘</h2><p>数据的永久存储。</p>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>数据的临时存储。处理数据速度远快于硬盘，所以才有存在的意义。处理数据应该尽量避免对硬盘的直接读写。</p>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><p>进行运算。计算数据来自于内存。</p>\n<p>计算时，数据从硬盘传到内存，再传给 CPU 进行运算。</p>\n<p>保存数据后，数据再保存到硬盘。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>先定义，后使用。</p>\n<p>定义规则和 C 一样，字母数字下划线，数字不能开头，不能是关键字。</p>\n<p>可以是中文名，但很 low~ 尽量不要用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">name = <span class=\"hljs-string\">&quot;Jingqing&quot;</span><br>name = <span class=\"hljs-string\">&quot;Rename&quot;</span> <span class=\"hljs-comment\">#直接重新赋值，地址不变</span><br></code></pre></td></tr></table></figure>\n\n<p>可以通过 id(变量名) 方法获取变量地址。</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int / long / float</td>\n<td>数字类型</td>\n</tr>\n<tr>\n<td>str</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>list</td>\n<td>列表</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>布尔</td>\n</tr>\n<tr>\n<td>set</td>\n<td>集合</td>\n</tr>\n<tr>\n<td>dict</td>\n<td>字典</td>\n</tr>\n<tr>\n<td>bytes</td>\n<td>字节</td>\n</tr>\n</tbody></table>\n<h2 id=\"数字类型\"><a href=\"#数字类型\" class=\"headerlink\" title=\"数字类型\"></a>数字类型</h2><p>python 3之后没有 long 类型了，全是 int.</p>\n<p>字符串类型不可以修改。如果已经把字符串类型赋给了一个变量，再重新赋值成其他字符串值，会发现地址变了，说明没法对原来的字符串做修改。（<code>name[2]=&#39;A&#39;</code>无效）</p>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>字符串像数组一样，可以依照从0开始的索引访问。也可以切片访问<code>name[2:4]</code>，取得[2]~[3]的字符串。</p>\n<p>多行字符串：’’’三个单引号后输入的内容，如果包含回车，就会把回车内容记录在字符串内。</p>\n<p>字符串拼接：直接做加法。</p>\n<p>字符串外部连接：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">name = <span class=\"hljs-string\">&quot;Jingqing&quot;</span><br>msg=<span class=\"hljs-string\">&quot;%s&quot;</span> % (name)<br></code></pre></td></tr></table></figure>\n\n<p>%s：字符串占位符</p>\n<p>%d：数字占位符</p>\n<p>%f：浮点占位符</p>\n<p>字符串中有几个%s，结尾的括号中就应该有几个变量。</p>\n<p>python 3 之后有另一种处理方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">msg=<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">&#123;name&#125;</span> is me.&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>在字符串开头输入 f，会把字符串中的大括号内容都替换成变量。</p>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>相当于数组</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">name_list=[<span class=\"hljs-string\">&quot;Jingqing&quot;</span>,<span class=\"hljs-string\">&quot;Fuwu&quot;</span>,<span class=\"hljs-string\">&quot;Fugu&quot;</span>]<br><span class=\"hljs-built_in\">print</span>(name_list[<span class=\"hljs-number\">1</span>])<br></code></pre></td></tr></table></figure>\n\n<p>增：name_list.append(x) （在结尾插入） insert(i,x)（在第 i 位插入）</p>\n<p>删：del name_list 或del name_list[i] 或列表名.remove(x)</p>\n<p>改：name_list[i]=”要修改的字符串”</p>\n<p>查：name_list.index(x) 根据内容查索引号</p>\n<p>切片：第 i 到 j 位：name_list[i:j+1]，如果有一边省略，就是取到头。比如 name_list[0:] 就是取所有数据。</p>\n<p>（切片也可以倒着切。如最后两位：name_list[-2:]）</p>\n<p>步长：name_list[i:j:2]，最后一位表示每几个数切一次，默认是1，也就是每个数都取。2就是隔一个取一个。</p>\n<p>嵌套：列表里面的数据是个列表。name_list [0] [1] 访问嵌套的列表。</p>\n<h2 id=\"常用运算符\"><a href=\"#常用运算符\" class=\"headerlink\" title=\"常用运算符\"></a>常用运算符</h2><p>+、-、*、/（带小数）、//（整除）、**（幂）、%。</p>\n<p>&lt;、&gt;、&lt;=、&gt;=、==、!=、&lt;&gt;（在 python 3中取消了）。</p>\n<p>+=、-=、*=、/=、%=、//=、**=。</p>\n<p>and、or、not。（and 的优先级高于 or）</p>\n<p>in、not in（查找字符串中有无给定子串 / 列表中有无给定成员，子串 in / not in 总数据）（in 不能测试数字类型）</p>\n<h1 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h1><p>name=input(“请输入姓名：”)</p>\n<p>input().strip()：去掉输入时两侧的空格</p>\n<p>input() 接收的都是字符串形式，不能直接拿去做运算。可以通过 int(input()) 强制转换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> age.isdigit():<br>    age=<span class=\"hljs-built_in\">int</span>(age)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;输入类型不是数字&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"条件控制\"><a href=\"#条件控制\" class=\"headerlink\" title=\"条件控制\"></a>条件控制</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 单分支</span><br><span class=\"hljs-keyword\">if</span> 条件: <span class=\"hljs-comment\"># 顶级代码</span><br>    表达式 <span class=\"hljs-comment\"># 必须缩进，属于子级代码</span><br>    表达式 <span class=\"hljs-comment\"># 同一级代码缩进必须一致，尽量都是 Tab</span><br><span class=\"hljs-comment\"># 双分支</span><br><span class=\"hljs-keyword\">if</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">else</span>:<br>    表达式<br><span class=\"hljs-comment\"># 多分支</span><br><span class=\"hljs-keyword\">if</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">elif</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">elif</span> 条件:<br>    表达式<br><span class=\"hljs-keyword\">else</span>:<br>    表达式<br></code></pre></td></tr></table></figure>\n\n<p>这里很离谱的地方是：表达式必须缩进（大概是因为不像 C 和 Java 有大括号，可以确定范围）</p>\n<p><strong>if 可以嵌套，最好不要超过4层。</strong></p>\n<h1 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h1><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\"># 输出0~9</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">50</span>,-<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># 从100输出到50，每次-1，左闭右开</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;hello&quot;</span>,<span class=\"hljs-string\">&quot;world&quot;</span>] <span class=\"hljs-comment\"># 输出hello\\nworld</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&quot;helloworld&quot;</span> <span class=\"hljs-comment\"># 输出h\\ne\\nl\\nl\\no\\nw\\no\\nr\\nl\\nd</span><br>\t<span class=\"hljs-built_in\">print</span>(i)<br></code></pre></td></tr></table></figure>\n\n<p>print() 默认参数：<code>print(end:&quot;\\n&quot;)</code>，表示每次print输出后都会换行。如果把 end 的实参修改，就不会换行。</p>\n<p>for 输出的内容必须是一个集合，比如字符串，列表。数字不行。</p>\n<p>i 的作用域只在 for 内。</p>\n<p>for 循环体内的内容和 if 一样，需要缩进。</p>\n<p><strong>for 可以嵌套，最好不要超过4层。</strong></p>\n<p>break、continue、exit()（退出整个程序）</p>\n<p>输出时可以通过字符串*数字来输出指定次数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;*&quot;</span>*<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\"># 输出3次 *</span><br></code></pre></td></tr></table></figure>\n\n<p>for…else… 当循环正常结束时执行 else 后面的内容。即没有中途 break 或 exit()</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">10</span>):<br>    <span class=\"hljs-built_in\">print</span>(i)<br>    <span class=\"hljs-keyword\">if</span>(i==<span class=\"hljs-number\">5</span>)<br>    \t<span class=\"hljs-keyword\">break</span> <span class=\"hljs-comment\"># 不会输出 else 里的内容</span><br><span class=\"hljs-keyword\">else</span><br>\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;循环正常结束，i=10&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<p>例如，判断一个数字是否为素数，正常做法就是先定义一个 flag 变量，然后用小于该数的所有数整除它，看余数是否为0。如果出现了余数为0，就令 flag =1.最后循环结束时如果 flag==0，说明该数为素数。</p>\n<p>用 for else 或 while else 就可以判断循环是正常结束的还是中途跳出的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">2</span>,n-<span class=\"hljs-number\">1</span>):<br>    <span class=\"hljs-keyword\">if</span>(n%i==<span class=\"hljs-number\">0</span>)<br>    \t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;n不是素数&quot;</span>)<br>    \t<span class=\"hljs-keyword\">break</span><br><span class=\"hljs-keyword\">else</span><br>\t<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;n是素数&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Java 学习博客_3 入门——基础语法","date":"2022-04-28T16:00:00.000Z","_content":"\n以[黑马程序员全套Java教程](https://www.bilibili.com/video/BV18J411W7cE?p=1)网课为主。\n\n# 数据输入\n\n输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。\n\n```java\nimport java.util.Scanner;//导包\nScanner sc=new Scanner(System.in);//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。\nint i=sc.nextInt();//接收数据\nString s=sc.nextLine();\n```\n\n# 分支、循环语句\n\nif - else 语句：和 C 语言一样。\n\nswitch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。\n\nfor, while, do - while 语句，及 break continue 和 C 一样。\n\n# 随机数\n\nRandom 类，在 java.util 包下，需要导包。\n\n```java\nimport java.util.Random;\nRandom r=new Random();\nint n=r.nextInt(10);//[0,10)的范围内取随机数\n```\n\n# IDEA\n\n集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。\n\n创建项目-项目内创建模块-模块 src 下创建包-包下创建类-类中编写代码。\n\n其中，.class 文件都会放在模块同级的 out 文件夹中。\n\n![AJdw2.png](https://s1.328888.xyz/2022/04/28/AJdw2.png)\n\n可以在 File - Settings - Editor - Font 中修改字体\n\n## 快捷键\n\npsvm + Tab：public static void main\n\nsout + Tab：System.out.println()\n\nCtrl + Alt + Space：自动补全代码\n\nCtrl + /：单行注释\n\nCtrl + Shift + /：多行注释\n\nCtrl + Alt + L：代码格式化\n\n## 模块操作\n\n新增模块： File - Project Structure - Modules - New Module - Java - 命名，修改路径\n\n删除模块：右键模块 - Remove Module\n\n​\t不过删除后在文件目录中仍然存在。\n\n导入模块：File - Project Structure - Modules - (+) - Import Modules - 选择模块。\n\n​\t如果显示 project SDK is not defined：点 set up.\n\n## 断点\n\nDeBug 调试，断点调试，可以查看程序运行细节。\n\n添加断点：在行号前点一下，出现红点。\n\n调试：右键，不是 run ,而是 debug。\n\nDebugger 窗口下的Frames：查看代码运行到了哪里，也可以查看方法调用情况。\n\nDebugger 窗口下的Variables：查看各变量运行过程中值的变化\n\nConsole 窗口：查看代码运行过程中的输出变化。如果代码中出现需要输入的情况，需要先在 Console 窗口中输入才能继续执行。\n\nstep info 按钮：下一步\n\nstop：停止\n\n再次点击红点，取消该断点。\n\n批量取消断点：点击两个红点的图案，选择 Java line breakpoints，点击 - 号即可全部删除。\n\n# 数组\n\n一次性声明大量**同类型**变量。\n\n```java\nint[] arr;//推荐。定义了一个 int 型的数组，数组名是 arr\nint arr[];//定义了一个 int 型变量，变量名是 arr 数组\n\nint[] arr=new int[]{1,2,3};//静态初始化\nint[] arr={1,2,3};//静态初始化简化版\nint[] arr=new int[3];//动态初始化，只申请了空间，系统赋予初始值\n//数字类型：初始值为0.0\n//布尔类型：初始值为 false\n//字符串类型：初始值为\"\"\n//引用类型：初始值为 null\n```\n\njava 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。\n\n## 栈内存\n\n定义的方法中的变量放在栈内存中，使用完直接消失。\n\n如`int a`，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。\n\n## 堆内存\n\n实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。\n\n如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]=1, arr[1]=2……）\n\n访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。\n\n因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。\n\n```java\nint[] arr1={1,2,3};\nint[] arr2=arr1;\narr2[0]=11;\narr2[1]=22;\narr2[2]=33;//这时访问 arr1[]，发现其中的数据也变成了11,22,33\n```\n\n## 数组常见问题\n\n1. 数组越界问题，ArrayIndexOutOfException。\n2. 空指针异常问题，NullPointerException。（`arr=null`，表示数组不指向任何有效对象）\n\n## Array.length\n\n数组自带属性 length，通过`arr.length`就能获得数组长度。\n\n# 方法\n\njava 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。\n\n像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。\n\n```java\npublic static 返回值类型 方法名(形参){//和 main 方法同级\n    方法体\n    return 返回值;\n}//定义\n\n方法名(实参);//在 main 方法中调用。有返回值类型的方法建议用变量接收调用\n```\n\n方法不能嵌套定义。\n\n## 方法重载\n\n多个方法在一个类中，有相同的方法名，但参数不完全相同。\n\n```java\npublic static int max(int a, int b)\npublic static int max(int a, int b, int c)\n```\n\n**注意：返回值不能作为判断方法是否重载的标准！**只有方法名和参数可以。\n\n调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。\n\n**形参值修改不会对实参造成影响。**main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存\n\n![A8wxg.png](https://s1.328888.xyz/2022/04/29/A8wxg.png)\n\n但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。\n\n![A8Kh1.png](https://s1.328888.xyz/2022/04/29/A8Kh1.png)\n\n如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。","source":"_posts/Java 学习博客_3 入门——基础语法.md","raw":"---\ntitle: Java 学习博客_3 入门——基础语法\ndate: 2022-04-29\ntags: study\ncategory: java\n---\n\n以[黑马程序员全套Java教程](https://www.bilibili.com/video/BV18J411W7cE?p=1)网课为主。\n\n# 数据输入\n\n输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。\n\n```java\nimport java.util.Scanner;//导包\nScanner sc=new Scanner(System.in);//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。\nint i=sc.nextInt();//接收数据\nString s=sc.nextLine();\n```\n\n# 分支、循环语句\n\nif - else 语句：和 C 语言一样。\n\nswitch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。\n\nfor, while, do - while 语句，及 break continue 和 C 一样。\n\n# 随机数\n\nRandom 类，在 java.util 包下，需要导包。\n\n```java\nimport java.util.Random;\nRandom r=new Random();\nint n=r.nextInt(10);//[0,10)的范围内取随机数\n```\n\n# IDEA\n\n集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。\n\n创建项目-项目内创建模块-模块 src 下创建包-包下创建类-类中编写代码。\n\n其中，.class 文件都会放在模块同级的 out 文件夹中。\n\n![AJdw2.png](https://s1.328888.xyz/2022/04/28/AJdw2.png)\n\n可以在 File - Settings - Editor - Font 中修改字体\n\n## 快捷键\n\npsvm + Tab：public static void main\n\nsout + Tab：System.out.println()\n\nCtrl + Alt + Space：自动补全代码\n\nCtrl + /：单行注释\n\nCtrl + Shift + /：多行注释\n\nCtrl + Alt + L：代码格式化\n\n## 模块操作\n\n新增模块： File - Project Structure - Modules - New Module - Java - 命名，修改路径\n\n删除模块：右键模块 - Remove Module\n\n​\t不过删除后在文件目录中仍然存在。\n\n导入模块：File - Project Structure - Modules - (+) - Import Modules - 选择模块。\n\n​\t如果显示 project SDK is not defined：点 set up.\n\n## 断点\n\nDeBug 调试，断点调试，可以查看程序运行细节。\n\n添加断点：在行号前点一下，出现红点。\n\n调试：右键，不是 run ,而是 debug。\n\nDebugger 窗口下的Frames：查看代码运行到了哪里，也可以查看方法调用情况。\n\nDebugger 窗口下的Variables：查看各变量运行过程中值的变化\n\nConsole 窗口：查看代码运行过程中的输出变化。如果代码中出现需要输入的情况，需要先在 Console 窗口中输入才能继续执行。\n\nstep info 按钮：下一步\n\nstop：停止\n\n再次点击红点，取消该断点。\n\n批量取消断点：点击两个红点的图案，选择 Java line breakpoints，点击 - 号即可全部删除。\n\n# 数组\n\n一次性声明大量**同类型**变量。\n\n```java\nint[] arr;//推荐。定义了一个 int 型的数组，数组名是 arr\nint arr[];//定义了一个 int 型变量，变量名是 arr 数组\n\nint[] arr=new int[]{1,2,3};//静态初始化\nint[] arr={1,2,3};//静态初始化简化版\nint[] arr=new int[3];//动态初始化，只申请了空间，系统赋予初始值\n//数字类型：初始值为0.0\n//布尔类型：初始值为 false\n//字符串类型：初始值为\"\"\n//引用类型：初始值为 null\n```\n\njava 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。\n\n## 栈内存\n\n定义的方法中的变量放在栈内存中，使用完直接消失。\n\n如`int a`，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。\n\n## 堆内存\n\n实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。\n\n如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]=1, arr[1]=2……）\n\n访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。\n\n因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。\n\n```java\nint[] arr1={1,2,3};\nint[] arr2=arr1;\narr2[0]=11;\narr2[1]=22;\narr2[2]=33;//这时访问 arr1[]，发现其中的数据也变成了11,22,33\n```\n\n## 数组常见问题\n\n1. 数组越界问题，ArrayIndexOutOfException。\n2. 空指针异常问题，NullPointerException。（`arr=null`，表示数组不指向任何有效对象）\n\n## Array.length\n\n数组自带属性 length，通过`arr.length`就能获得数组长度。\n\n# 方法\n\njava 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。\n\n像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。\n\n```java\npublic static 返回值类型 方法名(形参){//和 main 方法同级\n    方法体\n    return 返回值;\n}//定义\n\n方法名(实参);//在 main 方法中调用。有返回值类型的方法建议用变量接收调用\n```\n\n方法不能嵌套定义。\n\n## 方法重载\n\n多个方法在一个类中，有相同的方法名，但参数不完全相同。\n\n```java\npublic static int max(int a, int b)\npublic static int max(int a, int b, int c)\n```\n\n**注意：返回值不能作为判断方法是否重载的标准！**只有方法名和参数可以。\n\n调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。\n\n**形参值修改不会对实参造成影响。**main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存\n\n![A8wxg.png](https://s1.328888.xyz/2022/04/29/A8wxg.png)\n\n但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。\n\n![A8Kh1.png](https://s1.328888.xyz/2022/04/29/A8Kh1.png)\n\n如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。","slug":"Java 学习博客_3 入门——基础语法","published":1,"updated":"2022-04-29T09:13:18.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2k848520000nkv2bchc1au6","content":"<p>以<a href=\"https://www.bilibili.com/video/BV18J411W7cE?p=1\">黑马程序员全套Java教程</a>网课为主。</p>\n<h1 id=\"数据输入\"><a href=\"#数据输入\" class=\"headerlink\" title=\"数据输入\"></a>数据输入</h1><p>输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<span class=\"hljs-comment\">//导包</span><br>Scanner sc=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<span class=\"hljs-comment\">//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。</span><br><span class=\"hljs-type\">int</span> i=sc.nextInt();<span class=\"hljs-comment\">//接收数据</span><br>String s=sc.nextLine();<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"分支、循环语句\"><a href=\"#分支、循环语句\" class=\"headerlink\" title=\"分支、循环语句\"></a>分支、循环语句</h1><p>if - else 语句：和 C 语言一样。</p>\n<p>switch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。</p>\n<p>for, while, do - while 语句，及 break continue 和 C 一样。</p>\n<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><p>Random 类，在 java.util 包下，需要导包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Random;<br>Random r=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>();<br><span class=\"hljs-type\">int</span> n=r.nextInt(<span class=\"hljs-number\">10</span>);<span class=\"hljs-comment\">//[0,10)的范围内取随机数</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"IDEA\"><a href=\"#IDEA\" class=\"headerlink\" title=\"IDEA\"></a>IDEA</h1><p>集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。</p>\n<p>创建项目-项目内创建模块-模块 src 下创建包-包下创建类-类中编写代码。</p>\n<p>其中，.class 文件都会放在模块同级的 out 文件夹中。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/28/AJdw2.png\" alt=\"AJdw2.png\"></p>\n<p>可以在 File - Settings - Editor - Font 中修改字体</p>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>psvm + Tab：public static void main</p>\n<p>sout + Tab：System.out.println()</p>\n<p>Ctrl + Alt + Space：自动补全代码</p>\n<p>Ctrl + /：单行注释</p>\n<p>Ctrl + Shift + /：多行注释</p>\n<p>Ctrl + Alt + L：代码格式化</p>\n<h2 id=\"模块操作\"><a href=\"#模块操作\" class=\"headerlink\" title=\"模块操作\"></a>模块操作</h2><p>新增模块： File - Project Structure - Modules - New Module - Java - 命名，修改路径</p>\n<p>删除模块：右键模块 - Remove Module</p>\n<p>​    不过删除后在文件目录中仍然存在。</p>\n<p>导入模块：File - Project Structure - Modules - (+) - Import Modules - 选择模块。</p>\n<p>​    如果显示 project SDK is not defined：点 set up.</p>\n<h2 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h2><p>DeBug 调试，断点调试，可以查看程序运行细节。</p>\n<p>添加断点：在行号前点一下，出现红点。</p>\n<p>调试：右键，不是 run ,而是 debug。</p>\n<p>Debugger 窗口下的Frames：查看代码运行到了哪里，也可以查看方法调用情况。</p>\n<p>Debugger 窗口下的Variables：查看各变量运行过程中值的变化</p>\n<p>Console 窗口：查看代码运行过程中的输出变化。如果代码中出现需要输入的情况，需要先在 Console 窗口中输入才能继续执行。</p>\n<p>step info 按钮：下一步</p>\n<p>stop：停止</p>\n<p>再次点击红点，取消该断点。</p>\n<p>批量取消断点：点击两个红点的图案，选择 Java line breakpoints，点击 - 号即可全部删除。</p>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>一次性声明大量<strong>同类型</strong>变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[] arr;<span class=\"hljs-comment\">//推荐。定义了一个 int 型的数组，数组名是 arr</span><br><span class=\"hljs-type\">int</span> arr[];<span class=\"hljs-comment\">//定义了一个 int 型变量，变量名是 arr 数组</span><br><br><span class=\"hljs-type\">int</span>[] arr=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[]&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<span class=\"hljs-comment\">//静态初始化</span><br><span class=\"hljs-type\">int</span>[] arr=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<span class=\"hljs-comment\">//静态初始化简化版</span><br><span class=\"hljs-type\">int</span>[] arr=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">3</span>];<span class=\"hljs-comment\">//动态初始化，只申请了空间，系统赋予初始值</span><br><span class=\"hljs-comment\">//数字类型：初始值为0.0</span><br><span class=\"hljs-comment\">//布尔类型：初始值为 false</span><br><span class=\"hljs-comment\">//字符串类型：初始值为&quot;&quot;</span><br><span class=\"hljs-comment\">//引用类型：初始值为 null</span><br></code></pre></td></tr></table></figure>\n\n<p>java 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。</p>\n<h2 id=\"栈内存\"><a href=\"#栈内存\" class=\"headerlink\" title=\"栈内存\"></a>栈内存</h2><p>定义的方法中的变量放在栈内存中，使用完直接消失。</p>\n<p>如<code>int a</code>，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。</p>\n<h2 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h2><p>实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。</p>\n<p>如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]=1, arr[1]=2……）</p>\n<p>访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。</p>\n<p>因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[] arr1=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<br><span class=\"hljs-type\">int</span>[] arr2=arr1;<br>arr2[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">11</span>;<br>arr2[<span class=\"hljs-number\">1</span>]=<span class=\"hljs-number\">22</span>;<br>arr2[<span class=\"hljs-number\">2</span>]=<span class=\"hljs-number\">33</span>;<span class=\"hljs-comment\">//这时访问 arr1[]，发现其中的数据也变成了11,22,33</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组常见问题\"><a href=\"#数组常见问题\" class=\"headerlink\" title=\"数组常见问题\"></a>数组常见问题</h2><ol>\n<li>数组越界问题，ArrayIndexOutOfException。</li>\n<li>空指针异常问题，NullPointerException。（<code>arr=null</code>，表示数组不指向任何有效对象）</li>\n</ol>\n<h2 id=\"Array-length\"><a href=\"#Array-length\" class=\"headerlink\" title=\"Array.length\"></a>Array.length</h2><p>数组自带属性 length，通过<code>arr.length</code>就能获得数组长度。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>java 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。</p>\n<p>像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> 返回值类型 方法名(形参)&#123;<span class=\"hljs-comment\">//和 main 方法同级</span><br>    方法体<br>    <span class=\"hljs-keyword\">return</span> 返回值;<br>&#125;<span class=\"hljs-comment\">//定义</span><br><br>方法名(实参);<span class=\"hljs-comment\">//在 main 方法中调用。有返回值类型的方法建议用变量接收调用</span><br></code></pre></td></tr></table></figure>\n\n<p>方法不能嵌套定义。</p>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>多个方法在一个类中，有相同的方法名，但参数不完全相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c)</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>注意：返回值不能作为判断方法是否重载的标准！</strong>只有方法名和参数可以。</p>\n<p>调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。</p>\n<p><strong>形参值修改不会对实参造成影响。</strong>main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/29/A8wxg.png\" alt=\"A8wxg.png\"></p>\n<p>但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/29/A8Kh1.png\" alt=\"A8Kh1.png\"></p>\n<p>如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以<a href=\"https://www.bilibili.com/video/BV18J411W7cE?p=1\">黑马程序员全套Java教程</a>网课为主。</p>\n<h1 id=\"数据输入\"><a href=\"#数据输入\" class=\"headerlink\" title=\"数据输入\"></a>数据输入</h1><p>输入通过 Scanner 类实现。Scanner 类在 java.util 包下，要先导包才能使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Scanner;<span class=\"hljs-comment\">//导包</span><br>Scanner sc=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<span class=\"hljs-comment\">//创建对象。这句话中除了 sc 是变量名可以修改，其他的都不能改。</span><br><span class=\"hljs-type\">int</span> i=sc.nextInt();<span class=\"hljs-comment\">//接收数据</span><br>String s=sc.nextLine();<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"分支、循环语句\"><a href=\"#分支、循环语句\" class=\"headerlink\" title=\"分支、循环语句\"></a>分支、循环语句</h1><p>if - else 语句：和 C 语言一样。</p>\n<p>switch 语句：表达式的取值可以是 byte、short、int、char，JDK5之后可以是枚举，JDK7之后可以是 String。其他 case break default 用法和 C 一样。</p>\n<p>for, while, do - while 语句，及 break continue 和 C 一样。</p>\n<h1 id=\"随机数\"><a href=\"#随机数\" class=\"headerlink\" title=\"随机数\"></a>随机数</h1><p>Random 类，在 java.util 包下，需要导包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.Random;<br>Random r=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>();<br><span class=\"hljs-type\">int</span> n=r.nextInt(<span class=\"hljs-number\">10</span>);<span class=\"hljs-comment\">//[0,10)的范围内取随机数</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"IDEA\"><a href=\"#IDEA\" class=\"headerlink\" title=\"IDEA\"></a>IDEA</h1><p>集成环境：能够把代码编写、编译、执行、调试等功能集合到一起的开发工具。IDEA  就是 java 的集成环境之一。</p>\n<p>创建项目-项目内创建模块-模块 src 下创建包-包下创建类-类中编写代码。</p>\n<p>其中，.class 文件都会放在模块同级的 out 文件夹中。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/28/AJdw2.png\" alt=\"AJdw2.png\"></p>\n<p>可以在 File - Settings - Editor - Font 中修改字体</p>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>psvm + Tab：public static void main</p>\n<p>sout + Tab：System.out.println()</p>\n<p>Ctrl + Alt + Space：自动补全代码</p>\n<p>Ctrl + /：单行注释</p>\n<p>Ctrl + Shift + /：多行注释</p>\n<p>Ctrl + Alt + L：代码格式化</p>\n<h2 id=\"模块操作\"><a href=\"#模块操作\" class=\"headerlink\" title=\"模块操作\"></a>模块操作</h2><p>新增模块： File - Project Structure - Modules - New Module - Java - 命名，修改路径</p>\n<p>删除模块：右键模块 - Remove Module</p>\n<p>​    不过删除后在文件目录中仍然存在。</p>\n<p>导入模块：File - Project Structure - Modules - (+) - Import Modules - 选择模块。</p>\n<p>​    如果显示 project SDK is not defined：点 set up.</p>\n<h2 id=\"断点\"><a href=\"#断点\" class=\"headerlink\" title=\"断点\"></a>断点</h2><p>DeBug 调试，断点调试，可以查看程序运行细节。</p>\n<p>添加断点：在行号前点一下，出现红点。</p>\n<p>调试：右键，不是 run ,而是 debug。</p>\n<p>Debugger 窗口下的Frames：查看代码运行到了哪里，也可以查看方法调用情况。</p>\n<p>Debugger 窗口下的Variables：查看各变量运行过程中值的变化</p>\n<p>Console 窗口：查看代码运行过程中的输出变化。如果代码中出现需要输入的情况，需要先在 Console 窗口中输入才能继续执行。</p>\n<p>step info 按钮：下一步</p>\n<p>stop：停止</p>\n<p>再次点击红点，取消该断点。</p>\n<p>批量取消断点：点击两个红点的图案，选择 Java line breakpoints，点击 - 号即可全部删除。</p>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>一次性声明大量<strong>同类型</strong>变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[] arr;<span class=\"hljs-comment\">//推荐。定义了一个 int 型的数组，数组名是 arr</span><br><span class=\"hljs-type\">int</span> arr[];<span class=\"hljs-comment\">//定义了一个 int 型变量，变量名是 arr 数组</span><br><br><span class=\"hljs-type\">int</span>[] arr=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[]&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<span class=\"hljs-comment\">//静态初始化</span><br><span class=\"hljs-type\">int</span>[] arr=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<span class=\"hljs-comment\">//静态初始化简化版</span><br><span class=\"hljs-type\">int</span>[] arr=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">3</span>];<span class=\"hljs-comment\">//动态初始化，只申请了空间，系统赋予初始值</span><br><span class=\"hljs-comment\">//数字类型：初始值为0.0</span><br><span class=\"hljs-comment\">//布尔类型：初始值为 false</span><br><span class=\"hljs-comment\">//字符串类型：初始值为&quot;&quot;</span><br><span class=\"hljs-comment\">//引用类型：初始值为 null</span><br></code></pre></td></tr></table></figure>\n\n<p>java 程序运行时需要在内存中分配空间，为了提高效率，内存空间也被划分为不同的部分。</p>\n<h2 id=\"栈内存\"><a href=\"#栈内存\" class=\"headerlink\" title=\"栈内存\"></a>栈内存</h2><p>定义的方法中的变量放在栈内存中，使用完直接消失。</p>\n<p>如<code>int a</code>，以及上文中定义的数组名 arr（其值是指向堆内存中数组内容的地址）。</p>\n<h2 id=\"堆内存\"><a href=\"#堆内存\" class=\"headerlink\" title=\"堆内存\"></a>堆内存</h2><p>实体、对象等的定义放在堆内存中，使用完会在垃圾回收器空闲时进行回收。</p>\n<p>如 new 一个对象，以及上文中数组 arr 中的具体数据内容（arr[0]=1, arr[1]=2……）</p>\n<p>访问数组中的内容，首先根据栈内存中数组的地址找到相应的堆内存中的位置（以及移动相应的索引步长）然后访问数据。</p>\n<p>因此，当多个数组指向相同地址时，其中的内容是一样的，修改其中一个，另一个也会改变。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">int</span>[] arr1=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<br><span class=\"hljs-type\">int</span>[] arr2=arr1;<br>arr2[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">11</span>;<br>arr2[<span class=\"hljs-number\">1</span>]=<span class=\"hljs-number\">22</span>;<br>arr2[<span class=\"hljs-number\">2</span>]=<span class=\"hljs-number\">33</span>;<span class=\"hljs-comment\">//这时访问 arr1[]，发现其中的数据也变成了11,22,33</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数组常见问题\"><a href=\"#数组常见问题\" class=\"headerlink\" title=\"数组常见问题\"></a>数组常见问题</h2><ol>\n<li>数组越界问题，ArrayIndexOutOfException。</li>\n<li>空指针异常问题，NullPointerException。（<code>arr=null</code>，表示数组不指向任何有效对象）</li>\n</ol>\n<h2 id=\"Array-length\"><a href=\"#Array-length\" class=\"headerlink\" title=\"Array.length\"></a>Array.length</h2><p>数组自带属性 length，通过<code>arr.length</code>就能获得数组长度。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><p>java 中的方法类似 C 中的函数。只是涉及类和对象的问题，有一些小不同。</p>\n<p>像函数一样，是有独立功能的代码块组成的集合，可以拿去调用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> 返回值类型 方法名(形参)&#123;<span class=\"hljs-comment\">//和 main 方法同级</span><br>    方法体<br>    <span class=\"hljs-keyword\">return</span> 返回值;<br>&#125;<span class=\"hljs-comment\">//定义</span><br><br>方法名(实参);<span class=\"hljs-comment\">//在 main 方法中调用。有返回值类型的方法建议用变量接收调用</span><br></code></pre></td></tr></table></figure>\n\n<p>方法不能嵌套定义。</p>\n<h2 id=\"方法重载\"><a href=\"#方法重载\" class=\"headerlink\" title=\"方法重载\"></a>方法重载</h2><p>多个方法在一个类中，有相同的方法名，但参数不完全相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">max</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c)</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>注意：返回值不能作为判断方法是否重载的标准！</strong>只有方法名和参数可以。</p>\n<p>调用时，JVM 根据传入参数不同，来得知调用的是哪个方法。</p>\n<p><strong>形参值修改不会对实参造成影响。</strong>main() 方法存储在栈内存中，当 main() 方法调用其它方法时，其他方法进入栈内存</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/29/A8wxg.png\" alt=\"A8wxg.png\"></p>\n<p>但是其中的形参的值不对 main() 中的实参造成影响（除非是像数组、指针之类引用类型，根据地址去堆内存中修改数据），当 change() 方法执行完后就直接出栈了。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/29/A8Kh1.png\" alt=\"A8Kh1.png\"></p>\n<p>如图，如果是数组单元的值被修改了，实际上是堆内存中的内容被修改了， main() 方法中数组对应的地址中的内容也会被修改。</p>\n"},{"title":"C 关于gets()和scanf()处理空白字符的问题","date":"2022-02-25T16:00:00.000Z","_content":"\n## scanf()\n\nscanf()如果读入字符、字符串，就要注意回车、空格、制表符（统称为空白符）的问题。\n字符还比较好处理，比如要输入abc三个字符，中间就直接不加入任何空白符，直接连着输入”abc”即可。\nscanf()使用%s读入字符串，读到空白符时会自动结束，所以不能读入英文句子(“hello world”中间有空格，一次只能读一个单词)\n想要读入带有空格的句子，一种方法是用scanf读入一个个字符串（单词）。字符串以空白符结尾，且当空白符在开头时%s是不会读取空白符的，会跳过这里的空白符（和scanf读入整数或浮点数时类似）\n```c\nscanf(\"%s%s\",str1,str2);//输入\"hello world\"\nprintf(\"%s%s\\n\",str1,str2);//输出\"helloworld\"\nprintf(\"%s %s\\n\",str1,str2);//输出\"hello world\"\n```\n只要补齐空格就可以了。当然这种方法用来读入输出英文句子时局限性很大，每个单词都要定义一个字符串变量（或许可以定义一个char的二维数组/指向char一维数组的指针/指向指针的指针），而且还要自己补空格。\n另一个有趣的地方是scanf()里可以放空格，意思是跳过这里的空白符。\n```c\nscanf(\"%s %s\",str1,str2);//输入\"hello world\"\nprintf(\"%s%s\\n\",str1,str2);//输出\"helloworld\"\n```\n如果还是上例，其实没有影响，因为就算scanf里没有这个空格，str2也会自动跳过开头的空格从后面的w开始读入。不过这种方法在读入字符的时候处理输入的空白符，以及下文中和gets()的结合中就比较有用。\n\n## gets()\n\ngets()就可以读入空白符，空格、回车、制表符都能读入，并且读入回车时结束。因此可以借助gets()读入英文短句式的字符串（带有空格）\n```c\ngets(str);//输入\"hello world\\n\"\nprintf(\"%s\",str);//输出\"hello world\"\n```\n但是要注意回车的问题。\n当gets()读入的第一个数据是回车，则停止继续读入，并且str的内容就是回车。\n当gets()读入\"hello world\\n\",回车是不会被gets()读入的，还留在缓冲区。\n所以连着使用两个gets()，而中间不想办法处理掉回车，就会出错。\n```c\ngets(str1);//abc\\n\ngets(str2);//abc\\n\ngets(str3);//abc\\n\n//输出的结果是：abc\\nabc,str2读到的是回车。\n```\n此时可以用getchar()读掉中间的回车。\n在做翁恺老师C语言程序设计的PTA习题时，碰到了这样一道题：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2bf40d6f06ca4f999f51eefe9bea5cfd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n要交替输入浮点数和带空格的字符串，一开始没有细想回车的问题：\n```c\n//循环执行：\nscanf(\"%lf\",book[i].price);//读入浮点数\ngets(books[i].name);//读入字符串\n```\n后来经一番查询理解了两种函数对空白符的处理，也写了这篇博文。\n这道题有趣的地方是scanf和gets的结合，因此除了getchar()读掉中间的回车的办法，还可以在scanf末尾加空格：\n```c\n//循环执行：\nscanf(\"%lf \",book[i].price);//读入浮点数，并读掉结尾的空白符（回车）\ngets(books[i].name);//读入字符串\n```\n非常巧妙。\n以上是本人经试验、查询资料后得出的结论，也欢迎读者多多尝试，如有错误，还请读者雅正！","source":"_posts/C gets()和scanf()处理空白字符的问题.md","raw":"---\ntitle: C 关于gets()和scanf()处理空白字符的问题\ndate: 2022-02-26\ntags: problems\ncategory: clanguage\n---\n\n## scanf()\n\nscanf()如果读入字符、字符串，就要注意回车、空格、制表符（统称为空白符）的问题。\n字符还比较好处理，比如要输入abc三个字符，中间就直接不加入任何空白符，直接连着输入”abc”即可。\nscanf()使用%s读入字符串，读到空白符时会自动结束，所以不能读入英文句子(“hello world”中间有空格，一次只能读一个单词)\n想要读入带有空格的句子，一种方法是用scanf读入一个个字符串（单词）。字符串以空白符结尾，且当空白符在开头时%s是不会读取空白符的，会跳过这里的空白符（和scanf读入整数或浮点数时类似）\n```c\nscanf(\"%s%s\",str1,str2);//输入\"hello world\"\nprintf(\"%s%s\\n\",str1,str2);//输出\"helloworld\"\nprintf(\"%s %s\\n\",str1,str2);//输出\"hello world\"\n```\n只要补齐空格就可以了。当然这种方法用来读入输出英文句子时局限性很大，每个单词都要定义一个字符串变量（或许可以定义一个char的二维数组/指向char一维数组的指针/指向指针的指针），而且还要自己补空格。\n另一个有趣的地方是scanf()里可以放空格，意思是跳过这里的空白符。\n```c\nscanf(\"%s %s\",str1,str2);//输入\"hello world\"\nprintf(\"%s%s\\n\",str1,str2);//输出\"helloworld\"\n```\n如果还是上例，其实没有影响，因为就算scanf里没有这个空格，str2也会自动跳过开头的空格从后面的w开始读入。不过这种方法在读入字符的时候处理输入的空白符，以及下文中和gets()的结合中就比较有用。\n\n## gets()\n\ngets()就可以读入空白符，空格、回车、制表符都能读入，并且读入回车时结束。因此可以借助gets()读入英文短句式的字符串（带有空格）\n```c\ngets(str);//输入\"hello world\\n\"\nprintf(\"%s\",str);//输出\"hello world\"\n```\n但是要注意回车的问题。\n当gets()读入的第一个数据是回车，则停止继续读入，并且str的内容就是回车。\n当gets()读入\"hello world\\n\",回车是不会被gets()读入的，还留在缓冲区。\n所以连着使用两个gets()，而中间不想办法处理掉回车，就会出错。\n```c\ngets(str1);//abc\\n\ngets(str2);//abc\\n\ngets(str3);//abc\\n\n//输出的结果是：abc\\nabc,str2读到的是回车。\n```\n此时可以用getchar()读掉中间的回车。\n在做翁恺老师C语言程序设计的PTA习题时，碰到了这样一道题：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2bf40d6f06ca4f999f51eefe9bea5cfd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70)\n要交替输入浮点数和带空格的字符串，一开始没有细想回车的问题：\n```c\n//循环执行：\nscanf(\"%lf\",book[i].price);//读入浮点数\ngets(books[i].name);//读入字符串\n```\n后来经一番查询理解了两种函数对空白符的处理，也写了这篇博文。\n这道题有趣的地方是scanf和gets的结合，因此除了getchar()读掉中间的回车的办法，还可以在scanf末尾加空格：\n```c\n//循环执行：\nscanf(\"%lf \",book[i].price);//读入浮点数，并读掉结尾的空白符（回车）\ngets(books[i].name);//读入字符串\n```\n非常巧妙。\n以上是本人经试验、查询资料后得出的结论，也欢迎读者多多尝试，如有错误，还请读者雅正！","slug":"C gets()和scanf()处理空白字符的问题","published":1,"updated":"2022-05-01T16:52:03.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9rys0000w0v2c9j9b6z2","content":"<h2 id=\"scanf\"><a href=\"#scanf\" class=\"headerlink\" title=\"scanf()\"></a>scanf()</h2><p>scanf()如果读入字符、字符串，就要注意回车、空格、制表符（统称为空白符）的问题。<br>字符还比较好处理，比如要输入abc三个字符，中间就直接不加入任何空白符，直接连着输入”abc”即可。<br>scanf()使用%s读入字符串，读到空白符时会自动结束，所以不能读入英文句子(“hello world”中间有空格，一次只能读一个单词)<br>想要读入带有空格的句子，一种方法是用scanf读入一个个字符串（单词）。字符串以空白符结尾，且当空白符在开头时%s是不会读取空白符的，会跳过这里的空白符（和scanf读入整数或浮点数时类似）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%s%s&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输入&quot;hello world&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s%s\\n&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输出&quot;helloworld&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s %s\\n&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输出&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>\n<p>只要补齐空格就可以了。当然这种方法用来读入输出英文句子时局限性很大，每个单词都要定义一个字符串变量（或许可以定义一个char的二维数组/指向char一维数组的指针/指向指针的指针），而且还要自己补空格。<br>另一个有趣的地方是scanf()里可以放空格，意思是跳过这里的空白符。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%s %s&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输入&quot;hello world&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s%s\\n&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输出&quot;helloworld&quot;</span><br></code></pre></td></tr></table></figure>\n<p>如果还是上例，其实没有影响，因为就算scanf里没有这个空格，str2也会自动跳过开头的空格从后面的w开始读入。不过这种方法在读入字符的时候处理输入的空白符，以及下文中和gets()的结合中就比较有用。</p>\n<h2 id=\"gets\"><a href=\"#gets\" class=\"headerlink\" title=\"gets()\"></a>gets()</h2><p>gets()就可以读入空白符，空格、回车、制表符都能读入，并且读入回车时结束。因此可以借助gets()读入英文短句式的字符串（带有空格）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">gets(str);<span class=\"hljs-comment\">//输入&quot;hello world\\n&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>,str);<span class=\"hljs-comment\">//输出&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>\n<p>但是要注意回车的问题。<br>当gets()读入的第一个数据是回车，则停止继续读入，并且str的内容就是回车。<br>当gets()读入”hello world\\n”,回车是不会被gets()读入的，还留在缓冲区。<br>所以连着使用两个gets()，而中间不想办法处理掉回车，就会出错。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">gets(str1);<span class=\"hljs-comment\">//abc\\n</span><br>gets(str2);<span class=\"hljs-comment\">//abc\\n</span><br>gets(str3);<span class=\"hljs-comment\">//abc\\n</span><br><span class=\"hljs-comment\">//输出的结果是：abc\\nabc,str2读到的是回车。</span><br></code></pre></td></tr></table></figure>\n<p>此时可以用getchar()读掉中间的回车。<br>在做翁恺老师C语言程序设计的PTA习题时，碰到了这样一道题：<br><img src=\"https://img-blog.csdnimg.cn/2bf40d6f06ca4f999f51eefe9bea5cfd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>要交替输入浮点数和带空格的字符串，一开始没有细想回车的问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//循环执行：</span><br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%lf&quot;</span>,book[i].price);<span class=\"hljs-comment\">//读入浮点数</span><br>gets(books[i].name);<span class=\"hljs-comment\">//读入字符串</span><br></code></pre></td></tr></table></figure>\n<p>后来经一番查询理解了两种函数对空白符的处理，也写了这篇博文。<br>这道题有趣的地方是scanf和gets的结合，因此除了getchar()读掉中间的回车的办法，还可以在scanf末尾加空格：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//循环执行：</span><br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%lf &quot;</span>,book[i].price);<span class=\"hljs-comment\">//读入浮点数，并读掉结尾的空白符（回车）</span><br>gets(books[i].name);<span class=\"hljs-comment\">//读入字符串</span><br></code></pre></td></tr></table></figure>\n<p>非常巧妙。<br>以上是本人经试验、查询资料后得出的结论，也欢迎读者多多尝试，如有错误，还请读者雅正！</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"scanf\"><a href=\"#scanf\" class=\"headerlink\" title=\"scanf()\"></a>scanf()</h2><p>scanf()如果读入字符、字符串，就要注意回车、空格、制表符（统称为空白符）的问题。<br>字符还比较好处理，比如要输入abc三个字符，中间就直接不加入任何空白符，直接连着输入”abc”即可。<br>scanf()使用%s读入字符串，读到空白符时会自动结束，所以不能读入英文句子(“hello world”中间有空格，一次只能读一个单词)<br>想要读入带有空格的句子，一种方法是用scanf读入一个个字符串（单词）。字符串以空白符结尾，且当空白符在开头时%s是不会读取空白符的，会跳过这里的空白符（和scanf读入整数或浮点数时类似）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%s%s&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输入&quot;hello world&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s%s\\n&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输出&quot;helloworld&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s %s\\n&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输出&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>\n<p>只要补齐空格就可以了。当然这种方法用来读入输出英文句子时局限性很大，每个单词都要定义一个字符串变量（或许可以定义一个char的二维数组/指向char一维数组的指针/指向指针的指针），而且还要自己补空格。<br>另一个有趣的地方是scanf()里可以放空格，意思是跳过这里的空白符。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%s %s&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输入&quot;hello world&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s%s\\n&quot;</span>,str1,str2);<span class=\"hljs-comment\">//输出&quot;helloworld&quot;</span><br></code></pre></td></tr></table></figure>\n<p>如果还是上例，其实没有影响，因为就算scanf里没有这个空格，str2也会自动跳过开头的空格从后面的w开始读入。不过这种方法在读入字符的时候处理输入的空白符，以及下文中和gets()的结合中就比较有用。</p>\n<h2 id=\"gets\"><a href=\"#gets\" class=\"headerlink\" title=\"gets()\"></a>gets()</h2><p>gets()就可以读入空白符，空格、回车、制表符都能读入，并且读入回车时结束。因此可以借助gets()读入英文短句式的字符串（带有空格）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">gets(str);<span class=\"hljs-comment\">//输入&quot;hello world\\n&quot;</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>,str);<span class=\"hljs-comment\">//输出&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>\n<p>但是要注意回车的问题。<br>当gets()读入的第一个数据是回车，则停止继续读入，并且str的内容就是回车。<br>当gets()读入”hello world\\n”,回车是不会被gets()读入的，还留在缓冲区。<br>所以连着使用两个gets()，而中间不想办法处理掉回车，就会出错。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">gets(str1);<span class=\"hljs-comment\">//abc\\n</span><br>gets(str2);<span class=\"hljs-comment\">//abc\\n</span><br>gets(str3);<span class=\"hljs-comment\">//abc\\n</span><br><span class=\"hljs-comment\">//输出的结果是：abc\\nabc,str2读到的是回车。</span><br></code></pre></td></tr></table></figure>\n<p>此时可以用getchar()读掉中间的回车。<br>在做翁恺老师C语言程序设计的PTA习题时，碰到了这样一道题：<br><img src=\"https://img-blog.csdnimg.cn/2bf40d6f06ca4f999f51eefe9bea5cfd.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p0d3F3cQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>要交替输入浮点数和带空格的字符串，一开始没有细想回车的问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//循环执行：</span><br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%lf&quot;</span>,book[i].price);<span class=\"hljs-comment\">//读入浮点数</span><br>gets(books[i].name);<span class=\"hljs-comment\">//读入字符串</span><br></code></pre></td></tr></table></figure>\n<p>后来经一番查询理解了两种函数对空白符的处理，也写了这篇博文。<br>这道题有趣的地方是scanf和gets的结合，因此除了getchar()读掉中间的回车的办法，还可以在scanf末尾加空格：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//循环执行：</span><br><span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%lf &quot;</span>,book[i].price);<span class=\"hljs-comment\">//读入浮点数，并读掉结尾的空白符（回车）</span><br>gets(books[i].name);<span class=\"hljs-comment\">//读入字符串</span><br></code></pre></td></tr></table></figure>\n<p>非常巧妙。<br>以上是本人经试验、查询资料后得出的结论，也欢迎读者多多尝试，如有错误，还请读者雅正！</p>\n"},{"title":"C 结构体指针在函数中的应用问题","date":"2022-02-25T16:00:00.000Z","_content":"\n主函数传入函数的变量叫实参，而函数中的对应变量叫形参。形参实际上是实参的拷贝，所以如果我们修改形参的值，实参不会发生变化。\n后来学习了指针，指针就相当于钥匙，能打开对应房间（地址）的门。当指针作为函数参数时，实参和形参相当于拷贝的两把钥匙，但他们都指向同一个房间，同一个地址。借由形参访问地址，并改变地址中的值，能够真正修改地址中的值。\n而在学习结构体、链表时，常常进行的操作是对结构体指针赋值。\n比如添加新链表结点add函数，传入实参head（要修改的链表的头指针）先将新结点的内容赋给临时结构体指针p，然后将p的值赋给head或last->next，即挂在链表的结尾。\n\n```c\nhead=p;//当head为NULL的时候\nlast->next=p;//当head不为NULL的时候\n```\n最后返回head指针。\n但是这样做并不会直接对主函数中的head指针进行修改，为什么？\n因为我们修改的不是指针对应地址中的值，而是直接修改指针的值，改变了指针的指向（对钥匙本身的修改，让这把钥匙指向另一个房间；而不是对钥匙指向房间里的内容的修改）。当我们令head=p时，相当于让head自身的地址值改变，和指针p指向的地址一样。这就和修改普通变量一样，对形参的修改不会影响实参。\n解决方法：(翁恺老师的建议）\n1. head定义为全局变量，这样在所有函数中都能访问。但这种方法并不好，只对这个链表的head生效。如果还定义了其他链表，此add函数就不能对其他链表生效了。\n2. add函数返回新的我们想要的head结构体指针，在原函数中把add函数的返回值赋给head.\n3. 既然可以传递指针对应地址的值，我们就让指针所指的地址中的值是我们要修改的指针，即传入**phead指向指针的指针。这样就可以直接修改*phead的值了。\n4. 我们定义一个结构list，其中包含*head。在原函数中定义list，list.head=NULL；然后把list的指针`&list`传入add函数，add的参数是list的指针，在函数中就可以对list->head进行修改。","source":"_posts/C 结构体指针在函数中的应用问题.md","raw":"---\ntitle: C 结构体指针在函数中的应用问题\ndate: 2022-02-26\ntags: problems\ncategory: clanguage\n---\n\n主函数传入函数的变量叫实参，而函数中的对应变量叫形参。形参实际上是实参的拷贝，所以如果我们修改形参的值，实参不会发生变化。\n后来学习了指针，指针就相当于钥匙，能打开对应房间（地址）的门。当指针作为函数参数时，实参和形参相当于拷贝的两把钥匙，但他们都指向同一个房间，同一个地址。借由形参访问地址，并改变地址中的值，能够真正修改地址中的值。\n而在学习结构体、链表时，常常进行的操作是对结构体指针赋值。\n比如添加新链表结点add函数，传入实参head（要修改的链表的头指针）先将新结点的内容赋给临时结构体指针p，然后将p的值赋给head或last->next，即挂在链表的结尾。\n\n```c\nhead=p;//当head为NULL的时候\nlast->next=p;//当head不为NULL的时候\n```\n最后返回head指针。\n但是这样做并不会直接对主函数中的head指针进行修改，为什么？\n因为我们修改的不是指针对应地址中的值，而是直接修改指针的值，改变了指针的指向（对钥匙本身的修改，让这把钥匙指向另一个房间；而不是对钥匙指向房间里的内容的修改）。当我们令head=p时，相当于让head自身的地址值改变，和指针p指向的地址一样。这就和修改普通变量一样，对形参的修改不会影响实参。\n解决方法：(翁恺老师的建议）\n1. head定义为全局变量，这样在所有函数中都能访问。但这种方法并不好，只对这个链表的head生效。如果还定义了其他链表，此add函数就不能对其他链表生效了。\n2. add函数返回新的我们想要的head结构体指针，在原函数中把add函数的返回值赋给head.\n3. 既然可以传递指针对应地址的值，我们就让指针所指的地址中的值是我们要修改的指针，即传入**phead指向指针的指针。这样就可以直接修改*phead的值了。\n4. 我们定义一个结构list，其中包含*head。在原函数中定义list，list.head=NULL；然后把list的指针`&list`传入add函数，add的参数是list的指针，在函数中就可以对list->head进行修改。","slug":"C 结构体指针在函数中的应用问题","published":1,"updated":"2022-05-01T16:53:08.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9ryv0001w0v2cnax0ghv","content":"<p>主函数传入函数的变量叫实参，而函数中的对应变量叫形参。形参实际上是实参的拷贝，所以如果我们修改形参的值，实参不会发生变化。<br>后来学习了指针，指针就相当于钥匙，能打开对应房间（地址）的门。当指针作为函数参数时，实参和形参相当于拷贝的两把钥匙，但他们都指向同一个房间，同一个地址。借由形参访问地址，并改变地址中的值，能够真正修改地址中的值。<br>而在学习结构体、链表时，常常进行的操作是对结构体指针赋值。<br>比如添加新链表结点add函数，传入实参head（要修改的链表的头指针）先将新结点的内容赋给临时结构体指针p，然后将p的值赋给head或last-&gt;next，即挂在链表的结尾。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">head=p;<span class=\"hljs-comment\">//当head为NULL的时候</span><br>last-&gt;next=p;<span class=\"hljs-comment\">//当head不为NULL的时候</span><br></code></pre></td></tr></table></figure>\n<p>最后返回head指针。<br>但是这样做并不会直接对主函数中的head指针进行修改，为什么？<br>因为我们修改的不是指针对应地址中的值，而是直接修改指针的值，改变了指针的指向（对钥匙本身的修改，让这把钥匙指向另一个房间；而不是对钥匙指向房间里的内容的修改）。当我们令head=p时，相当于让head自身的地址值改变，和指针p指向的地址一样。这就和修改普通变量一样，对形参的修改不会影响实参。<br>解决方法：(翁恺老师的建议）</p>\n<ol>\n<li>head定义为全局变量，这样在所有函数中都能访问。但这种方法并不好，只对这个链表的head生效。如果还定义了其他链表，此add函数就不能对其他链表生效了。</li>\n<li>add函数返回新的我们想要的head结构体指针，在原函数中把add函数的返回值赋给head.</li>\n<li>既然可以传递指针对应地址的值，我们就让指针所指的地址中的值是我们要修改的指针，即传入*<em>phead指向指针的指针。这样就可以直接修改</em>phead的值了。</li>\n<li>我们定义一个结构list，其中包含*head。在原函数中定义list，list.head=NULL；然后把list的指针<code>&amp;list</code>传入add函数，add的参数是list的指针，在函数中就可以对list-&gt;head进行修改。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>主函数传入函数的变量叫实参，而函数中的对应变量叫形参。形参实际上是实参的拷贝，所以如果我们修改形参的值，实参不会发生变化。<br>后来学习了指针，指针就相当于钥匙，能打开对应房间（地址）的门。当指针作为函数参数时，实参和形参相当于拷贝的两把钥匙，但他们都指向同一个房间，同一个地址。借由形参访问地址，并改变地址中的值，能够真正修改地址中的值。<br>而在学习结构体、链表时，常常进行的操作是对结构体指针赋值。<br>比如添加新链表结点add函数，传入实参head（要修改的链表的头指针）先将新结点的内容赋给临时结构体指针p，然后将p的值赋给head或last-&gt;next，即挂在链表的结尾。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">head=p;<span class=\"hljs-comment\">//当head为NULL的时候</span><br>last-&gt;next=p;<span class=\"hljs-comment\">//当head不为NULL的时候</span><br></code></pre></td></tr></table></figure>\n<p>最后返回head指针。<br>但是这样做并不会直接对主函数中的head指针进行修改，为什么？<br>因为我们修改的不是指针对应地址中的值，而是直接修改指针的值，改变了指针的指向（对钥匙本身的修改，让这把钥匙指向另一个房间；而不是对钥匙指向房间里的内容的修改）。当我们令head=p时，相当于让head自身的地址值改变，和指针p指向的地址一样。这就和修改普通变量一样，对形参的修改不会影响实参。<br>解决方法：(翁恺老师的建议）</p>\n<ol>\n<li>head定义为全局变量，这样在所有函数中都能访问。但这种方法并不好，只对这个链表的head生效。如果还定义了其他链表，此add函数就不能对其他链表生效了。</li>\n<li>add函数返回新的我们想要的head结构体指针，在原函数中把add函数的返回值赋给head.</li>\n<li>既然可以传递指针对应地址的值，我们就让指针所指的地址中的值是我们要修改的指针，即传入*<em>phead指向指针的指针。这样就可以直接修改</em>phead的值了。</li>\n<li>我们定义一个结构list，其中包含*head。在原函数中定义list，list.head=NULL；然后把list的指针<code>&amp;list</code>传入add函数，add的参数是list的指针，在函数中就可以对list-&gt;head进行修改。</li>\n</ol>\n"},{"title":"Java 学习博客_10 入门——抽象类、抽象方法、接口","date":"2022-05-01T16:00:00.000Z","_content":"\n以黑马程序员全套Java教程网课为主。\n\n\n\n抽象方法：没有方法体的方法\n\n```java\npublic abstract void eat();\n```\n\n抽象类：含有抽象方法的类。\n\n（没有抽象方法的类也可以是抽象类，但是意义何在）\n\n抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象方法。\n\n# 接口\n\n接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：\n\n```java\npublic interface Jumpping{//接口\n    public abstract void Jump();\n}\n\npublic class Cat implements Jumpping{//实现\n    //重写 Jump() 方法。如果不重写， Cat 就是一个抽象类\n}\n```\n\n接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。\n\n接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。\n\n（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）\n\n接口是抽象类，不能直接实例化，可以借助多态的方法实例化。\n\n相较类与类之间不能多继承，只能层层继承：接口可以多实现`implements interface1, interface2`\n\n接口和接口之间也可以多继承`interface1 extends interface2, interface3`\n\n## 总结\n\n![An2QF.png](https://s1.328888.xyz/2022/05/01/An2QF.png)\n\n## 设计原则\n\n抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。\n\n但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。\n\n例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。分析本例如何用具体类、抽象类、接口实现。\n\n```mermaid\ngraph TB\nA[人]-->B[运动员]\nA-->C[教练]\nB-->D[篮球运动员]\nB-->E[乒乓球运动员]\nH[说英语]-->E\nH-->G\nC-->G[乒乓球教练]\nC-->F[篮球教练]\n```\n\n其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。\n\n## 抽象类 / 接口作为形参 / 返回值\n\n类也可以作为形式参数或函数的返回值。\n\n抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要的是实现了该抽象类的子类对象。\n\n如函数形参是Animal，实际需要通过多态的方法Animal a=new Cat();然后把a传给函数。\n\n接口作为形参/函数返回值，和抽象类一样，实际需要的是实现了该接口的类对象。\n\n","source":"_posts/Java 学习博客_10 入门——抽象类、抽象方法、接口.md","raw":"---\ntitle: Java 学习博客_10 入门——抽象类、抽象方法、接口\ndate: 2022-05-02\ntags: study\ncategory: java\n---\n\n以黑马程序员全套Java教程网课为主。\n\n\n\n抽象方法：没有方法体的方法\n\n```java\npublic abstract void eat();\n```\n\n抽象类：含有抽象方法的类。\n\n（没有抽象方法的类也可以是抽象类，但是意义何在）\n\n抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象方法。\n\n# 接口\n\n接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：\n\n```java\npublic interface Jumpping{//接口\n    public abstract void Jump();\n}\n\npublic class Cat implements Jumpping{//实现\n    //重写 Jump() 方法。如果不重写， Cat 就是一个抽象类\n}\n```\n\n接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。\n\n接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。\n\n（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）\n\n接口是抽象类，不能直接实例化，可以借助多态的方法实例化。\n\n相较类与类之间不能多继承，只能层层继承：接口可以多实现`implements interface1, interface2`\n\n接口和接口之间也可以多继承`interface1 extends interface2, interface3`\n\n## 总结\n\n![An2QF.png](https://s1.328888.xyz/2022/05/01/An2QF.png)\n\n## 设计原则\n\n抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。\n\n但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。\n\n例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。分析本例如何用具体类、抽象类、接口实现。\n\n```mermaid\ngraph TB\nA[人]-->B[运动员]\nA-->C[教练]\nB-->D[篮球运动员]\nB-->E[乒乓球运动员]\nH[说英语]-->E\nH-->G\nC-->G[乒乓球教练]\nC-->F[篮球教练]\n```\n\n其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。\n\n## 抽象类 / 接口作为形参 / 返回值\n\n类也可以作为形式参数或函数的返回值。\n\n抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要的是实现了该抽象类的子类对象。\n\n如函数形参是Animal，实际需要通过多态的方法Animal a=new Cat();然后把a传给函数。\n\n接口作为形参/函数返回值，和抽象类一样，实际需要的是实现了该接口的类对象。\n\n","slug":"Java 学习博客_10 入门——抽象类、抽象方法、接口","published":1,"updated":"2022-05-01T16:50:35.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9ryz0005w0v2fxf7enkl","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>抽象方法：没有方法体的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span>;<br></code></pre></td></tr></table></figure>\n\n<p>抽象类：含有抽象方法的类。</p>\n<p>（没有抽象方法的类也可以是抽象类，但是意义何在）</p>\n<p>抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象方法。</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Jumpping</span>&#123;<span class=\"hljs-comment\">//接口</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">Jump</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Jumpping</span>&#123;<span class=\"hljs-comment\">//实现</span><br>    <span class=\"hljs-comment\">//重写 Jump() 方法。如果不重写， Cat 就是一个抽象类</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。</p>\n<p>接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。</p>\n<p>（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）</p>\n<p>接口是抽象类，不能直接实例化，可以借助多态的方法实例化。</p>\n<p>相较类与类之间不能多继承，只能层层继承：接口可以多实现<code>implements interface1, interface2</code></p>\n<p>接口和接口之间也可以多继承<code>interface1 extends interface2, interface3</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://s1.328888.xyz/2022/05/01/An2QF.png\" alt=\"An2QF.png\"></p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。</p>\n<p>但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。</p>\n<p>例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。分析本例如何用具体类、抽象类、接口实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TB<br>A[人]--&gt;B[运动员]<br>A--&gt;C[教练]<br>B--&gt;D[篮球运动员]<br>B--&gt;E[乒乓球运动员]<br>H[说英语]--&gt;E<br>H--&gt;G<br>C--&gt;G[乒乓球教练]<br>C--&gt;F[篮球教练]<br></code></pre></td></tr></table></figure>\n\n<p>其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。</p>\n<h2 id=\"抽象类-接口作为形参-返回值\"><a href=\"#抽象类-接口作为形参-返回值\" class=\"headerlink\" title=\"抽象类 / 接口作为形参 / 返回值\"></a>抽象类 / 接口作为形参 / 返回值</h2><p>类也可以作为形式参数或函数的返回值。</p>\n<p>抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要的是实现了该抽象类的子类对象。</p>\n<p>如函数形参是Animal，实际需要通过多态的方法Animal a=new Cat();然后把a传给函数。</p>\n<p>接口作为形参/函数返回值，和抽象类一样，实际需要的是实现了该接口的类对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>抽象方法：没有方法体的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">()</span>;<br></code></pre></td></tr></table></figure>\n\n<p>抽象类：含有抽象方法的类。</p>\n<p>（没有抽象方法的类也可以是抽象类，但是意义何在）</p>\n<p>抽象类不能直接创建对象，需要子类把抽象方法重写补全后才能创建对象。否则，子类也是抽象方法。</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><p>接口是一种公共的行为规范标准，只要符合规范，大家都可以使用。 java 中的接口主要是对行为的抽象。如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Jumpping</span>&#123;<span class=\"hljs-comment\">//接口</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">Jump</span><span class=\"hljs-params\">()</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Jumpping</span>&#123;<span class=\"hljs-comment\">//实现</span><br>    <span class=\"hljs-comment\">//重写 Jump() 方法。如果不重写， Cat 就是一个抽象类</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>接口中的成员变量默认是 public static final 的，不能修改，而且可以通过 Class.成员变量 的方式直接访问。</p>\n<p>接口中没有构造方法和非抽象方法。成员方法默认是 public abstract 的。</p>\n<p>（但接口的实现类中可以有 super。这是因为所有没有父类的类都默认继承自 Object 类，如果接口的实现类使用 Object 类中的方法就会用到 super）</p>\n<p>接口是抽象类，不能直接实例化，可以借助多态的方法实例化。</p>\n<p>相较类与类之间不能多继承，只能层层继承：接口可以多实现<code>implements interface1, interface2</code></p>\n<p>接口和接口之间也可以多继承<code>interface1 extends interface2, interface3</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://s1.328888.xyz/2022/05/01/An2QF.png\" alt=\"An2QF.png\"></p>\n<h2 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h2><p>抽象类中的抽象方法所有对象中都必须有；接口则是选择性实现的。比如门这一大类，其中不管什么门，防盗门、木门、自动门，都有门的特有行为（开关门、锁门……）只是实现方法可能不一样，所以要在门父类中定义这些抽象方法，在子类中必须实现。</p>\n<p>但是对于门来说不是必须有的抽象方法（如响铃）这种抽象方法就应该作为接口，选择性实现。有响铃功能的门实现这一接口，没有响铃功能的门不必实现。</p>\n<p>例：有乒乓球运动员、乒乓球教练、篮球运动员、篮球教练。为了能出国交流，乒乓球运动员和教练需要会说英语。分析本例如何用具体类、抽象类、接口实现。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TB<br>A[人]--&gt;B[运动员]<br>A--&gt;C[教练]<br>B--&gt;D[篮球运动员]<br>B--&gt;E[乒乓球运动员]<br>H[说英语]--&gt;E<br>H--&gt;G<br>C--&gt;G[乒乓球教练]<br>C--&gt;F[篮球教练]<br></code></pre></td></tr></table></figure>\n\n<p>其中，人、运动员、教练是抽象类，说英语是接口。其他具体类需要实现接口，并重写继承的所有抽象方法。</p>\n<h2 id=\"抽象类-接口作为形参-返回值\"><a href=\"#抽象类-接口作为形参-返回值\" class=\"headerlink\" title=\"抽象类 / 接口作为形参 / 返回值\"></a>抽象类 / 接口作为形参 / 返回值</h2><p>类也可以作为形式参数或函数的返回值。</p>\n<p>抽象类：如果方法的形参或函数的返回值是抽象类名，实际需要的是实现了该抽象类的子类对象。</p>\n<p>如函数形参是Animal，实际需要通过多态的方法Animal a=new Cat();然后把a传给函数。</p>\n<p>接口作为形参/函数返回值，和抽象类一样，实际需要的是实现了该接口的类对象。</p>\n"},{"title":"Java 学习博客_4 入门——类和对象","date":"2022-04-29T16:00:00.000Z","_content":"\n以黑马程序员全套Java教程网课为主。\n\n# 类\n\n类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠\n\n类是对象的数据类型，是一个抽象的概念。\n\n# 对象\n\n类的实体化。比如罗小黑，是猫类的一个实体化。\n\n## 属性\n\n对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）\n\n## 行为\n\n对象能执行的动作，如猫可以叫，可以跑。\n\n# 类的定义\n\n```java\npublic class 类名{\n    数据类型 变量;\n    数据类型 变量;\n    数据类型 变量;\n    \n    方法1;\n    方法2;\n}\n\npublic class Cat{\n    String name;//初始值为null或0或false或\"\"\n    int age;\n    boolean tail;\n    String color;\n    \n    public void meow(){\n\t\tSystem.out.println(\"Meow!\");\n    }\n    public void eat(String food){\n\t\tSystem.out.println(\"Eat \"+food);\n    }\n}\n```\n\n# 对象的使用\n\n```java\n//在 main 方法中\nCat c=new Cat();\nc.name=\"小黑\";//c 的名字\nc.age=2;//2岁了\nc.tail=false;//有尾巴\nSystem.out.println(c.age);\nc.meow();//行为：猫叫\nc.eat(\"猫粮\")//行为：吃饭\n```\n\n在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。\n\n对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的**属性**等具体内容存储在**堆内存**中。对象中的**方法**调用时则加载到**栈内存**中，执行完毕后出栈。\n\n# 成员变量和局部变量\n\n成员变量：类中在方法外的变量（如上例中的属性变量）\n\n局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）\n\n| 成员变量           | 局部变量                                   |\n| ------------------ | ------------------------------------------ |\n| 类中方法外         | 方法中，或方法声明上                       |\n| 堆内存中           | 栈内存中                                   |\n| 对象消失时随之消失 | 方法调用完毕而消失                         |\n| 有默认的初始值     | 没有默认的初始值，必须先定义、赋值才能使用 |\n\n\n\n","source":"_posts/Java 学习博客_4 入门——类和对象.md","raw":"---\ntitle: Java 学习博客_4 入门——类和对象\ndate: 2022-04-30\ntags: study\ncategory: java\n---\n\n以黑马程序员全套Java教程网课为主。\n\n# 类\n\n类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠\n\n类是对象的数据类型，是一个抽象的概念。\n\n# 对象\n\n类的实体化。比如罗小黑，是猫类的一个实体化。\n\n## 属性\n\n对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）\n\n## 行为\n\n对象能执行的动作，如猫可以叫，可以跑。\n\n# 类的定义\n\n```java\npublic class 类名{\n    数据类型 变量;\n    数据类型 变量;\n    数据类型 变量;\n    \n    方法1;\n    方法2;\n}\n\npublic class Cat{\n    String name;//初始值为null或0或false或\"\"\n    int age;\n    boolean tail;\n    String color;\n    \n    public void meow(){\n\t\tSystem.out.println(\"Meow!\");\n    }\n    public void eat(String food){\n\t\tSystem.out.println(\"Eat \"+food);\n    }\n}\n```\n\n# 对象的使用\n\n```java\n//在 main 方法中\nCat c=new Cat();\nc.name=\"小黑\";//c 的名字\nc.age=2;//2岁了\nc.tail=false;//有尾巴\nSystem.out.println(c.age);\nc.meow();//行为：猫叫\nc.eat(\"猫粮\")//行为：吃饭\n```\n\n在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。\n\n对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的**属性**等具体内容存储在**堆内存**中。对象中的**方法**调用时则加载到**栈内存**中，执行完毕后出栈。\n\n# 成员变量和局部变量\n\n成员变量：类中在方法外的变量（如上例中的属性变量）\n\n局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）\n\n| 成员变量           | 局部变量                                   |\n| ------------------ | ------------------------------------------ |\n| 类中方法外         | 方法中，或方法声明上                       |\n| 堆内存中           | 栈内存中                                   |\n| 对象消失时随之消失 | 方法调用完毕而消失                         |\n| 有默认的初始值     | 没有默认的初始值，必须先定义、赋值才能使用 |\n\n\n\n","slug":"Java 学习博客_4 入门——类和对象","published":1,"updated":"2022-05-01T16:49:22.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9rz40009w0v233aa9hgl","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠</p>\n<p>类是对象的数据类型，是一个抽象的概念。</p>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><p>类的实体化。比如罗小黑，是猫类的一个实体化。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）</p>\n<h2 id=\"行为\"><a href=\"#行为\" class=\"headerlink\" title=\"行为\"></a>行为</h2><p>对象能执行的动作，如猫可以叫，可以跑。</p>\n<h1 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> class 类名&#123;<br>    数据类型 变量;<br>    数据类型 变量;<br>    数据类型 变量;<br>    <br>    方法<span class=\"hljs-number\">1</span>;<br>    方法<span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span>&#123;<br>    String name;<span class=\"hljs-comment\">//初始值为null或0或false或&quot;&quot;</span><br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-type\">boolean</span> tail;<br>    String color;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">meow</span><span class=\"hljs-params\">()</span>&#123;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Meow!&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">(String food)</span>&#123;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Eat &quot;</span>+food);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"对象的使用\"><a href=\"#对象的使用\" class=\"headerlink\" title=\"对象的使用\"></a>对象的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//在 main 方法中</span><br>Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>c.name=<span class=\"hljs-string\">&quot;小黑&quot;</span>;<span class=\"hljs-comment\">//c 的名字</span><br>c.age=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//2岁了</span><br>c.tail=<span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//有尾巴</span><br>System.out.println(c.age);<br>c.meow();<span class=\"hljs-comment\">//行为：猫叫</span><br>c.eat(<span class=\"hljs-string\">&quot;猫粮&quot;</span>)<span class=\"hljs-comment\">//行为：吃饭</span><br></code></pre></td></tr></table></figure>\n\n<p>在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。</p>\n<p>对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的<strong>属性</strong>等具体内容存储在<strong>堆内存</strong>中。对象中的<strong>方法</strong>调用时则加载到<strong>栈内存</strong>中，执行完毕后出栈。</p>\n<h1 id=\"成员变量和局部变量\"><a href=\"#成员变量和局部变量\" class=\"headerlink\" title=\"成员变量和局部变量\"></a>成员变量和局部变量</h1><p>成员变量：类中在方法外的变量（如上例中的属性变量）</p>\n<p>局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类中方法外</td>\n<td>方法中，或方法声明上</td>\n</tr>\n<tr>\n<td>堆内存中</td>\n<td>栈内存中</td>\n</tr>\n<tr>\n<td>对象消失时随之消失</td>\n<td>方法调用完毕而消失</td>\n</tr>\n<tr>\n<td>有默认的初始值</td>\n<td>没有默认的初始值，必须先定义、赋值才能使用</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p>类是对生活中一类具有共同属性和行为的事物的抽象。如猫类，都有毛的长短、颜色、名字等属性，也都能猫叫、吃饭等（不接受抬杠</p>\n<p>类是对象的数据类型，是一个抽象的概念。</p>\n<h1 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h1><p>类的实体化。比如罗小黑，是猫类的一个实体化。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>对象具有的各种特征，每个对象的每个属性都有特定的值（如猫毛有长毛、短毛、无毛）</p>\n<h2 id=\"行为\"><a href=\"#行为\" class=\"headerlink\" title=\"行为\"></a>行为</h2><p>对象能执行的动作，如猫可以叫，可以跑。</p>\n<h1 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> class 类名&#123;<br>    数据类型 变量;<br>    数据类型 变量;<br>    数据类型 变量;<br>    <br>    方法<span class=\"hljs-number\">1</span>;<br>    方法<span class=\"hljs-number\">2</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span>&#123;<br>    String name;<span class=\"hljs-comment\">//初始值为null或0或false或&quot;&quot;</span><br>    <span class=\"hljs-type\">int</span> age;<br>    <span class=\"hljs-type\">boolean</span> tail;<br>    String color;<br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">meow</span><span class=\"hljs-params\">()</span>&#123;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Meow!&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">eat</span><span class=\"hljs-params\">(String food)</span>&#123;<br>\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Eat &quot;</span>+food);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"对象的使用\"><a href=\"#对象的使用\" class=\"headerlink\" title=\"对象的使用\"></a>对象的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//在 main 方法中</span><br>Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>c.name=<span class=\"hljs-string\">&quot;小黑&quot;</span>;<span class=\"hljs-comment\">//c 的名字</span><br>c.age=<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//2岁了</span><br>c.tail=<span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//有尾巴</span><br>System.out.println(c.age);<br>c.meow();<span class=\"hljs-comment\">//行为：猫叫</span><br>c.eat(<span class=\"hljs-string\">&quot;猫粮&quot;</span>)<span class=\"hljs-comment\">//行为：吃饭</span><br></code></pre></td></tr></table></figure>\n\n<p>在同级目录下，类在一个文件中，main 方法在另一个文件中而且实例化了这个类，也是可以的。</p>\n<p>对象名 c 存储在栈内存中（其值代表对象的属性在堆内存中的地址），而对象的<strong>属性</strong>等具体内容存储在<strong>堆内存</strong>中。对象中的<strong>方法</strong>调用时则加载到<strong>栈内存</strong>中，执行完毕后出栈。</p>\n<h1 id=\"成员变量和局部变量\"><a href=\"#成员变量和局部变量\" class=\"headerlink\" title=\"成员变量和局部变量\"></a>成员变量和局部变量</h1><p>成员变量：类中在方法外的变量（如上例中的属性变量）</p>\n<p>局部变量：在类的方法中或方法声明上的变量。（如上例中 eat 方法声明的 food 局部变量）</p>\n<table>\n<thead>\n<tr>\n<th>成员变量</th>\n<th>局部变量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>类中方法外</td>\n<td>方法中，或方法声明上</td>\n</tr>\n<tr>\n<td>堆内存中</td>\n<td>栈内存中</td>\n</tr>\n<tr>\n<td>对象消失时随之消失</td>\n<td>方法调用完毕而消失</td>\n</tr>\n<tr>\n<td>有默认的初始值</td>\n<td>没有默认的初始值，必须先定义、赋值才能使用</td>\n</tr>\n</tbody></table>\n"},{"title":"Java 学习博客_5 入门——封装","date":"2022-04-29T16:00:00.000Z","_content":"\n以黑马程序员全套Java教程网课为主。\n\n\n\nJava 的三大特性：封装、继承、多态\n\n# 封装 packaging\n\n之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age=-30）\n\n因此我们要添加一些限制。\n\n## private 修饰符\n\n可以修饰成员变量、成员方法不被其他类使用。\n\n```java\nprivate String name;\nprivate int age;\n```\n\n被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get / set 方法。\n\n## 构造方法\n\n写在类中，作为类的方法。主要用于对象初始化。声明变量时`Cat c=new Cat();`Cat() 就是一种无参构造方法。\n\n每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。**建议无论是否用到构造方法，都写一个无参构造方法。**\n\n```java\npublic Cat(){}//我们自己加的无参构造方法，会覆盖系统默认的\npublic Cat(String name){//写一部分参数的构造方法也可以\n    this.name=name;//通过 this 赋给成员变量\n}\npublic Cat(String name, int age){//写全参数的构造方法也可以\n    this.name=name;\n    this.age=age;\n}\n//main 中构造对象：\nCat c1=new Cat();\nCat c2=new Cat(\"小黑\");\nCat c3=new Cat(\"小白\",2);//这些都可以，与自己写的构造方法的参数相对应。\n```\n\nthis被哪个对象调用，就代表哪个对象。\n\n![AlrRQ.png](https://s1.328888.xyz/2022/04/30/AlrRQ.png)\n\n然后把\"林青霞\" 字符串类型传入堆内存中。\n\n## get / set\n\n无参构造方法后用 setXxx() 方法创建对象。\n\n```java\npublic void setName(String name){//赋值\n\tthis.name=name;\n}\npublic void setAge(int age){\n    if(age>=0&&age<=20)//在 set 中可以添加一些限制，处理\n\tthis.age=age;\n}\n\npublic void getName(){//获取值\n\treturn name;\n}\npublic void getAge(){\n\treturn age;\n}\n\n//在 main 方法中赋值并获取值示例：\nCat c=new Cat();\nc.setName(\"小黑\");\nSystem.out.print(c.getName);\n```\n\n## 总结\n\n封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。\n","source":"_posts/Java 学习博客_5 入门——封装.md","raw":"---\ntitle: Java 学习博客_5 入门——封装\ndate: 2022-04-30\ntags: study\ncategory: java\n---\n\n以黑马程序员全套Java教程网课为主。\n\n\n\nJava 的三大特性：封装、继承、多态\n\n# 封装 packaging\n\n之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age=-30）\n\n因此我们要添加一些限制。\n\n## private 修饰符\n\n可以修饰成员变量、成员方法不被其他类使用。\n\n```java\nprivate String name;\nprivate int age;\n```\n\n被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get / set 方法。\n\n## 构造方法\n\n写在类中，作为类的方法。主要用于对象初始化。声明变量时`Cat c=new Cat();`Cat() 就是一种无参构造方法。\n\n每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。**建议无论是否用到构造方法，都写一个无参构造方法。**\n\n```java\npublic Cat(){}//我们自己加的无参构造方法，会覆盖系统默认的\npublic Cat(String name){//写一部分参数的构造方法也可以\n    this.name=name;//通过 this 赋给成员变量\n}\npublic Cat(String name, int age){//写全参数的构造方法也可以\n    this.name=name;\n    this.age=age;\n}\n//main 中构造对象：\nCat c1=new Cat();\nCat c2=new Cat(\"小黑\");\nCat c3=new Cat(\"小白\",2);//这些都可以，与自己写的构造方法的参数相对应。\n```\n\nthis被哪个对象调用，就代表哪个对象。\n\n![AlrRQ.png](https://s1.328888.xyz/2022/04/30/AlrRQ.png)\n\n然后把\"林青霞\" 字符串类型传入堆内存中。\n\n## get / set\n\n无参构造方法后用 setXxx() 方法创建对象。\n\n```java\npublic void setName(String name){//赋值\n\tthis.name=name;\n}\npublic void setAge(int age){\n    if(age>=0&&age<=20)//在 set 中可以添加一些限制，处理\n\tthis.age=age;\n}\n\npublic void getName(){//获取值\n\treturn name;\n}\npublic void getAge(){\n\treturn age;\n}\n\n//在 main 方法中赋值并获取值示例：\nCat c=new Cat();\nc.setName(\"小黑\");\nSystem.out.print(c.getName);\n```\n\n## 总结\n\n封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。\n","slug":"Java 学习博客_5 入门——封装","published":1,"updated":"2022-05-01T16:49:20.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9rz4000cw0v25yzw6ono","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>Java 的三大特性：封装、继承、多态</p>\n<h1 id=\"封装-packaging\"><a href=\"#封装-packaging\" class=\"headerlink\" title=\"封装 packaging\"></a>封装 packaging</h1><p>之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age=-30）</p>\n<p>因此我们要添加一些限制。</p>\n<h2 id=\"private-修饰符\"><a href=\"#private-修饰符\" class=\"headerlink\" title=\"private 修饰符\"></a>private 修饰符</h2><p>可以修饰成员变量、成员方法不被其他类使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> String name;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> age;<br></code></pre></td></tr></table></figure>\n\n<p>被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get / set 方法。</p>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p>写在类中，作为类的方法。主要用于对象初始化。声明变量时<code>Cat c=new Cat();</code>Cat() 就是一种无参构造方法。</p>\n<p>每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。<strong>建议无论是否用到构造方法，都写一个无参构造方法。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Cat</span><span class=\"hljs-params\">()</span>&#123;&#125;<span class=\"hljs-comment\">//我们自己加的无参构造方法，会覆盖系统默认的</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Cat</span><span class=\"hljs-params\">(String name)</span>&#123;<span class=\"hljs-comment\">//写一部分参数的构造方法也可以</span><br>    <span class=\"hljs-built_in\">this</span>.name=name;<span class=\"hljs-comment\">//通过 this 赋给成员变量</span><br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Cat</span><span class=\"hljs-params\">(String name, <span class=\"hljs-type\">int</span> age)</span>&#123;<span class=\"hljs-comment\">//写全参数的构造方法也可以</span><br>    <span class=\"hljs-built_in\">this</span>.name=name;<br>    <span class=\"hljs-built_in\">this</span>.age=age;<br>&#125;<br><span class=\"hljs-comment\">//main 中构造对象：</span><br>Cat c1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>Cat c2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>(<span class=\"hljs-string\">&quot;小黑&quot;</span>);<br>Cat c3=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>(<span class=\"hljs-string\">&quot;小白&quot;</span>,<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//这些都可以，与自己写的构造方法的参数相对应。</span><br></code></pre></td></tr></table></figure>\n\n<p>this被哪个对象调用，就代表哪个对象。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/30/AlrRQ.png\" alt=\"AlrRQ.png\"></p>\n<p>然后把”林青霞” 字符串类型传入堆内存中。</p>\n<h2 id=\"get-set\"><a href=\"#get-set\" class=\"headerlink\" title=\"get / set\"></a>get / set</h2><p>无参构造方法后用 setXxx() 方法创建对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setName</span><span class=\"hljs-params\">(String name)</span>&#123;<span class=\"hljs-comment\">//赋值</span><br>\t<span class=\"hljs-built_in\">this</span>.name=name;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setAge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(age&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;age&lt;=<span class=\"hljs-number\">20</span>)<span class=\"hljs-comment\">//在 set 中可以添加一些限制，处理</span><br>\t<span class=\"hljs-built_in\">this</span>.age=age;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span>&#123;<span class=\"hljs-comment\">//获取值</span><br>\t<span class=\"hljs-keyword\">return</span> name;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">getAge</span><span class=\"hljs-params\">()</span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> age;<br>&#125;<br><br><span class=\"hljs-comment\">//在 main 方法中赋值并获取值示例：</span><br>Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>c.setName(<span class=\"hljs-string\">&quot;小黑&quot;</span>);<br>System.out.print(c.getName);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>Java 的三大特性：封装、继承、多态</p>\n<h1 id=\"封装-packaging\"><a href=\"#封装-packaging\" class=\"headerlink\" title=\"封装 packaging\"></a>封装 packaging</h1><p>之前定义的成员变量都可以直接对值进行修改，存在安全隐患（比如设置 age=-30）</p>\n<p>因此我们要添加一些限制。</p>\n<h2 id=\"private-修饰符\"><a href=\"#private-修饰符\" class=\"headerlink\" title=\"private 修饰符\"></a>private 修饰符</h2><p>可以修饰成员变量、成员方法不被其他类使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> String name;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> age;<br></code></pre></td></tr></table></figure>\n\n<p>被 private 修饰的成员变量有两种赋值（访问）方式：构造方法和 get / set 方法。</p>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p>写在类中，作为类的方法。主要用于对象初始化。声明变量时<code>Cat c=new Cat();</code>Cat() 就是一种无参构造方法。</p>\n<p>每个类定义时系统都会给一个默认无参构造方法。如果自己给了一个无参构造方法，就会覆盖系统默认的。<strong>建议无论是否用到构造方法，都写一个无参构造方法。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Cat</span><span class=\"hljs-params\">()</span>&#123;&#125;<span class=\"hljs-comment\">//我们自己加的无参构造方法，会覆盖系统默认的</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Cat</span><span class=\"hljs-params\">(String name)</span>&#123;<span class=\"hljs-comment\">//写一部分参数的构造方法也可以</span><br>    <span class=\"hljs-built_in\">this</span>.name=name;<span class=\"hljs-comment\">//通过 this 赋给成员变量</span><br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Cat</span><span class=\"hljs-params\">(String name, <span class=\"hljs-type\">int</span> age)</span>&#123;<span class=\"hljs-comment\">//写全参数的构造方法也可以</span><br>    <span class=\"hljs-built_in\">this</span>.name=name;<br>    <span class=\"hljs-built_in\">this</span>.age=age;<br>&#125;<br><span class=\"hljs-comment\">//main 中构造对象：</span><br>Cat c1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>Cat c2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>(<span class=\"hljs-string\">&quot;小黑&quot;</span>);<br>Cat c3=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>(<span class=\"hljs-string\">&quot;小白&quot;</span>,<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//这些都可以，与自己写的构造方法的参数相对应。</span><br></code></pre></td></tr></table></figure>\n\n<p>this被哪个对象调用，就代表哪个对象。</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/30/AlrRQ.png\" alt=\"AlrRQ.png\"></p>\n<p>然后把”林青霞” 字符串类型传入堆内存中。</p>\n<h2 id=\"get-set\"><a href=\"#get-set\" class=\"headerlink\" title=\"get / set\"></a>get / set</h2><p>无参构造方法后用 setXxx() 方法创建对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setName</span><span class=\"hljs-params\">(String name)</span>&#123;<span class=\"hljs-comment\">//赋值</span><br>\t<span class=\"hljs-built_in\">this</span>.name=name;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setAge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age)</span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(age&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;age&lt;=<span class=\"hljs-number\">20</span>)<span class=\"hljs-comment\">//在 set 中可以添加一些限制，处理</span><br>\t<span class=\"hljs-built_in\">this</span>.age=age;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">getName</span><span class=\"hljs-params\">()</span>&#123;<span class=\"hljs-comment\">//获取值</span><br>\t<span class=\"hljs-keyword\">return</span> name;<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">getAge</span><span class=\"hljs-params\">()</span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> age;<br>&#125;<br><br><span class=\"hljs-comment\">//在 main 方法中赋值并获取值示例：</span><br>Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>c.setName(<span class=\"hljs-string\">&quot;小黑&quot;</span>);<br>System.out.print(c.getName);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法实现对隐藏信息的操作和访问，提高了代码安全性（在 setXxx() 方法中可以对数据进行校验）和代码复用性（封装方法可以复用）。</p>\n"},{"title":"Java 学习博客_6 入门——字符串类","date":"2022-04-29T16:00:00.000Z","_content":"\n以黑马程序员全套Java教程网课为主。\n\n# API\n\nJDK 中提供了实现各种功能的封装类，供我们使用。\n\n就像灯的开关，我们只用知道按下开关就能开灯关灯，并不需要弄明白底层原理如何实现。\n\n可以下载一个 java 帮助文档，在其中搜索这些类的具体使用方法。\n\n（*点击索引，打开输入框*\n\n*如果只有左侧目录显示，右侧不显示：*\n\n*右键帮助文档-属性-常规-最下面解除锁定*\n\n*重新打开帮助文档即可。*）\n\n![AWwYX.png](https://s1.328888.xyz/2022/04/30/AWwYX.png)\n\nPakckage：该类所处的包下（除了 java.lang，其他包都要导包）\n\n下拉还有构造方法、成员方法的详解。\n\n## 字符串输入\n\n查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。\n\n```java\nScanner sc=new Scanner(System.in);\nString line=sc.nextLine();\n//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。\n```\n\n# String\n\nString 类型代表字符串。其内容都是被双引号引住的。\n\n在 java.lang 包下，不用导包。\n\n```java\nString s=\"abc\";//直接赋值\nString s1=new String();//空字符串\n\nchar[] c={'a','b','c'};\nString s2=new String(c);//根据字符数组创建字符串\n\nbyte[] b={97,98,99};//a, b, c 对应的 ascii 码\nString s3=new String(b);\n```\n\n字符串一旦创建不能再修改。不过多个字符串的值可以共享`s1=s2;`\n\n字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。\n\n## 字符串比较：== 和成员方法 equals()\n\n用==判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。\n\n**基本类型 == 比较的是数据值是否相同，引用类型 == 比较的是地址是否相同。**\n\n用字符串的成员方法 equals() 判断，是比较字符串内容是否相同。\n\n```java\nchar[] c={'a','b','c'};\nString s1=new String(c);\nString s2=new String(c);\nSystem.out.println(s1==s2);//输出 false，因为 s1 s2 地址不同，只有内容是一样的\nSystem.out.println(s1.equals(s2));//输出 true\n\nString s3=\"abc\";\nString s4=\"abc\";\nSystem.out.println(s3==s4);//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。\nSystem.out.println(s3.equals(s4));//输出 true\n\nSystem.out.println(s1==s3);//输出 false\nSystem.out.println(s1.equals(s3));//输出 true\n```\n\n## 遍历字符串：成员方法 length() 和 charAt()\n\n`s.length()`可以获取字符串长度\n\ns.charAt(i) 可以获取索引为 i 处的字符\n\n```java\nfor(int i=0;i<s.length;i++){\n    System.out.println(s.charAt(i));\n}\n```\n\n## 字符串拼接\n\n字符串可以直接用 + 号拼接。\n\n```java\nString s1=\"Hello \";\nString s2=\"World\";\ns1=s1+s2;//Hello World\n```\n\n在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有\"Hello \"，\"World\"，\"Hello World\"三个字符串，而不是直接在\"Hello \"的位置上拼接\"World\"）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。\n\n## endsWith()\n\n查看字符串是否以指定子串结尾。\n\n```java\nString s1=\"hello world\";\ns1.endsWith(\"world\");\n```\n\n# StringBuilder 类\n\n与 String 类相比，最主要的特点在于内容可变。\n\n在 java.lang 包下，不用导包。\n\n构造方法：\n\n| 构造方法名              | 说明                                              |\n| ----------------------- | ------------------------------------------------- |\n| StringBuilder()         | 无参构造方法                                      |\n| StringBuilder(String s) | 把给定的 String 字符串转换成 StringBuilder 类型的 |\n\n| 成员方法名              | 说明                                          |\n| ----------------------- | --------------------------------------------- |\n| append(String s)        | 在结尾拼接上字符串 s                          |\n| StringBuilder reverse() | 反转字符串                                    |\n| String toString()       | 把 StringBuilder 类型转换为 String 类型并返回 |\n\n用 StringBuilder 完成字符串拼接操作：\n\n1. String 类型转换为 StringBuilder 类型\n2. StringBuilder 类型通过 append() 成员方法拼接字符串\n3. StringBuilder 类型通过 toString() 成员方法转换为 String 类型\n\n```java\nString s=\"Hello \";\nStringBuilder sb=new StringBuilder(s);//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举\nsb.append(\"World\");\nString s1=sb.toString();\n\n//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用\nString s1=new StringBuilder(s).append(\"World\").toString();\n```\n\n用 StringBuilder 完成字符串反转操作：\n\n```java\nString s=\"Hello World\";\nString sr=new StringBuilder(s).reverse().toString();\n```\n\n","source":"_posts/Java 学习博客_6 入门——字符串类.md","raw":"---\ntitle: Java 学习博客_6 入门——字符串类\ndate: 2022-04-30\ntags: study\ncategory: java\n---\n\n以黑马程序员全套Java教程网课为主。\n\n# API\n\nJDK 中提供了实现各种功能的封装类，供我们使用。\n\n就像灯的开关，我们只用知道按下开关就能开灯关灯，并不需要弄明白底层原理如何实现。\n\n可以下载一个 java 帮助文档，在其中搜索这些类的具体使用方法。\n\n（*点击索引，打开输入框*\n\n*如果只有左侧目录显示，右侧不显示：*\n\n*右键帮助文档-属性-常规-最下面解除锁定*\n\n*重新打开帮助文档即可。*）\n\n![AWwYX.png](https://s1.328888.xyz/2022/04/30/AWwYX.png)\n\nPakckage：该类所处的包下（除了 java.lang，其他包都要导包）\n\n下拉还有构造方法、成员方法的详解。\n\n## 字符串输入\n\n查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。\n\n```java\nScanner sc=new Scanner(System.in);\nString line=sc.nextLine();\n//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。\n```\n\n# String\n\nString 类型代表字符串。其内容都是被双引号引住的。\n\n在 java.lang 包下，不用导包。\n\n```java\nString s=\"abc\";//直接赋值\nString s1=new String();//空字符串\n\nchar[] c={'a','b','c'};\nString s2=new String(c);//根据字符数组创建字符串\n\nbyte[] b={97,98,99};//a, b, c 对应的 ascii 码\nString s3=new String(b);\n```\n\n字符串一旦创建不能再修改。不过多个字符串的值可以共享`s1=s2;`\n\n字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。\n\n## 字符串比较：== 和成员方法 equals()\n\n用==判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。\n\n**基本类型 == 比较的是数据值是否相同，引用类型 == 比较的是地址是否相同。**\n\n用字符串的成员方法 equals() 判断，是比较字符串内容是否相同。\n\n```java\nchar[] c={'a','b','c'};\nString s1=new String(c);\nString s2=new String(c);\nSystem.out.println(s1==s2);//输出 false，因为 s1 s2 地址不同，只有内容是一样的\nSystem.out.println(s1.equals(s2));//输出 true\n\nString s3=\"abc\";\nString s4=\"abc\";\nSystem.out.println(s3==s4);//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。\nSystem.out.println(s3.equals(s4));//输出 true\n\nSystem.out.println(s1==s3);//输出 false\nSystem.out.println(s1.equals(s3));//输出 true\n```\n\n## 遍历字符串：成员方法 length() 和 charAt()\n\n`s.length()`可以获取字符串长度\n\ns.charAt(i) 可以获取索引为 i 处的字符\n\n```java\nfor(int i=0;i<s.length;i++){\n    System.out.println(s.charAt(i));\n}\n```\n\n## 字符串拼接\n\n字符串可以直接用 + 号拼接。\n\n```java\nString s1=\"Hello \";\nString s2=\"World\";\ns1=s1+s2;//Hello World\n```\n\n在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有\"Hello \"，\"World\"，\"Hello World\"三个字符串，而不是直接在\"Hello \"的位置上拼接\"World\"）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。\n\n## endsWith()\n\n查看字符串是否以指定子串结尾。\n\n```java\nString s1=\"hello world\";\ns1.endsWith(\"world\");\n```\n\n# StringBuilder 类\n\n与 String 类相比，最主要的特点在于内容可变。\n\n在 java.lang 包下，不用导包。\n\n构造方法：\n\n| 构造方法名              | 说明                                              |\n| ----------------------- | ------------------------------------------------- |\n| StringBuilder()         | 无参构造方法                                      |\n| StringBuilder(String s) | 把给定的 String 字符串转换成 StringBuilder 类型的 |\n\n| 成员方法名              | 说明                                          |\n| ----------------------- | --------------------------------------------- |\n| append(String s)        | 在结尾拼接上字符串 s                          |\n| StringBuilder reverse() | 反转字符串                                    |\n| String toString()       | 把 StringBuilder 类型转换为 String 类型并返回 |\n\n用 StringBuilder 完成字符串拼接操作：\n\n1. String 类型转换为 StringBuilder 类型\n2. StringBuilder 类型通过 append() 成员方法拼接字符串\n3. StringBuilder 类型通过 toString() 成员方法转换为 String 类型\n\n```java\nString s=\"Hello \";\nStringBuilder sb=new StringBuilder(s);//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举\nsb.append(\"World\");\nString s1=sb.toString();\n\n//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用\nString s1=new StringBuilder(s).append(\"World\").toString();\n```\n\n用 StringBuilder 完成字符串反转操作：\n\n```java\nString s=\"Hello World\";\nString sr=new StringBuilder(s).reverse().toString();\n```\n\n","slug":"Java 学习博客_6 入门——字符串类","published":1,"updated":"2022-05-01T16:49:37.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9rz5000ew0v26xidbnoi","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><p>JDK 中提供了实现各种功能的封装类，供我们使用。</p>\n<p>就像灯的开关，我们只用知道按下开关就能开灯关灯，并不需要弄明白底层原理如何实现。</p>\n<p>可以下载一个 java 帮助文档，在其中搜索这些类的具体使用方法。</p>\n<p>（<em>点击索引，打开输入框</em></p>\n<p><em>如果只有左侧目录显示，右侧不显示：</em></p>\n<p><em>右键帮助文档-属性-常规-最下面解除锁定</em></p>\n<p><em>重新打开帮助文档即可。</em>）</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/30/AWwYX.png\" alt=\"AWwYX.png\"></p>\n<p>Pakckage：该类所处的包下（除了 java.lang，其他包都要导包）</p>\n<p>下拉还有构造方法、成员方法的详解。</p>\n<h2 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h2><p>查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Scanner sc=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>String line=sc.nextLine();<br><span class=\"hljs-comment\">//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><p>String 类型代表字符串。其内容都是被双引号引住的。</p>\n<p>在 java.lang 包下，不用导包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s=<span class=\"hljs-string\">&quot;abc&quot;</span>;<span class=\"hljs-comment\">//直接赋值</span><br>String s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>();<span class=\"hljs-comment\">//空字符串</span><br><br><span class=\"hljs-type\">char</span>[] c=&#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;;<br>String s2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(c);<span class=\"hljs-comment\">//根据字符数组创建字符串</span><br><br><span class=\"hljs-type\">byte</span>[] b=&#123;<span class=\"hljs-number\">97</span>,<span class=\"hljs-number\">98</span>,<span class=\"hljs-number\">99</span>&#125;;<span class=\"hljs-comment\">//a, b, c 对应的 ascii 码</span><br>String s3=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(b);<br></code></pre></td></tr></table></figure>\n\n<p>字符串一旦创建不能再修改。不过多个字符串的值可以共享<code>s1=s2;</code></p>\n<p>字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。</p>\n<h2 id=\"字符串比较：-和成员方法-equals\"><a href=\"#字符串比较：-和成员方法-equals\" class=\"headerlink\" title=\"字符串比较：== 和成员方法 equals()\"></a>字符串比较：== 和成员方法 equals()</h2><p>用==判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。</p>\n<p><strong>基本类型 == 比较的是数据值是否相同，引用类型 == 比较的是地址是否相同。</strong></p>\n<p>用字符串的成员方法 equals() 判断，是比较字符串内容是否相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">char</span>[] c=&#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;;<br>String s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(c);<br>String s2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(c);<br>System.out.println(s1==s2);<span class=\"hljs-comment\">//输出 false，因为 s1 s2 地址不同，只有内容是一样的</span><br>System.out.println(s1.equals(s2));<span class=\"hljs-comment\">//输出 true</span><br><br>String s3=<span class=\"hljs-string\">&quot;abc&quot;</span>;<br>String s4=<span class=\"hljs-string\">&quot;abc&quot;</span>;<br>System.out.println(s3==s4);<span class=\"hljs-comment\">//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。</span><br>System.out.println(s3.equals(s4));<span class=\"hljs-comment\">//输出 true</span><br><br>System.out.println(s1==s3);<span class=\"hljs-comment\">//输出 false</span><br>System.out.println(s1.equals(s3));<span class=\"hljs-comment\">//输出 true</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"遍历字符串：成员方法-length-和-charAt\"><a href=\"#遍历字符串：成员方法-length-和-charAt\" class=\"headerlink\" title=\"遍历字符串：成员方法 length() 和 charAt()\"></a>遍历字符串：成员方法 length() 和 charAt()</h2><p><code>s.length()</code>可以获取字符串长度</p>\n<p>s.charAt(i) 可以获取索引为 i 处的字符</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.length;i++)&#123;<br>    System.out.println(s.charAt(i));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><p>字符串可以直接用 + 号拼接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s1=<span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>String s2=<span class=\"hljs-string\">&quot;World&quot;</span>;<br>s1=s1+s2;<span class=\"hljs-comment\">//Hello World</span><br></code></pre></td></tr></table></figure>\n\n<p>在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有”Hello “，”World”，”Hello World”三个字符串，而不是直接在”Hello “的位置上拼接”World”）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。</p>\n<h2 id=\"endsWith\"><a href=\"#endsWith\" class=\"headerlink\" title=\"endsWith()\"></a>endsWith()</h2><p>查看字符串是否以指定子串结尾。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s1=<span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>s1.endsWith(<span class=\"hljs-string\">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"StringBuilder-类\"><a href=\"#StringBuilder-类\" class=\"headerlink\" title=\"StringBuilder 类\"></a>StringBuilder 类</h1><p>与 String 类相比，最主要的特点在于内容可变。</p>\n<p>在 java.lang 包下，不用导包。</p>\n<p>构造方法：</p>\n<table>\n<thead>\n<tr>\n<th>构造方法名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>StringBuilder()</td>\n<td>无参构造方法</td>\n</tr>\n<tr>\n<td>StringBuilder(String s)</td>\n<td>把给定的 String 字符串转换成 StringBuilder 类型的</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>成员方法名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>append(String s)</td>\n<td>在结尾拼接上字符串 s</td>\n</tr>\n<tr>\n<td>StringBuilder reverse()</td>\n<td>反转字符串</td>\n</tr>\n<tr>\n<td>String toString()</td>\n<td>把 StringBuilder 类型转换为 String 类型并返回</td>\n</tr>\n</tbody></table>\n<p>用 StringBuilder 完成字符串拼接操作：</p>\n<ol>\n<li>String 类型转换为 StringBuilder 类型</li>\n<li>StringBuilder 类型通过 append() 成员方法拼接字符串</li>\n<li>StringBuilder 类型通过 toString() 成员方法转换为 String 类型</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s=<span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>StringBuilder sb=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(s);<span class=\"hljs-comment\">//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举</span><br>sb.append(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>String s1=sb.toString();<br><br><span class=\"hljs-comment\">//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用</span><br>String s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(s).append(<span class=\"hljs-string\">&quot;World&quot;</span>).toString();<br></code></pre></td></tr></table></figure>\n\n<p>用 StringBuilder 完成字符串反转操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s=<span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>String sr=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(s).reverse().toString();<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><p>JDK 中提供了实现各种功能的封装类，供我们使用。</p>\n<p>就像灯的开关，我们只用知道按下开关就能开灯关灯，并不需要弄明白底层原理如何实现。</p>\n<p>可以下载一个 java 帮助文档，在其中搜索这些类的具体使用方法。</p>\n<p>（<em>点击索引，打开输入框</em></p>\n<p><em>如果只有左侧目录显示，右侧不显示：</em></p>\n<p><em>右键帮助文档-属性-常规-最下面解除锁定</em></p>\n<p><em>重新打开帮助文档即可。</em>）</p>\n<p><img src=\"https://s1.328888.xyz/2022/04/30/AWwYX.png\" alt=\"AWwYX.png\"></p>\n<p>Pakckage：该类所处的包下（除了 java.lang，其他包都要导包）</p>\n<p>下拉还有构造方法、成员方法的详解。</p>\n<h2 id=\"字符串输入\"><a href=\"#字符串输入\" class=\"headerlink\" title=\"字符串输入\"></a>字符串输入</h2><p>查看 Scanner 的帮助文档可以得知，成员方法 nextLine() 可以获取一整行内容，可用于输入接收字符串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Scanner sc=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>String line=sc.nextLine();<br><span class=\"hljs-comment\">//这里只输入 sc.nextLine() 然后 alt enter 代码自动补全，就会自动生成左边 String line。</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><p>String 类型代表字符串。其内容都是被双引号引住的。</p>\n<p>在 java.lang 包下，不用导包。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s=<span class=\"hljs-string\">&quot;abc&quot;</span>;<span class=\"hljs-comment\">//直接赋值</span><br>String s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>();<span class=\"hljs-comment\">//空字符串</span><br><br><span class=\"hljs-type\">char</span>[] c=&#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;;<br>String s2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(c);<span class=\"hljs-comment\">//根据字符数组创建字符串</span><br><br><span class=\"hljs-type\">byte</span>[] b=&#123;<span class=\"hljs-number\">97</span>,<span class=\"hljs-number\">98</span>,<span class=\"hljs-number\">99</span>&#125;;<span class=\"hljs-comment\">//a, b, c 对应的 ascii 码</span><br>String s3=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(b);<br></code></pre></td></tr></table></figure>\n\n<p>字符串一旦创建不能再修改。不过多个字符串的值可以共享<code>s1=s2;</code></p>\n<p>字符串在效果上像字符数组 char[]，但（JDK9）以后底层实现方法其实是字节数组 byte[]。</p>\n<h2 id=\"字符串比较：-和成员方法-equals\"><a href=\"#字符串比较：-和成员方法-equals\" class=\"headerlink\" title=\"字符串比较：== 和成员方法 equals()\"></a>字符串比较：== 和成员方法 equals()</h2><p>用==判断的比较，是比较 s1 和 s2 的值（即：对应字符串的地址值）是否相同。</p>\n<p><strong>基本类型 == 比较的是数据值是否相同，引用类型 == 比较的是地址是否相同。</strong></p>\n<p>用字符串的成员方法 equals() 判断，是比较字符串内容是否相同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">char</span>[] c=&#123;<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>&#125;;<br>String s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(c);<br>String s2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(c);<br>System.out.println(s1==s2);<span class=\"hljs-comment\">//输出 false，因为 s1 s2 地址不同，只有内容是一样的</span><br>System.out.println(s1.equals(s2));<span class=\"hljs-comment\">//输出 true</span><br><br>String s3=<span class=\"hljs-string\">&quot;abc&quot;</span>;<br>String s4=<span class=\"hljs-string\">&quot;abc&quot;</span>;<br>System.out.println(s3==s4);<span class=\"hljs-comment\">//输出 true，因为对于相同内容的字符串，JVM 会建立一个字符串对象（在堆内存的字符串池中）供它俩参考。</span><br>System.out.println(s3.equals(s4));<span class=\"hljs-comment\">//输出 true</span><br><br>System.out.println(s1==s3);<span class=\"hljs-comment\">//输出 false</span><br>System.out.println(s1.equals(s3));<span class=\"hljs-comment\">//输出 true</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"遍历字符串：成员方法-length-和-charAt\"><a href=\"#遍历字符串：成员方法-length-和-charAt\" class=\"headerlink\" title=\"遍历字符串：成员方法 length() 和 charAt()\"></a>遍历字符串：成员方法 length() 和 charAt()</h2><p><code>s.length()</code>可以获取字符串长度</p>\n<p>s.charAt(i) 可以获取索引为 i 处的字符</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;s.length;i++)&#123;<br>    System.out.println(s.charAt(i));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h2><p>字符串可以直接用 + 号拼接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s1=<span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>String s2=<span class=\"hljs-string\">&quot;World&quot;</span>;<br>s1=s1+s2;<span class=\"hljs-comment\">//Hello World</span><br></code></pre></td></tr></table></figure>\n\n<p>在内存中，字符串发生拼接后会在堆内存中新建一个字符串（有”Hello “，”World”，”Hello World”三个字符串，而不是直接在”Hello “的位置上拼接”World”）。这样操作还是比较费时费空间的。之后介绍的另一个类——StringBuilder 可以更有效地解决这个问题。</p>\n<h2 id=\"endsWith\"><a href=\"#endsWith\" class=\"headerlink\" title=\"endsWith()\"></a>endsWith()</h2><p>查看字符串是否以指定子串结尾。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s1=<span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>s1.endsWith(<span class=\"hljs-string\">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"StringBuilder-类\"><a href=\"#StringBuilder-类\" class=\"headerlink\" title=\"StringBuilder 类\"></a>StringBuilder 类</h1><p>与 String 类相比，最主要的特点在于内容可变。</p>\n<p>在 java.lang 包下，不用导包。</p>\n<p>构造方法：</p>\n<table>\n<thead>\n<tr>\n<th>构造方法名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>StringBuilder()</td>\n<td>无参构造方法</td>\n</tr>\n<tr>\n<td>StringBuilder(String s)</td>\n<td>把给定的 String 字符串转换成 StringBuilder 类型的</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>成员方法名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>append(String s)</td>\n<td>在结尾拼接上字符串 s</td>\n</tr>\n<tr>\n<td>StringBuilder reverse()</td>\n<td>反转字符串</td>\n</tr>\n<tr>\n<td>String toString()</td>\n<td>把 StringBuilder 类型转换为 String 类型并返回</td>\n</tr>\n</tbody></table>\n<p>用 StringBuilder 完成字符串拼接操作：</p>\n<ol>\n<li>String 类型转换为 StringBuilder 类型</li>\n<li>StringBuilder 类型通过 append() 成员方法拼接字符串</li>\n<li>StringBuilder 类型通过 toString() 成员方法转换为 String 类型</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s=<span class=\"hljs-string\">&quot;Hello &quot;</span>;<br>StringBuilder sb=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(s);<span class=\"hljs-comment\">//或者先无参构造，再在结尾拼接 append(s)，但有点多此一举</span><br>sb.append(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>String s1=sb.toString();<br><br><span class=\"hljs-comment\">//骚操作：匿名对象，使用完立刻被垃圾回收器回收，建议少用</span><br>String s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(s).append(<span class=\"hljs-string\">&quot;World&quot;</span>).toString();<br></code></pre></td></tr></table></figure>\n\n<p>用 StringBuilder 完成字符串反转操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">String s=<span class=\"hljs-string\">&quot;Hello World&quot;</span>;<br>String sr=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StringBuilder</span>(s).reverse().toString();<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Java 学习博客_8 入门——继承","date":"2022-04-30T16:00:00.000Z","_content":"\n以黑马程序员全套Java教程网课为主。\n\n\n\n有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。\n\n```java\npublic class Animal{//父类，基类，超类\n    String name;\n\tint age;\n\tboolean tail;\n\tString color;\n}\n\npublic class Cat extends Animal{//子类，派生类\n    public void meow(){\n        System.out.println(\"Meow!\");\n    }\n}\n\npublic class Dog extends Animal{\n    public void bark(){\n        System.out.println(\"Bark!\");\n    }\n}\n```\n\n提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。\n\n当子类属于父类的一种时，可以使用继承。\n\n## 变量访问特点\n\n范围越小，权限越高。\n\n访问优先级：子类中局部变量>子类中成员变量>父类中成员变量>找不到就报错\n\n如果想访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）\n\n![AmPt7.png](https://s1.328888.xyz/2022/05/01/AmPt7.png)\n\n## 构造方法的访问特点\n\n即使访问子类的构造方法，也会优先访问父类的无参构造方法，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。\n\n而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。\n\n因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）\n\n解决方法：1. 父类中补上无参构造方法\n\n2. 在子类构造方法中手动访问父类的带参构造方法来代替\n\n```java\npublic Fu(int age)\n{\n    this.age=age;\n}\n\npublic Zi()\n{\n\tsuper(20);\n}\npublic Zi(int age)\n{\n    super(age);//子类的带参构造方法就这样传递给父类即可\n}\n//不支持一个子类继承多个父类，但是允许多层基层（爷->父->子）\n```\n\n## 成员方法的访问特点\n\n先在子类中寻找，找不到再去父类中寻找。\n\n## 权限修饰符\n\npublic > protected > 默认 > private\n\n![Awiam.png](https://s1.328888.xyz/2022/05/01/Awiam.png)\n\n## 状态修饰符\n\n有 final 和 static。\n\n### final\n\n成员变量和成员方法被 final 修饰后，不可以被重新赋值 / 重写。\n\n类被 final 修饰后，也不可以作为父类。\n\n*引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容不可以改变）*\n\n### static\n\n被 static 修饰的成员变量在所有对象里值都是一样的。\n\n```java\npublic static String university;//在学生类中的静态成员变量\n\nStudent.unievrsity=\"北大\";//统一赋值\nStrudent s1=new Student();//university 变量的值是 \"北大\"\nStrudent s2=new Student();//university 变量的值是 \"北大\"\n```\n\n**静态成员方法只能访问静态成员变量 / 方法！**\n\n## 包 Package\n\n文件夹，用于存放编译后生成的 class 文件，方便管理。\n\n在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。\n\n```java\npackage com.ithema;\n\n//命令行根据路径建包\njavac -d . HelloWorld.java\n\n//编译\njavac HelloWorld.java\n\n//运行\njava com.ithema.HelloWorld\n```\n\n## 导包 import\n\n如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用\n\n`import B文件夹.要调用的类名;`\n\n## 方法重写\n\n子类中重新定义了父类中的方法。\n\n子类如果想访问父类中的方法，可以通过 super 来指定。\n\n```java\n@Override//注解，可以检查方法重写的正确性\npublic void function()\n{\n    System.out.println(\"子类中重写方法\");\n}\n```\n\n1. 父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。\n2. 子类的重写方法权限必须高于父类方法。（public > protected > 默认 > private）\n","source":"_posts/Java 学习博客_8 入门——继承.md","raw":"---\ntitle: Java 学习博客_8 入门——继承\ndate: 2022-05-01\ntags: study\ncategory: java\n---\n\n以黑马程序员全套Java教程网课为主。\n\n\n\n有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。\n\n```java\npublic class Animal{//父类，基类，超类\n    String name;\n\tint age;\n\tboolean tail;\n\tString color;\n}\n\npublic class Cat extends Animal{//子类，派生类\n    public void meow(){\n        System.out.println(\"Meow!\");\n    }\n}\n\npublic class Dog extends Animal{\n    public void bark(){\n        System.out.println(\"Bark!\");\n    }\n}\n```\n\n提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。\n\n当子类属于父类的一种时，可以使用继承。\n\n## 变量访问特点\n\n范围越小，权限越高。\n\n访问优先级：子类中局部变量>子类中成员变量>父类中成员变量>找不到就报错\n\n如果想访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）\n\n![AmPt7.png](https://s1.328888.xyz/2022/05/01/AmPt7.png)\n\n## 构造方法的访问特点\n\n即使访问子类的构造方法，也会优先访问父类的无参构造方法，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。\n\n而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。\n\n因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）\n\n解决方法：1. 父类中补上无参构造方法\n\n2. 在子类构造方法中手动访问父类的带参构造方法来代替\n\n```java\npublic Fu(int age)\n{\n    this.age=age;\n}\n\npublic Zi()\n{\n\tsuper(20);\n}\npublic Zi(int age)\n{\n    super(age);//子类的带参构造方法就这样传递给父类即可\n}\n//不支持一个子类继承多个父类，但是允许多层基层（爷->父->子）\n```\n\n## 成员方法的访问特点\n\n先在子类中寻找，找不到再去父类中寻找。\n\n## 权限修饰符\n\npublic > protected > 默认 > private\n\n![Awiam.png](https://s1.328888.xyz/2022/05/01/Awiam.png)\n\n## 状态修饰符\n\n有 final 和 static。\n\n### final\n\n成员变量和成员方法被 final 修饰后，不可以被重新赋值 / 重写。\n\n类被 final 修饰后，也不可以作为父类。\n\n*引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容不可以改变）*\n\n### static\n\n被 static 修饰的成员变量在所有对象里值都是一样的。\n\n```java\npublic static String university;//在学生类中的静态成员变量\n\nStudent.unievrsity=\"北大\";//统一赋值\nStrudent s1=new Student();//university 变量的值是 \"北大\"\nStrudent s2=new Student();//university 变量的值是 \"北大\"\n```\n\n**静态成员方法只能访问静态成员变量 / 方法！**\n\n## 包 Package\n\n文件夹，用于存放编译后生成的 class 文件，方便管理。\n\n在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。\n\n```java\npackage com.ithema;\n\n//命令行根据路径建包\njavac -d . HelloWorld.java\n\n//编译\njavac HelloWorld.java\n\n//运行\njava com.ithema.HelloWorld\n```\n\n## 导包 import\n\n如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用\n\n`import B文件夹.要调用的类名;`\n\n## 方法重写\n\n子类中重新定义了父类中的方法。\n\n子类如果想访问父类中的方法，可以通过 super 来指定。\n\n```java\n@Override//注解，可以检查方法重写的正确性\npublic void function()\n{\n    System.out.println(\"子类中重写方法\");\n}\n```\n\n1. 父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。\n2. 子类的重写方法权限必须高于父类方法。（public > protected > 默认 > private）\n","slug":"Java 学习博客_8 入门——继承","published":1,"updated":"2022-05-01T16:50:07.142Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9rz6000hw0v2bdvzeaxp","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span>&#123;<span class=\"hljs-comment\">//父类，基类，超类</span><br>    String name;<br>\t<span class=\"hljs-type\">int</span> age;<br>\t<span class=\"hljs-type\">boolean</span> tail;<br>\tString color;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>&#123;<span class=\"hljs-comment\">//子类，派生类</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">meow</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Meow!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bark</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Bark!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。</p>\n<p>当子类属于父类的一种时，可以使用继承。</p>\n<h2 id=\"变量访问特点\"><a href=\"#变量访问特点\" class=\"headerlink\" title=\"变量访问特点\"></a>变量访问特点</h2><p>范围越小，权限越高。</p>\n<p>访问优先级：子类中局部变量&gt;子类中成员变量&gt;父类中成员变量&gt;找不到就报错</p>\n<p>如果想访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）</p>\n<p><img src=\"https://s1.328888.xyz/2022/05/01/AmPt7.png\" alt=\"AmPt7.png\"></p>\n<h2 id=\"构造方法的访问特点\"><a href=\"#构造方法的访问特点\" class=\"headerlink\" title=\"构造方法的访问特点\"></a>构造方法的访问特点</h2><p>即使访问子类的构造方法，也会优先访问父类的无参构造方法，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。</p>\n<p>而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。</p>\n<p>因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）</p>\n<p>解决方法：1. 父类中补上无参构造方法</p>\n<ol start=\"2\">\n<li>在子类构造方法中手动访问父类的带参构造方法来代替</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Fu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age)</span><br>&#123;<br>    <span class=\"hljs-built_in\">this</span>.age=age;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Zi</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-built_in\">super</span>(<span class=\"hljs-number\">20</span>);<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Zi</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age)</span><br>&#123;<br>    <span class=\"hljs-built_in\">super</span>(age);<span class=\"hljs-comment\">//子类的带参构造方法就这样传递给父类即可</span><br>&#125;<br><span class=\"hljs-comment\">//不支持一个子类继承多个父类，但是允许多层基层（爷-&gt;父-&gt;子）</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"成员方法的访问特点\"><a href=\"#成员方法的访问特点\" class=\"headerlink\" title=\"成员方法的访问特点\"></a>成员方法的访问特点</h2><p>先在子类中寻找，找不到再去父类中寻找。</p>\n<h2 id=\"权限修饰符\"><a href=\"#权限修饰符\" class=\"headerlink\" title=\"权限修饰符\"></a>权限修饰符</h2><p>public &gt; protected &gt; 默认 &gt; private</p>\n<p><img src=\"https://s1.328888.xyz/2022/05/01/Awiam.png\" alt=\"Awiam.png\"></p>\n<h2 id=\"状态修饰符\"><a href=\"#状态修饰符\" class=\"headerlink\" title=\"状态修饰符\"></a>状态修饰符</h2><p>有 final 和 static。</p>\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>成员变量和成员方法被 final 修饰后，不可以被重新赋值 / 重写。</p>\n<p>类被 final 修饰后，也不可以作为父类。</p>\n<p><em>引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容不可以改变）</em></p>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><p>被 static 修饰的成员变量在所有对象里值都是一样的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String university;<span class=\"hljs-comment\">//在学生类中的静态成员变量</span><br><br>Student.unievrsity=<span class=\"hljs-string\">&quot;北大&quot;</span>;<span class=\"hljs-comment\">//统一赋值</span><br>Strudent s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>();<span class=\"hljs-comment\">//university 变量的值是 &quot;北大&quot;</span><br>Strudent s2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>();<span class=\"hljs-comment\">//university 变量的值是 &quot;北大&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>静态成员方法只能访问静态成员变量 / 方法！</strong></p>\n<h2 id=\"包-Package\"><a href=\"#包-Package\" class=\"headerlink\" title=\"包 Package\"></a>包 Package</h2><p>文件夹，用于存放编译后生成的 class 文件，方便管理。</p>\n<p>在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.ithema;<br><br><span class=\"hljs-comment\">//命令行根据路径建包</span><br>javac -d . HelloWorld.java<br><br><span class=\"hljs-comment\">//编译</span><br>javac HelloWorld.java<br><br><span class=\"hljs-comment\">//运行</span><br>java com.ithema.HelloWorld<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"导包-import\"><a href=\"#导包-import\" class=\"headerlink\" title=\"导包 import\"></a>导包 import</h2><p>如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用</p>\n<p><code>import B文件夹.要调用的类名;</code></p>\n<h2 id=\"方法重写\"><a href=\"#方法重写\" class=\"headerlink\" title=\"方法重写\"></a>方法重写</h2><p>子类中重新定义了父类中的方法。</p>\n<p>子类如果想访问父类中的方法，可以通过 super 来指定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><span class=\"hljs-comment\">//注解，可以检查方法重写的正确性</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">function</span><span class=\"hljs-params\">()</span><br>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;子类中重写方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。</li>\n<li>子类的重写方法权限必须高于父类方法。（public &gt; protected &gt; 默认 &gt; private）</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>有一些类有许多相同属性和方法（如猫和狗，有动物的共同特征）重复写两遍相对麻烦一些。可以把这些类的共同部分提取出来作为父类，这些类继承父类中的共有部分后再添加自己特有的内容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Animal</span>&#123;<span class=\"hljs-comment\">//父类，基类，超类</span><br>    String name;<br>\t<span class=\"hljs-type\">int</span> age;<br>\t<span class=\"hljs-type\">boolean</span> tail;<br>\tString color;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cat</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>&#123;<span class=\"hljs-comment\">//子类，派生类</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">meow</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Meow!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Animal</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bark</span><span class=\"hljs-params\">()</span>&#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;Bark!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>提高了代码的复用性，但是同时也提高了耦合性，如果父类修改子类也要跟着修改。</p>\n<p>当子类属于父类的一种时，可以使用继承。</p>\n<h2 id=\"变量访问特点\"><a href=\"#变量访问特点\" class=\"headerlink\" title=\"变量访问特点\"></a>变量访问特点</h2><p>范围越小，权限越高。</p>\n<p>访问优先级：子类中局部变量&gt;子类中成员变量&gt;父类中成员变量&gt;找不到就报错</p>\n<p>如果想访问父类中的元素：super 关键字（使用方法类似 this，只是 this 是访问本类中的成员， super 是访问父类中的成员）</p>\n<p><img src=\"https://s1.328888.xyz/2022/05/01/AmPt7.png\" alt=\"AmPt7.png\"></p>\n<h2 id=\"构造方法的访问特点\"><a href=\"#构造方法的访问特点\" class=\"headerlink\" title=\"构造方法的访问特点\"></a>构造方法的访问特点</h2><p>即使访问子类的构造方法，也会优先访问父类的无参构造方法，再访问子类的构造方法。因为毕竟子类由父类而来，需要先构造父类再构造子类。</p>\n<p>而在之前介绍过，如果在类中只定义了带参构造方法，就会覆盖系统默认给的无参构造方法，这时类中就没有无参构造方法了。这时再尝试使用类中的无参构造方法，就会报错。</p>\n<p>因此，如果在父类中只定义了带参构造方法，子类使用构造方法就会报错（因为先尝试使用父类无参构造方法却发现没有）</p>\n<p>解决方法：1. 父类中补上无参构造方法</p>\n<ol start=\"2\">\n<li>在子类构造方法中手动访问父类的带参构造方法来代替</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Fu</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age)</span><br>&#123;<br>    <span class=\"hljs-built_in\">this</span>.age=age;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Zi</span><span class=\"hljs-params\">()</span><br>&#123;<br>\t<span class=\"hljs-built_in\">super</span>(<span class=\"hljs-number\">20</span>);<br>&#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Zi</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> age)</span><br>&#123;<br>    <span class=\"hljs-built_in\">super</span>(age);<span class=\"hljs-comment\">//子类的带参构造方法就这样传递给父类即可</span><br>&#125;<br><span class=\"hljs-comment\">//不支持一个子类继承多个父类，但是允许多层基层（爷-&gt;父-&gt;子）</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"成员方法的访问特点\"><a href=\"#成员方法的访问特点\" class=\"headerlink\" title=\"成员方法的访问特点\"></a>成员方法的访问特点</h2><p>先在子类中寻找，找不到再去父类中寻找。</p>\n<h2 id=\"权限修饰符\"><a href=\"#权限修饰符\" class=\"headerlink\" title=\"权限修饰符\"></a>权限修饰符</h2><p>public &gt; protected &gt; 默认 &gt; private</p>\n<p><img src=\"https://s1.328888.xyz/2022/05/01/Awiam.png\" alt=\"Awiam.png\"></p>\n<h2 id=\"状态修饰符\"><a href=\"#状态修饰符\" class=\"headerlink\" title=\"状态修饰符\"></a>状态修饰符</h2><p>有 final 和 static。</p>\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>成员变量和成员方法被 final 修饰后，不可以被重新赋值 / 重写。</p>\n<p>类被 final 修饰后，也不可以作为父类。</p>\n<p><em>引用类型被 final 修饰后，不可以被重新赋值，指的是地址不能改变，指向的内容还是可以变的。（除了字符串类型，字符串类型内容不可以改变）</em></p>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h3><p>被 static 修饰的成员变量在所有对象里值都是一样的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String university;<span class=\"hljs-comment\">//在学生类中的静态成员变量</span><br><br>Student.unievrsity=<span class=\"hljs-string\">&quot;北大&quot;</span>;<span class=\"hljs-comment\">//统一赋值</span><br>Strudent s1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>();<span class=\"hljs-comment\">//university 变量的值是 &quot;北大&quot;</span><br>Strudent s2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Student</span>();<span class=\"hljs-comment\">//university 变量的值是 &quot;北大&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>静态成员方法只能访问静态成员变量 / 方法！</strong></p>\n<h2 id=\"包-Package\"><a href=\"#包-Package\" class=\"headerlink\" title=\"包 Package\"></a>包 Package</h2><p>文件夹，用于存放编译后生成的 class 文件，方便管理。</p>\n<p>在 IDEA 中新建的 java 文件会自动生成包路径。如果要在 cmd 窗口中运行带有包路径的文件，编译照常，执行需要注明 class 文件的路径。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">package</span> com.ithema;<br><br><span class=\"hljs-comment\">//命令行根据路径建包</span><br>javac -d . HelloWorld.java<br><br><span class=\"hljs-comment\">//编译</span><br>javac HelloWorld.java<br><br><span class=\"hljs-comment\">//运行</span><br>java com.ithema.HelloWorld<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"导包-import\"><a href=\"#导包-import\" class=\"headerlink\" title=\"导包 import\"></a>导包 import</h2><p>如果测试类在 src 文件夹的A文件夹下，要调用的类在 src 文件夹的B文件夹下，可以通过导包的方式来调用</p>\n<p><code>import B文件夹.要调用的类名;</code></p>\n<h2 id=\"方法重写\"><a href=\"#方法重写\" class=\"headerlink\" title=\"方法重写\"></a>方法重写</h2><p>子类中重新定义了父类中的方法。</p>\n<p>子类如果想访问父类中的方法，可以通过 super 来指定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><span class=\"hljs-comment\">//注解，可以检查方法重写的正确性</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">function</span><span class=\"hljs-params\">()</span><br>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;子类中重写方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>父类的方法如果是 private 的，子类中就访问不到，也构不成方法重写一说了。</li>\n<li>子类的重写方法权限必须高于父类方法。（public &gt; protected &gt; 默认 &gt; private）</li>\n</ol>\n"},{"title":"Java 学习博客_7 入门——集合类","date":"2022-04-29T16:00:00.000Z","_content":"\n以黑马程序员全套Java教程网课为主。\n\n\n\n集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。\n\nArrayList 就是集合的一种。\n\n# ArrayList\\<E\\>\n\n在 java.util 包下，需要导包。\n\n\\<E\\> 表示泛型，随便加一种数据类型。\n\n```java\nArrayList<String> array=new ArrayList<String>();\n```\n\n| 方法                        | 说明                                   |\n| --------------------------- | -------------------------------------- |\n| ArrayList\\<E\\>()            | 无参构造方法                           |\n| boolean add(E e)            | 结尾添加一个元素，成功返回true         |\n| void add(index i, E e)      | 在指定索引处添加一个元素（不能越界！） |\n| boolean remove(Object o)    | 删除指定对象，成功返回 true            |\n| E remove(int index)         | 删除指定索引处的值，返回该值           |\n| E set(int index, E element) | 修改指定索引处值，返回修改后的值       |\n| E get(int index)            | 返回指定索引处元素                     |\n| int size()                  | 返回集合元素个数                       |\n\n```java\narray.add(1);\narray.add(3);\narray.add(4);\narray.add(1,2);\nSystem.out.println(array);//输出 array：1，2，3，4\n```\n\n","source":"_posts/Java 学习博客_7 入门——集合类.md","raw":"---\ntitle: Java 学习博客_7 入门——集合类\ndate: 2022-04-30\ntags: study\ncategory: java\n---\n\n以黑马程序员全套Java教程网课为主。\n\n\n\n集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。\n\nArrayList 就是集合的一种。\n\n# ArrayList\\<E\\>\n\n在 java.util 包下，需要导包。\n\n\\<E\\> 表示泛型，随便加一种数据类型。\n\n```java\nArrayList<String> array=new ArrayList<String>();\n```\n\n| 方法                        | 说明                                   |\n| --------------------------- | -------------------------------------- |\n| ArrayList\\<E\\>()            | 无参构造方法                           |\n| boolean add(E e)            | 结尾添加一个元素，成功返回true         |\n| void add(index i, E e)      | 在指定索引处添加一个元素（不能越界！） |\n| boolean remove(Object o)    | 删除指定对象，成功返回 true            |\n| E remove(int index)         | 删除指定索引处的值，返回该值           |\n| E set(int index, E element) | 修改指定索引处值，返回修改后的值       |\n| E get(int index)            | 返回指定索引处元素                     |\n| int size()                  | 返回集合元素个数                       |\n\n```java\narray.add(1);\narray.add(3);\narray.add(4);\narray.add(1,2);\nSystem.out.println(array);//输出 array：1，2，3，4\n```\n\n","slug":"Java 学习博客_7 入门——集合类","published":1,"updated":"2022-05-01T16:49:53.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9rz7000kw0v2fdj92dr2","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。</p>\n<p>ArrayList 就是集合的一种。</p>\n<h1 id=\"ArrayList-lt-E-gt\"><a href=\"#ArrayList-lt-E-gt\" class=\"headerlink\" title=\"ArrayList&lt;E&gt;\"></a>ArrayList&lt;E&gt;</h1><p>在 java.util 包下，需要导包。</p>\n<p>&lt;E&gt; 表示泛型，随便加一种数据类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">ArrayList&lt;String&gt; array=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList&lt;E&gt;()</td>\n<td>无参构造方法</td>\n</tr>\n<tr>\n<td>boolean add(E e)</td>\n<td>结尾添加一个元素，成功返回true</td>\n</tr>\n<tr>\n<td>void add(index i, E e)</td>\n<td>在指定索引处添加一个元素（不能越界！）</td>\n</tr>\n<tr>\n<td>boolean remove(Object o)</td>\n<td>删除指定对象，成功返回 true</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>删除指定索引处的值，返回该值</td>\n</tr>\n<tr>\n<td>E set(int index, E element)</td>\n<td>修改指定索引处值，返回修改后的值</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>返回指定索引处元素</td>\n</tr>\n<tr>\n<td>int size()</td>\n<td>返回集合元素个数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">array.add(<span class=\"hljs-number\">1</span>);<br>array.add(<span class=\"hljs-number\">3</span>);<br>array.add(<span class=\"hljs-number\">4</span>);<br>array.add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br>System.out.println(array);<span class=\"hljs-comment\">//输出 array：1，2，3，4</span><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>集合和数组相比，就像 StringBuilder 之于 String，数组长度固定，集合长度可变。</p>\n<p>ArrayList 就是集合的一种。</p>\n<h1 id=\"ArrayList-lt-E-gt\"><a href=\"#ArrayList-lt-E-gt\" class=\"headerlink\" title=\"ArrayList&lt;E&gt;\"></a>ArrayList&lt;E&gt;</h1><p>在 java.util 包下，需要导包。</p>\n<p>&lt;E&gt; 表示泛型，随便加一种数据类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">ArrayList&lt;String&gt; array=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList&lt;E&gt;()</td>\n<td>无参构造方法</td>\n</tr>\n<tr>\n<td>boolean add(E e)</td>\n<td>结尾添加一个元素，成功返回true</td>\n</tr>\n<tr>\n<td>void add(index i, E e)</td>\n<td>在指定索引处添加一个元素（不能越界！）</td>\n</tr>\n<tr>\n<td>boolean remove(Object o)</td>\n<td>删除指定对象，成功返回 true</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>删除指定索引处的值，返回该值</td>\n</tr>\n<tr>\n<td>E set(int index, E element)</td>\n<td>修改指定索引处值，返回修改后的值</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>返回指定索引处元素</td>\n</tr>\n<tr>\n<td>int size()</td>\n<td>返回集合元素个数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">array.add(<span class=\"hljs-number\">1</span>);<br>array.add(<span class=\"hljs-number\">3</span>);<br>array.add(<span class=\"hljs-number\">4</span>);<br>array.add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<br>System.out.println(array);<span class=\"hljs-comment\">//输出 array：1，2，3，4</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"Java 学习博客_9 入门——多态","date":"2022-04-30T16:00:00.000Z","_content":"\n以黑马程序员全套Java教程网课为主。\n\n\n\n同一个对象在不同时刻表现出的形态也不同。\n\n```java\nCat c=new Cat();\nAnimal a=new Cat();//父类引用指向子类对象\n```\n\na 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。\n\n## 多态中成员的访问特点\n\n访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。*因为成员变量不会被重写*\n\n访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。\n\n例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。\n\n```java\npublic class AnimalOperator(Animal a)\n{\n    a.eat();\n}\n\n//使用\nCat c=new Cat();\nDog d=new Dog();\nPig p=new Pig();\nAnimalOperator(c);//多态\nAnimalOperator(d);//多态\nAnimalOperator(p);//多态\n```\n\n调用的都是子类中重写的方法。\n\n多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类就能访问（无论子类具体是哪一种）。\n\n但是多态无法访问子类中特有的方法。\n\n解决这一弊端的方法就是转型。\n\n```java\nAnimal a=new Cat();//向上转型，a 不能访问 Cat 类中特有的方法\nCat c=(Cat)a;//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。\n```\n\n使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。*ClassCastException*\n","source":"_posts/Java 学习博客_9 入门——多态.md","raw":"---\ntitle: Java 学习博客_9 入门——多态\ndate: 2022-05-01\ntags: study\ncategory: java\n---\n\n以黑马程序员全套Java教程网课为主。\n\n\n\n同一个对象在不同时刻表现出的形态也不同。\n\n```java\nCat c=new Cat();\nAnimal a=new Cat();//父类引用指向子类对象\n```\n\na 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。\n\n## 多态中成员的访问特点\n\n访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。*因为成员变量不会被重写*\n\n访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。\n\n例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。\n\n```java\npublic class AnimalOperator(Animal a)\n{\n    a.eat();\n}\n\n//使用\nCat c=new Cat();\nDog d=new Dog();\nPig p=new Pig();\nAnimalOperator(c);//多态\nAnimalOperator(d);//多态\nAnimalOperator(p);//多态\n```\n\n调用的都是子类中重写的方法。\n\n多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类就能访问（无论子类具体是哪一种）。\n\n但是多态无法访问子类中特有的方法。\n\n解决这一弊端的方法就是转型。\n\n```java\nAnimal a=new Cat();//向上转型，a 不能访问 Cat 类中特有的方法\nCat c=(Cat)a;//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。\n```\n\n使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。*ClassCastException*\n","slug":"Java 学习博客_9 入门——多态","published":1,"updated":"2022-05-01T16:50:20.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2nj9rz8000nw0v23o6d2ycz","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>同一个对象在不同时刻表现出的形态也不同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>Animal a=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<span class=\"hljs-comment\">//父类引用指向子类对象</span><br></code></pre></td></tr></table></figure>\n\n<p>a 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。</p>\n<h2 id=\"多态中成员的访问特点\"><a href=\"#多态中成员的访问特点\" class=\"headerlink\" title=\"多态中成员的访问特点\"></a>多态中成员的访问特点</h2><p>访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。<em>因为成员变量不会被重写</em></p>\n<p>访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。</p>\n<p>例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnimalOperator</span>(Animal a)<br>&#123;<br>    a.eat();<br>&#125;<br><br><span class=\"hljs-comment\">//使用</span><br>Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>Dog d=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br>Pig p=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pig</span>();<br>AnimalOperator(c);<span class=\"hljs-comment\">//多态</span><br>AnimalOperator(d);<span class=\"hljs-comment\">//多态</span><br>AnimalOperator(p);<span class=\"hljs-comment\">//多态</span><br></code></pre></td></tr></table></figure>\n\n<p>调用的都是子类中重写的方法。</p>\n<p>多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类就能访问（无论子类具体是哪一种）。</p>\n<p>但是多态无法访问子类中特有的方法。</p>\n<p>解决这一弊端的方法就是转型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Animal a=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<span class=\"hljs-comment\">//向上转型，a 不能访问 Cat 类中特有的方法</span><br>Cat c=(Cat)a;<span class=\"hljs-comment\">//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。</span><br></code></pre></td></tr></table></figure>\n\n<p>使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。<em>ClassCastException</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>同一个对象在不同时刻表现出的形态也不同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>Animal a=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<span class=\"hljs-comment\">//父类引用指向子类对象</span><br></code></pre></td></tr></table></figure>\n\n<p>a 在内存中是 Cat 的大小，但是编译时被视作 Animal 类型。</p>\n<h2 id=\"多态中成员的访问特点\"><a href=\"#多态中成员的访问特点\" class=\"headerlink\" title=\"多态中成员的访问特点\"></a>多态中成员的访问特点</h2><p>访问成员变量时：优先看等式左侧。如 Animal 和 Cat 中都对 age 赋值了，访问 age 得到的是 Animal 中的 age。<em>因为成员变量不会被重写</em></p>\n<p>访问成员方法时：优先看等式右侧。如 Cat 中重写了 eat 方法，使用 eat 方法就是使用 Cat 中的 eat 方法。</p>\n<p>例：Animal 父类，其中含有 eat() 成员方法；Cat Dog Pig 子类，其中都重写了 eat() 成员方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AnimalOperator</span>(Animal a)<br>&#123;<br>    a.eat();<br>&#125;<br><br><span class=\"hljs-comment\">//使用</span><br>Cat c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<br>Dog d=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br>Pig p=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Pig</span>();<br>AnimalOperator(c);<span class=\"hljs-comment\">//多态</span><br>AnimalOperator(d);<span class=\"hljs-comment\">//多态</span><br>AnimalOperator(p);<span class=\"hljs-comment\">//多态</span><br></code></pre></td></tr></table></figure>\n\n<p>调用的都是子类中重写的方法。</p>\n<p>多态提高了程序的拓展性。对于子类重写父类中的方法，我们只需要一个操作类就能访问（无论子类具体是哪一种）。</p>\n<p>但是多态无法访问子类中特有的方法。</p>\n<p>解决这一弊端的方法就是转型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Animal a=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cat</span>();<span class=\"hljs-comment\">//向上转型，a 不能访问 Cat 类中特有的方法</span><br>Cat c=(Cat)a;<span class=\"hljs-comment\">//向下转型，这样 c 就可以访问 Cat 类中特有的方法了。</span><br></code></pre></td></tr></table></figure>\n\n<p>使用转型的时候注意不能随便向下转型。如本例中 a 在内存中是 Cat 类，不能转换成 Dog 类。<em>ClassCastException</em></p>\n"},{"title":"Mysql ER 和 EER 模型","date":"2022-04-17T16:00:00.000Z","_content":"\n本文思路主要来源于[骆昊jackfrued 老师的网课](https://www.bilibili.com/video/BV1rP4y157jW?spm_id_from=333.999.0.0)\n仅供本人学习参考，未做其他用途！\n\n在此也建议读者通过老师的课程学习。\n\n## 介绍\n\n为什么要有 ER 图和 EER 图的存在？\n\n**真正做项目、设计数据库时，**实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR / json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）**是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。**\n\n### ER 模型\n\nER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。\n\n![百度百科图片](https://img-blog.csdnimg.cn/img_convert/e154bec557baf860b9da8b406aa2b411.png)\n\n相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。\n\n### EER 模型\n\n相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。\n\n#### 泛化层次\n\n包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。\n\n**子类父类**就是类似 Java 的继承，如动物是父类，猫、狗是其子类。**子类父类是一对一的关系！**\n\n**泛化**又叫归纳，就是将几个类的共同属性提取出来作为父类；\n\n**特化**又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。\n\n其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。\n\n**mandatory / optional**：父类中的所有属性都必须包含在每一个子类中 / 不用全部继承，选择部分继承即可（完全性限制）\n\n**disjoint / overlapping**：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）\n\n![img](https://pic1.zhimg.com/80/v2-11dfbdfea0c8705a7e425554b66ef610_1440w.jpg)\n\n图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D / O，表示 disjoint / overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。\n\n#### 汇集层次\n\nAggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。\n\n![img](https://pic4.zhimg.com/80/v2-bcf4d6b1f89bc0b8e12f7f835518537b_1440w.jpg)\n\n如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。\n\n#### 弱实体\n\n一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。\n\n![img](https://pic4.zhimg.com/80/v2-2891cd3fb7b84a5b98e158fa77cd3cdb_1440w.jpg)\n\nWorkbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）\n\n![EER 图示例](https://img-blog.csdnimg.cn/img_convert/b7d05f2614049fce76e68e0121c805a0.png)\n\n在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。\n\n*自动生成的 SQL 语句中，外键下方有两句话`ON DELETE NO ACTION` `ON UPDATE NO ACTION`，意为：当外键参考的主键修改/删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改/删除外键在使用的主键。*\n\n同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。\n\n*Power Designer 建模工具，也支持正 / 反向工程，可以生成 SQL 方言。完整版付费。*","source":"_posts/Mysql ER 和 EER 模型.md","raw":"---\ntitle: Mysql ER 和 EER 模型\ndate: 2022-04-18\ntags: problems\ncategory: database\n---\n\n本文思路主要来源于[骆昊jackfrued 老师的网课](https://www.bilibili.com/video/BV1rP4y157jW?spm_id_from=333.999.0.0)\n仅供本人学习参考，未做其他用途！\n\n在此也建议读者通过老师的课程学习。\n\n## 介绍\n\n为什么要有 ER 图和 EER 图的存在？\n\n**真正做项目、设计数据库时，**实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR / json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）**是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。**\n\n### ER 模型\n\nER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。\n\n![百度百科图片](https://img-blog.csdnimg.cn/img_convert/e154bec557baf860b9da8b406aa2b411.png)\n\n相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。\n\n### EER 模型\n\n相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。\n\n#### 泛化层次\n\n包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。\n\n**子类父类**就是类似 Java 的继承，如动物是父类，猫、狗是其子类。**子类父类是一对一的关系！**\n\n**泛化**又叫归纳，就是将几个类的共同属性提取出来作为父类；\n\n**特化**又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。\n\n其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。\n\n**mandatory / optional**：父类中的所有属性都必须包含在每一个子类中 / 不用全部继承，选择部分继承即可（完全性限制）\n\n**disjoint / overlapping**：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）\n\n![img](https://pic1.zhimg.com/80/v2-11dfbdfea0c8705a7e425554b66ef610_1440w.jpg)\n\n图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D / O，表示 disjoint / overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。\n\n#### 汇集层次\n\nAggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。\n\n![img](https://pic4.zhimg.com/80/v2-bcf4d6b1f89bc0b8e12f7f835518537b_1440w.jpg)\n\n如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。\n\n#### 弱实体\n\n一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。\n\n![img](https://pic4.zhimg.com/80/v2-2891cd3fb7b84a5b98e158fa77cd3cdb_1440w.jpg)\n\nWorkbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）\n\n![EER 图示例](https://img-blog.csdnimg.cn/img_convert/b7d05f2614049fce76e68e0121c805a0.png)\n\n在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。\n\n*自动生成的 SQL 语句中，外键下方有两句话`ON DELETE NO ACTION` `ON UPDATE NO ACTION`，意为：当外键参考的主键修改/删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改/删除外键在使用的主键。*\n\n同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。\n\n*Power Designer 建模工具，也支持正 / 反向工程，可以生成 SQL 方言。完整版付费。*","slug":"Mysql ER 和 EER 模型","published":1,"updated":"2022-05-05T05:46:53.987Z","_id":"cl2nj9rz9000qw0v21yo847vr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文思路主要来源于<a href=\"https://www.bilibili.com/video/BV1rP4y157jW?spm_id_from=333.999.0.0\">骆昊jackfrued 老师的网课</a><br>仅供本人学习参考，未做其他用途！</p>\n<p>在此也建议读者通过老师的课程学习。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>为什么要有 ER 图和 EER 图的存在？</p>\n<p><strong>真正做项目、设计数据库时，</strong>实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR / json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）<strong>是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。</strong></p>\n<h3 id=\"ER-模型\"><a href=\"#ER-模型\" class=\"headerlink\" title=\"ER 模型\"></a>ER 模型</h3><p>ER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e154bec557baf860b9da8b406aa2b411.png\" alt=\"百度百科图片\"></p>\n<p>相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。</p>\n<h3 id=\"EER-模型\"><a href=\"#EER-模型\" class=\"headerlink\" title=\"EER 模型\"></a>EER 模型</h3><p>相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。</p>\n<h4 id=\"泛化层次\"><a href=\"#泛化层次\" class=\"headerlink\" title=\"泛化层次\"></a>泛化层次</h4><p>包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。</p>\n<p><strong>子类父类</strong>就是类似 Java 的继承，如动物是父类，猫、狗是其子类。<strong>子类父类是一对一的关系！</strong></p>\n<p><strong>泛化</strong>又叫归纳，就是将几个类的共同属性提取出来作为父类；</p>\n<p><strong>特化</strong>又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。</p>\n<p>其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。</p>\n<p><strong>mandatory / optional</strong>：父类中的所有属性都必须包含在每一个子类中 / 不用全部继承，选择部分继承即可（完全性限制）</p>\n<p><strong>disjoint / overlapping</strong>：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-11dfbdfea0c8705a7e425554b66ef610_1440w.jpg\" alt=\"img\"></p>\n<p>图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D / O，表示 disjoint / overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。</p>\n<h4 id=\"汇集层次\"><a href=\"#汇集层次\" class=\"headerlink\" title=\"汇集层次\"></a>汇集层次</h4><p>Aggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-bcf4d6b1f89bc0b8e12f7f835518537b_1440w.jpg\" alt=\"img\"></p>\n<p>如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。</p>\n<h4 id=\"弱实体\"><a href=\"#弱实体\" class=\"headerlink\" title=\"弱实体\"></a>弱实体</h4><p>一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-2891cd3fb7b84a5b98e158fa77cd3cdb_1440w.jpg\" alt=\"img\"></p>\n<p>Workbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b7d05f2614049fce76e68e0121c805a0.png\" alt=\"EER 图示例\"></p>\n<p>在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。</p>\n<p><em>自动生成的 SQL 语句中，外键下方有两句话<code>ON DELETE NO ACTION</code> <code>ON UPDATE NO ACTION</code>，意为：当外键参考的主键修改/删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改/删除外键在使用的主键。</em></p>\n<p>同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。</p>\n<p><em>Power Designer 建模工具，也支持正 / 反向工程，可以生成 SQL 方言。完整版付费。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文思路主要来源于<a href=\"https://www.bilibili.com/video/BV1rP4y157jW?spm_id_from=333.999.0.0\">骆昊jackfrued 老师的网课</a><br>仅供本人学习参考，未做其他用途！</p>\n<p>在此也建议读者通过老师的课程学习。</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>为什么要有 ER 图和 EER 图的存在？</p>\n<p><strong>真正做项目、设计数据库时，</strong>实际并没有这么简单，比如还有很多用户看不到、但为了方便 DBA 使用而创建的字段。如 id，一般还会有两条 Date 字段（一表示这条记录被创建的时间，二表示这条记录最后更新的时间），以及预留一个 VARCHAR / json 字段；还有一些其他注意事项（比如 auto-increment 约束其实开发中不常用，更多使用算法比如分布式 ID 生成算法（如 SnowFlake……）当然对课程来说这并不重要）<strong>是不可能一上来就写 SQL 语句的，需要先设计表的结构和表之间的关系。</strong></p>\n<h3 id=\"ER-模型\"><a href=\"#ER-模型\" class=\"headerlink\" title=\"ER 模型\"></a>ER 模型</h3><p>ER 图（Entity Relationship, 实体关系）因此出现。下图是一个 ER 图的示例，其中矩形框代表：表（也就是实体），椭圆框代表：表中的字段（实体的属性），菱形框代表：关系，在连接线上表明了关系的重数。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e154bec557baf860b9da8b406aa2b411.png\" alt=\"百度百科图片\"></p>\n<p>相较于大段的 SQL 建表语句，只要能看懂 ER 图，表的结构、关系一目了然。</p>\n<h3 id=\"EER-模型\"><a href=\"#EER-模型\" class=\"headerlink\" title=\"EER 模型\"></a>EER 模型</h3><p>相较 ER 模型多了泛化层次、汇集层次、弱实体等概念。</p>\n<h4 id=\"泛化层次\"><a href=\"#泛化层次\" class=\"headerlink\" title=\"泛化层次\"></a>泛化层次</h4><p>包括 generalization 和 specialization （泛化和特化）、父类（superclass）和子类（subclass）的概念。</p>\n<p><strong>子类父类</strong>就是类似 Java 的继承，如动物是父类，猫、狗是其子类。<strong>子类父类是一对一的关系！</strong></p>\n<p><strong>泛化</strong>又叫归纳，就是将几个类的共同属性提取出来作为父类；</p>\n<p><strong>特化</strong>又叫演绎，就是在父类的基础上添加各自特殊的属性作为子类。</p>\n<p>其中，子类和超类又有两个关系属性：mandatory 和 optional、disjoint 和 overlapping。</p>\n<p><strong>mandatory / optional</strong>：父类中的所有属性都必须包含在每一个子类中 / 不用全部继承，选择部分继承即可（完全性限制）</p>\n<p><strong>disjoint / overlapping</strong>：继承同一个父类的几个子类之间是否可以有相交的属性（相交性限制）</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-11dfbdfea0c8705a7e425554b66ef610_1440w.jpg\" alt=\"img\"></p>\n<p>图中 运输工具是父类，飞机、火车、汽车是子类。圆圈中写 D / O，表示 disjoint / overlapping。父类和圆圈之间是双实线，表示是 mandatory 完全性继承。</p>\n<h4 id=\"汇集层次\"><a href=\"#汇集层次\" class=\"headerlink\" title=\"汇集层次\"></a>汇集层次</h4><p>Aggregation, 汇集层次不再有父类子类的区别，而是由……组成的区别。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-bcf4d6b1f89bc0b8e12f7f835518537b_1440w.jpg\" alt=\"img\"></p>\n<p>如图，房间、门窗、电脑、投影仪等是教室的组成部分，不是继承关系。</p>\n<h4 id=\"弱实体\"><a href=\"#弱实体\" class=\"headerlink\" title=\"弱实体\"></a>弱实体</h4><p>一种实体只有另一种实体存在的时候才有意义。如父母和子女，少了一方另一方就没有意义了。</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-2891cd3fb7b84a5b98e158fa77cd3cdb_1440w.jpg\" alt=\"img\"></p>\n<p>Workbench 等工具支持画 ER 图，甚至画好后可以自动生成 SQL 语句建表。 Workbench 中的图是 EER 图（扩展的ER 图）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b7d05f2614049fce76e68e0121c805a0.png\" alt=\"EER 图示例\"></p>\n<p>在 EER 图下，点击 DATABASE - FORWARD ENGINEER 正向工程，可以选择要生成的表、字段，生成 SQL 语句建立表。</p>\n<p><em>自动生成的 SQL 语句中，外键下方有两句话<code>ON DELETE NO ACTION</code> <code>ON UPDATE NO ACTION</code>，意为：当外键参考的主键修改/删除时，外键所在的表会受到什么样的影响？——不采取任何行动。建议去掉这两句话。如果去掉，就不能随便修改/删除外键在使用的主键。</em></p>\n<p>同样地，在 SQL 语句页面，点击DATABASE - REVERSE ENGINEER 反向工程，可以根据表的结构生成 EER 图。</p>\n<p><em>Power Designer 建模工具，也支持正 / 反向工程，可以生成 SQL 方言。完整版付费。</em></p>\n"},{"title":"git_2 命令行添加、提交操作","date":"2022-05-01T16:00:00.000Z","_content":"\n# 本地库初始化\n\ngit 的专属命令都是以 git 打头的。\n\n在文件夹中右键 -- git bash here 启动 git 命令行。\n\n| 命令         | 作用                                 |\n| ------------ | ------------------------------------ |\n| ll           | 当前目录下的资源                     |\n| ls -lA       | 带隐藏资源                           |\n| ls -l\\|less  | 分频查看                             |\n| pwd          | 当前位置路径                         |\n| mkdir 目录名 | 新建目录                             |\n| git init     | 初始化当前目录（并创建 .git 文件夹） |\n\n**.git 里存放的是本地库相关的子目录和文件，不要删除和随便修改！！**\n\n# 设置签名\n\n需要设置用户名和 email 地址，唯一用处就是标识开发者身份。\n\n**登录代码托管中心的账号密码（如 github、gitee）和签名的用户名、email 地址没有任何关系。**\n\n项目/仓库级别：只对当前本地库范围内有效。\n\n系统用户级别：对当前系统的登录账号（lenovo）有效。\n\n同时存在的话，项目/仓库级别优先级更高。但是二者必须至少有一个。\n\n```\ngit config user.name Jingqing\t\t\t//项目级别\ngit config user.email Jingqing@163.com\t//项目级别\n\ngit config --global user.name Jingqing\t\t\t//系统用户级别\ngit config --global user.email Jingqing@163.com\t//系统用户级别\n```\n\n项目级别的签名：在项目文件夹下输入 `cat .git/config`，会发现在签名就保存在 .git 文件夹的 config 目录下。\n\n项目级别的签名：`cat ~/.gitconfig`跳转到家目录查看。\n\n*开发时如果不是特殊需求，一般一个系统级别签名即可。*\n\n# 查看状态\n\ngit status 查看工作区、暂存区状态\n\nno commit yet：指本地库里没有内容，因为 commit 之后是会放到本地库里的。\n\nnothing to commit：暂存区没有内容可以提交。\n\nchanges to be committed：暂存区有内容等待提交。\n\n# 提交文件\n\n```\n//vim 新建文件\nvim good.txt\n//然后输入文本文档内容，按 esc 后按两次大写 Z 保存退出。\ngit add good.txt\n//这里提示：warning, 行末的 LF 会被替换为 CRLF，这和安装时 git 的配置有关，影响不大\ngit rm --cached good.txt\n//撤回暂存区的内容\ngit commit good.txt\n//提交文件，然后会提示：请输入提交的信息备注，并且显示一个 vim 编辑器\n//输入注释信息后按 esc 输入 冒号+wq 退出\n\n//但是其实这样才是更常见的用法\ngit commit -m \"信息备注\" good.txt\n```\n\n第一次提交会显示 root commit 根提交","source":"_posts/git_2 命令行添加、提交操作.md","raw":"---\ntitle: git_2 命令行添加、提交操作\ndate: 2022-05-02\ntags: study\ncategory: git\n---\n\n# 本地库初始化\n\ngit 的专属命令都是以 git 打头的。\n\n在文件夹中右键 -- git bash here 启动 git 命令行。\n\n| 命令         | 作用                                 |\n| ------------ | ------------------------------------ |\n| ll           | 当前目录下的资源                     |\n| ls -lA       | 带隐藏资源                           |\n| ls -l\\|less  | 分频查看                             |\n| pwd          | 当前位置路径                         |\n| mkdir 目录名 | 新建目录                             |\n| git init     | 初始化当前目录（并创建 .git 文件夹） |\n\n**.git 里存放的是本地库相关的子目录和文件，不要删除和随便修改！！**\n\n# 设置签名\n\n需要设置用户名和 email 地址，唯一用处就是标识开发者身份。\n\n**登录代码托管中心的账号密码（如 github、gitee）和签名的用户名、email 地址没有任何关系。**\n\n项目/仓库级别：只对当前本地库范围内有效。\n\n系统用户级别：对当前系统的登录账号（lenovo）有效。\n\n同时存在的话，项目/仓库级别优先级更高。但是二者必须至少有一个。\n\n```\ngit config user.name Jingqing\t\t\t//项目级别\ngit config user.email Jingqing@163.com\t//项目级别\n\ngit config --global user.name Jingqing\t\t\t//系统用户级别\ngit config --global user.email Jingqing@163.com\t//系统用户级别\n```\n\n项目级别的签名：在项目文件夹下输入 `cat .git/config`，会发现在签名就保存在 .git 文件夹的 config 目录下。\n\n项目级别的签名：`cat ~/.gitconfig`跳转到家目录查看。\n\n*开发时如果不是特殊需求，一般一个系统级别签名即可。*\n\n# 查看状态\n\ngit status 查看工作区、暂存区状态\n\nno commit yet：指本地库里没有内容，因为 commit 之后是会放到本地库里的。\n\nnothing to commit：暂存区没有内容可以提交。\n\nchanges to be committed：暂存区有内容等待提交。\n\n# 提交文件\n\n```\n//vim 新建文件\nvim good.txt\n//然后输入文本文档内容，按 esc 后按两次大写 Z 保存退出。\ngit add good.txt\n//这里提示：warning, 行末的 LF 会被替换为 CRLF，这和安装时 git 的配置有关，影响不大\ngit rm --cached good.txt\n//撤回暂存区的内容\ngit commit good.txt\n//提交文件，然后会提示：请输入提交的信息备注，并且显示一个 vim 编辑器\n//输入注释信息后按 esc 输入 冒号+wq 退出\n\n//但是其实这样才是更常见的用法\ngit commit -m \"信息备注\" good.txt\n```\n\n第一次提交会显示 root commit 根提交","slug":"git_2 命令行添加、提交操作","published":1,"updated":"2022-05-02T05:16:35.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2oa3oub0000p0v27mn93nyr","content":"<h1 id=\"本地库初始化\"><a href=\"#本地库初始化\" class=\"headerlink\" title=\"本地库初始化\"></a>本地库初始化</h1><p>git 的专属命令都是以 git 打头的。</p>\n<p>在文件夹中右键 – git bash here 启动 git 命令行。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ll</td>\n<td>当前目录下的资源</td>\n</tr>\n<tr>\n<td>ls -lA</td>\n<td>带隐藏资源</td>\n</tr>\n<tr>\n<td>ls -l|less</td>\n<td>分频查看</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>当前位置路径</td>\n</tr>\n<tr>\n<td>mkdir 目录名</td>\n<td>新建目录</td>\n</tr>\n<tr>\n<td>git init</td>\n<td>初始化当前目录（并创建 .git 文件夹）</td>\n</tr>\n</tbody></table>\n<p><strong>.git 里存放的是本地库相关的子目录和文件，不要删除和随便修改！！</strong></p>\n<h1 id=\"设置签名\"><a href=\"#设置签名\" class=\"headerlink\" title=\"设置签名\"></a>设置签名</h1><p>需要设置用户名和 email 地址，唯一用处就是标识开发者身份。</p>\n<p><strong>登录代码托管中心的账号密码（如 github、gitee）和签名的用户名、email 地址没有任何关系。</strong></p>\n<p>项目/仓库级别：只对当前本地库范围内有效。</p>\n<p>系统用户级别：对当前系统的登录账号（lenovo）有效。</p>\n<p>同时存在的话，项目/仓库级别优先级更高。但是二者必须至少有一个。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git config user.name Jingqing\t\t\t//项目级别<br>git config user.email Jingqing@163.com\t//项目级别<br><br>git config --global user.name Jingqing\t\t\t//系统用户级别<br>git config --global user.email Jingqing@163.com\t//系统用户级别<br></code></pre></td></tr></table></figure>\n\n<p>项目级别的签名：在项目文件夹下输入 <code>cat .git/config</code>，会发现在签名就保存在 .git 文件夹的 config 目录下。</p>\n<p>项目级别的签名：<code>cat ~/.gitconfig</code>跳转到家目录查看。</p>\n<p><em>开发时如果不是特殊需求，一般一个系统级别签名即可。</em></p>\n<h1 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h1><p>git status 查看工作区、暂存区状态</p>\n<p>no commit yet：指本地库里没有内容，因为 commit 之后是会放到本地库里的。</p>\n<p>nothing to commit：暂存区没有内容可以提交。</p>\n<p>changes to be committed：暂存区有内容等待提交。</p>\n<h1 id=\"提交文件\"><a href=\"#提交文件\" class=\"headerlink\" title=\"提交文件\"></a>提交文件</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">//vim 新建文件<br>vim good.txt<br>//然后输入文本文档内容，按 esc 后按两次大写 Z 保存退出。<br>git add good.txt<br>//这里提示：warning, 行末的 LF 会被替换为 CRLF，这和安装时 git 的配置有关，影响不大<br>git rm --cached good.txt<br>//撤回暂存区的内容<br>git commit good.txt<br>//提交文件，然后会提示：请输入提交的信息备注，并且显示一个 vim 编辑器<br>//输入注释信息后按 esc 输入 冒号+wq 退出<br><br>//但是其实这样才是更常见的用法<br>git commit -m &quot;信息备注&quot; good.txt<br></code></pre></td></tr></table></figure>\n\n<p>第一次提交会显示 root commit 根提交</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"本地库初始化\"><a href=\"#本地库初始化\" class=\"headerlink\" title=\"本地库初始化\"></a>本地库初始化</h1><p>git 的专属命令都是以 git 打头的。</p>\n<p>在文件夹中右键 – git bash here 启动 git 命令行。</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ll</td>\n<td>当前目录下的资源</td>\n</tr>\n<tr>\n<td>ls -lA</td>\n<td>带隐藏资源</td>\n</tr>\n<tr>\n<td>ls -l|less</td>\n<td>分频查看</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>当前位置路径</td>\n</tr>\n<tr>\n<td>mkdir 目录名</td>\n<td>新建目录</td>\n</tr>\n<tr>\n<td>git init</td>\n<td>初始化当前目录（并创建 .git 文件夹）</td>\n</tr>\n</tbody></table>\n<p><strong>.git 里存放的是本地库相关的子目录和文件，不要删除和随便修改！！</strong></p>\n<h1 id=\"设置签名\"><a href=\"#设置签名\" class=\"headerlink\" title=\"设置签名\"></a>设置签名</h1><p>需要设置用户名和 email 地址，唯一用处就是标识开发者身份。</p>\n<p><strong>登录代码托管中心的账号密码（如 github、gitee）和签名的用户名、email 地址没有任何关系。</strong></p>\n<p>项目/仓库级别：只对当前本地库范围内有效。</p>\n<p>系统用户级别：对当前系统的登录账号（lenovo）有效。</p>\n<p>同时存在的话，项目/仓库级别优先级更高。但是二者必须至少有一个。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git config user.name Jingqing\t\t\t//项目级别<br>git config user.email Jingqing@163.com\t//项目级别<br><br>git config --global user.name Jingqing\t\t\t//系统用户级别<br>git config --global user.email Jingqing@163.com\t//系统用户级别<br></code></pre></td></tr></table></figure>\n\n<p>项目级别的签名：在项目文件夹下输入 <code>cat .git/config</code>，会发现在签名就保存在 .git 文件夹的 config 目录下。</p>\n<p>项目级别的签名：<code>cat ~/.gitconfig</code>跳转到家目录查看。</p>\n<p><em>开发时如果不是特殊需求，一般一个系统级别签名即可。</em></p>\n<h1 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h1><p>git status 查看工作区、暂存区状态</p>\n<p>no commit yet：指本地库里没有内容，因为 commit 之后是会放到本地库里的。</p>\n<p>nothing to commit：暂存区没有内容可以提交。</p>\n<p>changes to be committed：暂存区有内容等待提交。</p>\n<h1 id=\"提交文件\"><a href=\"#提交文件\" class=\"headerlink\" title=\"提交文件\"></a>提交文件</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">//vim 新建文件<br>vim good.txt<br>//然后输入文本文档内容，按 esc 后按两次大写 Z 保存退出。<br>git add good.txt<br>//这里提示：warning, 行末的 LF 会被替换为 CRLF，这和安装时 git 的配置有关，影响不大<br>git rm --cached good.txt<br>//撤回暂存区的内容<br>git commit good.txt<br>//提交文件，然后会提示：请输入提交的信息备注，并且显示一个 vim 编辑器<br>//输入注释信息后按 esc 输入 冒号+wq 退出<br><br>//但是其实这样才是更常见的用法<br>git commit -m &quot;信息备注&quot; good.txt<br></code></pre></td></tr></table></figure>\n\n<p>第一次提交会显示 root commit 根提交</p>\n"},{"title":"SQL 语句——DQL 例题及注意事项","date":"2022-04-24T16:00:00.000Z","_content":"\n学习于：b站 骆昊jackfrued 老师的网课\n\n## 简单排序——查询最大值、次大只\n\n1. 员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。\n\n   做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。\n\n   做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。\n\n   做法③：\n\n   ```mysql\n   select `ename`,`salary` from `tb_employee` t1 where(\n       select count(*) from `tb_employee` t2 where `t2`.`salary`>`t1`.`salary`\n   )=0;-- 结尾改成1，就是工资第二高的人\n   ```\n\n2. 查询除了 boss 外工资最高的人。\n\n   在题1的基础上，用 where 排除掉 boss。\n\n   ```mysql\n   select `ename`,`salary` from `tb_employee` \n   where `salary`=(\n       select max(salary) from `tb_employee` where `position`<>'boss'\n   );\n   ```\n\n3. 查询月薪 top 3的人。\n\n   这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。\n\n   ```mysql\n   select `ename`,`salary` from `tb_employee` t1 where(\n       select count(*) from `tb_employee` t2 where `t2`.`salary`>`t1`.`salary`\n   )<3 order by `salary` desc;\n   ```\n\n4. 查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。\n\n   题目很简单，但是**遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。**要用 ifnull() 或 coalesce() 函数限制一下。\n\n5. 查询所有部门名称及员工人数。\n\n   部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。**重点注意几种连接的不同。**比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。\n\n   ```mysql\n   select dname,total from `tb_department` t1\n   left join (\n       select dname, ifnull(count(*), as total from `tb_department` t2 group by `stu_id`\n   ) on t1.`stu_id`=t2.`stu_id`;\n   ```\n\n6. 查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious\n\n   先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。\n\n   ```mysql\n   select sname,salary from `tb_employee` t1\n   inner join (\n   \tselect avg(salary),dno from `tb_employee` group by dno;\n   )t2 on t1.dno=t2.dno and t1.salary > t2.avg(salary);-- 两个连表条件\n   ```\n\n7. 查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。\n\n   派生表通过薪水值、部门号和员工表、部门表相连接。\n\n8. 查询薪水排名4-6员工的薪水、姓名、**排名**。\n\n   问题1：怎么查出排名？\n\n   问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5\n\n   解决：mysql 8的窗口函数可以解决排名 / top N 问题。\n\n   ①不用窗口函数：\n\n   系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：`set @a=0;`或`select@a:=0;`而且变量也可以通过 as 起别名。\n\n   我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。\n\n   ```mysql\n   set @a=0;\n   select row_num,ename,salary from (\n   \tselect @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0\n       from `tb_employee` order by salary desc\n   ) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次\n   ```\n\n   注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.\n\n   另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。\n\n9. 查询每个部门薪水排名前两名的员工。\n\n   Top N 问题通过题1的做法③解决。\n\n   ```mysql\n   select eno,ename,salary,dno from `tb_employee` t1\n   where (\n   \tselect count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary>t1.salary\n   )<2 order by t1.dno asc, t1.salary desc;\n   ```\n\n## 窗口函数\n\n内容来自：[通俗易懂的学会：SQL 窗口函数 - 知乎](https://zhuanlan.zhihu.com/p/92654574)\n\n应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by\n\n窗口函数不光是函数，有一套完整的语法。\n\n```mysql\n<窗口函数> over (partition by <用于分组的列名>\n                order by <用于排序的列名>)\n```\n\n<窗口函数> 处放聚合函数或专用窗口函数。\n\n窗口函数是以一个列的形式使用的。\n\n### 专用窗口函数\n\nrank、dese rank、row_number\n\n![img](https://img-blog.csdnimg.cn/img_convert/18d3c41260cad2a0ecbae4732018948c.png)\n\n### partition by 和 group by 的区别\n\n![img](https://img-blog.csdnimg.cn/img_convert/6650ec247ab10db38a52d904bfecbd3c.png)\n\n使用：\n\n```mysql\nselect `ename`,`sal`,\nrank() over (order by `sal` desc)as `r1`,\ndense_rank() over (order by `sal` desc)as `r2`,\nrow_number() over (order by `sal` desc)as `r3`\nfrom `tb_emp`;\n```\n\n第八题窗口函数做法：加一个 where r between 4 and 6 的条件。\n\n至于要用哪种专用函数，就要看要求了。\n\n第九题窗口函数做法：因为产生了分组，因此不能直接用 where r <=2。但是窗口函数的分组后的列做筛选，既不能直接用 where 也不能用 having。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。\n\n```mysql\nselect `ename`,`sal`,`dno`\nfrom(\n    select `ename`,`sal`,`dno`,\n    rank() over (partition by `dno` order by `sal` desc)as `r`\n    from `tb_emp`\n) `temp` where `r`<=2;-- 不能在派生表里直接筛选\n```\n\n*窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。*\n","source":"_posts/SQL 语句——DQL 例题及注意事项.md","raw":"---\ntitle: SQL 语句——DQL 例题及注意事项\ndate: 2022-04-25\ntags: study\ncategory: database\n---\n\n学习于：b站 骆昊jackfrued 老师的网课\n\n## 简单排序——查询最大值、次大只\n\n1. 员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。\n\n   做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。\n\n   做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。\n\n   做法③：\n\n   ```mysql\n   select `ename`,`salary` from `tb_employee` t1 where(\n       select count(*) from `tb_employee` t2 where `t2`.`salary`>`t1`.`salary`\n   )=0;-- 结尾改成1，就是工资第二高的人\n   ```\n\n2. 查询除了 boss 外工资最高的人。\n\n   在题1的基础上，用 where 排除掉 boss。\n\n   ```mysql\n   select `ename`,`salary` from `tb_employee` \n   where `salary`=(\n       select max(salary) from `tb_employee` where `position`<>'boss'\n   );\n   ```\n\n3. 查询月薪 top 3的人。\n\n   这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。\n\n   ```mysql\n   select `ename`,`salary` from `tb_employee` t1 where(\n       select count(*) from `tb_employee` t2 where `t2`.`salary`>`t1`.`salary`\n   )<3 order by `salary` desc;\n   ```\n\n4. 查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。\n\n   题目很简单，但是**遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。**要用 ifnull() 或 coalesce() 函数限制一下。\n\n5. 查询所有部门名称及员工人数。\n\n   部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。**重点注意几种连接的不同。**比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。\n\n   ```mysql\n   select dname,total from `tb_department` t1\n   left join (\n       select dname, ifnull(count(*), as total from `tb_department` t2 group by `stu_id`\n   ) on t1.`stu_id`=t2.`stu_id`;\n   ```\n\n6. 查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious\n\n   先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。\n\n   ```mysql\n   select sname,salary from `tb_employee` t1\n   inner join (\n   \tselect avg(salary),dno from `tb_employee` group by dno;\n   )t2 on t1.dno=t2.dno and t1.salary > t2.avg(salary);-- 两个连表条件\n   ```\n\n7. 查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。\n\n   派生表通过薪水值、部门号和员工表、部门表相连接。\n\n8. 查询薪水排名4-6员工的薪水、姓名、**排名**。\n\n   问题1：怎么查出排名？\n\n   问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5\n\n   解决：mysql 8的窗口函数可以解决排名 / top N 问题。\n\n   ①不用窗口函数：\n\n   系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：`set @a=0;`或`select@a:=0;`而且变量也可以通过 as 起别名。\n\n   我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。\n\n   ```mysql\n   set @a=0;\n   select row_num,ename,salary from (\n   \tselect @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0\n       from `tb_employee` order by salary desc\n   ) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次\n   ```\n\n   注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.\n\n   另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。\n\n9. 查询每个部门薪水排名前两名的员工。\n\n   Top N 问题通过题1的做法③解决。\n\n   ```mysql\n   select eno,ename,salary,dno from `tb_employee` t1\n   where (\n   \tselect count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary>t1.salary\n   )<2 order by t1.dno asc, t1.salary desc;\n   ```\n\n## 窗口函数\n\n内容来自：[通俗易懂的学会：SQL 窗口函数 - 知乎](https://zhuanlan.zhihu.com/p/92654574)\n\n应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by\n\n窗口函数不光是函数，有一套完整的语法。\n\n```mysql\n<窗口函数> over (partition by <用于分组的列名>\n                order by <用于排序的列名>)\n```\n\n<窗口函数> 处放聚合函数或专用窗口函数。\n\n窗口函数是以一个列的形式使用的。\n\n### 专用窗口函数\n\nrank、dese rank、row_number\n\n![img](https://img-blog.csdnimg.cn/img_convert/18d3c41260cad2a0ecbae4732018948c.png)\n\n### partition by 和 group by 的区别\n\n![img](https://img-blog.csdnimg.cn/img_convert/6650ec247ab10db38a52d904bfecbd3c.png)\n\n使用：\n\n```mysql\nselect `ename`,`sal`,\nrank() over (order by `sal` desc)as `r1`,\ndense_rank() over (order by `sal` desc)as `r2`,\nrow_number() over (order by `sal` desc)as `r3`\nfrom `tb_emp`;\n```\n\n第八题窗口函数做法：加一个 where r between 4 and 6 的条件。\n\n至于要用哪种专用函数，就要看要求了。\n\n第九题窗口函数做法：因为产生了分组，因此不能直接用 where r <=2。但是窗口函数的分组后的列做筛选，既不能直接用 where 也不能用 having。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。\n\n```mysql\nselect `ename`,`sal`,`dno`\nfrom(\n    select `ename`,`sal`,`dno`,\n    rank() over (partition by `dno` order by `sal` desc)as `r`\n    from `tb_emp`\n) `temp` where `r`<=2;-- 不能在派生表里直接筛选\n```\n\n*窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。*\n","slug":"SQL 语句——DQL 例题及注意事项","published":1,"updated":"2022-05-02T05:23:18.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2oa3oul0002p0v2814m0wft","content":"<p>学习于：b站 骆昊jackfrued 老师的网课</p>\n<h2 id=\"简单排序——查询最大值、次大只\"><a href=\"#简单排序——查询最大值、次大只\" class=\"headerlink\" title=\"简单排序——查询最大值、次大只\"></a>简单排序——查询最大值、次大只</h2><ol>\n<li><p>员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。</p>\n<p>做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。</p>\n<p>做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。</p>\n<p>做法③：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`salary` from `tb_employee` t1 where(<br>    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`<br>)=0;-- 结尾改成1，就是工资第二高的人<br></code></pre></td></tr></table></figure></li>\n<li><p>查询除了 boss 外工资最高的人。</p>\n<p>在题1的基础上，用 where 排除掉 boss。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`salary` from `tb_employee` <br>where `salary`=(<br>    select max(salary) from `tb_employee` where `position`&lt;&gt;&#x27;boss&#x27;<br>);<br></code></pre></td></tr></table></figure></li>\n<li><p>查询月薪 top 3的人。</p>\n<p>这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`salary` from `tb_employee` t1 where(<br>    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`<br>)&lt;3 order by `salary` desc;<br></code></pre></td></tr></table></figure></li>\n<li><p>查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。</p>\n<p>题目很简单，但是<strong>遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。</strong>要用 ifnull() 或 coalesce() 函数限制一下。</p>\n</li>\n<li><p>查询所有部门名称及员工人数。</p>\n<p>部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。<strong>重点注意几种连接的不同。</strong>比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select dname,total from `tb_department` t1<br>left join (<br>    select dname, ifnull(count(*), as total from `tb_department` t2 group by `stu_id`<br>) on t1.`stu_id`=t2.`stu_id`;<br></code></pre></td></tr></table></figure></li>\n<li><p>查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious</p>\n<p>先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select sname,salary from `tb_employee` t1<br>inner join (<br>\tselect avg(salary),dno from `tb_employee` group by dno;<br>)t2 on t1.dno=t2.dno and t1.salary &gt; t2.avg(salary);-- 两个连表条件<br></code></pre></td></tr></table></figure></li>\n<li><p>查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。</p>\n<p>派生表通过薪水值、部门号和员工表、部门表相连接。</p>\n</li>\n<li><p>查询薪水排名4-6员工的薪水、姓名、<strong>排名</strong>。</p>\n<p>问题1：怎么查出排名？</p>\n<p>问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5</p>\n<p>解决：mysql 8的窗口函数可以解决排名 / top N 问题。</p>\n<p>①不用窗口函数：</p>\n<p>系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：<code>set @a=0;</code>或<code>select@a:=0;</code>而且变量也可以通过 as 起别名。</p>\n<p>我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set @a=0;<br>select row_num,ename,salary from (<br>\tselect @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0<br>    from `tb_employee` order by salary desc<br>) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次<br></code></pre></td></tr></table></figure>\n\n<p>注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.</p>\n<p>另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。</p>\n</li>\n<li><p>查询每个部门薪水排名前两名的员工。</p>\n<p>Top N 问题通过题1的做法③解决。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select eno,ename,salary,dno from `tb_employee` t1<br>where (<br>\tselect count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary&gt;t1.salary<br>)&lt;2 order by t1.dno asc, t1.salary desc;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"窗口函数\"><a href=\"#窗口函数\" class=\"headerlink\" title=\"窗口函数\"></a>窗口函数</h2><p>内容来自：<a href=\"https://zhuanlan.zhihu.com/p/92654574\">通俗易懂的学会：SQL 窗口函数 - 知乎</a></p>\n<p>应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by</p>\n<p>窗口函数不光是函数，有一套完整的语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;<br>                order by &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure>\n\n<p>&lt;窗口函数&gt; 处放聚合函数或专用窗口函数。</p>\n<p>窗口函数是以一个列的形式使用的。</p>\n<h3 id=\"专用窗口函数\"><a href=\"#专用窗口函数\" class=\"headerlink\" title=\"专用窗口函数\"></a>专用窗口函数</h3><p>rank、dese rank、row_number</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/18d3c41260cad2a0ecbae4732018948c.png\" alt=\"img\"></p>\n<h3 id=\"partition-by-和-group-by-的区别\"><a href=\"#partition-by-和-group-by-的区别\" class=\"headerlink\" title=\"partition by 和 group by 的区别\"></a>partition by 和 group by 的区别</h3><p><img src=\"https://img-blog.csdnimg.cn/img_convert/6650ec247ab10db38a52d904bfecbd3c.png\" alt=\"img\"></p>\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`sal`,<br>rank() over (order by `sal` desc)as `r1`,<br>dense_rank() over (order by `sal` desc)as `r2`,<br>row_number() over (order by `sal` desc)as `r3`<br>from `tb_emp`;<br></code></pre></td></tr></table></figure>\n\n<p>第八题窗口函数做法：加一个 where r between 4 and 6 的条件。</p>\n<p>至于要用哪种专用函数，就要看要求了。</p>\n<p>第九题窗口函数做法：因为产生了分组，因此不能直接用 where r &lt;=2。但是窗口函数的分组后的列做筛选，既不能直接用 where 也不能用 having。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`sal`,`dno`<br>from(<br>    select `ename`,`sal`,`dno`,<br>    rank() over (partition by `dno` order by `sal` desc)as `r`<br>    from `tb_emp`<br>) `temp` where `r`&lt;=2;-- 不能在派生表里直接筛选<br></code></pre></td></tr></table></figure>\n\n<p><em>窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习于：b站 骆昊jackfrued 老师的网课</p>\n<h2 id=\"简单排序——查询最大值、次大只\"><a href=\"#简单排序——查询最大值、次大只\" class=\"headerlink\" title=\"简单排序——查询最大值、次大只\"></a>简单排序——查询最大值、次大只</h2><ol>\n<li><p>员工表中含有员工号、姓名、薪水、职位、补贴 、所在部门等信息。查询薪水最高的员工姓名和薪水值。</p>\n<p>做法①：最普通的子查询，先查出最大工资值，再筛选出员工表中工资值等于这个数的员工。</p>\n<p>做法②：limit 做法。先按薪水降序排序所有员工，再只 limit 1 取第一条员工信息。这种做法的局限性在 limit 介绍的时候我也有写，就是当最值不只一位的时候，这种方法只能查出1位员工。</p>\n<p>做法③：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`salary` from `tb_employee` t1 where(<br>    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`<br>)=0;-- 结尾改成1，就是工资第二高的人<br></code></pre></td></tr></table></figure></li>\n<li><p>查询除了 boss 外工资最高的人。</p>\n<p>在题1的基础上，用 where 排除掉 boss。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`salary` from `tb_employee` <br>where `salary`=(<br>    select max(salary) from `tb_employee` where `position`&lt;&gt;&#x27;boss&#x27;<br>);<br></code></pre></td></tr></table></figure></li>\n<li><p>查询月薪 top 3的人。</p>\n<p>这时出现了和题1一样的情况。用 limit ，可能会漏掉工资并列的第四人；因此，这里用题1的方法③最合适。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`salary` from `tb_employee` t1 where(<br>    select count(*) from `tb_employee` t2 where `t2`.`salary`&gt;`t1`.`salary`<br>)&lt;3 order by `salary` desc;<br></code></pre></td></tr></table></figure></li>\n<li><p>查询所有员工的姓名和年薪。年薪计算公式：月薪*12+补贴。</p>\n<p>题目很简单，但是<strong>遇到计算一定要注意数据是否 Not Null，如果出现 Null 数据结果也会变成 Null。</strong>要用 ifnull() 或 coalesce() 函数限制一下。</p>\n</li>\n<li><p>查询所有部门名称及员工人数。</p>\n<p>部门名称在部门表中，每个部门的人数则需要根据员工表中部门号统计。显然这里要先查出员工表的员工号和统计员工信息，再把结果表和部门表做连接。<strong>重点注意几种连接的不同。</strong>比如此题，即便有的部门没有员工，也要显示出来，因此应该部门表 left join 派生表。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select dname,total from `tb_department` t1<br>left join (<br>    select dname, ifnull(count(*), as total from `tb_department` t2 group by `stu_id`<br>) on t1.`stu_id`=t2.`stu_id`;<br></code></pre></td></tr></table></figure></li>\n<li><p>查询每个部门比本部门平均薪水高的员工名及薪水。记得说清楚列属于哪个表，不然报错 ambigious</p>\n<p>先按部门分组，查询出平均成绩和员工号表；再通过部门号和员工表连接，并筛选出薪水值大于平均值的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select sname,salary from `tb_employee` t1<br>inner join (<br>\tselect avg(salary),dno from `tb_employee` group by dno;<br>)t2 on t1.dno=t2.dno and t1.salary &gt; t2.avg(salary);-- 两个连表条件<br></code></pre></td></tr></table></figure></li>\n<li><p>查询每个部门中薪水最高的员工的用户姓名、薪水、部门名称。</p>\n<p>派生表通过薪水值、部门号和员工表、部门表相连接。</p>\n</li>\n<li><p>查询薪水排名4-6员工的薪水、姓名、<strong>排名</strong>。</p>\n<p>问题1：怎么查出排名？</p>\n<p>问题2：这题并没有想象中的简单。比如员工薪水前8名是5000,5000,4000,4000,3000,3000,3000,2000，那么其实第三、第四人两个人并列第三，4-6显示的排名值就应该是3，5，5</p>\n<p>解决：mysql 8的窗口函数可以解决排名 / top N 问题。</p>\n<p>①不用窗口函数：</p>\n<p>系统变量一般不写@或写两个@@（可以通过 show variables 查询），自己定义的变量写一个@，赋值的方法：<code>set @a=0;</code>或<code>select@a:=0;</code>而且变量也可以通过 as 起别名。</p>\n<p>我们先定义一个变量，变量从0开始，每次选择＋1，就可以当做序号用了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">set @a=0;<br>select row_num,ename,salary from (<br>\tselect @a=@a+1 as `row_num`,ename,salary,(select @a:=0) -- @a 重新赋值为0<br>    from `tb_employee` order by salary desc<br>) where `row_num` between 4 and 6;-- 子查询中做了几次查询，@a 就加几次<br></code></pre></td></tr></table></figure>\n\n<p>注意不要在括号里用 limit 3 offset 3，因为这样的话子查询就只会进行3次，@a 的值就只会从1到3.</p>\n<p>另外，每次查询时都要重新给@a 赋值为0，不然其值会累加。</p>\n</li>\n<li><p>查询每个部门薪水排名前两名的员工。</p>\n<p>Top N 问题通过题1的做法③解决。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select eno,ename,salary,dno from `tb_employee` t1<br>where (<br>\tselect count(*) from `tb_employee` t2 where t1.`dno`=t2.`dno` and t2.salary&gt;t1.salary<br>)&lt;2 order by t1.dno asc, t1.salary desc;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"窗口函数\"><a href=\"#窗口函数\" class=\"headerlink\" title=\"窗口函数\"></a>窗口函数</h2><p>内容来自：<a href=\"https://zhuanlan.zhihu.com/p/92654574\">通俗易懂的学会：SQL 窗口函数 - 知乎</a></p>\n<p>应用于组内排名和 Top N 类问题。 一般是处理 where 和 group by</p>\n<p>窗口函数不光是函数，有一套完整的语法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;<br>                order by &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure>\n\n<p>&lt;窗口函数&gt; 处放聚合函数或专用窗口函数。</p>\n<p>窗口函数是以一个列的形式使用的。</p>\n<h3 id=\"专用窗口函数\"><a href=\"#专用窗口函数\" class=\"headerlink\" title=\"专用窗口函数\"></a>专用窗口函数</h3><p>rank、dese rank、row_number</p>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/18d3c41260cad2a0ecbae4732018948c.png\" alt=\"img\"></p>\n<h3 id=\"partition-by-和-group-by-的区别\"><a href=\"#partition-by-和-group-by-的区别\" class=\"headerlink\" title=\"partition by 和 group by 的区别\"></a>partition by 和 group by 的区别</h3><p><img src=\"https://img-blog.csdnimg.cn/img_convert/6650ec247ab10db38a52d904bfecbd3c.png\" alt=\"img\"></p>\n<p>使用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`sal`,<br>rank() over (order by `sal` desc)as `r1`,<br>dense_rank() over (order by `sal` desc)as `r2`,<br>row_number() over (order by `sal` desc)as `r3`<br>from `tb_emp`;<br></code></pre></td></tr></table></figure>\n\n<p>第八题窗口函数做法：加一个 where r between 4 and 6 的条件。</p>\n<p>至于要用哪种专用函数，就要看要求了。</p>\n<p>第九题窗口函数做法：因为产生了分组，因此不能直接用 where r &lt;=2。但是窗口函数的分组后的列做筛选，既不能直接用 where 也不能用 having。应该把窗口函数的查询结果作为一个派生表，再用 where 做选择。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select `ename`,`sal`,`dno`<br>from(<br>    select `ename`,`sal`,`dno`,<br>    rank() over (partition by `dno` order by `sal` desc)as `r`<br>    from `tb_emp`<br>) `temp` where `r`&lt;=2;-- 不能在派生表里直接筛选<br></code></pre></td></tr></table></figure>\n\n<p><em>窗口函数性能还是比较差的，业务中不应使用，数据分析师可能会常用一些。</em></p>\n"},{"title":"git_1 版本控制介绍","date":"2022-05-01T16:00:00.000Z","_content":"\n[【尚硅谷】Git与GitHub基础全套完整版教程（快速上手，一套搞定）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1pW411A7a5?p=3&spm_id_from=pageDriver)\n\n# 为什么需要版本控制？\n\n单人开发有的时候，在开发过程中需要回退到之前的版本。好的版本管理可以大大提高开发效率。\n\n多人开发的时候，不同人做修改 / 上传时间不统一，如果两个人同时上传，后者就会把前者的内容覆盖。普通文件服务器不能管理文件内容。\n\n# 版本控制工具特性\n\n**版本控制是一种思想，版本控制工具（如 SVN、git）是对其实现。**\n\n集中式版本控制工具：如 SVN，开发人员都是客户端，而内容存储在服务器上，所有人和服务器交互。缺点在于服务器一挂，历史数据全部丢失，客户端上只能保存当前状态。（单点故障）\n\n分布式版本控制工具：如 git ，开发人员在本地就能进行完整的版本控制。就算一个人的数据丢失了，依靠其他人的也能找回来，能有效避免单点故障。不过还是不建议本地库传数据，还是有一个远程库。\n\ngit其他优点：\n\n- 大部分操作在本地进行，不需要联网\n- 完整性保证（哈希算法，之后介绍）\n- 尽可能添加数据，而不是删除或修改数据\n- 分支操作快捷流畅\n- 与 Linux 命令全面兼容\n\n# 版本控制工具应该具有的功能？\n\n- 协同修改：多个人并行不悖地修改同一份文件。\n- 数据备份：保存历史版本。\n- 版本管理：各个版本之间肯定有重叠的部分，这一部分不要重复保存。对此，SVN 采用增量式管理的方法（每次只保存修改的部分），git 采取的是文件系统快照的方法。\n- 权限控制：不同人的权限不同。git 不仅支持权限控制，还可以对团队外开发者贡献的代码进行审核。\n- 历史记录：查看修改人、时间、内容、日志等，还可以把本地文件恢复到之前的状态。\n- 分支管理：允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。\n\n# Git 结构\n\n![AbdOT.png](https://s1.328888.xyz/2022/05/01/AbdOT.png)\n\n# Git 和代码托管中心\n\n代码托管中心可以帮我们维护远程库\n\n局域网内：Gitlab\n\n外网：Github，Gitee\n\n开发者通过 push 把代码推送到远程库。其他开发者要先 clone 把代码克隆下来，然后加入团队，然后才能把自己做的修改 push 推送到远程库。再通过 pull 把其他人的操作拉取下来。\n\n如果需要项目成员之外的人修改代码：那个人先通过 fork 克隆一个自己的远程库，然后自己对自己的远程库做 clone、push 等操作，修改完成之后向项目开发者发送 pull request 请求，开发者审核同意后 merge 合并代码。","source":"_posts/git_1 版本控制介绍.md","raw":"---\ntitle: git_1 版本控制介绍\ndate: 2022-05-02\ntags: study\ncategory: git\n\n---\n\n[【尚硅谷】Git与GitHub基础全套完整版教程（快速上手，一套搞定）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1pW411A7a5?p=3&spm_id_from=pageDriver)\n\n# 为什么需要版本控制？\n\n单人开发有的时候，在开发过程中需要回退到之前的版本。好的版本管理可以大大提高开发效率。\n\n多人开发的时候，不同人做修改 / 上传时间不统一，如果两个人同时上传，后者就会把前者的内容覆盖。普通文件服务器不能管理文件内容。\n\n# 版本控制工具特性\n\n**版本控制是一种思想，版本控制工具（如 SVN、git）是对其实现。**\n\n集中式版本控制工具：如 SVN，开发人员都是客户端，而内容存储在服务器上，所有人和服务器交互。缺点在于服务器一挂，历史数据全部丢失，客户端上只能保存当前状态。（单点故障）\n\n分布式版本控制工具：如 git ，开发人员在本地就能进行完整的版本控制。就算一个人的数据丢失了，依靠其他人的也能找回来，能有效避免单点故障。不过还是不建议本地库传数据，还是有一个远程库。\n\ngit其他优点：\n\n- 大部分操作在本地进行，不需要联网\n- 完整性保证（哈希算法，之后介绍）\n- 尽可能添加数据，而不是删除或修改数据\n- 分支操作快捷流畅\n- 与 Linux 命令全面兼容\n\n# 版本控制工具应该具有的功能？\n\n- 协同修改：多个人并行不悖地修改同一份文件。\n- 数据备份：保存历史版本。\n- 版本管理：各个版本之间肯定有重叠的部分，这一部分不要重复保存。对此，SVN 采用增量式管理的方法（每次只保存修改的部分），git 采取的是文件系统快照的方法。\n- 权限控制：不同人的权限不同。git 不仅支持权限控制，还可以对团队外开发者贡献的代码进行审核。\n- 历史记录：查看修改人、时间、内容、日志等，还可以把本地文件恢复到之前的状态。\n- 分支管理：允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。\n\n# Git 结构\n\n![AbdOT.png](https://s1.328888.xyz/2022/05/01/AbdOT.png)\n\n# Git 和代码托管中心\n\n代码托管中心可以帮我们维护远程库\n\n局域网内：Gitlab\n\n外网：Github，Gitee\n\n开发者通过 push 把代码推送到远程库。其他开发者要先 clone 把代码克隆下来，然后加入团队，然后才能把自己做的修改 push 推送到远程库。再通过 pull 把其他人的操作拉取下来。\n\n如果需要项目成员之外的人修改代码：那个人先通过 fork 克隆一个自己的远程库，然后自己对自己的远程库做 clone、push 等操作，修改完成之后向项目开发者发送 pull request 请求，开发者审核同意后 merge 合并代码。","slug":"git_1 版本控制介绍","published":1,"updated":"2022-05-02T05:17:13.167Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2oa3oun0004p0v267hl7wju","content":"<p><a href=\"https://www.bilibili.com/video/BV1pW411A7a5?p=3&spm_id_from=pageDriver\">【尚硅谷】Git与GitHub基础全套完整版教程（快速上手，一套搞定）_哔哩哔哩_bilibili</a></p>\n<h1 id=\"为什么需要版本控制？\"><a href=\"#为什么需要版本控制？\" class=\"headerlink\" title=\"为什么需要版本控制？\"></a>为什么需要版本控制？</h1><p>单人开发有的时候，在开发过程中需要回退到之前的版本。好的版本管理可以大大提高开发效率。</p>\n<p>多人开发的时候，不同人做修改 / 上传时间不统一，如果两个人同时上传，后者就会把前者的内容覆盖。普通文件服务器不能管理文件内容。</p>\n<h1 id=\"版本控制工具特性\"><a href=\"#版本控制工具特性\" class=\"headerlink\" title=\"版本控制工具特性\"></a>版本控制工具特性</h1><p><strong>版本控制是一种思想，版本控制工具（如 SVN、git）是对其实现。</strong></p>\n<p>集中式版本控制工具：如 SVN，开发人员都是客户端，而内容存储在服务器上，所有人和服务器交互。缺点在于服务器一挂，历史数据全部丢失，客户端上只能保存当前状态。（单点故障）</p>\n<p>分布式版本控制工具：如 git ，开发人员在本地就能进行完整的版本控制。就算一个人的数据丢失了，依靠其他人的也能找回来，能有效避免单点故障。不过还是不建议本地库传数据，还是有一个远程库。</p>\n<p>git其他优点：</p>\n<ul>\n<li>大部分操作在本地进行，不需要联网</li>\n<li>完整性保证（哈希算法，之后介绍）</li>\n<li>尽可能添加数据，而不是删除或修改数据</li>\n<li>分支操作快捷流畅</li>\n<li>与 Linux 命令全面兼容</li>\n</ul>\n<h1 id=\"版本控制工具应该具有的功能？\"><a href=\"#版本控制工具应该具有的功能？\" class=\"headerlink\" title=\"版本控制工具应该具有的功能？\"></a>版本控制工具应该具有的功能？</h1><ul>\n<li>协同修改：多个人并行不悖地修改同一份文件。</li>\n<li>数据备份：保存历史版本。</li>\n<li>版本管理：各个版本之间肯定有重叠的部分，这一部分不要重复保存。对此，SVN 采用增量式管理的方法（每次只保存修改的部分），git 采取的是文件系统快照的方法。</li>\n<li>权限控制：不同人的权限不同。git 不仅支持权限控制，还可以对团队外开发者贡献的代码进行审核。</li>\n<li>历史记录：查看修改人、时间、内容、日志等，还可以把本地文件恢复到之前的状态。</li>\n<li>分支管理：允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。</li>\n</ul>\n<h1 id=\"Git-结构\"><a href=\"#Git-结构\" class=\"headerlink\" title=\"Git 结构\"></a>Git 结构</h1><p><img src=\"https://s1.328888.xyz/2022/05/01/AbdOT.png\" alt=\"AbdOT.png\"></p>\n<h1 id=\"Git-和代码托管中心\"><a href=\"#Git-和代码托管中心\" class=\"headerlink\" title=\"Git 和代码托管中心\"></a>Git 和代码托管中心</h1><p>代码托管中心可以帮我们维护远程库</p>\n<p>局域网内：Gitlab</p>\n<p>外网：Github，Gitee</p>\n<p>开发者通过 push 把代码推送到远程库。其他开发者要先 clone 把代码克隆下来，然后加入团队，然后才能把自己做的修改 push 推送到远程库。再通过 pull 把其他人的操作拉取下来。</p>\n<p>如果需要项目成员之外的人修改代码：那个人先通过 fork 克隆一个自己的远程库，然后自己对自己的远程库做 clone、push 等操作，修改完成之后向项目开发者发送 pull request 请求，开发者审核同意后 merge 合并代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.bilibili.com/video/BV1pW411A7a5?p=3&spm_id_from=pageDriver\">【尚硅谷】Git与GitHub基础全套完整版教程（快速上手，一套搞定）_哔哩哔哩_bilibili</a></p>\n<h1 id=\"为什么需要版本控制？\"><a href=\"#为什么需要版本控制？\" class=\"headerlink\" title=\"为什么需要版本控制？\"></a>为什么需要版本控制？</h1><p>单人开发有的时候，在开发过程中需要回退到之前的版本。好的版本管理可以大大提高开发效率。</p>\n<p>多人开发的时候，不同人做修改 / 上传时间不统一，如果两个人同时上传，后者就会把前者的内容覆盖。普通文件服务器不能管理文件内容。</p>\n<h1 id=\"版本控制工具特性\"><a href=\"#版本控制工具特性\" class=\"headerlink\" title=\"版本控制工具特性\"></a>版本控制工具特性</h1><p><strong>版本控制是一种思想，版本控制工具（如 SVN、git）是对其实现。</strong></p>\n<p>集中式版本控制工具：如 SVN，开发人员都是客户端，而内容存储在服务器上，所有人和服务器交互。缺点在于服务器一挂，历史数据全部丢失，客户端上只能保存当前状态。（单点故障）</p>\n<p>分布式版本控制工具：如 git ，开发人员在本地就能进行完整的版本控制。就算一个人的数据丢失了，依靠其他人的也能找回来，能有效避免单点故障。不过还是不建议本地库传数据，还是有一个远程库。</p>\n<p>git其他优点：</p>\n<ul>\n<li>大部分操作在本地进行，不需要联网</li>\n<li>完整性保证（哈希算法，之后介绍）</li>\n<li>尽可能添加数据，而不是删除或修改数据</li>\n<li>分支操作快捷流畅</li>\n<li>与 Linux 命令全面兼容</li>\n</ul>\n<h1 id=\"版本控制工具应该具有的功能？\"><a href=\"#版本控制工具应该具有的功能？\" class=\"headerlink\" title=\"版本控制工具应该具有的功能？\"></a>版本控制工具应该具有的功能？</h1><ul>\n<li>协同修改：多个人并行不悖地修改同一份文件。</li>\n<li>数据备份：保存历史版本。</li>\n<li>版本管理：各个版本之间肯定有重叠的部分，这一部分不要重复保存。对此，SVN 采用增量式管理的方法（每次只保存修改的部分），git 采取的是文件系统快照的方法。</li>\n<li>权限控制：不同人的权限不同。git 不仅支持权限控制，还可以对团队外开发者贡献的代码进行审核。</li>\n<li>历史记录：查看修改人、时间、内容、日志等，还可以把本地文件恢复到之前的状态。</li>\n<li>分支管理：允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率。</li>\n</ul>\n<h1 id=\"Git-结构\"><a href=\"#Git-结构\" class=\"headerlink\" title=\"Git 结构\"></a>Git 结构</h1><p><img src=\"https://s1.328888.xyz/2022/05/01/AbdOT.png\" alt=\"AbdOT.png\"></p>\n<h1 id=\"Git-和代码托管中心\"><a href=\"#Git-和代码托管中心\" class=\"headerlink\" title=\"Git 和代码托管中心\"></a>Git 和代码托管中心</h1><p>代码托管中心可以帮我们维护远程库</p>\n<p>局域网内：Gitlab</p>\n<p>外网：Github，Gitee</p>\n<p>开发者通过 push 把代码推送到远程库。其他开发者要先 clone 把代码克隆下来，然后加入团队，然后才能把自己做的修改 push 推送到远程库。再通过 pull 把其他人的操作拉取下来。</p>\n<p>如果需要项目成员之外的人修改代码：那个人先通过 fork 克隆一个自己的远程库，然后自己对自己的远程库做 clone、push 等操作，修改完成之后向项目开发者发送 pull request 请求，开发者审核同意后 merge 合并代码。</p>\n"},{"title":"git_3 版本控制","date":"2022-05-02T16:00:00.000Z","_content":"\n# 查看历史版本信息\n\n`git log`查看之前的版本信息。\n\n其中可以看到 HEAD->master（或 main），HEAD 是指向当前版本的指针，之后修改版本其实就是移动这个指针。\n\n如果最下面一行是冒号，说明记录多到一页装不下了。\n\n多屏显示控制方式：空格向下翻页，b 向上翻页，q退出。\n\n`git log --pretty=oneline`以每次版本占一行的，漂亮的方式 显示版本信息。\n\n`git log --oneline`连哈希值也会缩短（被称为局部索引值）。**只能查看之前的版本信息，版本回退后不能看到将来的版本。**\n\n`git reflog`显示 commit 信息，以及从当前版本移动到这个版本需要多少步（如：HEAD@{1}表示差了一个版本，0表示这个版本就是当前版本）**可以查看历史/未来版本。**\n\n# 版本前进 / 回退\n\n本质就是移动 HEAD 指针。\n\n方法1：首先通过 `git log --oneline`找到要跳转的版本的哈希值\n\n```\ngit reset --hard Fd83ed9 // 结尾是刚才获取的哈希值，即局部索引值\n```\n\n不管前进后退都是这种方法。\n\n方法2：只能后退\n\n```\ngit reset --hard^//回退一个版本。有几个异或符号，回退几个版本。\n```\n\n方法3：只能后退\n\n```\ngit reset hard~3//回退3个版本\n```\n\nsoft：修改本地库的指针。修改后输入`cat good.txt` 查看本地库的文件，会发现文件已经变成修改版本后的文件了。\n\n*如果输入 `git status` ，会发现暂存区也被 modified 了。并不是因为暂存区变了，而是本地库指针移动了，和暂存区无法对应了。*\n\nmixed：修改本地库的指针，并重置暂存区。\n\nhard：修改本地库的指针，并重置暂存区和工作区。\n\n# 删除及找回删除文件\n\n如果是删除并提交了删除操作之后：\n\n```git\nrm aaa.txt//删除文件\ngit add aaa.txt//添加删除操作\ngit commit -m \"\" aaa.txt//提交删除操作\n\ngit reflog//查看历代版本及其哈希值\ngit reset --hard abcdef//回退到有这个文件的版本\ngit checkout -- aaa.txt//另一种方法\n```\n\n如果是删除后把删除操作添加到暂存区后：`git reset --hard HEAD`。\n\n# 比较文件差异\n\n```\n//工作区未提交到暂存区：\ngit diff a.txt//比较该文件做的改动。红色行删除，绿色行新增/修改。\n//工作区提交到暂存区后：上一种方法查不出差别。\ngit diff HEAD a.txt//比较本地库的版本\ngit diff HEAD^3 a.txt//比较本地库的当前版本和倒退三个版本的区别\n```\n\n不带文件名就是比较多个文件。","source":"_posts/git_3 版本控制.md","raw":"---\ntitle: git_3 版本控制\ndate: 2022-05-03\ntags: study\ncategory: git\n---\n\n# 查看历史版本信息\n\n`git log`查看之前的版本信息。\n\n其中可以看到 HEAD->master（或 main），HEAD 是指向当前版本的指针，之后修改版本其实就是移动这个指针。\n\n如果最下面一行是冒号，说明记录多到一页装不下了。\n\n多屏显示控制方式：空格向下翻页，b 向上翻页，q退出。\n\n`git log --pretty=oneline`以每次版本占一行的，漂亮的方式 显示版本信息。\n\n`git log --oneline`连哈希值也会缩短（被称为局部索引值）。**只能查看之前的版本信息，版本回退后不能看到将来的版本。**\n\n`git reflog`显示 commit 信息，以及从当前版本移动到这个版本需要多少步（如：HEAD@{1}表示差了一个版本，0表示这个版本就是当前版本）**可以查看历史/未来版本。**\n\n# 版本前进 / 回退\n\n本质就是移动 HEAD 指针。\n\n方法1：首先通过 `git log --oneline`找到要跳转的版本的哈希值\n\n```\ngit reset --hard Fd83ed9 // 结尾是刚才获取的哈希值，即局部索引值\n```\n\n不管前进后退都是这种方法。\n\n方法2：只能后退\n\n```\ngit reset --hard^//回退一个版本。有几个异或符号，回退几个版本。\n```\n\n方法3：只能后退\n\n```\ngit reset hard~3//回退3个版本\n```\n\nsoft：修改本地库的指针。修改后输入`cat good.txt` 查看本地库的文件，会发现文件已经变成修改版本后的文件了。\n\n*如果输入 `git status` ，会发现暂存区也被 modified 了。并不是因为暂存区变了，而是本地库指针移动了，和暂存区无法对应了。*\n\nmixed：修改本地库的指针，并重置暂存区。\n\nhard：修改本地库的指针，并重置暂存区和工作区。\n\n# 删除及找回删除文件\n\n如果是删除并提交了删除操作之后：\n\n```git\nrm aaa.txt//删除文件\ngit add aaa.txt//添加删除操作\ngit commit -m \"\" aaa.txt//提交删除操作\n\ngit reflog//查看历代版本及其哈希值\ngit reset --hard abcdef//回退到有这个文件的版本\ngit checkout -- aaa.txt//另一种方法\n```\n\n如果是删除后把删除操作添加到暂存区后：`git reset --hard HEAD`。\n\n# 比较文件差异\n\n```\n//工作区未提交到暂存区：\ngit diff a.txt//比较该文件做的改动。红色行删除，绿色行新增/修改。\n//工作区提交到暂存区后：上一种方法查不出差别。\ngit diff HEAD a.txt//比较本地库的版本\ngit diff HEAD^3 a.txt//比较本地库的当前版本和倒退三个版本的区别\n```\n\n不带文件名就是比较多个文件。","slug":"git_3 版本控制","published":1,"updated":"2022-05-04T04:23:41.174Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2r2wk4r00001gv29wtv43do","content":"<h1 id=\"查看历史版本信息\"><a href=\"#查看历史版本信息\" class=\"headerlink\" title=\"查看历史版本信息\"></a>查看历史版本信息</h1><p><code>git log</code>查看之前的版本信息。</p>\n<p>其中可以看到 HEAD-&gt;master（或 main），HEAD 是指向当前版本的指针，之后修改版本其实就是移动这个指针。</p>\n<p>如果最下面一行是冒号，说明记录多到一页装不下了。</p>\n<p>多屏显示控制方式：空格向下翻页，b 向上翻页，q退出。</p>\n<p><code>git log --pretty=oneline</code>以每次版本占一行的，漂亮的方式 显示版本信息。</p>\n<p><code>git log --oneline</code>连哈希值也会缩短（被称为局部索引值）。<strong>只能查看之前的版本信息，版本回退后不能看到将来的版本。</strong></p>\n<p><code>git reflog</code>显示 commit 信息，以及从当前版本移动到这个版本需要多少步（如：HEAD@{1}表示差了一个版本，0表示这个版本就是当前版本）<strong>可以查看历史/未来版本。</strong></p>\n<h1 id=\"版本前进-回退\"><a href=\"#版本前进-回退\" class=\"headerlink\" title=\"版本前进 / 回退\"></a>版本前进 / 回退</h1><p>本质就是移动 HEAD 指针。</p>\n<p>方法1：首先通过 <code>git log --oneline</code>找到要跳转的版本的哈希值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git reset --hard Fd83ed9 // 结尾是刚才获取的哈希值，即局部索引值<br></code></pre></td></tr></table></figure>\n\n<p>不管前进后退都是这种方法。</p>\n<p>方法2：只能后退</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git reset --hard^//回退一个版本。有几个异或符号，回退几个版本。<br></code></pre></td></tr></table></figure>\n\n<p>方法3：只能后退</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git reset hard~3//回退3个版本<br></code></pre></td></tr></table></figure>\n\n<p>soft：修改本地库的指针。修改后输入<code>cat good.txt</code> 查看本地库的文件，会发现文件已经变成修改版本后的文件了。</p>\n<p><em>如果输入 <code>git status</code> ，会发现暂存区也被 modified 了。并不是因为暂存区变了，而是本地库指针移动了，和暂存区无法对应了。</em></p>\n<p>mixed：修改本地库的指针，并重置暂存区。</p>\n<p>hard：修改本地库的指针，并重置暂存区和工作区。</p>\n<h1 id=\"删除及找回删除文件\"><a href=\"#删除及找回删除文件\" class=\"headerlink\" title=\"删除及找回删除文件\"></a>删除及找回删除文件</h1><p>如果是删除并提交了删除操作之后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">rm aaa.txt//删除文件<br>git add aaa.txt//添加删除操作<br>git commit -m &quot;&quot; aaa.txt//提交删除操作<br><br>git reflog//查看历代版本及其哈希值<br>git reset --hard abcdef//回退到有这个文件的版本<br>git checkout -- aaa.txt//另一种方法<br></code></pre></td></tr></table></figure>\n\n<p>如果是删除后把删除操作添加到暂存区后：<code>git reset --hard HEAD</code>。</p>\n<h1 id=\"比较文件差异\"><a href=\"#比较文件差异\" class=\"headerlink\" title=\"比较文件差异\"></a>比较文件差异</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">//工作区未提交到暂存区：<br>git diff a.txt//比较该文件做的改动。红色行删除，绿色行新增/修改。<br>//工作区提交到暂存区后：上一种方法查不出差别。<br>git diff HEAD a.txt//比较本地库的版本<br>git diff HEAD^3 a.txt//比较本地库的当前版本和倒退三个版本的区别<br></code></pre></td></tr></table></figure>\n\n<p>不带文件名就是比较多个文件。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"查看历史版本信息\"><a href=\"#查看历史版本信息\" class=\"headerlink\" title=\"查看历史版本信息\"></a>查看历史版本信息</h1><p><code>git log</code>查看之前的版本信息。</p>\n<p>其中可以看到 HEAD-&gt;master（或 main），HEAD 是指向当前版本的指针，之后修改版本其实就是移动这个指针。</p>\n<p>如果最下面一行是冒号，说明记录多到一页装不下了。</p>\n<p>多屏显示控制方式：空格向下翻页，b 向上翻页，q退出。</p>\n<p><code>git log --pretty=oneline</code>以每次版本占一行的，漂亮的方式 显示版本信息。</p>\n<p><code>git log --oneline</code>连哈希值也会缩短（被称为局部索引值）。<strong>只能查看之前的版本信息，版本回退后不能看到将来的版本。</strong></p>\n<p><code>git reflog</code>显示 commit 信息，以及从当前版本移动到这个版本需要多少步（如：HEAD@{1}表示差了一个版本，0表示这个版本就是当前版本）<strong>可以查看历史/未来版本。</strong></p>\n<h1 id=\"版本前进-回退\"><a href=\"#版本前进-回退\" class=\"headerlink\" title=\"版本前进 / 回退\"></a>版本前进 / 回退</h1><p>本质就是移动 HEAD 指针。</p>\n<p>方法1：首先通过 <code>git log --oneline</code>找到要跳转的版本的哈希值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git reset --hard Fd83ed9 // 结尾是刚才获取的哈希值，即局部索引值<br></code></pre></td></tr></table></figure>\n\n<p>不管前进后退都是这种方法。</p>\n<p>方法2：只能后退</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git reset --hard^//回退一个版本。有几个异或符号，回退几个版本。<br></code></pre></td></tr></table></figure>\n\n<p>方法3：只能后退</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">git reset hard~3//回退3个版本<br></code></pre></td></tr></table></figure>\n\n<p>soft：修改本地库的指针。修改后输入<code>cat good.txt</code> 查看本地库的文件，会发现文件已经变成修改版本后的文件了。</p>\n<p><em>如果输入 <code>git status</code> ，会发现暂存区也被 modified 了。并不是因为暂存区变了，而是本地库指针移动了，和暂存区无法对应了。</em></p>\n<p>mixed：修改本地库的指针，并重置暂存区。</p>\n<p>hard：修改本地库的指针，并重置暂存区和工作区。</p>\n<h1 id=\"删除及找回删除文件\"><a href=\"#删除及找回删除文件\" class=\"headerlink\" title=\"删除及找回删除文件\"></a>删除及找回删除文件</h1><p>如果是删除并提交了删除操作之后：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs git\">rm aaa.txt//删除文件<br>git add aaa.txt//添加删除操作<br>git commit -m &quot;&quot; aaa.txt//提交删除操作<br><br>git reflog//查看历代版本及其哈希值<br>git reset --hard abcdef//回退到有这个文件的版本<br>git checkout -- aaa.txt//另一种方法<br></code></pre></td></tr></table></figure>\n\n<p>如果是删除后把删除操作添加到暂存区后：<code>git reset --hard HEAD</code>。</p>\n<h1 id=\"比较文件差异\"><a href=\"#比较文件差异\" class=\"headerlink\" title=\"比较文件差异\"></a>比较文件差异</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">//工作区未提交到暂存区：<br>git diff a.txt//比较该文件做的改动。红色行删除，绿色行新增/修改。<br>//工作区提交到暂存区后：上一种方法查不出差别。<br>git diff HEAD a.txt//比较本地库的版本<br>git diff HEAD^3 a.txt//比较本地库的当前版本和倒退三个版本的区别<br></code></pre></td></tr></table></figure>\n\n<p>不带文件名就是比较多个文件。</p>\n"},{"title":"html_css_案例_1","date":"2022-05-03T16:00:00.000Z","_content":"\n[黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动端前端视频教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV14J4114768?p=1)\n\n\n\n![Av2CA.png](https://s1.328888.xyz/2022/05/02/Av2CA.png)\n\n以上为学成在线网页案例。本文主要涉及老师讲解的 Header 部分。\n\n# 分析\n\n建议样式设置遵循以下步骤：\n\n1. **布局定位属性：display / position / float / clear / visibility / overflow**\n2. **自身属性：width / height / margin / padding / border / background**\n3. **文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word**\n4. **其他属性：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient……**\n\n设计思路：\n\n1. 确定版心（在页面最中央的），宽度一旦确定不能更改\n2. 确定行模块（标准流）和列模块（浮动）。*网页布局第一准则*\n3. 确定浮动元素中每个列的大小和位置。*网页布局第二准则*\n4. **先理清布局结构，再写代码。**\n\n# 写代码\n\n首先记得清除全局样式\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n```\n\n### 版心\n\n利用 Ps 测量知，版心部分宽1200像素，并且全部居中对齐。\n\n因为涉及到好几个块级元素都是这样的样式，所以用类选择器。\n\n```css\n.w {/*版心的宽度、居中样式*/\n    width: 1200px;\n    margin: auto;/*设置 margin-left 和 right 都是 auto，就会居中*/\n}\n```\n\n然后设计顺序是先把一行设计完（包括这行内的所有元素），然后再设计下一行。\n\n\n\n## Header\n\n![AEZUX.png](https://s1.328888.xyz/2022/05/02/AEZUX.png)\n\n从左到右依次为：logo，导航栏 nav，搜索 search，头像 user 四列。\n\n四列有着同样的高度，设置这一行的盒子的样式第一种做法是一整个盒子把这一行四列包起来，这个盒子和这四个元素一样高，然后设置上下外边距；（老师的方法）\n\n第二种做法是一整个盒子包住这四个元素，但是这个盒子更大一些，在盒子内部设置内边距留有一些空间；解法很多。\n\n记得 header 盒子要同时选中 header 和版心 w 两个样式类。\n\n```html\n<div class=\"header w\">头部盒子</div>\n```\n\n测量得知：logo 高度42像素，上下各有30像素的空白。\n\n```css\n.header {/*包裹 header 一行的盒子的样式*/\n\theight: 42px;\n    margin: 30px auto;/*表示：上下30px，左右水平居中*/\n}\n```\n\n#### logo：学成在线\n\n```html\n<img src=\"image/logo.png\" />\n```\n\nlogo 图标高42像素，宽200像素。此外记得，这几个盒子横向放在一行中，所以都要加 float 属性。\n\n```css\n.logo {\n    float:left;\n    width: 200px;\n    height:42px;\n}\n```\n\n#### 导航栏\n\n**实际开发中，导航栏是采用 li 包裹 a 标签的方法实现的**，这样使得链接标签结构更加清晰，而且如果堆叠 a 标签，有可能被搜索引擎怀疑恶意堆砌关键字而降权。\n\n```html\n<div class=\"nav\">\n\t<ul>\n        <li><a href=\"#\">首页</a></li>\n        <li><a href=\"#\">课程</a></li>\n        <li><a href=\"#\">职业规划</a></li>\n    </ul>\n</div>\n```\n\n先把页面中的所有 li 标签前面的圆点去掉，然后写 nav 类选择器。\n\n测量得知，其距离左边的 logo 图标60像素。\n\n```css\nli {\n    line-style: none;\n}\n.nav {\n    float:left;\n    margin-left: 60px;\n}\n```\n\n对于具体的三个导航栏，浮动要给 li 标签设置而不是 a 标签设置。每个导航栏按钮之间相距30像素。\n\n```css\n.nav li {\n    float: left;\n}\n```\n\n然后，真正想实现点击跳转的链接效果，点击范围不只局限于文字区域，而是整块盒子可以点击。所以要给 a 设置为块级元素属性。\n\n三个导航栏长度随其内容的长度而变化，所以要设置水平方向上内边距 padding 而不能设置盒子具体大小。\n\n```css\na {\n    text-decoration: none;/*去掉链接标签自带的下划线*/\n}\n\n.nav li a {\n    display: block;\n    height: 42px;\n    padding: 0 10px;\n    line-height: 42px;/*使得文字内容垂直居中对齐*/\n    font-size: 18px;\n    color: black;\n}\n```\n\nli 标签不用设置宽度，一方面是浮动的块级元素的特性：其宽度会和内容一样宽；\n\n一方面考虑到以后可能还会添加新的导航栏。\n\n最后是期望鼠标经过导航栏链接元素的时候，文字变成蓝色，且盒子底部会出现蓝色的线提示鼠标悬停在该块上。用 hover 完成。\n\n```css\n.nav li a:hover {\n\tborder-bottom: blue;/*线宽和文字内容一样宽*/\n    color: blue;\n}\n```\n\n#### 搜索框 \n\n![hdRMC.png](https://s1.328888.xyz/2022/05/03/hdRMC.png)\n\n一个大盒子包住，左侧：输入文本框；右侧：按钮。\n\n```html\n<div class=\"search\">\n    <input / value=\"输入关键词\">\n    <button />\n</div>\n```\n\n```css\n.search {\n    float: left;\n    width: 410px;\n    height: 42px;\n    margin-left: 50px;\n}\n\n.search input {/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/\n    float: left;\n    width: 345px;/*其实整个输入框宽360px。只是因为盒子设置了宽度，再有了 padding-left 会撑大盒子。因此要360-15*/\n    height: 42px;\n    padding-left: 15px;\n    border: 1px solid blue;\n    border-right: 0;/*因为右边是搜索按钮，可以不用边框*/\n    color: #bfbfbf;\n    font-size: 14px;/*Ps 中测量得到的 pt 单位和 px 一样大*/\n}\n\n.search button {/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/\n    float: left;\n    wdith； 50px;\n    height: 42px;\n    button: 0;/*去掉按钮默认的边框*/\n    background: url(image/button.png);\n}\n```\n\n#### 登录状态\n\n![hlga2.png](https://s1.328888.xyz/2022/05/04/hlga2.png)\n\n```html\n<div class=\"user\">\n    <img url=\"\" alt=\"\" />\n    qq-leishui\n</div>\n```\n\n```css\n.user {\n    float: right;\n    line-height: 42px;\n    margin-right: 30px;\n    font-size: 14px;\n    color: #666;\n}\n```\n\n图片文字部分居中：之后的课程涉及到。\n","source":"_posts/html css_案例_1 Header.md","raw":"---\ntitle: html_css_案例_1\ndate: 2022-05-04\ntags: study\ncategory: html+css\n---\n\n[黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动端前端视频教程_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV14J4114768?p=1)\n\n\n\n![Av2CA.png](https://s1.328888.xyz/2022/05/02/Av2CA.png)\n\n以上为学成在线网页案例。本文主要涉及老师讲解的 Header 部分。\n\n# 分析\n\n建议样式设置遵循以下步骤：\n\n1. **布局定位属性：display / position / float / clear / visibility / overflow**\n2. **自身属性：width / height / margin / padding / border / background**\n3. **文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word**\n4. **其他属性：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient……**\n\n设计思路：\n\n1. 确定版心（在页面最中央的），宽度一旦确定不能更改\n2. 确定行模块（标准流）和列模块（浮动）。*网页布局第一准则*\n3. 确定浮动元素中每个列的大小和位置。*网页布局第二准则*\n4. **先理清布局结构，再写代码。**\n\n# 写代码\n\n首先记得清除全局样式\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n```\n\n### 版心\n\n利用 Ps 测量知，版心部分宽1200像素，并且全部居中对齐。\n\n因为涉及到好几个块级元素都是这样的样式，所以用类选择器。\n\n```css\n.w {/*版心的宽度、居中样式*/\n    width: 1200px;\n    margin: auto;/*设置 margin-left 和 right 都是 auto，就会居中*/\n}\n```\n\n然后设计顺序是先把一行设计完（包括这行内的所有元素），然后再设计下一行。\n\n\n\n## Header\n\n![AEZUX.png](https://s1.328888.xyz/2022/05/02/AEZUX.png)\n\n从左到右依次为：logo，导航栏 nav，搜索 search，头像 user 四列。\n\n四列有着同样的高度，设置这一行的盒子的样式第一种做法是一整个盒子把这一行四列包起来，这个盒子和这四个元素一样高，然后设置上下外边距；（老师的方法）\n\n第二种做法是一整个盒子包住这四个元素，但是这个盒子更大一些，在盒子内部设置内边距留有一些空间；解法很多。\n\n记得 header 盒子要同时选中 header 和版心 w 两个样式类。\n\n```html\n<div class=\"header w\">头部盒子</div>\n```\n\n测量得知：logo 高度42像素，上下各有30像素的空白。\n\n```css\n.header {/*包裹 header 一行的盒子的样式*/\n\theight: 42px;\n    margin: 30px auto;/*表示：上下30px，左右水平居中*/\n}\n```\n\n#### logo：学成在线\n\n```html\n<img src=\"image/logo.png\" />\n```\n\nlogo 图标高42像素，宽200像素。此外记得，这几个盒子横向放在一行中，所以都要加 float 属性。\n\n```css\n.logo {\n    float:left;\n    width: 200px;\n    height:42px;\n}\n```\n\n#### 导航栏\n\n**实际开发中，导航栏是采用 li 包裹 a 标签的方法实现的**，这样使得链接标签结构更加清晰，而且如果堆叠 a 标签，有可能被搜索引擎怀疑恶意堆砌关键字而降权。\n\n```html\n<div class=\"nav\">\n\t<ul>\n        <li><a href=\"#\">首页</a></li>\n        <li><a href=\"#\">课程</a></li>\n        <li><a href=\"#\">职业规划</a></li>\n    </ul>\n</div>\n```\n\n先把页面中的所有 li 标签前面的圆点去掉，然后写 nav 类选择器。\n\n测量得知，其距离左边的 logo 图标60像素。\n\n```css\nli {\n    line-style: none;\n}\n.nav {\n    float:left;\n    margin-left: 60px;\n}\n```\n\n对于具体的三个导航栏，浮动要给 li 标签设置而不是 a 标签设置。每个导航栏按钮之间相距30像素。\n\n```css\n.nav li {\n    float: left;\n}\n```\n\n然后，真正想实现点击跳转的链接效果，点击范围不只局限于文字区域，而是整块盒子可以点击。所以要给 a 设置为块级元素属性。\n\n三个导航栏长度随其内容的长度而变化，所以要设置水平方向上内边距 padding 而不能设置盒子具体大小。\n\n```css\na {\n    text-decoration: none;/*去掉链接标签自带的下划线*/\n}\n\n.nav li a {\n    display: block;\n    height: 42px;\n    padding: 0 10px;\n    line-height: 42px;/*使得文字内容垂直居中对齐*/\n    font-size: 18px;\n    color: black;\n}\n```\n\nli 标签不用设置宽度，一方面是浮动的块级元素的特性：其宽度会和内容一样宽；\n\n一方面考虑到以后可能还会添加新的导航栏。\n\n最后是期望鼠标经过导航栏链接元素的时候，文字变成蓝色，且盒子底部会出现蓝色的线提示鼠标悬停在该块上。用 hover 完成。\n\n```css\n.nav li a:hover {\n\tborder-bottom: blue;/*线宽和文字内容一样宽*/\n    color: blue;\n}\n```\n\n#### 搜索框 \n\n![hdRMC.png](https://s1.328888.xyz/2022/05/03/hdRMC.png)\n\n一个大盒子包住，左侧：输入文本框；右侧：按钮。\n\n```html\n<div class=\"search\">\n    <input / value=\"输入关键词\">\n    <button />\n</div>\n```\n\n```css\n.search {\n    float: left;\n    width: 410px;\n    height: 42px;\n    margin-left: 50px;\n}\n\n.search input {/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/\n    float: left;\n    width: 345px;/*其实整个输入框宽360px。只是因为盒子设置了宽度，再有了 padding-left 会撑大盒子。因此要360-15*/\n    height: 42px;\n    padding-left: 15px;\n    border: 1px solid blue;\n    border-right: 0;/*因为右边是搜索按钮，可以不用边框*/\n    color: #bfbfbf;\n    font-size: 14px;/*Ps 中测量得到的 pt 单位和 px 一样大*/\n}\n\n.search button {/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/\n    float: left;\n    wdith； 50px;\n    height: 42px;\n    button: 0;/*去掉按钮默认的边框*/\n    background: url(image/button.png);\n}\n```\n\n#### 登录状态\n\n![hlga2.png](https://s1.328888.xyz/2022/05/04/hlga2.png)\n\n```html\n<div class=\"user\">\n    <img url=\"\" alt=\"\" />\n    qq-leishui\n</div>\n```\n\n```css\n.user {\n    float: right;\n    line-height: 42px;\n    margin-right: 30px;\n    font-size: 14px;\n    color: #666;\n}\n```\n\n图片文字部分居中：之后的课程涉及到。\n","slug":"html css_案例_1 Header","published":1,"updated":"2022-05-04T04:24:07.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2r2wk4x00011gv2dhrocvg0","content":"<p><a href=\"https://www.bilibili.com/video/BV14J4114768?p=1\">黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动端前端视频教程_哔哩哔哩_bilibili</a></p>\n<p><img src=\"https://s1.328888.xyz/2022/05/02/Av2CA.png\" alt=\"Av2CA.png\"></p>\n<p>以上为学成在线网页案例。本文主要涉及老师讲解的 Header 部分。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>建议样式设置遵循以下步骤：</p>\n<ol>\n<li><strong>布局定位属性：display / position / float / clear / visibility / overflow</strong></li>\n<li><strong>自身属性：width / height / margin / padding / border / background</strong></li>\n<li><strong>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</strong></li>\n<li><strong>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient……</strong></li>\n</ol>\n<p>设计思路：</p>\n<ol>\n<li>确定版心（在页面最中央的），宽度一旦确定不能更改</li>\n<li>确定行模块（标准流）和列模块（浮动）。<em>网页布局第一准则</em></li>\n<li>确定浮动元素中每个列的大小和位置。<em>网页布局第二准则</em></li>\n<li><strong>先理清布局结构，再写代码。</strong></li>\n</ol>\n<h1 id=\"写代码\"><a href=\"#写代码\" class=\"headerlink\" title=\"写代码\"></a>写代码</h1><p>首先记得清除全局样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">* &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"版心\"><a href=\"#版心\" class=\"headerlink\" title=\"版心\"></a>版心</h3><p>利用 Ps 测量知，版心部分宽1200像素，并且全部居中对齐。</p>\n<p>因为涉及到好几个块级元素都是这样的样式，所以用类选择器。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.w</span> &#123;<span class=\"hljs-comment\">/*版心的宽度、居中样式*/</span><br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">1200px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: auto;<span class=\"hljs-comment\">/*设置 margin-left 和 right 都是 auto，就会居中*/</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后设计顺序是先把一行设计完（包括这行内的所有元素），然后再设计下一行。</p>\n<h2 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h2><p><img src=\"https://s1.328888.xyz/2022/05/02/AEZUX.png\" alt=\"AEZUX.png\"></p>\n<p>从左到右依次为：logo，导航栏 nav，搜索 search，头像 user 四列。</p>\n<p>四列有着同样的高度，设置这一行的盒子的样式第一种做法是一整个盒子把这一行四列包起来，这个盒子和这四个元素一样高，然后设置上下外边距；（老师的方法）</p>\n<p>第二种做法是一整个盒子包住这四个元素，但是这个盒子更大一些，在盒子内部设置内边距留有一些空间；解法很多。</p>\n<p>记得 header 盒子要同时选中 header 和版心 w 两个样式类。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;header w&quot;</span>&gt;</span>头部盒子<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>测量得知：logo 高度42像素，上下各有30像素的空白。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.header</span> &#123;<span class=\"hljs-comment\">/*包裹 header 一行的盒子的样式*/</span><br>\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">30px</span> auto;<span class=\"hljs-comment\">/*表示：上下30px，左右水平居中*/</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"logo：学成在线\"><a href=\"#logo：学成在线\" class=\"headerlink\" title=\"logo：学成在线\"></a>logo：学成在线</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image/logo.png&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>logo 图标高42像素，宽200像素。此外记得，这几个盒子横向放在一行中，所以都要加 float 属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.logo</span> &#123;<br>    <span class=\"hljs-attribute\">float</span><span class=\"hljs-selector-pseudo\">:left</span>;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>    <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">42px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"导航栏\"><a href=\"#导航栏\" class=\"headerlink\" title=\"导航栏\"></a>导航栏</h4><p><strong>实际开发中，导航栏是采用 li 包裹 a 标签的方法实现的</strong>，这样使得链接标签结构更加清晰，而且如果堆叠 a 标签，有可能被搜索引擎怀疑恶意堆砌关键字而降权。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;nav&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>首页<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>课程<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>职业规划<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>先把页面中的所有 li 标签前面的圆点去掉，然后写 nav 类选择器。</p>\n<p>测量得知，其距离左边的 logo 图标60像素。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">li</span> &#123;<br>    line-style: none;<br>&#125;<br><span class=\"hljs-selector-class\">.nav</span> &#123;<br>    <span class=\"hljs-attribute\">float</span><span class=\"hljs-selector-pseudo\">:left</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">60px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于具体的三个导航栏，浮动要给 li 标签设置而不是 a 标签设置。每个导航栏按钮之间相距30像素。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> &#123;<br>    <span class=\"hljs-attribute\">float</span>: left;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，真正想实现点击跳转的链接效果，点击范围不只局限于文字区域，而是整块盒子可以点击。所以要给 a 设置为块级元素属性。</p>\n<p>三个导航栏长度随其内容的长度而变化，所以要设置水平方向上内边距 padding 而不能设置盒子具体大小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span> &#123;<br>    <span class=\"hljs-attribute\">text-decoration</span>: none;<span class=\"hljs-comment\">/*去掉链接标签自带的下划线*/</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10px</span>;<br>    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">42px</span>;<span class=\"hljs-comment\">/*使得文字内容垂直居中对齐*/</span><br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>li 标签不用设置宽度，一方面是浮动的块级元素的特性：其宽度会和内容一样宽；</p>\n<p>一方面考虑到以后可能还会添加新的导航栏。</p>\n<p>最后是期望鼠标经过导航栏链接元素的时候，文字变成蓝色，且盒子底部会出现蓝色的线提示鼠标悬停在该块上。用 hover 完成。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>\t<span class=\"hljs-attribute\">border-bottom</span>: blue;<span class=\"hljs-comment\">/*线宽和文字内容一样宽*/</span><br>    <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h4><p><img src=\"https://s1.328888.xyz/2022/05/03/hdRMC.png\" alt=\"hdRMC.png\"></p>\n<p>一个大盒子包住，左侧：输入文本框；右侧：按钮。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;search&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> / <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;输入关键词&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.search</span> &#123;<br>    <span class=\"hljs-attribute\">float</span>: left;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">410px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">50px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.search</span> <span class=\"hljs-selector-tag\">input</span> &#123;<span class=\"hljs-comment\">/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/</span><br>    <span class=\"hljs-attribute\">float</span>: left;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">345px</span>;<span class=\"hljs-comment\">/*其实整个输入框宽360px。只是因为盒子设置了宽度，再有了 padding-left 会撑大盒子。因此要360-15*/</span><br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">15px</span>;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid blue;<br>    <span class=\"hljs-attribute\">border-right</span>: <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">/*因为右边是搜索按钮，可以不用边框*/</span><br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#bfbfbf</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">14px</span>;<span class=\"hljs-comment\">/*Ps 中测量得到的 pt 单位和 px 一样大*/</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.search</span> <span class=\"hljs-selector-tag\">button</span> &#123;<span class=\"hljs-comment\">/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/</span><br>    <span class=\"hljs-attribute\">float</span>: left;<br>    wdith； <span class=\"hljs-number\">50px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-selector-tag\">button</span>: <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">/*去掉按钮默认的边框*/</span><br>    <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">image/button.png</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"登录状态\"><a href=\"#登录状态\" class=\"headerlink\" title=\"登录状态\"></a>登录状态</h4><p><img src=\"https://s1.328888.xyz/2022/05/04/hlga2.png\" alt=\"hlga2.png\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;user&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> /&gt;</span><br>    qq-leishui<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.user</span> &#123;<br>    <span class=\"hljs-attribute\">float</span>: right;<br>    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">margin-right</span>: <span class=\"hljs-number\">30px</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">14px</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#666</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>图片文字部分居中：之后的课程涉及到。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.bilibili.com/video/BV14J4114768?p=1\">黑马程序员pink老师前端入门教程，零基础必看的h5(html5)+css3+移动端前端视频教程_哔哩哔哩_bilibili</a></p>\n<p><img src=\"https://s1.328888.xyz/2022/05/02/Av2CA.png\" alt=\"Av2CA.png\"></p>\n<p>以上为学成在线网页案例。本文主要涉及老师讲解的 Header 部分。</p>\n<h1 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h1><p>建议样式设置遵循以下步骤：</p>\n<ol>\n<li><strong>布局定位属性：display / position / float / clear / visibility / overflow</strong></li>\n<li><strong>自身属性：width / height / margin / padding / border / background</strong></li>\n<li><strong>文本属性：color / font / text-decoration / text-align / vertical-align / white-space / break-word</strong></li>\n<li><strong>其他属性：content / cursor / border-radius / box-shadow / text-shadow / background: linear-gradient……</strong></li>\n</ol>\n<p>设计思路：</p>\n<ol>\n<li>确定版心（在页面最中央的），宽度一旦确定不能更改</li>\n<li>确定行模块（标准流）和列模块（浮动）。<em>网页布局第一准则</em></li>\n<li>确定浮动元素中每个列的大小和位置。<em>网页布局第二准则</em></li>\n<li><strong>先理清布局结构，再写代码。</strong></li>\n</ol>\n<h1 id=\"写代码\"><a href=\"#写代码\" class=\"headerlink\" title=\"写代码\"></a>写代码</h1><p>首先记得清除全局样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">* &#123;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"版心\"><a href=\"#版心\" class=\"headerlink\" title=\"版心\"></a>版心</h3><p>利用 Ps 测量知，版心部分宽1200像素，并且全部居中对齐。</p>\n<p>因为涉及到好几个块级元素都是这样的样式，所以用类选择器。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.w</span> &#123;<span class=\"hljs-comment\">/*版心的宽度、居中样式*/</span><br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">1200px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: auto;<span class=\"hljs-comment\">/*设置 margin-left 和 right 都是 auto，就会居中*/</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后设计顺序是先把一行设计完（包括这行内的所有元素），然后再设计下一行。</p>\n<h2 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h2><p><img src=\"https://s1.328888.xyz/2022/05/02/AEZUX.png\" alt=\"AEZUX.png\"></p>\n<p>从左到右依次为：logo，导航栏 nav，搜索 search，头像 user 四列。</p>\n<p>四列有着同样的高度，设置这一行的盒子的样式第一种做法是一整个盒子把这一行四列包起来，这个盒子和这四个元素一样高，然后设置上下外边距；（老师的方法）</p>\n<p>第二种做法是一整个盒子包住这四个元素，但是这个盒子更大一些，在盒子内部设置内边距留有一些空间；解法很多。</p>\n<p>记得 header 盒子要同时选中 header 和版心 w 两个样式类。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;header w&quot;</span>&gt;</span>头部盒子<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>测量得知：logo 高度42像素，上下各有30像素的空白。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.header</span> &#123;<span class=\"hljs-comment\">/*包裹 header 一行的盒子的样式*/</span><br>\t<span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">30px</span> auto;<span class=\"hljs-comment\">/*表示：上下30px，左右水平居中*/</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"logo：学成在线\"><a href=\"#logo：学成在线\" class=\"headerlink\" title=\"logo：学成在线\"></a>logo：学成在线</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;image/logo.png&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>logo 图标高42像素，宽200像素。此外记得，这几个盒子横向放在一行中，所以都要加 float 属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.logo</span> &#123;<br>    <span class=\"hljs-attribute\">float</span><span class=\"hljs-selector-pseudo\">:left</span>;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">200px</span>;<br>    <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">42px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"导航栏\"><a href=\"#导航栏\" class=\"headerlink\" title=\"导航栏\"></a>导航栏</h4><p><strong>实际开发中，导航栏是采用 li 包裹 a 标签的方法实现的</strong>，这样使得链接标签结构更加清晰，而且如果堆叠 a 标签，有可能被搜索引擎怀疑恶意堆砌关键字而降权。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;nav&quot;</span>&gt;</span><br>\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>首页<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>课程<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>职业规划<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>先把页面中的所有 li 标签前面的圆点去掉，然后写 nav 类选择器。</p>\n<p>测量得知，其距离左边的 logo 图标60像素。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">li</span> &#123;<br>    line-style: none;<br>&#125;<br><span class=\"hljs-selector-class\">.nav</span> &#123;<br>    <span class=\"hljs-attribute\">float</span><span class=\"hljs-selector-pseudo\">:left</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">60px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>对于具体的三个导航栏，浮动要给 li 标签设置而不是 a 标签设置。每个导航栏按钮之间相距30像素。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> &#123;<br>    <span class=\"hljs-attribute\">float</span>: left;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后，真正想实现点击跳转的链接效果，点击范围不只局限于文字区域，而是整块盒子可以点击。所以要给 a 设置为块级元素属性。</p>\n<p>三个导航栏长度随其内容的长度而变化，所以要设置水平方向上内边距 padding 而不能设置盒子具体大小。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">a</span> &#123;<br>    <span class=\"hljs-attribute\">text-decoration</span>: none;<span class=\"hljs-comment\">/*去掉链接标签自带的下划线*/</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>    <span class=\"hljs-attribute\">display</span>: block;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10px</span>;<br>    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">42px</span>;<span class=\"hljs-comment\">/*使得文字内容垂直居中对齐*/</span><br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;<br>    <span class=\"hljs-attribute\">color</span>: black;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>li 标签不用设置宽度，一方面是浮动的块级元素的特性：其宽度会和内容一样宽；</p>\n<p>一方面考虑到以后可能还会添加新的导航栏。</p>\n<p>最后是期望鼠标经过导航栏链接元素的时候，文字变成蓝色，且盒子底部会出现蓝色的线提示鼠标悬停在该块上。用 hover 完成。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>\t<span class=\"hljs-attribute\">border-bottom</span>: blue;<span class=\"hljs-comment\">/*线宽和文字内容一样宽*/</span><br>    <span class=\"hljs-attribute\">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h4><p><img src=\"https://s1.328888.xyz/2022/05/03/hdRMC.png\" alt=\"hdRMC.png\"></p>\n<p>一个大盒子包住，左侧：输入文本框；右侧：按钮。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;search&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> / <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;输入关键词&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.search</span> &#123;<br>    <span class=\"hljs-attribute\">float</span>: left;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">410px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">50px</span>;<br>&#125;<br><br><span class=\"hljs-selector-class\">.search</span> <span class=\"hljs-selector-tag\">input</span> &#123;<span class=\"hljs-comment\">/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/</span><br>    <span class=\"hljs-attribute\">float</span>: left;<br>    <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">345px</span>;<span class=\"hljs-comment\">/*其实整个输入框宽360px。只是因为盒子设置了宽度，再有了 padding-left 会撑大盒子。因此要360-15*/</span><br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">15px</span>;<br>    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid blue;<br>    <span class=\"hljs-attribute\">border-right</span>: <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">/*因为右边是搜索按钮，可以不用边框*/</span><br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#bfbfbf</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">14px</span>;<span class=\"hljs-comment\">/*Ps 中测量得到的 pt 单位和 px 一样大*/</span><br>&#125;<br><br><span class=\"hljs-selector-class\">.search</span> <span class=\"hljs-selector-tag\">button</span> &#123;<span class=\"hljs-comment\">/*虽然相邻的行内块元素会放在同一行，但是行内块元素之间有默认空隙，所以要加浮动。*/</span><br>    <span class=\"hljs-attribute\">float</span>: left;<br>    wdith； <span class=\"hljs-number\">50px</span>;<br>    <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-selector-tag\">button</span>: <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">/*去掉按钮默认的边框*/</span><br>    <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">image/button.png</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"登录状态\"><a href=\"#登录状态\" class=\"headerlink\" title=\"登录状态\"></a>登录状态</h4><p><img src=\"https://s1.328888.xyz/2022/05/04/hlga2.png\" alt=\"hlga2.png\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;user&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span> /&gt;</span><br>    qq-leishui<br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.user</span> &#123;<br>    <span class=\"hljs-attribute\">float</span>: right;<br>    <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">42px</span>;<br>    <span class=\"hljs-attribute\">margin-right</span>: <span class=\"hljs-number\">30px</span>;<br>    <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">14px</span>;<br>    <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#666</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>图片文字部分居中：之后的课程涉及到。</p>\n"},{"title":"Java 学习博客_11 入门——内部类","date":"2022-05-04T16:00:00.000Z","_content":"\n\n\n以黑马程序员全套Java教程网课为主。\n\n在类中定义一个类。\n\n# 内部类和外部类的互相使用\n\n无论外部类的成员变量的权限修饰符是什么（private, public……）内部类都可以直接访问外部类的全部成员变量。\n\n而外部类如果想访问内部类的成员，需要先创建一个内部类对象再访问。\n\n*因为都在同一个类中，所以即使权限修饰符是 private 也可以访问。*\n\n# 外界使用内部类\n\n外界使用内部类：`Outer.Inner oi=new Outer().new Inner();`\n\n如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。\n\n# 内部类的分类\n\n在类的成员位置定义：成员内部类\n\n在类的局部定义：局部内部类。\n\n## 局部内部类\n\n不能从外界直接创建对象，只能通过调用方法来创建类\n\n```java\npublic class Outer {\n\tprivate int num=10;\n    public void method() {\n        class Inner {\n\t\t\tpublic void show(){\n                System.out.println(num);//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量\n            }\n        }\n        Inner i=new Inner();//在方法中创建内部对象\n        i.show();//创建对象之后，记得调用内部方法的成员变量\n    }\n}\n```\n\n## 匿名内部类\n\n继承了另一个类，或实现了接口的子类匿名对象。\n\n首先有一个父类/接口，其中有具体的/抽象的方法，然后匿名内部类对其进行重写/实现。\n\n```java\n//接口文件 inter.java 中：\npublic interface inter {\n    public void show();//抽象方法\n}\n\n//外部类文件 Outer.java 中\npublic class Outer {\n\tprivate int num=10;\n    public void method() {\n        new inter {\n            @Override\n            public void show(){\n                System.out.println(\"匿名内部类\");\n            }\n        }.show();//创建匿名对象之后，记得调用成员变量\n        \n        //另一种方法：\n        inter i=new inter {\n            @Override\n            public void show(){\n                System.out.println(\"匿名内部类\");\n            }\n        }\n        i.show();\n    }\n}\n```\n\n使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行j的 jump 。\n\n我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；\n\n然后用堕胎的方式`jump c=new cat(); jump d=new dog();` 新建对象并传给 method 方法。\n\n但是可以通过匿名内部类的方法：\n\n```java\njo.method(new jump(){\n    @Override\n    public void jump()\n    {\n        System.out.println(\"猫跳高\");\n    }\n});\n\njo.method(new jump(){\n    @Override\n    public void jump()\n    {\n        System.out.println(\"狗跳高\");\n    }\n});\n```\n\n直接穿一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。","source":"_posts/Java 学习博客_11 入门——内部类.md","raw":"---\ntitle: Java 学习博客_11 入门——内部类\ndate: 2022-5-5\ntags: study\ncategory: java\n---\n\n\n\n以黑马程序员全套Java教程网课为主。\n\n在类中定义一个类。\n\n# 内部类和外部类的互相使用\n\n无论外部类的成员变量的权限修饰符是什么（private, public……）内部类都可以直接访问外部类的全部成员变量。\n\n而外部类如果想访问内部类的成员，需要先创建一个内部类对象再访问。\n\n*因为都在同一个类中，所以即使权限修饰符是 private 也可以访问。*\n\n# 外界使用内部类\n\n外界使用内部类：`Outer.Inner oi=new Outer().new Inner();`\n\n如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。\n\n# 内部类的分类\n\n在类的成员位置定义：成员内部类\n\n在类的局部定义：局部内部类。\n\n## 局部内部类\n\n不能从外界直接创建对象，只能通过调用方法来创建类\n\n```java\npublic class Outer {\n\tprivate int num=10;\n    public void method() {\n        class Inner {\n\t\t\tpublic void show(){\n                System.out.println(num);//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量\n            }\n        }\n        Inner i=new Inner();//在方法中创建内部对象\n        i.show();//创建对象之后，记得调用内部方法的成员变量\n    }\n}\n```\n\n## 匿名内部类\n\n继承了另一个类，或实现了接口的子类匿名对象。\n\n首先有一个父类/接口，其中有具体的/抽象的方法，然后匿名内部类对其进行重写/实现。\n\n```java\n//接口文件 inter.java 中：\npublic interface inter {\n    public void show();//抽象方法\n}\n\n//外部类文件 Outer.java 中\npublic class Outer {\n\tprivate int num=10;\n    public void method() {\n        new inter {\n            @Override\n            public void show(){\n                System.out.println(\"匿名内部类\");\n            }\n        }.show();//创建匿名对象之后，记得调用成员变量\n        \n        //另一种方法：\n        inter i=new inter {\n            @Override\n            public void show(){\n                System.out.println(\"匿名内部类\");\n            }\n        }\n        i.show();\n    }\n}\n```\n\n使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行j的 jump 。\n\n我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；\n\n然后用堕胎的方式`jump c=new cat(); jump d=new dog();` 新建对象并传给 method 方法。\n\n但是可以通过匿名内部类的方法：\n\n```java\njo.method(new jump(){\n    @Override\n    public void jump()\n    {\n        System.out.println(\"猫跳高\");\n    }\n});\n\njo.method(new jump(){\n    @Override\n    public void jump()\n    {\n        System.out.println(\"狗跳高\");\n    }\n});\n```\n\n直接穿一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。","slug":"Java 学习博客_11 入门——内部类","published":1,"updated":"2022-05-05T02:49:56.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2sexu6n0000r4v2323jdjld","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>在类中定义一个类。</p>\n<h1 id=\"内部类和外部类的互相使用\"><a href=\"#内部类和外部类的互相使用\" class=\"headerlink\" title=\"内部类和外部类的互相使用\"></a>内部类和外部类的互相使用</h1><p>无论外部类的成员变量的权限修饰符是什么（private, public……）内部类都可以直接访问外部类的全部成员变量。</p>\n<p>而外部类如果想访问内部类的成员，需要先创建一个内部类对象再访问。</p>\n<p><em>因为都在同一个类中，所以即使权限修饰符是 private 也可以访问。</em></p>\n<h1 id=\"外界使用内部类\"><a href=\"#外界使用内部类\" class=\"headerlink\" title=\"外界使用内部类\"></a>外界使用内部类</h1><p>外界使用内部类：<code>Outer.Inner oi=new Outer().new Inner();</code></p>\n<p>如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。</p>\n<h1 id=\"内部类的分类\"><a href=\"#内部类的分类\" class=\"headerlink\" title=\"内部类的分类\"></a>内部类的分类</h1><p>在类的成员位置定义：成员内部类</p>\n<p>在类的局部定义：局部内部类。</p>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>不能从外界直接创建对象，只能通过调用方法来创建类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> num=<span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>&#123;<br>                System.out.println(num);<span class=\"hljs-comment\">//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量</span><br>            &#125;<br>        &#125;<br>        Inner i=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<span class=\"hljs-comment\">//在方法中创建内部对象</span><br>        i.show();<span class=\"hljs-comment\">//创建对象之后，记得调用内部方法的成员变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>继承了另一个类，或实现了接口的子类匿名对象。</p>\n<p>首先有一个父类/接口，其中有具体的/抽象的方法，然后匿名内部类对其进行重写/实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//接口文件 inter.java 中：</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">inter</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>;<span class=\"hljs-comment\">//抽象方法</span><br>&#125;<br><br><span class=\"hljs-comment\">//外部类文件 Outer.java 中</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> num=<span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">inter</span> &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>&#123;<br>                System.out.println(<span class=\"hljs-string\">&quot;匿名内部类&quot;</span>);<br>            &#125;<br>        &#125;.show();<span class=\"hljs-comment\">//创建匿名对象之后，记得调用成员变量</span><br>        <br>        <span class=\"hljs-comment\">//另一种方法：</span><br>        inter i=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">inter</span> &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>&#123;<br>                System.out.println(<span class=\"hljs-string\">&quot;匿名内部类&quot;</span>);<br>            &#125;<br>        &#125;<br>        i.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行j的 jump 。</p>\n<p>我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；</p>\n<p>然后用堕胎的方式<code>jump c=new cat(); jump d=new dog();</code> 新建对象并传给 method 方法。</p>\n<p>但是可以通过匿名内部类的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">jo.method(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">jump</span>()&#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">jump</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;猫跳高&quot;</span>);<br>    &#125;<br>&#125;);<br><br>jo.method(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">jump</span>()&#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">jump</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;狗跳高&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>直接穿一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<p>在类中定义一个类。</p>\n<h1 id=\"内部类和外部类的互相使用\"><a href=\"#内部类和外部类的互相使用\" class=\"headerlink\" title=\"内部类和外部类的互相使用\"></a>内部类和外部类的互相使用</h1><p>无论外部类的成员变量的权限修饰符是什么（private, public……）内部类都可以直接访问外部类的全部成员变量。</p>\n<p>而外部类如果想访问内部类的成员，需要先创建一个内部类对象再访问。</p>\n<p><em>因为都在同一个类中，所以即使权限修饰符是 private 也可以访问。</em></p>\n<h1 id=\"外界使用内部类\"><a href=\"#外界使用内部类\" class=\"headerlink\" title=\"外界使用内部类\"></a>外界使用内部类</h1><p>外界使用内部类：<code>Outer.Inner oi=new Outer().new Inner();</code></p>\n<p>如果 inner 是私有的，或者是局部内部类，则不能通过上述方法调用。但是可以在 outer 里定义一个公开的方法，在方法中 new 一个 inner 并使用其中的成员方法。对于外部的调用者来说，他只需调用 outer 的这个方法，就可以访问 inner 的成员方法。不过对使用者来说他并不知道内部结构如此。</p>\n<h1 id=\"内部类的分类\"><a href=\"#内部类的分类\" class=\"headerlink\" title=\"内部类的分类\"></a>内部类的分类</h1><p>在类的成员位置定义：成员内部类</p>\n<p>在类的局部定义：局部内部类。</p>\n<h2 id=\"局部内部类\"><a href=\"#局部内部类\" class=\"headerlink\" title=\"局部内部类\"></a>局部内部类</h2><p>不能从外界直接创建对象，只能通过调用方法来创建类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> num=<span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Inner</span> &#123;<br>\t\t\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>&#123;<br>                System.out.println(num);<span class=\"hljs-comment\">//局部内部类可以访问外部类的成员变量，或 method 方法中的局部变量</span><br>            &#125;<br>        &#125;<br>        Inner i=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Inner</span>();<span class=\"hljs-comment\">//在方法中创建内部对象</span><br>        i.show();<span class=\"hljs-comment\">//创建对象之后，记得调用内部方法的成员变量</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><p>继承了另一个类，或实现了接口的子类匿名对象。</p>\n<p>首先有一个父类/接口，其中有具体的/抽象的方法，然后匿名内部类对其进行重写/实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//接口文件 inter.java 中：</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">inter</span> &#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>;<span class=\"hljs-comment\">//抽象方法</span><br>&#125;<br><br><span class=\"hljs-comment\">//外部类文件 Outer.java 中</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Outer</span> &#123;<br>\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> num=<span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">inter</span> &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>&#123;<br>                System.out.println(<span class=\"hljs-string\">&quot;匿名内部类&quot;</span>);<br>            &#125;<br>        &#125;.show();<span class=\"hljs-comment\">//创建匿名对象之后，记得调用成员变量</span><br>        <br>        <span class=\"hljs-comment\">//另一种方法：</span><br>        inter i=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">inter</span> &#123;<br>            <span class=\"hljs-meta\">@Override</span><br>            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span>&#123;<br>                System.out.println(<span class=\"hljs-string\">&quot;匿名内部类&quot;</span>);<br>            &#125;<br>        &#125;<br>        i.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用示例：假如我们有一个 jump 接口，有一个 jumpoperator 类，其中包含 method(Jump j) 执行j的 jump 。</p>\n<p>我们要让不同动物都能 jump，就要在不同动物类中 implements jump 接口，并重写其中的抽象方法；</p>\n<p>然后用堕胎的方式<code>jump c=new cat(); jump d=new dog();</code> 新建对象并传给 method 方法。</p>\n<p>但是可以通过匿名内部类的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">jo.method(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">jump</span>()&#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">jump</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;猫跳高&quot;</span>);<br>    &#125;<br>&#125;);<br><br>jo.method(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">jump</span>()&#123;<br>    <span class=\"hljs-meta\">@Override</span><br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">jump</span><span class=\"hljs-params\">()</span><br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;狗跳高&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>直接穿一个匿名内部类参数给 method 方法，就不用新建文件重新定义类了。</p>\n"},{"title":"Java 学习博客_12 入门——常用 API","date":"2022-05-04T16:00:00.000Z","_content":"\n\n\n以黑马程序员全套Java教程网课为主。\n\n# Math\n\n不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。\n\n| 方法                                        | 说明                                     |\n| ------------------------------------------- | ---------------------------------------- |\n| public static int abs(int a)                | 绝对值，支持 double  float int long 类型 |\n| public static double ceil(double a)         | 向上取整，返回一个 double 值             |\n| public static double floor(double a)        | 向下取整，返回一个 double 值             |\n| public static int round(float a)            | 四舍五入                                 |\n| public static int max(int a,int b)          |                                          |\n| public static int min(int a,int b)          |                                          |\n| public static double pow(double a,double b) | a 的 b 次幂                              |\n| public static double random()               | 随机数，范围 [0.0,1.0)                   |\n\n随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用`random()*100`。\n\n# System\n\n不用导包，不能实例化，static\n\n| 方法                                   | 说明                                               |\n| -------------------------------------- | -------------------------------------------------- |\n| public static void exit(int status)    | 终止运行 JVM，非零表示非正常终止                   |\n| public static long currentTimeMillis() | 返回当前时间到1970年1月1日的时间间隔，以毫秒为单位 |\n\ncurrentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。\n\n# Object\n\nObject 类是所有类的根类。\n\n| 方法                              | 说明                                                   |\n| --------------------------------- | ------------------------------------------------------ |\n| public String toString()          | 返回对象的字符串表示形式。建议子类全部重写该方法       |\n| public boolean equals(Object obj) | 比较对象是否相等（默认比较地址）。重写可以比较对象内容 |\n\n\n\n## toString() 方法\n\nObject 中包含 toString 方法\n\n```java\npublic String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n输出类名@+一串哈希值。\n\n一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter / setter 一样自动生成。类似：\n\n```java\n//手动实现\npublic String toString(){\nreturn \"{ Person:name=\" + name +\" age=\" + age+\"}\";// name 和 age 都是本类中的成员变量\n}\n```\n\n## equals\n\n`s1.equals(s2)`本质上是比较两个对象的地址，肯定是 false。\n\n一般也会重写/自动生成可以比较两个对象内容是否一致的方法。\n\n```java\npublic boolean equals(Object o) {\n    if (this==o) return true; //同一个对象\n    if(o==null||getClass()!=o.getClass()) return false;//o是空对象，或这两个对象不属于一个类\n    Student student=(Student) o;//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来\n    if (age!=student.age)return false; \n    return name!=null?name.equals(student.name):student.name==null;//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用\n}\n```\n\n# Arrays 类\n\n需要导包 `java.util.Arrays`，不能创建对象，成员是 static的。\n\n| 方法                                   | 说明                              |\n| -------------------------------------- | --------------------------------- |\n| public static String toString(int[] a) | 返回形如 \"[a, b, c]\" 的字符串形式 |\n| public static void sort(int[] a)       | 按数字顺序排列指定的数组          |\n\n# 补充：工具类\n\n以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。\n\n不能创建对象的方法是：\n\n```java \npublic Math(){};\npublic Arrays(){};\npublic System(){};\n```\n\n自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。\n\n# 基本类型包装类\n\n其中有一些方法能更好地处理基本数据类型。\n\n包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean\n\n## 方法示例\n\n| 方法                                    | 说明                          |\n| --------------------------------------- | ----------------------------- |\n| public static Integer valueOf(int i)    | 把 int 转换为 Integer 类型    |\n| public static Integer valueOf(String s) | 把 String 转换为 Integer 类型 |\n\npublic String[] split(String regex) 把给定字符串用 regex 分隔开。\n\n如给定字符串 s 是\"1 2 3 4\"，`s.split(\" \")`就会得到4个字符串：\"1\"\"2\"\"3\"\"4\"。\n\n## 基本类型转换\n\nint -> String：\n\n① 空字符串\"\"+int 类型\n\n② String s=String.valueOf(i)\n\nString -> int：\n\n① Integer in=Integer.valueOf(s);\n\nint i=intValue(in);\n\n② int i=Integer.parseInt(s);\n\n## 自动装箱和拆箱\n\n装箱：基本类型->对应的包装类型\n\n拆箱：包装类型->基本类型\n\n```java\nInteger i=Integer.valueOf(100);//装箱\nInteger ii=100;//自动装箱\n\nii=ii.intValue()+200;//拆箱\nii+=200;//自动拆箱\n\nInteger i3=null;\ni3+=300;//NullPointerException。因此对象使用之前最好先判断是否为 null\n```\n\n# 日期类\n\n## Date\n\nDate 类，需要导包。**注意是 java.util 下的，而不是 java.sql 下的！**java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。\n\n| 方法                           | 说明                                                   |\n| ------------------------------ | ------------------------------------------------------ |\n| public Date()                  | 初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒 |\n| public Date(long Date)         | 分配一个 Date 对象，值为从标准时间起指定的毫秒数       |\n| public long getTime()          | 获取日期对象从标准时间到现在的毫秒数                   |\n| public void setTime(long time) | 设置时间，单位为毫秒                                   |\n\n```java\n//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份\n\nlong d=1000*60*60;\nDate da=new Date(d);//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）\n\nlong time=System.currentTimeMillis();//可以这样获取当前时间，然后传给 Date() 或 setTime()\n```\n\n## SimpleDateFormat\n\n可以自己设置日期格式。\n\n| 方法                                    | 说明                                 |\n| --------------------------------------- | ------------------------------------ |\n| public SimpleDateFormat()               | 构造方法，并使用系统默认的 Date 格式 |\n| public SimpleDateFormat(String pattern) | 构造方法，并使用自己规定的格式       |\n| public final String format(Date d)      | 将日期对象转换为相应格式的字符串     |\n| public final Date parse(String s)       | 将字符串转换为日期                   |\n\n```java\npublic static void main(String[] args) throws Parse Exception{//结尾要加一些东西，在 IDEA 中可以自动补全\n    Date d=new Date;//被分配时的时间\n    SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年-MM月-dd日 HH:mm:ss\");\n    String s=sdf.format(d);\n    System.out.println(s);//输出格式就形如 2022年-05月-05日 10:24:00\n    \n    String ss=\"2022-05-05 10:24:00\";\n    SimpleDateFormat sdf1=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    Date d1=sdf1.parse(ss);\n}\n```\n\ny 年 M 月 d 日\n\nH 时 m 分 s 秒\n\n（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把Date转换为String和把String转换为Date；这两个方法可以设置两个传入参数：\n\npublic static String dateToString(Date d, String format)\n\npublic static String StringTodate(String s, String format)\n\n在方法内根据传入的字符串格式，利用SimpleDateFormat的方法进行转换。）\n\n## Calendar 类\n\n需要导包`java.util.Calendar`，是一个抽象类。\n\n为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。\n\nCalendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？\n\n```java\nCalendar rightnow=Calendar.getInstance();\n```\n\n其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。\n\n| 方法                                                 | 说明                    |\n| ---------------------------------------------------- | ----------------------- |\n| public int get(int field)                            | 获取给定日历字段的值    |\n| public abstract void add(int field, int amount)      | 添加/减去给定的日历字段 |\n| public final void set(int year, int month, int date) | 设置日历的年月日        |\n\n```java\ny=c.get(Calendar.YEAR);\nm=c.get(Calendar.MONTH)+1;//month 是从0开始的，所以要+1\nd=c.get(Calendar.DATE);\n\n//例：求2020年2月有多少天?\nCalendar c=Calendar.getInstance();\nc.set(2020,2,1);//设置为3月1日\nc.add(Calendar.DATE,-1);//倒退1天，就是2月的最后一天\nSystem.out.println(\"2020年2月有\"+c.get(Calendar.DATE)+\"天\");\n```\n\n","source":"_posts/Java 学习博客_12 入门——常用 API.md","raw":"---\ntitle: Java 学习博客_12 入门——常用 API\ndate: 2022-5-5\ntags: study\ncategory: java\n---\n\n\n\n以黑马程序员全套Java教程网课为主。\n\n# Math\n\n不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。\n\n| 方法                                        | 说明                                     |\n| ------------------------------------------- | ---------------------------------------- |\n| public static int abs(int a)                | 绝对值，支持 double  float int long 类型 |\n| public static double ceil(double a)         | 向上取整，返回一个 double 值             |\n| public static double floor(double a)        | 向下取整，返回一个 double 值             |\n| public static int round(float a)            | 四舍五入                                 |\n| public static int max(int a,int b)          |                                          |\n| public static int min(int a,int b)          |                                          |\n| public static double pow(double a,double b) | a 的 b 次幂                              |\n| public static double random()               | 随机数，范围 [0.0,1.0)                   |\n\n随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用`random()*100`。\n\n# System\n\n不用导包，不能实例化，static\n\n| 方法                                   | 说明                                               |\n| -------------------------------------- | -------------------------------------------------- |\n| public static void exit(int status)    | 终止运行 JVM，非零表示非正常终止                   |\n| public static long currentTimeMillis() | 返回当前时间到1970年1月1日的时间间隔，以毫秒为单位 |\n\ncurrentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。\n\n# Object\n\nObject 类是所有类的根类。\n\n| 方法                              | 说明                                                   |\n| --------------------------------- | ------------------------------------------------------ |\n| public String toString()          | 返回对象的字符串表示形式。建议子类全部重写该方法       |\n| public boolean equals(Object obj) | 比较对象是否相等（默认比较地址）。重写可以比较对象内容 |\n\n\n\n## toString() 方法\n\nObject 中包含 toString 方法\n\n```java\npublic String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n\n输出类名@+一串哈希值。\n\n一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter / setter 一样自动生成。类似：\n\n```java\n//手动实现\npublic String toString(){\nreturn \"{ Person:name=\" + name +\" age=\" + age+\"}\";// name 和 age 都是本类中的成员变量\n}\n```\n\n## equals\n\n`s1.equals(s2)`本质上是比较两个对象的地址，肯定是 false。\n\n一般也会重写/自动生成可以比较两个对象内容是否一致的方法。\n\n```java\npublic boolean equals(Object o) {\n    if (this==o) return true; //同一个对象\n    if(o==null||getClass()!=o.getClass()) return false;//o是空对象，或这两个对象不属于一个类\n    Student student=(Student) o;//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来\n    if (age!=student.age)return false; \n    return name!=null?name.equals(student.name):student.name==null;//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用\n}\n```\n\n# Arrays 类\n\n需要导包 `java.util.Arrays`，不能创建对象，成员是 static的。\n\n| 方法                                   | 说明                              |\n| -------------------------------------- | --------------------------------- |\n| public static String toString(int[] a) | 返回形如 \"[a, b, c]\" 的字符串形式 |\n| public static void sort(int[] a)       | 按数字顺序排列指定的数组          |\n\n# 补充：工具类\n\n以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。\n\n不能创建对象的方法是：\n\n```java \npublic Math(){};\npublic Arrays(){};\npublic System(){};\n```\n\n自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。\n\n# 基本类型包装类\n\n其中有一些方法能更好地处理基本数据类型。\n\n包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean\n\n## 方法示例\n\n| 方法                                    | 说明                          |\n| --------------------------------------- | ----------------------------- |\n| public static Integer valueOf(int i)    | 把 int 转换为 Integer 类型    |\n| public static Integer valueOf(String s) | 把 String 转换为 Integer 类型 |\n\npublic String[] split(String regex) 把给定字符串用 regex 分隔开。\n\n如给定字符串 s 是\"1 2 3 4\"，`s.split(\" \")`就会得到4个字符串：\"1\"\"2\"\"3\"\"4\"。\n\n## 基本类型转换\n\nint -> String：\n\n① 空字符串\"\"+int 类型\n\n② String s=String.valueOf(i)\n\nString -> int：\n\n① Integer in=Integer.valueOf(s);\n\nint i=intValue(in);\n\n② int i=Integer.parseInt(s);\n\n## 自动装箱和拆箱\n\n装箱：基本类型->对应的包装类型\n\n拆箱：包装类型->基本类型\n\n```java\nInteger i=Integer.valueOf(100);//装箱\nInteger ii=100;//自动装箱\n\nii=ii.intValue()+200;//拆箱\nii+=200;//自动拆箱\n\nInteger i3=null;\ni3+=300;//NullPointerException。因此对象使用之前最好先判断是否为 null\n```\n\n# 日期类\n\n## Date\n\nDate 类，需要导包。**注意是 java.util 下的，而不是 java.sql 下的！**java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。\n\n| 方法                           | 说明                                                   |\n| ------------------------------ | ------------------------------------------------------ |\n| public Date()                  | 初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒 |\n| public Date(long Date)         | 分配一个 Date 对象，值为从标准时间起指定的毫秒数       |\n| public long getTime()          | 获取日期对象从标准时间到现在的毫秒数                   |\n| public void setTime(long time) | 设置时间，单位为毫秒                                   |\n\n```java\n//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份\n\nlong d=1000*60*60;\nDate da=new Date(d);//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）\n\nlong time=System.currentTimeMillis();//可以这样获取当前时间，然后传给 Date() 或 setTime()\n```\n\n## SimpleDateFormat\n\n可以自己设置日期格式。\n\n| 方法                                    | 说明                                 |\n| --------------------------------------- | ------------------------------------ |\n| public SimpleDateFormat()               | 构造方法，并使用系统默认的 Date 格式 |\n| public SimpleDateFormat(String pattern) | 构造方法，并使用自己规定的格式       |\n| public final String format(Date d)      | 将日期对象转换为相应格式的字符串     |\n| public final Date parse(String s)       | 将字符串转换为日期                   |\n\n```java\npublic static void main(String[] args) throws Parse Exception{//结尾要加一些东西，在 IDEA 中可以自动补全\n    Date d=new Date;//被分配时的时间\n    SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年-MM月-dd日 HH:mm:ss\");\n    String s=sdf.format(d);\n    System.out.println(s);//输出格式就形如 2022年-05月-05日 10:24:00\n    \n    String ss=\"2022-05-05 10:24:00\";\n    SimpleDateFormat sdf1=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    Date d1=sdf1.parse(ss);\n}\n```\n\ny 年 M 月 d 日\n\nH 时 m 分 s 秒\n\n（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把Date转换为String和把String转换为Date；这两个方法可以设置两个传入参数：\n\npublic static String dateToString(Date d, String format)\n\npublic static String StringTodate(String s, String format)\n\n在方法内根据传入的字符串格式，利用SimpleDateFormat的方法进行转换。）\n\n## Calendar 类\n\n需要导包`java.util.Calendar`，是一个抽象类。\n\n为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。\n\nCalendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？\n\n```java\nCalendar rightnow=Calendar.getInstance();\n```\n\n其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。\n\n| 方法                                                 | 说明                    |\n| ---------------------------------------------------- | ----------------------- |\n| public int get(int field)                            | 获取给定日历字段的值    |\n| public abstract void add(int field, int amount)      | 添加/减去给定的日历字段 |\n| public final void set(int year, int month, int date) | 设置日历的年月日        |\n\n```java\ny=c.get(Calendar.YEAR);\nm=c.get(Calendar.MONTH)+1;//month 是从0开始的，所以要+1\nd=c.get(Calendar.DATE);\n\n//例：求2020年2月有多少天?\nCalendar c=Calendar.getInstance();\nc.set(2020,2,1);//设置为3月1日\nc.add(Calendar.DATE,-1);//倒退1天，就是2月的最后一天\nSystem.out.println(\"2020年2月有\"+c.get(Calendar.DATE)+\"天\");\n```\n\n","slug":"Java 学习博客_12 入门——常用 API","published":1,"updated":"2022-05-05T02:50:22.594Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2sexu6y0003r4v2f5sg4e84","content":"<p>以黑马程序员全套Java教程网课为主。</p>\n<h1 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h1><p>不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static int abs(int a)</td>\n<td>绝对值，支持 double  float int long 类型</td>\n</tr>\n<tr>\n<td>public static double ceil(double a)</td>\n<td>向上取整，返回一个 double 值</td>\n</tr>\n<tr>\n<td>public static double floor(double a)</td>\n<td>向下取整，返回一个 double 值</td>\n</tr>\n<tr>\n<td>public static int round(float a)</td>\n<td>四舍五入</td>\n</tr>\n<tr>\n<td>public static int max(int a,int b)</td>\n<td></td>\n</tr>\n<tr>\n<td>public static int min(int a,int b)</td>\n<td></td>\n</tr>\n<tr>\n<td>public static double pow(double a,double b)</td>\n<td>a 的 b 次幂</td>\n</tr>\n<tr>\n<td>public static double random()</td>\n<td>随机数，范围 [0.0,1.0)</td>\n</tr>\n</tbody></table>\n<p>随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用<code>random()*100</code>。</p>\n<h1 id=\"System\"><a href=\"#System\" class=\"headerlink\" title=\"System\"></a>System</h1><p>不用导包，不能实例化，static</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static void exit(int status)</td>\n<td>终止运行 JVM，非零表示非正常终止</td>\n</tr>\n<tr>\n<td>public static long currentTimeMillis()</td>\n<td>返回当前时间到1970年1月1日的时间间隔，以毫秒为单位</td>\n</tr>\n</tbody></table>\n<p>currentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。</p>\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><p>Object 类是所有类的根类。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public String toString()</td>\n<td>返回对象的字符串表示形式。建议子类全部重写该方法</td>\n</tr>\n<tr>\n<td>public boolean equals(Object obj)</td>\n<td>比较对象是否相等（默认比较地址）。重写可以比较对象内容</td>\n</tr>\n</tbody></table>\n<h2 id=\"toString-方法\"><a href=\"#toString-方法\" class=\"headerlink\" title=\"toString() 方法\"></a>toString() 方法</h2><p>Object 中包含 toString 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> getClass().getName() + <span class=\"hljs-string\">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出类名@+一串哈希值。</p>\n<p>一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter / setter 一样自动生成。类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//手动实现</span><br><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&#123; Person:name=&quot;</span> + name +<span class=\"hljs-string\">&quot; age=&quot;</span> + age+<span class=\"hljs-string\">&quot;&#125;&quot;</span>;<span class=\"hljs-comment\">// name 和 age 都是本类中的成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h2><p><code>s1.equals(s2)</code>本质上是比较两个对象的地址，肯定是 false。</p>\n<p>一般也会重写/自动生成可以比较两个对象内容是否一致的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">equals</span><span class=\"hljs-params\">(Object o)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>==o) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//同一个对象</span><br>    <span class=\"hljs-keyword\">if</span>(o==<span class=\"hljs-literal\">null</span>||getClass()!=o.getClass()) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//o是空对象，或这两个对象不属于一个类</span><br>    Student student=(Student) o;<span class=\"hljs-comment\">//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来</span><br>    <span class=\"hljs-keyword\">if</span> (age!=student.age)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <br>    <span class=\"hljs-keyword\">return</span> name!=<span class=\"hljs-literal\">null</span>?name.equals(student.name):student.name==<span class=\"hljs-literal\">null</span>;<span class=\"hljs-comment\">//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Arrays-类\"><a href=\"#Arrays-类\" class=\"headerlink\" title=\"Arrays 类\"></a>Arrays 类</h1><p>需要导包 <code>java.util.Arrays</code>，不能创建对象，成员是 static的。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static String toString(int[] a)</td>\n<td>返回形如 “[a, b, c]” 的字符串形式</td>\n</tr>\n<tr>\n<td>public static void sort(int[] a)</td>\n<td>按数字顺序排列指定的数组</td>\n</tr>\n</tbody></table>\n<h1 id=\"补充：工具类\"><a href=\"#补充：工具类\" class=\"headerlink\" title=\"补充：工具类\"></a>补充：工具类</h1><p>以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。</p>\n<p>不能创建对象的方法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Math</span><span class=\"hljs-params\">()</span>&#123;&#125;;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Arrays</span><span class=\"hljs-params\">()</span>&#123;&#125;;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">System</span><span class=\"hljs-params\">()</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。</p>\n<h1 id=\"基本类型包装类\"><a href=\"#基本类型包装类\" class=\"headerlink\" title=\"基本类型包装类\"></a>基本类型包装类</h1><p>其中有一些方法能更好地处理基本数据类型。</p>\n<p>包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p>\n<h2 id=\"方法示例\"><a href=\"#方法示例\" class=\"headerlink\" title=\"方法示例\"></a>方法示例</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static Integer valueOf(int i)</td>\n<td>把 int 转换为 Integer 类型</td>\n</tr>\n<tr>\n<td>public static Integer valueOf(String s)</td>\n<td>把 String 转换为 Integer 类型</td>\n</tr>\n</tbody></table>\n<p>public String[] split(String regex) 把给定字符串用 regex 分隔开。</p>\n<p>如给定字符串 s 是”1 2 3 4”，<code>s.split(&quot; &quot;)</code>就会得到4个字符串：”1””2””3””4”。</p>\n<h2 id=\"基本类型转换\"><a href=\"#基本类型转换\" class=\"headerlink\" title=\"基本类型转换\"></a>基本类型转换</h2><p>int -&gt; String：</p>\n<p>① 空字符串””+int 类型</p>\n<p>② String s=String.valueOf(i)</p>\n<p>String -&gt; int：</p>\n<p>① Integer in=Integer.valueOf(s);</p>\n<p>int i=intValue(in);</p>\n<p>② int i=Integer.parseInt(s);</p>\n<h2 id=\"自动装箱和拆箱\"><a href=\"#自动装箱和拆箱\" class=\"headerlink\" title=\"自动装箱和拆箱\"></a>自动装箱和拆箱</h2><p>装箱：基本类型-&gt;对应的包装类型</p>\n<p>拆箱：包装类型-&gt;基本类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Integer i=Integer.valueOf(<span class=\"hljs-number\">100</span>);<span class=\"hljs-comment\">//装箱</span><br>Integer ii=<span class=\"hljs-number\">100</span>;<span class=\"hljs-comment\">//自动装箱</span><br><br>ii=ii.intValue()+<span class=\"hljs-number\">200</span>;<span class=\"hljs-comment\">//拆箱</span><br>ii+=<span class=\"hljs-number\">200</span>;<span class=\"hljs-comment\">//自动拆箱</span><br><br>Integer i3=<span class=\"hljs-literal\">null</span>;<br>i3+=<span class=\"hljs-number\">300</span>;<span class=\"hljs-comment\">//NullPointerException。因此对象使用之前最好先判断是否为 null</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"日期类\"><a href=\"#日期类\" class=\"headerlink\" title=\"日期类\"></a>日期类</h1><h2 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h2><p>Date 类，需要导包。<strong>注意是 java.util 下的，而不是 java.sql 下的！</strong>java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public Date()</td>\n<td>初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒</td>\n</tr>\n<tr>\n<td>public Date(long Date)</td>\n<td>分配一个 Date 对象，值为从标准时间起指定的毫秒数</td>\n</tr>\n<tr>\n<td>public long getTime()</td>\n<td>获取日期对象从标准时间到现在的毫秒数</td>\n</tr>\n<tr>\n<td>public void setTime(long time)</td>\n<td>设置时间，单位为毫秒</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份</span><br><br><span class=\"hljs-type\">long</span> d=<span class=\"hljs-number\">1000</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>;<br>Date da=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(d);<span class=\"hljs-comment\">//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）</span><br><br><span class=\"hljs-type\">long</span> time=System.currentTimeMillis();<span class=\"hljs-comment\">//可以这样获取当前时间，然后传给 Date() 或 setTime()</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SimpleDateFormat\"><a href=\"#SimpleDateFormat\" class=\"headerlink\" title=\"SimpleDateFormat\"></a>SimpleDateFormat</h2><p>可以自己设置日期格式。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public SimpleDateFormat()</td>\n<td>构造方法，并使用系统默认的 Date 格式</td>\n</tr>\n<tr>\n<td>public SimpleDateFormat(String pattern)</td>\n<td>构造方法，并使用自己规定的格式</td>\n</tr>\n<tr>\n<td>public final String format(Date d)</td>\n<td>将日期对象转换为相应格式的字符串</td>\n</tr>\n<tr>\n<td>public final Date parse(String s)</td>\n<td>将字符串转换为日期</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Parse Exception&#123;<span class=\"hljs-comment\">//结尾要加一些东西，在 IDEA 中可以自动补全</span><br>    Date d=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>;<span class=\"hljs-comment\">//被分配时的时间</span><br>    SimpleDateFormat sdf=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy年-MM月-dd日 HH:mm:ss&quot;</span>);<br>    String s=sdf.format(d);<br>    System.out.println(s);<span class=\"hljs-comment\">//输出格式就形如 2022年-05月-05日 10:24:00</span><br>    <br>    String ss=<span class=\"hljs-string\">&quot;2022-05-05 10:24:00&quot;</span>;<br>    SimpleDateFormat sdf1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    Date d1=sdf1.parse(ss);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>y 年 M 月 d 日</p>\n<p>H 时 m 分 s 秒</p>\n<p>（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把Date转换为String和把String转换为Date；这两个方法可以设置两个传入参数：</p>\n<p>public static String dateToString(Date d, String format)</p>\n<p>public static String StringTodate(String s, String format)</p>\n<p>在方法内根据传入的字符串格式，利用SimpleDateFormat的方法进行转换。）</p>\n<h2 id=\"Calendar-类\"><a href=\"#Calendar-类\" class=\"headerlink\" title=\"Calendar 类\"></a>Calendar 类</h2><p>需要导包<code>java.util.Calendar</code>，是一个抽象类。</p>\n<p>为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。</p>\n<p>Calendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Calendar rightnow=Calendar.getInstance();<br></code></pre></td></tr></table></figure>\n\n<p>其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public int get(int field)</td>\n<td>获取给定日历字段的值</td>\n</tr>\n<tr>\n<td>public abstract void add(int field, int amount)</td>\n<td>添加/减去给定的日历字段</td>\n</tr>\n<tr>\n<td>public final void set(int year, int month, int date)</td>\n<td>设置日历的年月日</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">y=c.get(Calendar.YEAR);<br>m=c.get(Calendar.MONTH)+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//month 是从0开始的，所以要+1</span><br>d=c.get(Calendar.DATE);<br><br><span class=\"hljs-comment\">//例：求2020年2月有多少天?</span><br>Calendar c=Calendar.getInstance();<br>c.set(<span class=\"hljs-number\">2020</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//设置为3月1日</span><br>c.add(Calendar.DATE,-<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//倒退1天，就是2月的最后一天</span><br>System.out.println(<span class=\"hljs-string\">&quot;2020年2月有&quot;</span>+c.get(Calendar.DATE)+<span class=\"hljs-string\">&quot;天&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>以黑马程序员全套Java教程网课为主。</p>\n<h1 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h1><p>不用导包，成员变量、方法都带有static修饰，可以直接通过类名访问。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static int abs(int a)</td>\n<td>绝对值，支持 double  float int long 类型</td>\n</tr>\n<tr>\n<td>public static double ceil(double a)</td>\n<td>向上取整，返回一个 double 值</td>\n</tr>\n<tr>\n<td>public static double floor(double a)</td>\n<td>向下取整，返回一个 double 值</td>\n</tr>\n<tr>\n<td>public static int round(float a)</td>\n<td>四舍五入</td>\n</tr>\n<tr>\n<td>public static int max(int a,int b)</td>\n<td></td>\n</tr>\n<tr>\n<td>public static int min(int a,int b)</td>\n<td></td>\n</tr>\n<tr>\n<td>public static double pow(double a,double b)</td>\n<td>a 的 b 次幂</td>\n</tr>\n<tr>\n<td>public static double random()</td>\n<td>随机数，范围 [0.0,1.0)</td>\n</tr>\n</tbody></table>\n<p>随机数想要其他范围可以做算术运算。如 [0.0, 100.0)就用<code>random()*100</code>。</p>\n<h1 id=\"System\"><a href=\"#System\" class=\"headerlink\" title=\"System\"></a>System</h1><p>不用导包，不能实例化，static</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static void exit(int status)</td>\n<td>终止运行 JVM，非零表示非正常终止</td>\n</tr>\n<tr>\n<td>public static long currentTimeMillis()</td>\n<td>返回当前时间到1970年1月1日的时间间隔，以毫秒为单位</td>\n</tr>\n</tbody></table>\n<p>currentTimeMillis() 可以整除求得当前年份；可以用两个 currentTimeMillis() 值做差求时间间隔等。</p>\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><p>Object 类是所有类的根类。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public String toString()</td>\n<td>返回对象的字符串表示形式。建议子类全部重写该方法</td>\n</tr>\n<tr>\n<td>public boolean equals(Object obj)</td>\n<td>比较对象是否相等（默认比较地址）。重写可以比较对象内容</td>\n</tr>\n</tbody></table>\n<h2 id=\"toString-方法\"><a href=\"#toString-方法\" class=\"headerlink\" title=\"toString() 方法\"></a>toString() 方法</h2><p>Object 中包含 toString 方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> getClass().getName() + <span class=\"hljs-string\">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出类名@+一串哈希值。</p>\n<p>一般重写 toString() 方法，用于输出简明扼要的类信息。IDEA 中可以像构造方法和 getter / setter 一样自动生成。类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//手动实现</span><br><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span>&#123;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&#123; Person:name=&quot;</span> + name +<span class=\"hljs-string\">&quot; age=&quot;</span> + age+<span class=\"hljs-string\">&quot;&#125;&quot;</span>;<span class=\"hljs-comment\">// name 和 age 都是本类中的成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"equals\"><a href=\"#equals\" class=\"headerlink\" title=\"equals\"></a>equals</h2><p><code>s1.equals(s2)</code>本质上是比较两个对象的地址，肯定是 false。</p>\n<p>一般也会重写/自动生成可以比较两个对象内容是否一致的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">equals</span><span class=\"hljs-params\">(Object o)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>==o) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">//同一个对象</span><br>    <span class=\"hljs-keyword\">if</span>(o==<span class=\"hljs-literal\">null</span>||getClass()!=o.getClass()) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//o是空对象，或这两个对象不属于一个类</span><br>    Student student=(Student) o;<span class=\"hljs-comment\">//因为调用 equals 传参的时候向上转型了，o 变成了 Object 类，要转回来</span><br>    <span class=\"hljs-keyword\">if</span> (age!=student.age)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <br>    <span class=\"hljs-keyword\">return</span> name!=<span class=\"hljs-literal\">null</span>?name.equals(student.name):student.name==<span class=\"hljs-literal\">null</span>;<span class=\"hljs-comment\">//要么 name 都是空字符串，要么相同。equals() 方法只有非空字符串才能调用</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Arrays-类\"><a href=\"#Arrays-类\" class=\"headerlink\" title=\"Arrays 类\"></a>Arrays 类</h1><p>需要导包 <code>java.util.Arrays</code>，不能创建对象，成员是 static的。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static String toString(int[] a)</td>\n<td>返回形如 “[a, b, c]” 的字符串形式</td>\n</tr>\n<tr>\n<td>public static void sort(int[] a)</td>\n<td>按数字顺序排列指定的数组</td>\n</tr>\n</tbody></table>\n<h1 id=\"补充：工具类\"><a href=\"#补充：工具类\" class=\"headerlink\" title=\"补充：工具类\"></a>补充：工具类</h1><p>以上工具类的特点都是：不能创建对象，但是成员方法都是 static 修饰，可以直接用类名访问。</p>\n<p>不能创建对象的方法是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Math</span><span class=\"hljs-params\">()</span>&#123;&#125;;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Arrays</span><span class=\"hljs-params\">()</span>&#123;&#125;;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">System</span><span class=\"hljs-params\">()</span>&#123;&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>自己写了无参构造方法，会把系统默认的无参构造方法覆盖。而该方法又是私有的，因此外界无法访问创建对象。</p>\n<h1 id=\"基本类型包装类\"><a href=\"#基本类型包装类\" class=\"headerlink\" title=\"基本类型包装类\"></a>基本类型包装类</h1><p>其中有一些方法能更好地处理基本数据类型。</p>\n<p>包括：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p>\n<h2 id=\"方法示例\"><a href=\"#方法示例\" class=\"headerlink\" title=\"方法示例\"></a>方法示例</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public static Integer valueOf(int i)</td>\n<td>把 int 转换为 Integer 类型</td>\n</tr>\n<tr>\n<td>public static Integer valueOf(String s)</td>\n<td>把 String 转换为 Integer 类型</td>\n</tr>\n</tbody></table>\n<p>public String[] split(String regex) 把给定字符串用 regex 分隔开。</p>\n<p>如给定字符串 s 是”1 2 3 4”，<code>s.split(&quot; &quot;)</code>就会得到4个字符串：”1””2””3””4”。</p>\n<h2 id=\"基本类型转换\"><a href=\"#基本类型转换\" class=\"headerlink\" title=\"基本类型转换\"></a>基本类型转换</h2><p>int -&gt; String：</p>\n<p>① 空字符串””+int 类型</p>\n<p>② String s=String.valueOf(i)</p>\n<p>String -&gt; int：</p>\n<p>① Integer in=Integer.valueOf(s);</p>\n<p>int i=intValue(in);</p>\n<p>② int i=Integer.parseInt(s);</p>\n<h2 id=\"自动装箱和拆箱\"><a href=\"#自动装箱和拆箱\" class=\"headerlink\" title=\"自动装箱和拆箱\"></a>自动装箱和拆箱</h2><p>装箱：基本类型-&gt;对应的包装类型</p>\n<p>拆箱：包装类型-&gt;基本类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Integer i=Integer.valueOf(<span class=\"hljs-number\">100</span>);<span class=\"hljs-comment\">//装箱</span><br>Integer ii=<span class=\"hljs-number\">100</span>;<span class=\"hljs-comment\">//自动装箱</span><br><br>ii=ii.intValue()+<span class=\"hljs-number\">200</span>;<span class=\"hljs-comment\">//拆箱</span><br>ii+=<span class=\"hljs-number\">200</span>;<span class=\"hljs-comment\">//自动拆箱</span><br><br>Integer i3=<span class=\"hljs-literal\">null</span>;<br>i3+=<span class=\"hljs-number\">300</span>;<span class=\"hljs-comment\">//NullPointerException。因此对象使用之前最好先判断是否为 null</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"日期类\"><a href=\"#日期类\" class=\"headerlink\" title=\"日期类\"></a>日期类</h1><h2 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h2><p>Date 类，需要导包。<strong>注意是 java.util 下的，而不是 java.sql 下的！</strong>java.util 下的 Date 类非最终类，所以可以有子类， java.sql 下的 Date 类就是其子类。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public Date()</td>\n<td>初始化一个 Date 对象，值为其被分配时的时间，精确到毫秒</td>\n</tr>\n<tr>\n<td>public Date(long Date)</td>\n<td>分配一个 Date 对象，值为从标准时间起指定的毫秒数</td>\n</tr>\n<tr>\n<td>public long getTime()</td>\n<td>获取日期对象从标准时间到现在的毫秒数</td>\n</tr>\n<tr>\n<td>public void setTime(long time)</td>\n<td>设置时间，单位为毫秒</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//输出 Date 对象，得到：星期 月份 日期 时 分 秒 CST 年份</span><br><br><span class=\"hljs-type\">long</span> d=<span class=\"hljs-number\">1000</span>*<span class=\"hljs-number\">60</span>*<span class=\"hljs-number\">60</span>;<br>Date da=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(d);<span class=\"hljs-comment\">//标准时间往后1h，即1970.1.1 上午9点（不是1点，因为 CST 有时差）</span><br><br><span class=\"hljs-type\">long</span> time=System.currentTimeMillis();<span class=\"hljs-comment\">//可以这样获取当前时间，然后传给 Date() 或 setTime()</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"SimpleDateFormat\"><a href=\"#SimpleDateFormat\" class=\"headerlink\" title=\"SimpleDateFormat\"></a>SimpleDateFormat</h2><p>可以自己设置日期格式。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public SimpleDateFormat()</td>\n<td>构造方法，并使用系统默认的 Date 格式</td>\n</tr>\n<tr>\n<td>public SimpleDateFormat(String pattern)</td>\n<td>构造方法，并使用自己规定的格式</td>\n</tr>\n<tr>\n<td>public final String format(Date d)</td>\n<td>将日期对象转换为相应格式的字符串</td>\n</tr>\n<tr>\n<td>public final Date parse(String s)</td>\n<td>将字符串转换为日期</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Parse Exception&#123;<span class=\"hljs-comment\">//结尾要加一些东西，在 IDEA 中可以自动补全</span><br>    Date d=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>;<span class=\"hljs-comment\">//被分配时的时间</span><br>    SimpleDateFormat sdf=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy年-MM月-dd日 HH:mm:ss&quot;</span>);<br>    String s=sdf.format(d);<br>    System.out.println(s);<span class=\"hljs-comment\">//输出格式就形如 2022年-05月-05日 10:24:00</span><br>    <br>    String ss=<span class=\"hljs-string\">&quot;2022-05-05 10:24:00&quot;</span>;<br>    SimpleDateFormat sdf1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    Date d1=sdf1.parse(ss);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>y 年 M 月 d 日</p>\n<p>H 时 m 分 s 秒</p>\n<p>（实际运用的时候，也可以让用户自己指定格式。比如单独写一个日期工具类，有两个方法，把Date转换为String和把String转换为Date；这两个方法可以设置两个传入参数：</p>\n<p>public static String dateToString(Date d, String format)</p>\n<p>public static String StringTodate(String s, String format)</p>\n<p>在方法内根据传入的字符串格式，利用SimpleDateFormat的方法进行转换。）</p>\n<h2 id=\"Calendar-类\"><a href=\"#Calendar-类\" class=\"headerlink\" title=\"Calendar 类\"></a>Calendar 类</h2><p>需要导包<code>java.util.Calendar</code>，是一个抽象类。</p>\n<p>为某一时刻和某些日历字段的转换，以及操作日历字段提供了一些方法。</p>\n<p>Calendar 类有一个类方法可以获取 Calendar 对象。可是 Calendar 类不是抽象类吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Calendar rightnow=Calendar.getInstance();<br></code></pre></td></tr></table></figure>\n\n<p>其实这个方法和 Calendar 的直接子类有关，所以这个实例化相当于多态。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public int get(int field)</td>\n<td>获取给定日历字段的值</td>\n</tr>\n<tr>\n<td>public abstract void add(int field, int amount)</td>\n<td>添加/减去给定的日历字段</td>\n</tr>\n<tr>\n<td>public final void set(int year, int month, int date)</td>\n<td>设置日历的年月日</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">y=c.get(Calendar.YEAR);<br>m=c.get(Calendar.MONTH)+<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//month 是从0开始的，所以要+1</span><br>d=c.get(Calendar.DATE);<br><br><span class=\"hljs-comment\">//例：求2020年2月有多少天?</span><br>Calendar c=Calendar.getInstance();<br>c.set(<span class=\"hljs-number\">2020</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//设置为3月1日</span><br>c.add(Calendar.DATE,-<span class=\"hljs-number\">1</span>);<span class=\"hljs-comment\">//倒退1天，就是2月的最后一天</span><br>System.out.println(<span class=\"hljs-string\">&quot;2020年2月有&quot;</span>+c.get(Calendar.DATE)+<span class=\"hljs-string\">&quot;天&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Java 学习博客_13 入门——异常","date":"2022-05-06T16:00:00.000Z","_content":"\n\n\n有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。\n\n# Throwable\n\nThrowable 是所有错误、异常的父类。\n\n```mermaid\ngraph LR\nA[Throwable]-->B[Error]\nA-->C[异常]\nC-->R[RuntimeException 运行型异常]\nC-->O[其他 编译型异常]\n```\n\nError 程序无法处理，而异常程序可以处理。\n\nRuntimeException：运行时异常，非受检异常， 可以先不处理，真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。\n\n编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。\n\n# 处理异常\n\nJVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。\n\n程序员还可以有自己的处理异常方法，如 try...catch 和 throw。\n\n## try...catch\n\n```java\ntry{\n    可能出现异常的代码;\n}\ncatch(异常类名 变量名){\n    出现异常后的处理代码;\n}\n\nString s=\"2022-05-07\";\nSimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-mm-dd\");\nsdf.parse(s);//这个方法不能直接用，必须要加异常处理\n\ntry{\n    sdf.parse(s);\n}\ncatch(ParseException e){\n    System.out.print(\"parseException!\");//不管会不会发生异常，都要写\n}\n```\n\n出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，**处理完成后可以继续执行。**\n\n如果异常变量命名为 e ,尝试调用 e 的成员方法`e.printStackTrace()`就会输出平时出现异常时系统默认提示的信息：`java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... `\n\n但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。\n\n### Throwable 的成员方法\n\nThrowable 作为超类，其所有子类都可以使用他的成员方法。\n\n| 方法                          | 说明                              |\n| ----------------------------- | --------------------------------- |\n| public String getMessage()    | 返回此 Throwable 的详细消息字符串 |\n| public String toString()      | 返回此可抛出的简短描述            |\n| public void printStackTrace() | 把异常的错误信息输出到控制台      |\n\n```\ne.getMessage():  Index 3 out of bounds for length 3\ne.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\ne.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....\n```\n\n利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：\n\n```java\npublic class Throwable {\n    private String detailMessage;//Throwable 类中的一个成员方法\n    \n    public Throwable(String message){\n        detailMessage=message;//构造方法。出现异常时，会通过这种方法构造一个异常对象\n    }\n    \n    public String getMessage(){\n        return detailMessage;\n    }\n}\n```\n\n## Throws\n\n可以抛出异常给 try catch 处理，但是自身不能解决。\n\n```java\nthrows 异常类名;\n\npublic static void main(String[] args){\n    System.out.println(\"运行开始\");\n    method1();\n    try{\n        method2();//抛出给了 try catch 处理\n    }\n    catch(ParseException e)\n    {\n        System.out.println(\"运行错误\");\n    }\n    System.out.println(\"运行结束\");\n}\n\npublic static void method1() throws ArrayIndexOutOfException{\n    int[] arr={1,2,3};\n    System.out.println(arr[3]);//会报错并停止运行， throws 并没有解决异常\n}\n\npublic static void method2() throws ParseException{\n    String s=\"2022-05-07\";\n\tSimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-mm-dd\");\n\tsdf.parse(s);//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。\n}\n```\n\n# 自定义异常\n\n```java\npublic class 类名 extends Exception{\n    无参构造\n    带参构造\n}\n\npublic class ScoreException extends Exception{\n    public ScoreException(){}\n    public ScoreException(message){\n        super(message);//把 message 传给父类处理\n    }\n}\n\n//异常类的使用\npublic class Teacher throws ScoreException{\n    public void checkScore(int score)\n    {\n        if(score<0||score>100){\n            throw new ScoreException(\"输入分数有误！请重新输入\");//throw 不是 throws!\n            /*throw 写在方法体内，throws 写在类定义里。\n            throws 不一定有异常，而 throw 一定是抛出了异常。*/\n        }\n        else\n            System.out.println(\"分数正常\");\n    }\n}\n\npublic static void main(String[] args){\n    Scanner sc=new Scanner(System.in);\n    int score=sc.nextInt();\n    Teacher t=new Teacher();\n    try{//调用方法时，要处理抛过来的异常\n        t.checkScore(score);\n    }\n    catch(ScoreException e){\n        e.printStackTrace();\n    }\n}\n//异常时就会输出：异常类型 ScoreException，异常原因\"输入分数有误！请重新输入\"，异常位置。\n```\n\n","source":"_posts/Java 学习博客_13 入门——异常.md","raw":"---\ntitle: Java 学习博客_13 入门——异常\ndate: 2022-05-07\ntags: study\ncategory: java\n---\n\n\n\n有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。\n\n# Throwable\n\nThrowable 是所有错误、异常的父类。\n\n```mermaid\ngraph LR\nA[Throwable]-->B[Error]\nA-->C[异常]\nC-->R[RuntimeException 运行型异常]\nC-->O[其他 编译型异常]\n```\n\nError 程序无法处理，而异常程序可以处理。\n\nRuntimeException：运行时异常，非受检异常， 可以先不处理，真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。\n\n编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。\n\n# 处理异常\n\nJVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。\n\n程序员还可以有自己的处理异常方法，如 try...catch 和 throw。\n\n## try...catch\n\n```java\ntry{\n    可能出现异常的代码;\n}\ncatch(异常类名 变量名){\n    出现异常后的处理代码;\n}\n\nString s=\"2022-05-07\";\nSimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-mm-dd\");\nsdf.parse(s);//这个方法不能直接用，必须要加异常处理\n\ntry{\n    sdf.parse(s);\n}\ncatch(ParseException e){\n    System.out.print(\"parseException!\");//不管会不会发生异常，都要写\n}\n```\n\n出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，**处理完成后可以继续执行。**\n\n如果异常变量命名为 e ,尝试调用 e 的成员方法`e.printStackTrace()`就会输出平时出现异常时系统默认提示的信息：`java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... `\n\n但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。\n\n### Throwable 的成员方法\n\nThrowable 作为超类，其所有子类都可以使用他的成员方法。\n\n| 方法                          | 说明                              |\n| ----------------------------- | --------------------------------- |\n| public String getMessage()    | 返回此 Throwable 的详细消息字符串 |\n| public String toString()      | 返回此可抛出的简短描述            |\n| public void printStackTrace() | 把异常的错误信息输出到控制台      |\n\n```\ne.getMessage():  Index 3 out of bounds for length 3\ne.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\ne.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....\n```\n\n利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：\n\n```java\npublic class Throwable {\n    private String detailMessage;//Throwable 类中的一个成员方法\n    \n    public Throwable(String message){\n        detailMessage=message;//构造方法。出现异常时，会通过这种方法构造一个异常对象\n    }\n    \n    public String getMessage(){\n        return detailMessage;\n    }\n}\n```\n\n## Throws\n\n可以抛出异常给 try catch 处理，但是自身不能解决。\n\n```java\nthrows 异常类名;\n\npublic static void main(String[] args){\n    System.out.println(\"运行开始\");\n    method1();\n    try{\n        method2();//抛出给了 try catch 处理\n    }\n    catch(ParseException e)\n    {\n        System.out.println(\"运行错误\");\n    }\n    System.out.println(\"运行结束\");\n}\n\npublic static void method1() throws ArrayIndexOutOfException{\n    int[] arr={1,2,3};\n    System.out.println(arr[3]);//会报错并停止运行， throws 并没有解决异常\n}\n\npublic static void method2() throws ParseException{\n    String s=\"2022-05-07\";\n\tSimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-mm-dd\");\n\tsdf.parse(s);//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。\n}\n```\n\n# 自定义异常\n\n```java\npublic class 类名 extends Exception{\n    无参构造\n    带参构造\n}\n\npublic class ScoreException extends Exception{\n    public ScoreException(){}\n    public ScoreException(message){\n        super(message);//把 message 传给父类处理\n    }\n}\n\n//异常类的使用\npublic class Teacher throws ScoreException{\n    public void checkScore(int score)\n    {\n        if(score<0||score>100){\n            throw new ScoreException(\"输入分数有误！请重新输入\");//throw 不是 throws!\n            /*throw 写在方法体内，throws 写在类定义里。\n            throws 不一定有异常，而 throw 一定是抛出了异常。*/\n        }\n        else\n            System.out.println(\"分数正常\");\n    }\n}\n\npublic static void main(String[] args){\n    Scanner sc=new Scanner(System.in);\n    int score=sc.nextInt();\n    Teacher t=new Teacher();\n    try{//调用方法时，要处理抛过来的异常\n        t.checkScore(score);\n    }\n    catch(ScoreException e){\n        e.printStackTrace();\n    }\n}\n//异常时就会输出：异常类型 ScoreException，异常原因\"输入分数有误！请重新输入\"，异常位置。\n```\n\n","slug":"Java 学习博客_13 入门——异常","published":1,"updated":"2022-05-07T07:51:50.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2vkltig0000q8v2175i17tj","content":"<p>有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。</p>\n<h1 id=\"Throwable\"><a href=\"#Throwable\" class=\"headerlink\" title=\"Throwable\"></a>Throwable</h1><p>Throwable 是所有错误、异常的父类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR<br>A[Throwable]--&gt;B[Error]<br>A--&gt;C[异常]<br>C--&gt;R[RuntimeException 运行型异常]<br>C--&gt;O[其他 编译型异常]<br></code></pre></td></tr></table></figure>\n\n<p>Error 程序无法处理，而异常程序可以处理。</p>\n<p>RuntimeException：运行时异常，非受检异常， 可以先不处理，真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。</p>\n<p>编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。</p>\n<h1 id=\"处理异常\"><a href=\"#处理异常\" class=\"headerlink\" title=\"处理异常\"></a>处理异常</h1><p>JVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。</p>\n<p>程序员还可以有自己的处理异常方法，如 try…catch 和 throw。</p>\n<h2 id=\"try…catch\"><a href=\"#try…catch\" class=\"headerlink\" title=\"try…catch\"></a>try…catch</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">try</span>&#123;<br>    可能出现异常的代码;<br>&#125;<br><span class=\"hljs-keyword\">catch</span>(异常类名 变量名)&#123;<br>    出现异常后的处理代码;<br>&#125;<br><br>String s=<span class=\"hljs-string\">&quot;2022-05-07&quot;</span>;<br>SimpleDateFormat sdf=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy-mm-dd&quot;</span>);<br>sdf.parse(s);<span class=\"hljs-comment\">//这个方法不能直接用，必须要加异常处理</span><br><br><span class=\"hljs-keyword\">try</span>&#123;<br>    sdf.parse(s);<br>&#125;<br><span class=\"hljs-keyword\">catch</span>(ParseException e)&#123;<br>    System.out.print(<span class=\"hljs-string\">&quot;parseException!&quot;</span>);<span class=\"hljs-comment\">//不管会不会发生异常，都要写</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，<strong>处理完成后可以继续执行。</strong></p>\n<p>如果异常变量命名为 e ,尝试调用 e 的成员方法<code>e.printStackTrace()</code>就会输出平时出现异常时系统默认提示的信息：<code>java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... </code></p>\n<p>但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。</p>\n<h3 id=\"Throwable-的成员方法\"><a href=\"#Throwable-的成员方法\" class=\"headerlink\" title=\"Throwable 的成员方法\"></a>Throwable 的成员方法</h3><p>Throwable 作为超类，其所有子类都可以使用他的成员方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public String getMessage()</td>\n<td>返回此 Throwable 的详细消息字符串</td>\n</tr>\n<tr>\n<td>public String toString()</td>\n<td>返回此可抛出的简短描述</td>\n</tr>\n<tr>\n<td>public void printStackTrace()</td>\n<td>把异常的错误信息输出到控制台</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">e.getMessage():  Index 3 out of bounds for length 3<br>e.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3<br>e.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....<br></code></pre></td></tr></table></figure>\n\n<p>利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Throwable</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> String detailMessage;<span class=\"hljs-comment\">//Throwable 类中的一个成员方法</span><br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Throwable</span><span class=\"hljs-params\">(String message)</span>&#123;<br>        detailMessage=message;<span class=\"hljs-comment\">//构造方法。出现异常时，会通过这种方法构造一个异常对象</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getMessage</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> detailMessage;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Throws\"><a href=\"#Throws\" class=\"headerlink\" title=\"Throws\"></a>Throws</h2><p>可以抛出异常给 try catch 处理，但是自身不能解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">throws</span> 异常类名;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;运行开始&quot;</span>);<br>    method1();<br>    <span class=\"hljs-keyword\">try</span>&#123;<br>        method2();<span class=\"hljs-comment\">//抛出给了 try catch 处理</span><br>    &#125;<br>    <span class=\"hljs-keyword\">catch</span>(ParseException e)<br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;运行错误&quot;</span>);<br>    &#125;<br>    System.out.println(<span class=\"hljs-string\">&quot;运行结束&quot;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method1</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ArrayIndexOutOfException&#123;<br>    <span class=\"hljs-type\">int</span>[] arr=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<br>    System.out.println(arr[<span class=\"hljs-number\">3</span>]);<span class=\"hljs-comment\">//会报错并停止运行， throws 并没有解决异常</span><br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ParseException&#123;<br>    String s=<span class=\"hljs-string\">&quot;2022-05-07&quot;</span>;<br>\tSimpleDateFormat sdf=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy-mm-dd&quot;</span>);<br>\tsdf.parse(s);<span class=\"hljs-comment\">//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> class 类名 <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;<br>    无参构造<br>    带参构造<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ScoreException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ScoreException</span><span class=\"hljs-params\">()</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ScoreException</span><span class=\"hljs-params\">(message)</span>&#123;<br>        <span class=\"hljs-built_in\">super</span>(message);<span class=\"hljs-comment\">//把 message 传给父类处理</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//异常类的使用</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Teacher</span> <span class=\"hljs-keyword\">throws</span> ScoreException&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">checkScore</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> score)</span><br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(score&lt;<span class=\"hljs-number\">0</span>||score&gt;<span class=\"hljs-number\">100</span>)&#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ScoreException</span>(<span class=\"hljs-string\">&quot;输入分数有误！请重新输入&quot;</span>);<span class=\"hljs-comment\">//throw 不是 throws!</span><br>            <span class=\"hljs-comment\">/*throw 写在方法体内，throws 写在类定义里。</span><br><span class=\"hljs-comment\">            throws 不一定有异常，而 throw 一定是抛出了异常。*/</span><br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>            System.out.println(<span class=\"hljs-string\">&quot;分数正常&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>    Scanner sc=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>    <span class=\"hljs-type\">int</span> score=sc.nextInt();<br>    Teacher t=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Teacher</span>();<br>    <span class=\"hljs-keyword\">try</span>&#123;<span class=\"hljs-comment\">//调用方法时，要处理抛过来的异常</span><br>        t.checkScore(score);<br>    &#125;<br>    <span class=\"hljs-keyword\">catch</span>(ScoreException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//异常时就会输出：异常类型 ScoreException，异常原因&quot;输入分数有误！请重新输入&quot;，异常位置。</span><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>有时因为编译错误，会提示一些信息（如：数组越界 ArrayIndexOutOfBoundException) 其实这些提示信息也是类。</p>\n<h1 id=\"Throwable\"><a href=\"#Throwable\" class=\"headerlink\" title=\"Throwable\"></a>Throwable</h1><p>Throwable 是所有错误、异常的父类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR<br>A[Throwable]--&gt;B[Error]<br>A--&gt;C[异常]<br>C--&gt;R[RuntimeException 运行型异常]<br>C--&gt;O[其他 编译型异常]<br></code></pre></td></tr></table></figure>\n\n<p>Error 程序无法处理，而异常程序可以处理。</p>\n<p>RuntimeException：运行时异常，非受检异常， 可以先不处理，真的异常了再进行处理。在编译期间不会检查，其他类错误在编译期间检查。</p>\n<p>编译时异常：受检异常，不管运行会不会异常，都需要进行异常处理，不然无法编译。</p>\n<h1 id=\"处理异常\"><a href=\"#处理异常\" class=\"headerlink\" title=\"处理异常\"></a>处理异常</h1><p>JVM 对异常的默认处理方式：输出异常名称、位置、原因，并停止运行。</p>\n<p>程序员还可以有自己的处理异常方法，如 try…catch 和 throw。</p>\n<h2 id=\"try…catch\"><a href=\"#try…catch\" class=\"headerlink\" title=\"try…catch\"></a>try…catch</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">try</span>&#123;<br>    可能出现异常的代码;<br>&#125;<br><span class=\"hljs-keyword\">catch</span>(异常类名 变量名)&#123;<br>    出现异常后的处理代码;<br>&#125;<br><br>String s=<span class=\"hljs-string\">&quot;2022-05-07&quot;</span>;<br>SimpleDateFormat sdf=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy-mm-dd&quot;</span>);<br>sdf.parse(s);<span class=\"hljs-comment\">//这个方法不能直接用，必须要加异常处理</span><br><br><span class=\"hljs-keyword\">try</span>&#123;<br>    sdf.parse(s);<br>&#125;<br><span class=\"hljs-keyword\">catch</span>(ParseException e)&#123;<br>    System.out.print(<span class=\"hljs-string\">&quot;parseException!&quot;</span>);<span class=\"hljs-comment\">//不管会不会发生异常，都要写</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>出现异常时，异常对象会被提交给 Java 运行时系统，如果和 catch 中的异常类匹配就会进行异常的处理，<strong>处理完成后可以继续执行。</strong></p>\n<p>如果异常变量命名为 e ,尝试调用 e 的成员方法<code>e.printStackTrace()</code>就会输出平时出现异常时系统默认提示的信息：<code>java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method..... </code></p>\n<p>但是通过这种方法处理异常之后，异常后面的部分仍然可以执行。</p>\n<h3 id=\"Throwable-的成员方法\"><a href=\"#Throwable-的成员方法\" class=\"headerlink\" title=\"Throwable 的成员方法\"></a>Throwable 的成员方法</h3><p>Throwable 作为超类，其所有子类都可以使用他的成员方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public String getMessage()</td>\n<td>返回此 Throwable 的详细消息字符串</td>\n</tr>\n<tr>\n<td>public String toString()</td>\n<td>返回此可抛出的简短描述</td>\n</tr>\n<tr>\n<td>public void printStackTrace()</td>\n<td>把异常的错误信息输出到控制台</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">e.getMessage():  Index 3 out of bounds for length 3<br>e.toString(): java . lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3<br>e.printStackTrace(): java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3  at com.ithema_02.ExceptionDemo02.method.....<br></code></pre></td></tr></table></figure>\n\n<p>利用 Ctrl B 追根溯源可以得知， getMessage() 内部大概是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Throwable</span> &#123;<br>    <span class=\"hljs-keyword\">private</span> String detailMessage;<span class=\"hljs-comment\">//Throwable 类中的一个成员方法</span><br>    <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Throwable</span><span class=\"hljs-params\">(String message)</span>&#123;<br>        detailMessage=message;<span class=\"hljs-comment\">//构造方法。出现异常时，会通过这种方法构造一个异常对象</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getMessage</span><span class=\"hljs-params\">()</span>&#123;<br>        <span class=\"hljs-keyword\">return</span> detailMessage;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Throws\"><a href=\"#Throws\" class=\"headerlink\" title=\"Throws\"></a>Throws</h2><p>可以抛出异常给 try catch 处理，但是自身不能解决。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">throws</span> 异常类名;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>    System.out.println(<span class=\"hljs-string\">&quot;运行开始&quot;</span>);<br>    method1();<br>    <span class=\"hljs-keyword\">try</span>&#123;<br>        method2();<span class=\"hljs-comment\">//抛出给了 try catch 处理</span><br>    &#125;<br>    <span class=\"hljs-keyword\">catch</span>(ParseException e)<br>    &#123;<br>        System.out.println(<span class=\"hljs-string\">&quot;运行错误&quot;</span>);<br>    &#125;<br>    System.out.println(<span class=\"hljs-string\">&quot;运行结束&quot;</span>);<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method1</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ArrayIndexOutOfException&#123;<br>    <span class=\"hljs-type\">int</span>[] arr=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>&#125;;<br>    System.out.println(arr[<span class=\"hljs-number\">3</span>]);<span class=\"hljs-comment\">//会报错并停止运行， throws 并没有解决异常</span><br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">method2</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> ParseException&#123;<br>    String s=<span class=\"hljs-string\">&quot;2022-05-07&quot;</span>;<br>\tSimpleDateFormat sdf=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SimpleDateFormat</span>(<span class=\"hljs-string\">&quot;yyyy-mm-dd&quot;</span>);<br>\tsdf.parse(s);<span class=\"hljs-comment\">//因为抛出，可以使用了。如果异常，try catch 会显示“运行结束”并继续运行。</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> class 类名 <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;<br>    无参构造<br>    带参构造<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ScoreException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Exception</span>&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ScoreException</span><span class=\"hljs-params\">()</span>&#123;&#125;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">ScoreException</span><span class=\"hljs-params\">(message)</span>&#123;<br>        <span class=\"hljs-built_in\">super</span>(message);<span class=\"hljs-comment\">//把 message 传给父类处理</span><br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">//异常类的使用</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Teacher</span> <span class=\"hljs-keyword\">throws</span> ScoreException&#123;<br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">checkScore</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> score)</span><br>    &#123;<br>        <span class=\"hljs-keyword\">if</span>(score&lt;<span class=\"hljs-number\">0</span>||score&gt;<span class=\"hljs-number\">100</span>)&#123;<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ScoreException</span>(<span class=\"hljs-string\">&quot;输入分数有误！请重新输入&quot;</span>);<span class=\"hljs-comment\">//throw 不是 throws!</span><br>            <span class=\"hljs-comment\">/*throw 写在方法体内，throws 写在类定义里。</span><br><span class=\"hljs-comment\">            throws 不一定有异常，而 throw 一定是抛出了异常。*/</span><br>        &#125;<br>        <span class=\"hljs-keyword\">else</span><br>            System.out.println(<span class=\"hljs-string\">&quot;分数正常&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span>&#123;<br>    Scanner sc=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);<br>    <span class=\"hljs-type\">int</span> score=sc.nextInt();<br>    Teacher t=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Teacher</span>();<br>    <span class=\"hljs-keyword\">try</span>&#123;<span class=\"hljs-comment\">//调用方法时，要处理抛过来的异常</span><br>        t.checkScore(score);<br>    &#125;<br>    <span class=\"hljs-keyword\">catch</span>(ScoreException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">//异常时就会输出：异常类型 ScoreException，异常原因&quot;输入分数有误！请重新输入&quot;，异常位置。</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"Java 学习博客_14 入门——集合进阶1","date":"2022-05-07T16:00:00.000Z","_content":"\n\n\n```mermaid\ngraph LR\nA[集合]-->C[Collection]\nA-->M[Map]\nC-->L[List]\nC-->S[Set]\nL-->AL(ArrayList)\nL-->LL(LinkedList)\nS-->HS(HashSet)\nS-->TS(TreeSet)\nM-->HM(HashMap)\n```\n\n其中方形的是接口，圆角的是实现类。\n\n因此先学习 Collection 和 Map 接口后，只需要学习下一级的特有的部分。\n\n# Collection\n\njava.util.Collection\n\nCollection 是单例集合的最高级接口。他表示一组对象，这些对象也被称为 Collection 的元素。\n\n无法直接实现。可以用多态的方式实现。\n\n```java\nCollection<String> c=new ArrayList<String>();\n//add(E e) 方法添加元素\nc.add(\"Hello\");\nc.add(\"World\");\nSystem.out.println(c);//输出['Hello','World']，因为 ArrayList 中重写了 toString 方法，所以得到的不是一串地址\n```\n\n| 方法                       | 说明                                      |\n| -------------------------- | ----------------------------------------- |\n| boolean add(E e)           | 添加元素，永远返回 true                   |\n| boolean remove(Object o)   | 从集合中移除指定的元素，成功移除返回 true |\n| void clear()               | 清空集合中的元素                          |\n| boolean contains(Object o) | 判断集合中是否存在指定的元素              |\n| boolean isEmpty()          | 判断集合是否为空                          |\n| int size()                 | 集合长度                                  |\n\n快捷键：Alt+7，能看到类的所有信息\n\n## 迭代器 iterator\n\njava.util.Iterator\n\nIterator 是一个接口。使用 Iterator 迭代器遍历集合元素。\n\n```java\nIterator<String> it=c.iterator();//通过集合对象中的迭代方法获取对象\n```\n\n追根溯源可以得知，Collection.iterator()方法返回的是一个实现了 Iterator 接口的类：Itr.\n\n所以实际上是通过多态的方式实例化的。\n\n| 方法              | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| E next()          | 返回下一个元素（越界访问：NoSuchElementException，被请求的元素不存在） |\n| boolean hasNext() | 如果存在下一个元素，返回 true                                |\n\n```java\nwhile(it.hasNext()){\n    String s=it.next();//这样更好一些，因为元素可能还要做其他操作\n    System.out.println(s);\n}\n```\n\nit.next() 像指针一样从0开始遍历。\n\n# List\n\njava.util.List\n\n继承自 Collection 类，可以使用其中的方法。\n\nList 是有序、有索引的。相较于集合 Set，List 中的元素可以重复。\n\n```java\nList<String> l=new ArrayList<String>();\nl.add(\"Hello\");\nl.add(\"World\");\nSystem.out.println(l);//按存储的顺序输出，[\"Hello\",\"World\"]\n```\n\n| 方法                          | 说明           |\n| ----------------------------- | -------------- |\n| void add(int index,E element) | 感觉并不用解释 |\n| E remove(int index)           |                |\n| E set(int index,E element)    |                |\n| E get(int index)              |                |\n\n越界报错 IndexOutOfException。\n\n另一种遍历集合的方法是 for 循环。\n\n```java\nfor(int i=0;i<l.size();i++)System.out.println(l.get(i));\n```\n\n## 并发修改异常\n\n当不允许这样的修改时，会抛出此方法。\n\n如：在使用 iterator 遍历过程中，在集合中添加了新的元素。\n\niterator 调用 next() 方法时，会先调用 checkForComodification() 方法。\n\ncheckForComodification() 会检验 modCount 修改集合的次数和expectedModCount 预期修改集合的次数是否相等。\n\nmodCount 来自于 ArrayList 的父类：AbstractList，初始值为0.每次使用 add() 方法时，modCount 就会++。\n\nexpectedCount 来自于 Itr 类，且初始值为 `expectedCount=modCount`.\n\n每次实例化一个 Iterator 类，都会调用其子类 Itr 类，使得 expectedCount 等于当前的 modCount。\n\n然后遍历过程中每次调用 next() 方法时，都会先检查一下`expectedCount==modCount`，即集合有没有被修改。如果没有修改就可以顺利地返回下一个元素；如果有异常 checkForComodificationException，就会终止运行。\n\n```mermaid\ngraph TB\nC[Collection]-->|获取迭代对象|I[iterator]\nC-->|多态|Arr[Arraylist]\nI-->|多态|Itr[Itr]\nI-->W{\"iterator.hasNext()==true\"}\nItr-->A(expectedCount=modCount)\nW-->|no|en(遍历结束)\nW-->|yes|N(\"iterator.next()\")\nN-->cf(\"checkForComodification()\")\ncf-->cfe{\"expectedCount==modCount\"}\n\nX-->W\ncfe-->|no|Y(checkForComodificationException)\ncfe-->|yes|X(\"集合没有被修改,继续遍历\")\n```\n\n但是通过 for 循环遍历集合，在遍历过程中对集合进行修改，不会报异常。\n\n## ListInterator\n\n通过 List 中的 listInterator() 方法得到。可以从各个方向遍历，迭代期间可以修改列表，还可以获取列表迭代器的当前位置。\n\n| 方法                  | 说明                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| boolean hasNext()     |                                                              |\n| E next()              |                                                              |\n| boolean hasPrevious() | 反向遍历用到                                                 |\n| E previous()          | 反向遍历用到                                                 |\n| void add(E e)         | 添加元素，**注意是通过 listInterator 添加的，不是通过集合添加的！** |\n|                       |                                                              |\n\n```java\nList<String> l=new ArrayList<String>();\nl.add(\"Hello\");\nl.add(\"World\");\nl.add(\"java\");\nListInterator<String> li=l.listInterator();//实际上是 listItr 类作为 listInterator 类的子类，通过多态实现\nwhile(li.hasNext()){\n    System.out.println(l.next());\n}\n\nwhile(li.hasPrevious()){\n    System.out.println(l.previous());\n}\n\nwhile(li.hasNext()){\n    String s=l.next();\n    if(s.equals(\"World\")){\n        li.add(\"!!!\");//特别注意，并不是调用了l的 add() 方法，而是 li 的 add() 方法！\n    }\n    System.out.println(s);\n}\n```\n\n在 listItr 类中的 add() 方法，添加完元素之后，有一句`expectedModCount=modCount;`重新把实际修改值赋给了预期修改值。因此 next() 方法中判断`expectedModCount==modCount`，即使添加了新元素也仍然是 true. 不会发生并发修改异常。\n\n## 增强 for\n\n```java\nfor(E e:数组或 Collection 的集合)\n{\n\t//在这里使用变量e，把其当做集合元素来用\n}\n\nfor(int i:arr){\n    System.out.println(i);\n}\n\nfor(int i:list){\n    System.out.println(i);\n}\n//内部是一个 iterator 迭代器，不可以中途修改数据，会引发并发修改异常。\n```\n\n## 几种遍历方式的选择\n\n单纯的遍历：增强 for 最简单。\n\n需要用到索引：普通 for。\n\n迭代器也要会用。\n\n# 数据结构\n\n## 栈\n\n后入先出 FILO。\n\n## 队列\n\n先入先出 FIFO。\n\n## 数组\n\n可以根据索引查找，查找效率高；增删效率低。\n\n## 链表\n\n每个结点存储数据和下一个结点的地址值。最后一个结点地址值为空。\n\n相比数组，增删只需要修改增删处前后结点的地址值，效率更高。\n\n但是查询必须从头开始，效率低。\n\n# List 的子类\n\nArrayList 底层数据结构是数组，LinkedList 底层数据结构是链表。\n\n用法一模一样，查询效率高就用 ArrayList，增删效率高用 LinkedList。\n\n## LinkList 特有功能\n\n| 方法                      | 说明 |\n| ------------------------- | ---- |\n| public void addFirst(E e) |      |\n| public void addLast(E e)  |      |\n| public E getFirst()       |      |\n| public E getLast()        |      |\n| public void removeFirst() |      |\n| public void removeLast()  |      |\n\n","source":"_posts/Java 学习博客_14 入门——集合进阶1.md","raw":"---\ntitle: Java 学习博客_14 入门——集合进阶1\ndate: 2022-05-08\ntags: study\ncategory: java\n---\n\n\n\n```mermaid\ngraph LR\nA[集合]-->C[Collection]\nA-->M[Map]\nC-->L[List]\nC-->S[Set]\nL-->AL(ArrayList)\nL-->LL(LinkedList)\nS-->HS(HashSet)\nS-->TS(TreeSet)\nM-->HM(HashMap)\n```\n\n其中方形的是接口，圆角的是实现类。\n\n因此先学习 Collection 和 Map 接口后，只需要学习下一级的特有的部分。\n\n# Collection\n\njava.util.Collection\n\nCollection 是单例集合的最高级接口。他表示一组对象，这些对象也被称为 Collection 的元素。\n\n无法直接实现。可以用多态的方式实现。\n\n```java\nCollection<String> c=new ArrayList<String>();\n//add(E e) 方法添加元素\nc.add(\"Hello\");\nc.add(\"World\");\nSystem.out.println(c);//输出['Hello','World']，因为 ArrayList 中重写了 toString 方法，所以得到的不是一串地址\n```\n\n| 方法                       | 说明                                      |\n| -------------------------- | ----------------------------------------- |\n| boolean add(E e)           | 添加元素，永远返回 true                   |\n| boolean remove(Object o)   | 从集合中移除指定的元素，成功移除返回 true |\n| void clear()               | 清空集合中的元素                          |\n| boolean contains(Object o) | 判断集合中是否存在指定的元素              |\n| boolean isEmpty()          | 判断集合是否为空                          |\n| int size()                 | 集合长度                                  |\n\n快捷键：Alt+7，能看到类的所有信息\n\n## 迭代器 iterator\n\njava.util.Iterator\n\nIterator 是一个接口。使用 Iterator 迭代器遍历集合元素。\n\n```java\nIterator<String> it=c.iterator();//通过集合对象中的迭代方法获取对象\n```\n\n追根溯源可以得知，Collection.iterator()方法返回的是一个实现了 Iterator 接口的类：Itr.\n\n所以实际上是通过多态的方式实例化的。\n\n| 方法              | 说明                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| E next()          | 返回下一个元素（越界访问：NoSuchElementException，被请求的元素不存在） |\n| boolean hasNext() | 如果存在下一个元素，返回 true                                |\n\n```java\nwhile(it.hasNext()){\n    String s=it.next();//这样更好一些，因为元素可能还要做其他操作\n    System.out.println(s);\n}\n```\n\nit.next() 像指针一样从0开始遍历。\n\n# List\n\njava.util.List\n\n继承自 Collection 类，可以使用其中的方法。\n\nList 是有序、有索引的。相较于集合 Set，List 中的元素可以重复。\n\n```java\nList<String> l=new ArrayList<String>();\nl.add(\"Hello\");\nl.add(\"World\");\nSystem.out.println(l);//按存储的顺序输出，[\"Hello\",\"World\"]\n```\n\n| 方法                          | 说明           |\n| ----------------------------- | -------------- |\n| void add(int index,E element) | 感觉并不用解释 |\n| E remove(int index)           |                |\n| E set(int index,E element)    |                |\n| E get(int index)              |                |\n\n越界报错 IndexOutOfException。\n\n另一种遍历集合的方法是 for 循环。\n\n```java\nfor(int i=0;i<l.size();i++)System.out.println(l.get(i));\n```\n\n## 并发修改异常\n\n当不允许这样的修改时，会抛出此方法。\n\n如：在使用 iterator 遍历过程中，在集合中添加了新的元素。\n\niterator 调用 next() 方法时，会先调用 checkForComodification() 方法。\n\ncheckForComodification() 会检验 modCount 修改集合的次数和expectedModCount 预期修改集合的次数是否相等。\n\nmodCount 来自于 ArrayList 的父类：AbstractList，初始值为0.每次使用 add() 方法时，modCount 就会++。\n\nexpectedCount 来自于 Itr 类，且初始值为 `expectedCount=modCount`.\n\n每次实例化一个 Iterator 类，都会调用其子类 Itr 类，使得 expectedCount 等于当前的 modCount。\n\n然后遍历过程中每次调用 next() 方法时，都会先检查一下`expectedCount==modCount`，即集合有没有被修改。如果没有修改就可以顺利地返回下一个元素；如果有异常 checkForComodificationException，就会终止运行。\n\n```mermaid\ngraph TB\nC[Collection]-->|获取迭代对象|I[iterator]\nC-->|多态|Arr[Arraylist]\nI-->|多态|Itr[Itr]\nI-->W{\"iterator.hasNext()==true\"}\nItr-->A(expectedCount=modCount)\nW-->|no|en(遍历结束)\nW-->|yes|N(\"iterator.next()\")\nN-->cf(\"checkForComodification()\")\ncf-->cfe{\"expectedCount==modCount\"}\n\nX-->W\ncfe-->|no|Y(checkForComodificationException)\ncfe-->|yes|X(\"集合没有被修改,继续遍历\")\n```\n\n但是通过 for 循环遍历集合，在遍历过程中对集合进行修改，不会报异常。\n\n## ListInterator\n\n通过 List 中的 listInterator() 方法得到。可以从各个方向遍历，迭代期间可以修改列表，还可以获取列表迭代器的当前位置。\n\n| 方法                  | 说明                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| boolean hasNext()     |                                                              |\n| E next()              |                                                              |\n| boolean hasPrevious() | 反向遍历用到                                                 |\n| E previous()          | 反向遍历用到                                                 |\n| void add(E e)         | 添加元素，**注意是通过 listInterator 添加的，不是通过集合添加的！** |\n|                       |                                                              |\n\n```java\nList<String> l=new ArrayList<String>();\nl.add(\"Hello\");\nl.add(\"World\");\nl.add(\"java\");\nListInterator<String> li=l.listInterator();//实际上是 listItr 类作为 listInterator 类的子类，通过多态实现\nwhile(li.hasNext()){\n    System.out.println(l.next());\n}\n\nwhile(li.hasPrevious()){\n    System.out.println(l.previous());\n}\n\nwhile(li.hasNext()){\n    String s=l.next();\n    if(s.equals(\"World\")){\n        li.add(\"!!!\");//特别注意，并不是调用了l的 add() 方法，而是 li 的 add() 方法！\n    }\n    System.out.println(s);\n}\n```\n\n在 listItr 类中的 add() 方法，添加完元素之后，有一句`expectedModCount=modCount;`重新把实际修改值赋给了预期修改值。因此 next() 方法中判断`expectedModCount==modCount`，即使添加了新元素也仍然是 true. 不会发生并发修改异常。\n\n## 增强 for\n\n```java\nfor(E e:数组或 Collection 的集合)\n{\n\t//在这里使用变量e，把其当做集合元素来用\n}\n\nfor(int i:arr){\n    System.out.println(i);\n}\n\nfor(int i:list){\n    System.out.println(i);\n}\n//内部是一个 iterator 迭代器，不可以中途修改数据，会引发并发修改异常。\n```\n\n## 几种遍历方式的选择\n\n单纯的遍历：增强 for 最简单。\n\n需要用到索引：普通 for。\n\n迭代器也要会用。\n\n# 数据结构\n\n## 栈\n\n后入先出 FILO。\n\n## 队列\n\n先入先出 FIFO。\n\n## 数组\n\n可以根据索引查找，查找效率高；增删效率低。\n\n## 链表\n\n每个结点存储数据和下一个结点的地址值。最后一个结点地址值为空。\n\n相比数组，增删只需要修改增删处前后结点的地址值，效率更高。\n\n但是查询必须从头开始，效率低。\n\n# List 的子类\n\nArrayList 底层数据结构是数组，LinkedList 底层数据结构是链表。\n\n用法一模一样，查询效率高就用 ArrayList，增删效率高用 LinkedList。\n\n## LinkList 特有功能\n\n| 方法                      | 说明 |\n| ------------------------- | ---- |\n| public void addFirst(E e) |      |\n| public void addLast(E e)  |      |\n| public E getFirst()       |      |\n| public E getLast()        |      |\n| public void removeFirst() |      |\n| public void removeLast()  |      |\n\n","slug":"Java 学习博客_14 入门——集合进阶1","published":1,"updated":"2022-05-08T06:03:20.506Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2ww38h90000pkv226rsh94z","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR<br>A[集合]--&gt;C[Collection]<br>A--&gt;M[Map]<br>C--&gt;L[List]<br>C--&gt;S[Set]<br>L--&gt;AL(ArrayList)<br>L--&gt;LL(LinkedList)<br>S--&gt;HS(HashSet)<br>S--&gt;TS(TreeSet)<br>M--&gt;HM(HashMap)<br></code></pre></td></tr></table></figure>\n\n<p>其中方形的是接口，圆角的是实现类。</p>\n<p>因此先学习 Collection 和 Map 接口后，只需要学习下一级的特有的部分。</p>\n<h1 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h1><p>java.util.Collection</p>\n<p>Collection 是单例集合的最高级接口。他表示一组对象，这些对象也被称为 Collection 的元素。</p>\n<p>无法直接实现。可以用多态的方式实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Collection&lt;String&gt; c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br><span class=\"hljs-comment\">//add(E e) 方法添加元素</span><br>c.add(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>c.add(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>System.out.println(c);<span class=\"hljs-comment\">//输出[&#x27;Hello&#x27;,&#x27;World&#x27;]，因为 ArrayList 中重写了 toString 方法，所以得到的不是一串地址</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean add(E e)</td>\n<td>添加元素，永远返回 true</td>\n</tr>\n<tr>\n<td>boolean remove(Object o)</td>\n<td>从集合中移除指定的元素，成功移除返回 true</td>\n</tr>\n<tr>\n<td>void clear()</td>\n<td>清空集合中的元素</td>\n</tr>\n<tr>\n<td>boolean contains(Object o)</td>\n<td>判断集合中是否存在指定的元素</td>\n</tr>\n<tr>\n<td>boolean isEmpty()</td>\n<td>判断集合是否为空</td>\n</tr>\n<tr>\n<td>int size()</td>\n<td>集合长度</td>\n</tr>\n</tbody></table>\n<p>快捷键：Alt+7，能看到类的所有信息</p>\n<h2 id=\"迭代器-iterator\"><a href=\"#迭代器-iterator\" class=\"headerlink\" title=\"迭代器 iterator\"></a>迭代器 iterator</h2><p>java.util.Iterator</p>\n<p>Iterator 是一个接口。使用 Iterator 迭代器遍历集合元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Iterator&lt;String&gt; it=c.iterator();<span class=\"hljs-comment\">//通过集合对象中的迭代方法获取对象</span><br></code></pre></td></tr></table></figure>\n\n<p>追根溯源可以得知，Collection.iterator()方法返回的是一个实现了 Iterator 接口的类：Itr.</p>\n<p>所以实际上是通过多态的方式实例化的。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E next()</td>\n<td>返回下一个元素（越界访问：NoSuchElementException，被请求的元素不存在）</td>\n</tr>\n<tr>\n<td>boolean hasNext()</td>\n<td>如果存在下一个元素，返回 true</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">while</span>(it.hasNext())&#123;<br>    String s=it.next();<span class=\"hljs-comment\">//这样更好一些，因为元素可能还要做其他操作</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>it.next() 像指针一样从0开始遍历。</p>\n<h1 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h1><p>java.util.List</p>\n<p>继承自 Collection 类，可以使用其中的方法。</p>\n<p>List 是有序、有索引的。相较于集合 Set，List 中的元素可以重复。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; l=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br>l.add(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>l.add(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>System.out.println(l);<span class=\"hljs-comment\">//按存储的顺序输出，[&quot;Hello&quot;,&quot;World&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void add(int index,E element)</td>\n<td>感觉并不用解释</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td></td>\n</tr>\n<tr>\n<td>E set(int index,E element)</td>\n<td></td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>越界报错 IndexOutOfException。</p>\n<p>另一种遍历集合的方法是 for 循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;l.size();i++)System.out.println(l.get(i));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"并发修改异常\"><a href=\"#并发修改异常\" class=\"headerlink\" title=\"并发修改异常\"></a>并发修改异常</h2><p>当不允许这样的修改时，会抛出此方法。</p>\n<p>如：在使用 iterator 遍历过程中，在集合中添加了新的元素。</p>\n<p>iterator 调用 next() 方法时，会先调用 checkForComodification() 方法。</p>\n<p>checkForComodification() 会检验 modCount 修改集合的次数和expectedModCount 预期修改集合的次数是否相等。</p>\n<p>modCount 来自于 ArrayList 的父类：AbstractList，初始值为0.每次使用 add() 方法时，modCount 就会++。</p>\n<p>expectedCount 来自于 Itr 类，且初始值为 <code>expectedCount=modCount</code>.</p>\n<p>每次实例化一个 Iterator 类，都会调用其子类 Itr 类，使得 expectedCount 等于当前的 modCount。</p>\n<p>然后遍历过程中每次调用 next() 方法时，都会先检查一下<code>expectedCount==modCount</code>，即集合有没有被修改。如果没有修改就可以顺利地返回下一个元素；如果有异常 checkForComodificationException，就会终止运行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TB<br>C[Collection]--&gt;|获取迭代对象|I[iterator]<br>C--&gt;|多态|Arr[Arraylist]<br>I--&gt;|多态|Itr[Itr]<br>I--&gt;W&#123;&quot;iterator.hasNext()==true&quot;&#125;<br>Itr--&gt;A(expectedCount=modCount)<br>W--&gt;|no|en(遍历结束)<br>W--&gt;|yes|N(&quot;iterator.next()&quot;)<br>N--&gt;cf(&quot;checkForComodification()&quot;)<br>cf--&gt;cfe&#123;&quot;expectedCount==modCount&quot;&#125;<br><br>X--&gt;W<br>cfe--&gt;|no|Y(checkForComodificationException)<br>cfe--&gt;|yes|X(&quot;集合没有被修改,继续遍历&quot;)<br></code></pre></td></tr></table></figure>\n\n<p>但是通过 for 循环遍历集合，在遍历过程中对集合进行修改，不会报异常。</p>\n<h2 id=\"ListInterator\"><a href=\"#ListInterator\" class=\"headerlink\" title=\"ListInterator\"></a>ListInterator</h2><p>通过 List 中的 listInterator() 方法得到。可以从各个方向遍历，迭代期间可以修改列表，还可以获取列表迭代器的当前位置。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean hasNext()</td>\n<td></td>\n</tr>\n<tr>\n<td>E next()</td>\n<td></td>\n</tr>\n<tr>\n<td>boolean hasPrevious()</td>\n<td>反向遍历用到</td>\n</tr>\n<tr>\n<td>E previous()</td>\n<td>反向遍历用到</td>\n</tr>\n<tr>\n<td>void add(E e)</td>\n<td>添加元素，<strong>注意是通过 listInterator 添加的，不是通过集合添加的！</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; l=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br>l.add(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>l.add(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>l.add(<span class=\"hljs-string\">&quot;java&quot;</span>);<br>ListInterator&lt;String&gt; li=l.listInterator();<span class=\"hljs-comment\">//实际上是 listItr 类作为 listInterator 类的子类，通过多态实现</span><br><span class=\"hljs-keyword\">while</span>(li.hasNext())&#123;<br>    System.out.println(l.next());<br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(li.hasPrevious())&#123;<br>    System.out.println(l.previous());<br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(li.hasNext())&#123;<br>    String s=l.next();<br>    <span class=\"hljs-keyword\">if</span>(s.equals(<span class=\"hljs-string\">&quot;World&quot;</span>))&#123;<br>        li.add(<span class=\"hljs-string\">&quot;!!!&quot;</span>);<span class=\"hljs-comment\">//特别注意，并不是调用了l的 add() 方法，而是 li 的 add() 方法！</span><br>    &#125;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 listItr 类中的 add() 方法，添加完元素之后，有一句<code>expectedModCount=modCount;</code>重新把实际修改值赋给了预期修改值。因此 next() 方法中判断<code>expectedModCount==modCount</code>，即使添加了新元素也仍然是 true. 不会发生并发修改异常。</p>\n<h2 id=\"增强-for\"><a href=\"#增强-for\" class=\"headerlink\" title=\"增强 for\"></a>增强 for</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(E e:数组或 Collection 的集合)<br>&#123;<br>\t<span class=\"hljs-comment\">//在这里使用变量e，把其当做集合元素来用</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i:arr)&#123;<br>    System.out.println(i);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i:list)&#123;<br>    System.out.println(i);<br>&#125;<br><span class=\"hljs-comment\">//内部是一个 iterator 迭代器，不可以中途修改数据，会引发并发修改异常。</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"几种遍历方式的选择\"><a href=\"#几种遍历方式的选择\" class=\"headerlink\" title=\"几种遍历方式的选择\"></a>几种遍历方式的选择</h2><p>单纯的遍历：增强 for 最简单。</p>\n<p>需要用到索引：普通 for。</p>\n<p>迭代器也要会用。</p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>后入先出 FILO。</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>先入先出 FIFO。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>可以根据索引查找，查找效率高；增删效率低。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>每个结点存储数据和下一个结点的地址值。最后一个结点地址值为空。</p>\n<p>相比数组，增删只需要修改增删处前后结点的地址值，效率更高。</p>\n<p>但是查询必须从头开始，效率低。</p>\n<h1 id=\"List-的子类\"><a href=\"#List-的子类\" class=\"headerlink\" title=\"List 的子类\"></a>List 的子类</h1><p>ArrayList 底层数据结构是数组，LinkedList 底层数据结构是链表。</p>\n<p>用法一模一样，查询效率高就用 ArrayList，增删效率高用 LinkedList。</p>\n<h2 id=\"LinkList-特有功能\"><a href=\"#LinkList-特有功能\" class=\"headerlink\" title=\"LinkList 特有功能\"></a>LinkList 特有功能</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public void addFirst(E e)</td>\n<td></td>\n</tr>\n<tr>\n<td>public void addLast(E e)</td>\n<td></td>\n</tr>\n<tr>\n<td>public E getFirst()</td>\n<td></td>\n</tr>\n<tr>\n<td>public E getLast()</td>\n<td></td>\n</tr>\n<tr>\n<td>public void removeFirst()</td>\n<td></td>\n</tr>\n<tr>\n<td>public void removeLast()</td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph LR<br>A[集合]--&gt;C[Collection]<br>A--&gt;M[Map]<br>C--&gt;L[List]<br>C--&gt;S[Set]<br>L--&gt;AL(ArrayList)<br>L--&gt;LL(LinkedList)<br>S--&gt;HS(HashSet)<br>S--&gt;TS(TreeSet)<br>M--&gt;HM(HashMap)<br></code></pre></td></tr></table></figure>\n\n<p>其中方形的是接口，圆角的是实现类。</p>\n<p>因此先学习 Collection 和 Map 接口后，只需要学习下一级的特有的部分。</p>\n<h1 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h1><p>java.util.Collection</p>\n<p>Collection 是单例集合的最高级接口。他表示一组对象，这些对象也被称为 Collection 的元素。</p>\n<p>无法直接实现。可以用多态的方式实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Collection&lt;String&gt; c=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br><span class=\"hljs-comment\">//add(E e) 方法添加元素</span><br>c.add(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>c.add(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>System.out.println(c);<span class=\"hljs-comment\">//输出[&#x27;Hello&#x27;,&#x27;World&#x27;]，因为 ArrayList 中重写了 toString 方法，所以得到的不是一串地址</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean add(E e)</td>\n<td>添加元素，永远返回 true</td>\n</tr>\n<tr>\n<td>boolean remove(Object o)</td>\n<td>从集合中移除指定的元素，成功移除返回 true</td>\n</tr>\n<tr>\n<td>void clear()</td>\n<td>清空集合中的元素</td>\n</tr>\n<tr>\n<td>boolean contains(Object o)</td>\n<td>判断集合中是否存在指定的元素</td>\n</tr>\n<tr>\n<td>boolean isEmpty()</td>\n<td>判断集合是否为空</td>\n</tr>\n<tr>\n<td>int size()</td>\n<td>集合长度</td>\n</tr>\n</tbody></table>\n<p>快捷键：Alt+7，能看到类的所有信息</p>\n<h2 id=\"迭代器-iterator\"><a href=\"#迭代器-iterator\" class=\"headerlink\" title=\"迭代器 iterator\"></a>迭代器 iterator</h2><p>java.util.Iterator</p>\n<p>Iterator 是一个接口。使用 Iterator 迭代器遍历集合元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Iterator&lt;String&gt; it=c.iterator();<span class=\"hljs-comment\">//通过集合对象中的迭代方法获取对象</span><br></code></pre></td></tr></table></figure>\n\n<p>追根溯源可以得知，Collection.iterator()方法返回的是一个实现了 Iterator 接口的类：Itr.</p>\n<p>所以实际上是通过多态的方式实例化的。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>E next()</td>\n<td>返回下一个元素（越界访问：NoSuchElementException，被请求的元素不存在）</td>\n</tr>\n<tr>\n<td>boolean hasNext()</td>\n<td>如果存在下一个元素，返回 true</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">while</span>(it.hasNext())&#123;<br>    String s=it.next();<span class=\"hljs-comment\">//这样更好一些，因为元素可能还要做其他操作</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>it.next() 像指针一样从0开始遍历。</p>\n<h1 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h1><p>java.util.List</p>\n<p>继承自 Collection 类，可以使用其中的方法。</p>\n<p>List 是有序、有索引的。相较于集合 Set，List 中的元素可以重复。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; l=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br>l.add(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>l.add(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>System.out.println(l);<span class=\"hljs-comment\">//按存储的顺序输出，[&quot;Hello&quot;,&quot;World&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>void add(int index,E element)</td>\n<td>感觉并不用解释</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td></td>\n</tr>\n<tr>\n<td>E set(int index,E element)</td>\n<td></td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>越界报错 IndexOutOfException。</p>\n<p>另一种遍历集合的方法是 for 循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;l.size();i++)System.out.println(l.get(i));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"并发修改异常\"><a href=\"#并发修改异常\" class=\"headerlink\" title=\"并发修改异常\"></a>并发修改异常</h2><p>当不允许这样的修改时，会抛出此方法。</p>\n<p>如：在使用 iterator 遍历过程中，在集合中添加了新的元素。</p>\n<p>iterator 调用 next() 方法时，会先调用 checkForComodification() 方法。</p>\n<p>checkForComodification() 会检验 modCount 修改集合的次数和expectedModCount 预期修改集合的次数是否相等。</p>\n<p>modCount 来自于 ArrayList 的父类：AbstractList，初始值为0.每次使用 add() 方法时，modCount 就会++。</p>\n<p>expectedCount 来自于 Itr 类，且初始值为 <code>expectedCount=modCount</code>.</p>\n<p>每次实例化一个 Iterator 类，都会调用其子类 Itr 类，使得 expectedCount 等于当前的 modCount。</p>\n<p>然后遍历过程中每次调用 next() 方法时，都会先检查一下<code>expectedCount==modCount</code>，即集合有没有被修改。如果没有修改就可以顺利地返回下一个元素；如果有异常 checkForComodificationException，就会终止运行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mermaid\">graph TB<br>C[Collection]--&gt;|获取迭代对象|I[iterator]<br>C--&gt;|多态|Arr[Arraylist]<br>I--&gt;|多态|Itr[Itr]<br>I--&gt;W&#123;&quot;iterator.hasNext()==true&quot;&#125;<br>Itr--&gt;A(expectedCount=modCount)<br>W--&gt;|no|en(遍历结束)<br>W--&gt;|yes|N(&quot;iterator.next()&quot;)<br>N--&gt;cf(&quot;checkForComodification()&quot;)<br>cf--&gt;cfe&#123;&quot;expectedCount==modCount&quot;&#125;<br><br>X--&gt;W<br>cfe--&gt;|no|Y(checkForComodificationException)<br>cfe--&gt;|yes|X(&quot;集合没有被修改,继续遍历&quot;)<br></code></pre></td></tr></table></figure>\n\n<p>但是通过 for 循环遍历集合，在遍历过程中对集合进行修改，不会报异常。</p>\n<h2 id=\"ListInterator\"><a href=\"#ListInterator\" class=\"headerlink\" title=\"ListInterator\"></a>ListInterator</h2><p>通过 List 中的 listInterator() 方法得到。可以从各个方向遍历，迭代期间可以修改列表，还可以获取列表迭代器的当前位置。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>boolean hasNext()</td>\n<td></td>\n</tr>\n<tr>\n<td>E next()</td>\n<td></td>\n</tr>\n<tr>\n<td>boolean hasPrevious()</td>\n<td>反向遍历用到</td>\n</tr>\n<tr>\n<td>E previous()</td>\n<td>反向遍历用到</td>\n</tr>\n<tr>\n<td>void add(E e)</td>\n<td>添加元素，<strong>注意是通过 listInterator 添加的，不是通过集合添加的！</strong></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">List&lt;String&gt; l=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;String&gt;();<br>l.add(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>l.add(<span class=\"hljs-string\">&quot;World&quot;</span>);<br>l.add(<span class=\"hljs-string\">&quot;java&quot;</span>);<br>ListInterator&lt;String&gt; li=l.listInterator();<span class=\"hljs-comment\">//实际上是 listItr 类作为 listInterator 类的子类，通过多态实现</span><br><span class=\"hljs-keyword\">while</span>(li.hasNext())&#123;<br>    System.out.println(l.next());<br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(li.hasPrevious())&#123;<br>    System.out.println(l.previous());<br>&#125;<br><br><span class=\"hljs-keyword\">while</span>(li.hasNext())&#123;<br>    String s=l.next();<br>    <span class=\"hljs-keyword\">if</span>(s.equals(<span class=\"hljs-string\">&quot;World&quot;</span>))&#123;<br>        li.add(<span class=\"hljs-string\">&quot;!!!&quot;</span>);<span class=\"hljs-comment\">//特别注意，并不是调用了l的 add() 方法，而是 li 的 add() 方法！</span><br>    &#125;<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 listItr 类中的 add() 方法，添加完元素之后，有一句<code>expectedModCount=modCount;</code>重新把实际修改值赋给了预期修改值。因此 next() 方法中判断<code>expectedModCount==modCount</code>，即使添加了新元素也仍然是 true. 不会发生并发修改异常。</p>\n<h2 id=\"增强-for\"><a href=\"#增强-for\" class=\"headerlink\" title=\"增强 for\"></a>增强 for</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span>(E e:数组或 Collection 的集合)<br>&#123;<br>\t<span class=\"hljs-comment\">//在这里使用变量e，把其当做集合元素来用</span><br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i:arr)&#123;<br>    System.out.println(i);<br>&#125;<br><br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i:list)&#123;<br>    System.out.println(i);<br>&#125;<br><span class=\"hljs-comment\">//内部是一个 iterator 迭代器，不可以中途修改数据，会引发并发修改异常。</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"几种遍历方式的选择\"><a href=\"#几种遍历方式的选择\" class=\"headerlink\" title=\"几种遍历方式的选择\"></a>几种遍历方式的选择</h2><p>单纯的遍历：增强 for 最简单。</p>\n<p>需要用到索引：普通 for。</p>\n<p>迭代器也要会用。</p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>后入先出 FILO。</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>先入先出 FIFO。</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>可以根据索引查找，查找效率高；增删效率低。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>每个结点存储数据和下一个结点的地址值。最后一个结点地址值为空。</p>\n<p>相比数组，增删只需要修改增删处前后结点的地址值，效率更高。</p>\n<p>但是查询必须从头开始，效率低。</p>\n<h1 id=\"List-的子类\"><a href=\"#List-的子类\" class=\"headerlink\" title=\"List 的子类\"></a>List 的子类</h1><p>ArrayList 底层数据结构是数组，LinkedList 底层数据结构是链表。</p>\n<p>用法一模一样，查询效率高就用 ArrayList，增删效率高用 LinkedList。</p>\n<h2 id=\"LinkList-特有功能\"><a href=\"#LinkList-特有功能\" class=\"headerlink\" title=\"LinkList 特有功能\"></a>LinkList 特有功能</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public void addFirst(E e)</td>\n<td></td>\n</tr>\n<tr>\n<td>public void addLast(E e)</td>\n<td></td>\n</tr>\n<tr>\n<td>public E getFirst()</td>\n<td></td>\n</tr>\n<tr>\n<td>public E getLast()</td>\n<td></td>\n</tr>\n<tr>\n<td>public void removeFirst()</td>\n<td></td>\n</tr>\n<tr>\n<td>public void removeLast()</td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"title":"正则表达式_1","date":"2022-05-08T16:00:00.000Z","_content":"\n正则表达式可以被视作是增强版的通配符，可以匹配制定规则的字符串。\n\n# 练习方法\n\n可以在编译器中自带的查找功能尝试，也可以在 [regex101.com](https://regex101.com) 在线测试工具中尝试。\n\n# 限定符 Quantifiers\n\n? 表示前面的字符需要出现0次或1次。\n\n如：`used?` 可以匹配 use 和 used.\n\n\\* 表示前面的字符需要出现0次或多次。\n\n如：`ab*c`会匹配ac、abc、abbbc……但不能匹配到 adc。\n\n\\+ 表示前面的字符需要出现1次或多次。\n\n如上例，`ab+c`不会匹配 ac。\n\n{数字} 表示前面的字符需要出现多少次。\n\n如：`ab{6}c`表示 abbbbbbc，`ab{2,6}c` 表示b出现2~6次，`ab{2,}c`表示b出现2次以上。\n\n() 用于限定多个字符。\n\n如：`(ab)?c`表示c或abc。\n\n# 或运算 or\n\n`a (cat|dog)` 表示 a cat 或 a dog.**括号不能少**\n\n# 字符类 Character Classes\n\n[]+，用于匹配单词，单词的字符只能取自方括号内。\n\n如：`[abc]+`表示只由 abc 组成的字符，`aabbcc`等。\n\n`[a-z]+`表示所有小写字母\n\n`[a-zA-Z]+`表示所有字母\n\n`[0-9]+`表示所有数字\n\n方括号内加^表示取反，如`[^a-z]+`表示所有非小写字母的字符（甚至包括换行符）\n\n# 元字符 Meta-characters\n\n\\d：数字字符\n\n\\D：非数字字符\n\n\\w：单词字符（英文字符、数字字符、下划线）\n\n\\W：非单词字符\n\n\\s：空白字符（Tab、空格、换行符）\n\n\\S：非空白字符\n\n\\b：单词字符的边界，相当于文本的开头或结束。\n\n.：任意字符（不包括换行符）\n\n^：匹配行首，如`^a`只会匹配出现在行开头的a\n\n$：匹配行尾，如`a$`只会匹配出现在行开头的a\n\n反斜杠用在符号前还可以做转义，如\\\\.表示.字符。\n\n# 贪婪与懒惰匹配 Greedy vs Lazy Match\n\n```html\n<span><b>This is a simple text</b></span>\n```\n\n如果想匹配所有的标签，也就是匹配<>，中间的内容是一个或多个任意字符。\n\n`<.+>`\n\n但是这样匹配，会把整行都匹配起来，而不是每个标签单独匹配。这就是贪婪匹配，会尽可能多地匹配。因为.也会匹配>号。\n\n`<.+?>`\n\n# 例： IP 地址\n\nIP 地址形如 192.168.0.1\n\n由四部分数字和三个.组成，每部分数字都不能大于255.\n\n首先表示出四部分数字+3个.的形式：\n\n```\n(\\d+\\.){3}(\\d+)\n```\n\n然后再考虑处理数字大小的问题。\n\n首先，如果百位是2，十位是5，个位只能取0-5\n\n如果百位是2，十位是0-4，个位任意数字\n\n如果百位是0或1，十位和个位可以是任意数字\n\n```\n((25[0-5]|2[0-4]\\d|[01]\\d\\d)\\.){3}(25[0-5]|2[0-4]\\d|[01]\\d\\d)\n```\n\n然后考虑百位和十位可能不存在的问题：用?处理这两位。\n\n```\n((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\n```\n\n最后首尾加一个\\b限定字符边界\n\n```\n\\b((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\b\n```\n\n","source":"_posts/正则表达式_1.md","raw":"---\ntitle: 正则表达式_1\ndate: 2022-05-09\ntags: study\ncategory: regex\n---\n\n正则表达式可以被视作是增强版的通配符，可以匹配制定规则的字符串。\n\n# 练习方法\n\n可以在编译器中自带的查找功能尝试，也可以在 [regex101.com](https://regex101.com) 在线测试工具中尝试。\n\n# 限定符 Quantifiers\n\n? 表示前面的字符需要出现0次或1次。\n\n如：`used?` 可以匹配 use 和 used.\n\n\\* 表示前面的字符需要出现0次或多次。\n\n如：`ab*c`会匹配ac、abc、abbbc……但不能匹配到 adc。\n\n\\+ 表示前面的字符需要出现1次或多次。\n\n如上例，`ab+c`不会匹配 ac。\n\n{数字} 表示前面的字符需要出现多少次。\n\n如：`ab{6}c`表示 abbbbbbc，`ab{2,6}c` 表示b出现2~6次，`ab{2,}c`表示b出现2次以上。\n\n() 用于限定多个字符。\n\n如：`(ab)?c`表示c或abc。\n\n# 或运算 or\n\n`a (cat|dog)` 表示 a cat 或 a dog.**括号不能少**\n\n# 字符类 Character Classes\n\n[]+，用于匹配单词，单词的字符只能取自方括号内。\n\n如：`[abc]+`表示只由 abc 组成的字符，`aabbcc`等。\n\n`[a-z]+`表示所有小写字母\n\n`[a-zA-Z]+`表示所有字母\n\n`[0-9]+`表示所有数字\n\n方括号内加^表示取反，如`[^a-z]+`表示所有非小写字母的字符（甚至包括换行符）\n\n# 元字符 Meta-characters\n\n\\d：数字字符\n\n\\D：非数字字符\n\n\\w：单词字符（英文字符、数字字符、下划线）\n\n\\W：非单词字符\n\n\\s：空白字符（Tab、空格、换行符）\n\n\\S：非空白字符\n\n\\b：单词字符的边界，相当于文本的开头或结束。\n\n.：任意字符（不包括换行符）\n\n^：匹配行首，如`^a`只会匹配出现在行开头的a\n\n$：匹配行尾，如`a$`只会匹配出现在行开头的a\n\n反斜杠用在符号前还可以做转义，如\\\\.表示.字符。\n\n# 贪婪与懒惰匹配 Greedy vs Lazy Match\n\n```html\n<span><b>This is a simple text</b></span>\n```\n\n如果想匹配所有的标签，也就是匹配<>，中间的内容是一个或多个任意字符。\n\n`<.+>`\n\n但是这样匹配，会把整行都匹配起来，而不是每个标签单独匹配。这就是贪婪匹配，会尽可能多地匹配。因为.也会匹配>号。\n\n`<.+?>`\n\n# 例： IP 地址\n\nIP 地址形如 192.168.0.1\n\n由四部分数字和三个.组成，每部分数字都不能大于255.\n\n首先表示出四部分数字+3个.的形式：\n\n```\n(\\d+\\.){3}(\\d+)\n```\n\n然后再考虑处理数字大小的问题。\n\n首先，如果百位是2，十位是5，个位只能取0-5\n\n如果百位是2，十位是0-4，个位任意数字\n\n如果百位是0或1，十位和个位可以是任意数字\n\n```\n((25[0-5]|2[0-4]\\d|[01]\\d\\d)\\.){3}(25[0-5]|2[0-4]\\d|[01]\\d\\d)\n```\n\n然后考虑百位和十位可能不存在的问题：用?处理这两位。\n\n```\n((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\n```\n\n最后首尾加一个\\b限定字符边界\n\n```\n\\b((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\b\n```\n\n","slug":"正则表达式_1","published":1,"updated":"2022-05-08T16:21:32.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2xidk2r000064v2htbsf2tz","content":"<p>正则表达式可以被视作是增强版的通配符，可以匹配制定规则的字符串。</p>\n<h1 id=\"练习方法\"><a href=\"#练习方法\" class=\"headerlink\" title=\"练习方法\"></a>练习方法</h1><p>可以在编译器中自带的查找功能尝试，也可以在 <a href=\"https://regex101.com/\">regex101.com</a> 在线测试工具中尝试。</p>\n<h1 id=\"限定符-Quantifiers\"><a href=\"#限定符-Quantifiers\" class=\"headerlink\" title=\"限定符 Quantifiers\"></a>限定符 Quantifiers</h1><p>? 表示前面的字符需要出现0次或1次。</p>\n<p>如：<code>used?</code> 可以匹配 use 和 used.</p>\n<p>* 表示前面的字符需要出现0次或多次。</p>\n<p>如：<code>ab*c</code>会匹配ac、abc、abbbc……但不能匹配到 adc。</p>\n<p>+ 表示前面的字符需要出现1次或多次。</p>\n<p>如上例，<code>ab+c</code>不会匹配 ac。</p>\n<p>{数字} 表示前面的字符需要出现多少次。</p>\n<p>如：<code>ab&#123;6&#125;c</code>表示 abbbbbbc，<code>ab&#123;2,6&#125;c</code> 表示b出现2~6次，<code>ab&#123;2,&#125;c</code>表示b出现2次以上。</p>\n<p>() 用于限定多个字符。</p>\n<p>如：<code>(ab)?c</code>表示c或abc。</p>\n<h1 id=\"或运算-or\"><a href=\"#或运算-or\" class=\"headerlink\" title=\"或运算 or\"></a>或运算 or</h1><p><code>a (cat|dog)</code> 表示 a cat 或 a dog.<strong>括号不能少</strong></p>\n<h1 id=\"字符类-Character-Classes\"><a href=\"#字符类-Character-Classes\" class=\"headerlink\" title=\"字符类 Character Classes\"></a>字符类 Character Classes</h1><p>[]+，用于匹配单词，单词的字符只能取自方括号内。</p>\n<p>如：<code>[abc]+</code>表示只由 abc 组成的字符，<code>aabbcc</code>等。</p>\n<p><code>[a-z]+</code>表示所有小写字母</p>\n<p><code>[a-zA-Z]+</code>表示所有字母</p>\n<p><code>[0-9]+</code>表示所有数字</p>\n<p>方括号内加^表示取反，如<code>[^a-z]+</code>表示所有非小写字母的字符（甚至包括换行符）</p>\n<h1 id=\"元字符-Meta-characters\"><a href=\"#元字符-Meta-characters\" class=\"headerlink\" title=\"元字符 Meta-characters\"></a>元字符 Meta-characters</h1><p>\\d：数字字符</p>\n<p>\\D：非数字字符</p>\n<p>\\w：单词字符（英文字符、数字字符、下划线）</p>\n<p>\\W：非单词字符</p>\n<p>\\s：空白字符（Tab、空格、换行符）</p>\n<p>\\S：非空白字符</p>\n<p>\\b：单词字符的边界，相当于文本的开头或结束。</p>\n<p>.：任意字符（不包括换行符）</p>\n<p>^：匹配行首，如<code>^a</code>只会匹配出现在行开头的a</p>\n<p>$：匹配行尾，如<code>a$</code>只会匹配出现在行开头的a</p>\n<p>反斜杠用在符号前还可以做转义，如\\.表示.字符。</p>\n<h1 id=\"贪婪与懒惰匹配-Greedy-vs-Lazy-Match\"><a href=\"#贪婪与懒惰匹配-Greedy-vs-Lazy-Match\" class=\"headerlink\" title=\"贪婪与懒惰匹配 Greedy vs Lazy Match\"></a>贪婪与懒惰匹配 Greedy vs Lazy Match</h1><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>This is a simple text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想匹配所有的标签，也就是匹配&lt;&gt;，中间的内容是一个或多个任意字符。</p>\n<p><code>&lt;.+&gt;</code></p>\n<p>但是这样匹配，会把整行都匹配起来，而不是每个标签单独匹配。这就是贪婪匹配，会尽可能多地匹配。因为.也会匹配&gt;号。</p>\n<p><code>&lt;.+?&gt;</code></p>\n<h1 id=\"例：-IP-地址\"><a href=\"#例：-IP-地址\" class=\"headerlink\" title=\"例： IP 地址\"></a>例： IP 地址</h1><p>IP 地址形如 192.168.0.1</p>\n<p>由四部分数字和三个.组成，每部分数字都不能大于255.</p>\n<p>首先表示出四部分数字+3个.的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">(\\d+\\.)&#123;3&#125;(\\d+)<br></code></pre></td></tr></table></figure>\n\n<p>然后再考虑处理数字大小的问题。</p>\n<p>首先，如果百位是2，十位是5，个位只能取0-5</p>\n<p>如果百位是2，十位是0-4，个位任意数字</p>\n<p>如果百位是0或1，十位和个位可以是任意数字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">((25[0-5]|2[0-4]\\d|[01]\\d\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|[01]\\d\\d)<br></code></pre></td></tr></table></figure>\n\n<p>然后考虑百位和十位可能不存在的问题：用?处理这两位。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)<br></code></pre></td></tr></table></figure>\n\n<p>最后首尾加一个\\b限定字符边界</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">\\b((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\b<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>正则表达式可以被视作是增强版的通配符，可以匹配制定规则的字符串。</p>\n<h1 id=\"练习方法\"><a href=\"#练习方法\" class=\"headerlink\" title=\"练习方法\"></a>练习方法</h1><p>可以在编译器中自带的查找功能尝试，也可以在 <a href=\"https://regex101.com/\">regex101.com</a> 在线测试工具中尝试。</p>\n<h1 id=\"限定符-Quantifiers\"><a href=\"#限定符-Quantifiers\" class=\"headerlink\" title=\"限定符 Quantifiers\"></a>限定符 Quantifiers</h1><p>? 表示前面的字符需要出现0次或1次。</p>\n<p>如：<code>used?</code> 可以匹配 use 和 used.</p>\n<p>* 表示前面的字符需要出现0次或多次。</p>\n<p>如：<code>ab*c</code>会匹配ac、abc、abbbc……但不能匹配到 adc。</p>\n<p>+ 表示前面的字符需要出现1次或多次。</p>\n<p>如上例，<code>ab+c</code>不会匹配 ac。</p>\n<p>{数字} 表示前面的字符需要出现多少次。</p>\n<p>如：<code>ab&#123;6&#125;c</code>表示 abbbbbbc，<code>ab&#123;2,6&#125;c</code> 表示b出现2~6次，<code>ab&#123;2,&#125;c</code>表示b出现2次以上。</p>\n<p>() 用于限定多个字符。</p>\n<p>如：<code>(ab)?c</code>表示c或abc。</p>\n<h1 id=\"或运算-or\"><a href=\"#或运算-or\" class=\"headerlink\" title=\"或运算 or\"></a>或运算 or</h1><p><code>a (cat|dog)</code> 表示 a cat 或 a dog.<strong>括号不能少</strong></p>\n<h1 id=\"字符类-Character-Classes\"><a href=\"#字符类-Character-Classes\" class=\"headerlink\" title=\"字符类 Character Classes\"></a>字符类 Character Classes</h1><p>[]+，用于匹配单词，单词的字符只能取自方括号内。</p>\n<p>如：<code>[abc]+</code>表示只由 abc 组成的字符，<code>aabbcc</code>等。</p>\n<p><code>[a-z]+</code>表示所有小写字母</p>\n<p><code>[a-zA-Z]+</code>表示所有字母</p>\n<p><code>[0-9]+</code>表示所有数字</p>\n<p>方括号内加^表示取反，如<code>[^a-z]+</code>表示所有非小写字母的字符（甚至包括换行符）</p>\n<h1 id=\"元字符-Meta-characters\"><a href=\"#元字符-Meta-characters\" class=\"headerlink\" title=\"元字符 Meta-characters\"></a>元字符 Meta-characters</h1><p>\\d：数字字符</p>\n<p>\\D：非数字字符</p>\n<p>\\w：单词字符（英文字符、数字字符、下划线）</p>\n<p>\\W：非单词字符</p>\n<p>\\s：空白字符（Tab、空格、换行符）</p>\n<p>\\S：非空白字符</p>\n<p>\\b：单词字符的边界，相当于文本的开头或结束。</p>\n<p>.：任意字符（不包括换行符）</p>\n<p>^：匹配行首，如<code>^a</code>只会匹配出现在行开头的a</p>\n<p>$：匹配行尾，如<code>a$</code>只会匹配出现在行开头的a</p>\n<p>反斜杠用在符号前还可以做转义，如\\.表示.字符。</p>\n<h1 id=\"贪婪与懒惰匹配-Greedy-vs-Lazy-Match\"><a href=\"#贪婪与懒惰匹配-Greedy-vs-Lazy-Match\" class=\"headerlink\" title=\"贪婪与懒惰匹配 Greedy vs Lazy Match\"></a>贪婪与懒惰匹配 Greedy vs Lazy Match</h1><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>This is a simple text<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想匹配所有的标签，也就是匹配&lt;&gt;，中间的内容是一个或多个任意字符。</p>\n<p><code>&lt;.+&gt;</code></p>\n<p>但是这样匹配，会把整行都匹配起来，而不是每个标签单独匹配。这就是贪婪匹配，会尽可能多地匹配。因为.也会匹配&gt;号。</p>\n<p><code>&lt;.+?&gt;</code></p>\n<h1 id=\"例：-IP-地址\"><a href=\"#例：-IP-地址\" class=\"headerlink\" title=\"例： IP 地址\"></a>例： IP 地址</h1><p>IP 地址形如 192.168.0.1</p>\n<p>由四部分数字和三个.组成，每部分数字都不能大于255.</p>\n<p>首先表示出四部分数字+3个.的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">(\\d+\\.)&#123;3&#125;(\\d+)<br></code></pre></td></tr></table></figure>\n\n<p>然后再考虑处理数字大小的问题。</p>\n<p>首先，如果百位是2，十位是5，个位只能取0-5</p>\n<p>如果百位是2，十位是0-4，个位任意数字</p>\n<p>如果百位是0或1，十位和个位可以是任意数字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">((25[0-5]|2[0-4]\\d|[01]\\d\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|[01]\\d\\d)<br></code></pre></td></tr></table></figure>\n\n<p>然后考虑百位和十位可能不存在的问题：用?处理这两位。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)<br></code></pre></td></tr></table></figure>\n\n<p>最后首尾加一个\\b限定字符边界</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">\\b((25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\b<br></code></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl245sb4z0000s0v20g663k5p","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2462f0g000dcov2606a4zhq"},{"post_id":"cl245sb560001s0v2bzx12eg8","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2462f0j000icov23u5gdlgh"},{"post_id":"cl03y1b0800003wv2hx8mg9y2","category_id":"cl2462f0k000mcov26it14oyd","_id":"cl2462f0m000vcov28zfm7mdy"},{"post_id":"cl04122ju0001pgv2ah9oewd6","category_id":"cl2462f0g000ccov2hjrr11h0","_id":"cl2462f0n000ycov27eb89p5u"},{"post_id":"cl02m4pyp0001fsv2bf156buq","category_id":"cl2462f0g000ccov2hjrr11h0","_id":"cl2462f0n0010cov2ansa1ucs"},{"post_id":"cl186hpxq0000vgv2fovs52rg","category_id":"cl2462f0n000xcov207lw48bg","_id":"cl2462f0o0011cov2epbr8rp4"},{"post_id":"cl2772w3z00004sv21bda7355","category_id":"cl2462ezy0001cov23z9kghje","_id":"cl2772w4100024sv29bn5hq1u"},{"post_id":"cl2flbwhu0000bkv2236dfg6l","category_id":"cl2462ezy0001cov23z9kghje","_id":"cl2flbwi90003bkv2hgzd09an"},{"post_id":"cl2bd00s80000pkv21osde9l8","category_id":"cl2462ezy0001cov23z9kghje","_id":"cl2flbwi90004bkv253weajri"},{"post_id":"cl2fvt0ng00009cv2f1zm4pr5","category_id":"cl2462ezy0001cov23z9kghje","_id":"cl2fvt0nn00029cv2g5cobl2k"},{"post_id":"cl2fwocup0000vkv2e2xxbmp8","category_id":"cl2462ezy0001cov23z9kghje","_id":"cl2fwocuu0002vkv26vny8uvo"},{"post_id":"cl2ixwni600002cv2gwl4d5dc","category_id":"cl2ixwnid00012cv27a2o8hjm","_id":"cl2ixwnih00032cv227ptdm0k"},{"post_id":"cl2k848520000nkv2bchc1au6","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2k8485f0002nkv25ee05v7d"},{"post_id":"cl2nj9rys0000w0v2c9j9b6z2","category_id":"cl2462f0g000ccov2hjrr11h0","_id":"cl2nj9ryz0006w0v2gjr4gex8"},{"post_id":"cl2nj9ryv0001w0v2cnax0ghv","category_id":"cl2462f0g000ccov2hjrr11h0","_id":"cl2nj9rz4000aw0v22093dr8r"},{"post_id":"cl2nj9ryz0005w0v2fxf7enkl","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2nj9rz6000fw0v2cnpndjm8"},{"post_id":"cl2nj9rz40009w0v233aa9hgl","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2nj9rz7000iw0v2b3b3av0v"},{"post_id":"cl2nj9rz4000cw0v25yzw6ono","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2nj9rz8000lw0v2770i3vuh"},{"post_id":"cl2nj9rz5000ew0v26xidbnoi","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2nj9rza000rw0v22dwpc6d7"},{"post_id":"cl2nj9rz6000hw0v2bdvzeaxp","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2nj9rzb000tw0v2egbf3u1p"},{"post_id":"cl2nj9rz7000kw0v2fdj92dr2","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2nj9rzb000vw0v28nk4cyk0"},{"post_id":"cl2nj9rz8000nw0v23o6d2ycz","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2nj9rzb000ww0v27xwhc184"},{"post_id":"cl2nj9rz9000qw0v21yo847vr","category_id":"cl2462ezy0001cov23z9kghje","_id":"cl2nj9rzb000xw0v246bzdqen"},{"post_id":"cl2oa3oub0000p0v27mn93nyr","category_id":"cl2nj9ryz0007w0v2ddxzgl4t","_id":"cl2oa3oup0006p0v2cgpn0uim"},{"post_id":"cl2oa3oul0002p0v2814m0wft","category_id":"cl2462ezy0001cov23z9kghje","_id":"cl2oa3oup0008p0v22odc8idp"},{"post_id":"cl2oa3oun0004p0v267hl7wju","category_id":"cl2nj9ryz0007w0v2ddxzgl4t","_id":"cl2oa3oup0009p0v2ejwm45st"},{"post_id":"cl2462f060003cov2fahrfq16","category_id":"cl2oa3oue0001p0v2efkf3hm4","_id":"cl2oa3oup000ap0v28lbt1479"},{"post_id":"cl2r2wk4r00001gv29wtv43do","category_id":"cl2nj9ryz0007w0v2ddxzgl4t","_id":"cl2r2wk5700051gv206k4errw"},{"post_id":"cl2r2wk4x00011gv2dhrocvg0","category_id":"cl2r2wk5100031gv2deyvhpiu","_id":"cl2r2wk5700061gv2ecez5dwd"},{"post_id":"cl2sexu6n0000r4v2323jdjld","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2sexu6u0002r4v238cgcdf3"},{"post_id":"cl2sexu6y0003r4v2f5sg4e84","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2sexu710005r4v2dl2578j4"},{"post_id":"cl2vkltig0000q8v2175i17tj","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2vkltiq0002q8v218d8g82m"},{"post_id":"cl2ww38h90000pkv226rsh94z","category_id":"cl2462f070004cov2f9020e3s","_id":"cl2ww38hf0002pkv28500glh7"},{"post_id":"cl2xidk2r000064v2htbsf2tz","category_id":"cl2xidk2v000164v2ff603h5y","_id":"cl2xidk35000364v241pube3b"}],"PostTag":[{"post_id":"cl245sb4z0000s0v20g663k5p","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2462f0e000bcov23wmohuhb"},{"post_id":"cl245sb560001s0v2bzx12eg8","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2462f0i000fcov2gkdw9n6k"},{"post_id":"cl186hpxq0000vgv2fovs52rg","tag_id":"cl2462f030002cov2h2e3992b","_id":"cl2462f0j000jcov24st5ds2k"},{"post_id":"cl2462f060003cov2fahrfq16","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2462f0k000pcov23chp68zr"},{"post_id":"cl03y1b0800003wv2hx8mg9y2","tag_id":"cl2462f0j000gcov29et333mz","_id":"cl2462f0m000tcov26n0v92l6"},{"post_id":"cl04122ju0001pgv2ah9oewd6","tag_id":"cl2462f0j000gcov29et333mz","_id":"cl2462f0m000wcov2g011c60h"},{"post_id":"cl02m4pyp0001fsv2bf156buq","tag_id":"cl2462f0j000gcov29et333mz","_id":"cl2462f0n000zcov2bik6aciv"},{"post_id":"cl2772w3z00004sv21bda7355","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2772w4100014sv26n32g59b"},{"post_id":"cl2flbwhu0000bkv2236dfg6l","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2flbwi80001bkv20mo3faq7"},{"post_id":"cl2bd00s80000pkv21osde9l8","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2flbwi90002bkv24y80gint"},{"post_id":"cl2fvt0ng00009cv2f1zm4pr5","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2fvt0nn00019cv26usn98j3"},{"post_id":"cl2fwocup0000vkv2e2xxbmp8","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2fwocuu0001vkv2bh1qc2q7"},{"post_id":"cl2ixwni600002cv2gwl4d5dc","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2ixwnih00022cv2b76c6sbi"},{"post_id":"cl2k848520000nkv2bchc1au6","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2k8485f0001nkv27hf888f1"},{"post_id":"cl2nj9rys0000w0v2c9j9b6z2","tag_id":"cl2462f030002cov2h2e3992b","_id":"cl2nj9ryx0002w0v235m75qrh"},{"post_id":"cl2nj9ryv0001w0v2cnax0ghv","tag_id":"cl2462f030002cov2h2e3992b","_id":"cl2nj9ryy0004w0v22z9h9j94"},{"post_id":"cl2nj9ryz0005w0v2fxf7enkl","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2nj9rz4000bw0v2awo093kp"},{"post_id":"cl2nj9rz40009w0v233aa9hgl","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2nj9rz5000dw0v22gmz19s0"},{"post_id":"cl2nj9rz4000cw0v25yzw6ono","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2nj9rz6000gw0v2046f87wb"},{"post_id":"cl2nj9rz5000ew0v26xidbnoi","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2nj9rz7000jw0v2evl9e8j8"},{"post_id":"cl2nj9rz6000hw0v2bdvzeaxp","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2nj9rz8000mw0v2bspybzny"},{"post_id":"cl2nj9rz7000kw0v2fdj92dr2","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2nj9rz9000pw0v295w27bjd"},{"post_id":"cl2nj9rz8000nw0v23o6d2ycz","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2nj9rza000sw0v2a8t0fs0e"},{"post_id":"cl2nj9rz9000qw0v21yo847vr","tag_id":"cl2462f030002cov2h2e3992b","_id":"cl2nj9rzb000uw0v2go0fao70"},{"post_id":"cl2oa3oub0000p0v27mn93nyr","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2oa3oun0003p0v2bl945p1c"},{"post_id":"cl2oa3oul0002p0v2814m0wft","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2oa3ouo0005p0v26rgd71fm"},{"post_id":"cl2oa3oun0004p0v267hl7wju","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2oa3oup0007p0v215l98gg8"},{"post_id":"cl2r2wk4r00001gv29wtv43do","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2r2wk5000021gv214rjhcnf"},{"post_id":"cl2r2wk4x00011gv2dhrocvg0","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2r2wk5600041gv28wnl3nze"},{"post_id":"cl2sexu6n0000r4v2323jdjld","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2sexu6t0001r4v2g3cegqum"},{"post_id":"cl2sexu6y0003r4v2f5sg4e84","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2sexu700004r4v29xf3fous"},{"post_id":"cl2vkltig0000q8v2175i17tj","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2vkltio0001q8v25fwqe775"},{"post_id":"cl2ww38h90000pkv226rsh94z","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2ww38hf0001pkv253ay33zv"},{"post_id":"cl2xidk2r000064v2htbsf2tz","tag_id":"cl2462f080005cov2dtzoajqo","_id":"cl2xidk34000264v25tbsbnai"}],"Tag":[{"name":"code","_id":"cl03y1b0f00023wv20897ccu4"},{"name":"projects","_id":"cl186hpxu0001vgv2hv4qcxhe"},{"name":"problems","_id":"cl2462f030002cov2h2e3992b"},{"name":"study","_id":"cl2462f080005cov2dtzoajqo"},{"name":"homework","_id":"cl2462f0j000gcov29et333mz"}]}}