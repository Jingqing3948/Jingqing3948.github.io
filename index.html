<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title> 灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">灰海宽松的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['没有一条路无风无浪', '常应常静，常清净矣', 'Love the Life You Live'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-项目学习：黑马点评"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/05/21/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/"
    >项目学习：黑马点评</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/21/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/" class="article-date">
  <time datetime="2025-05-20T23:00:00.000Z" itemprop="datePublished">2025-05-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="黑马点评项目介绍"><a href="#黑马点评项目介绍" class="headerlink" title="黑马点评项目介绍"></a>黑马点评项目介绍</h1><p>类似大众点评。</p>
<p>要实现的功能：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232128675.png" alt="image-20250523124316562"></p>
<h1 id="项目导入"><a href="#项目导入" class="headerlink" title="项目导入"></a>项目导入</h1><p>基础代码，数据库等，不过多赘述。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232128575.png" alt="image-20250523124618786" style="zoom:50%;" />

<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p>不是微服务是单体架构模式，因为重点还是在 Redis 学习上。Springboot 那个课涉及微服务实战，我后面应该也会学习一下。</p>
<p>架构图如下，前后端分离，开发完成后前后端分别部署在 Nginx 和 Tomcat 上。</p>
<pre class="mermaid">graph LR
    K1[客户端]
    K2[客户端]
    K3[客户端]
    K1-->N[前端<br>Nginx]
    K2-->N
    K3-->N
    N-->T[后端<br>Tomcat]
    subgraph Redis 集群
        R1[Redis]
        R2[Redis]
        R3[Redis]
        end
    T-->R1
    T-->R2
    T-->R3
    subgraph MySQL 集群
        M1[MySQL]
        M2[MySQL]
        M3[MySQL]
    end
    T-->M1
    T-->M2
    T-->M3</pre>

<p>后期这个项目可能还会做一些水平横向扩展，比如多 Tomcat 集群数据共享等，后面再扩展。</p>
<p>导入 nginx 前端，mysql 数据库及 java 后端服务器运行后就可以看到如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232128062.png" alt="image-20250523212804999"></p>
<h1 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h1><h2 id="Session-实现"><a href="#Session-实现" class="headerlink" title="Session 实现"></a>Session 实现</h2><p>首先用 Session 尝试实现一下。</p>
<pre class="mermaid">graph TD

%% 校验登录状态
subgraph 校验登录状态
    C1[开始] --> C2[请求并携带 cookie]
    C2 --> C3[从 session 获取用户]
    C3 --> C4{判断用户是否存在}
    C4 -- 有 --> C5[保存用户到 ThreadLocal]
    C5 --> C6[放行]
    C6 --> C7[结束]
    C4 -- 没有 --> C8[拦截]
    C8 --> C7
end

%% 短信验证码登录/注册
subgraph 短信验证码登录/注册
    B1[开始] --> B2[提交手机号和验证码]
    B2 --> B3{校验验证码}
    B3 -- 不一致 --> B2
    B3 -- 一致 --> B4[根据手机号查询用户]
    B4 --> B5{用户是否存在}
    B5 -- 不存在 --> B6[创建新用户]
    B6 --> B7[保存用户到数据库]
    B7 --> B8[保存用户到 session]
    B5 -- 存在 --> B8
    B8 --> B9[结束]
end

%% 发送短信验证码
subgraph 发送短信验证码
    A1[开始] --> A2[提交手机号]
    A2 --> A3{校验手机号}
    A3 -- 不符合 --> A2
    A3 -- 符合 --> A4[生成验证码]
    A4 --> A5[保存验证码到 session]
    A5 --> A6[发送验证码]
    A6 --> A7[结束]
end</pre>

<p>其他地方都比较好理解。保存用户到 ThreadLocal 是因为每次访问用户信息都要访问 session。</p>
<h2 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h2><p>点击用户登录界面，输入手机号尝试发送短信，根据发送链接 <code>xxx/user/code?phone=xxx</code> 可以看出请求路径是 <code>/user/code</code>，请求参数是电话号码，无返回值。</p>
<p>在 <code>UserController</code> 类文件中可以看到这个待完成的函数 <code>public Result SendCode</code>，具体的发送短信请求还是交给 <code>userService</code> 去实现的，所以我们这里补全这个函数将任务交给 <code>userService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/UserController.java</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> IUserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送手机验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源代码中，有一个 <code>IUserService</code> 接口里面声明了所有需要实现的 <code>UserService</code> 方法（目前是空的），然后 <code>UserServiceImpl</code> 类继承自 <code>ServiceImpl</code> 类实现了 <code>IUserService</code>。所以通过 IDEA 快速补全，我们先在 <code>IUserService</code> 里面添加一个待实现的 <code>sendCode </code>方法，然后再在 <code>UserServiceImpl</code> 里面实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/IUserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/UserServiceImpl.java</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">// 用于 log.debug 传递多个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据流程图分析步骤</span></span><br><span class="line">        <span class="comment">// 1. 校验手机号</span></span><br><span class="line">        <span class="comment">// 2. 如果不符合，返回错误信息</span></span><br><span class="line">        <span class="comment">// 在老师提供的 utils 工具类里面有校验手机号的正则表达式</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3， 如果符合，生成验证码</span></span><br><span class="line">        <span class="comment">// 随机生成6位数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 保存验证码到 session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发送验证码</span></span><br><span class="line">        <span class="comment">// 这里就和具体的运营商服务平台等等有关了，其实不算什么重点，就随便写一下代替一下</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 返回 ok</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232245964.png" alt="image-20250523224519872" style="zoom:67%;" />

<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>现在可以发送验证码了，用户收到验证码之后怎么校验登录呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/UserController.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">// TODO 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> userService.login(loginForm, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/IUserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/UserServiceImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 校验手机号。虽然之前发送验证码的时候已经校验过了，</span></span><br><span class="line">    <span class="comment">// 但是现在用户填写完成验证码又改了一个错误的手机号再提交也是有可能的。所以有必要二次验证</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !code.equals(cacheCode.toString()))&#123;</span><br><span class="line">        <span class="comment">// 3. 不一致，报错</span></span><br><span class="line">        <span class="comment">// 反向嵌套，避免越嵌套越深</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 一致，根据手机号查询用户 select * from user where phone = xxx</span></span><br><span class="line">    <span class="comment">// 这个类继承自 ServiceImpl，由 mybatisplus 提供，可以实现方便的单表增删改查。</span></span><br><span class="line">    <span class="comment">// 我们已经在 User 里面注解了对应的 MySQL 表是 tb_user，传给 ServiceImpl 就可以实现方便的 MySQL 操作</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 6. 不存在，创建新用户，保存用户到数据库</span></span><br><span class="line">        <span class="comment">// 其实创建用户大多数字段都不需要知道，先手机号，然后随机生成一个昵称就行了</span></span><br><span class="line">        user = createUserwithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 保存用户到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">// return 就不需要给用户 token 了，因为 session id 已经自动存在 cookie 里面了，用户带着 cookie 就能校验</span></span><br><span class="line">    <span class="keyword">return</span>  Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createUserwithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setPhone(phone);</span><br><span class="line">    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mybatis 修改数据库命令：</span></span><br><span class="line">    save(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现登录校验功能了，不过我们会发现用户登录信息没有被成功保存，登陆之后再点击用户，还是需要输入手机号发验证码登录验证。</p>
<h2 id="登录校验拦截器"><a href="#登录校验拦截器" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h2><p><code>xxx/user/me</code> 是登录校验的请求，查询是否已经登录。</p>
<p>按理来说我们应该在每个 Controller 里面补全代码，根据获取到的 cookie 里携带的 session id 去找到对应的 session，进而获取到对应的用户数据。但是有很多 Controller 可能都需要这样获取用户信息，所以这种写法就不太好。</p>
<p>我们可以用拦截器处理：</p>
<pre class="mermaid">graph LR
    A[拦截器<br>（统一入口）] --> B[OrderController]
    A --> C[UserController]
    A --> D[XxxController]</pre>

<p>然后拦截器校验完，按我们之前说的，把用户信息缓存到 ThreadLocal 里面供这些控制类取用。</p>
<p>拦截器可以写在 utils 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/LoginInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// preHandle 实现：到达 Controller 之前执行，进行登录校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 session 中的用户信息</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4. 不存在，拦截。最好加一些标识.401 状态码表示未授权</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 存在，保存用户信息到 ThreadLocal。老师已经写好了：</span></span><br><span class="line">        UserHolder.saveUser((User) user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 放行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 实现：Controller 执行完成之后执行，销毁用户数据避免内存泄露</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拦截器做好了，接下来需要配置一个 MVC 使其生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/MvcConfig.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 添加拦截器，并且除外一些不需要拦截的路径</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">// 其实有挺多用不到用户信息的，随便写一些做个示范。</span></span><br><span class="line">                        <span class="comment">// 比如店铺信息，热门博客，用户发送验证码，用户登录这些其实都用不到用户的信息</span></span><br><span class="line">                        <span class="string">&quot;shop/xx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;shop-type/xx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，再回到对应的控制类里面完善代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/UserController.java</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">me</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前登录的用户并返回</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行，现在登录完就可以看到用户信息了：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241406383.png" alt="image-20250524140619277" style="zoom:67%;" />

<p>但是目前这样实现有一个非常严重的问题：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241413447.png" alt="image-20250524141312310"></p>
<p>是的密码也会返回。</p>
<h2 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h2><p>我们再捋一下用户信息泄露的整个过程：</p>
<ol>
<li>用户信息在数据库里。</li>
<li>登录校验后，从数据库中取得用户信息，存到 session 也就是 Tomcat 的内存空间里面，方便后续使用。</li>
<li>校验登录状态：根据 cookie 传来的 session id，在 session 中找到对应存在的用户后，存到 ThreadLocal 里面方便后续使用。</li>
</ol>
<p>要不直接就不把密码什么的无用或者敏感信息存到 session 里面，也能节约内存空间，也安全？</p>
<p>这里老师直接定义了一个类：UserDTO，里面只有用户 id 昵称 头像三个属性。所以我们存数据到 session 里面之前需要将 User 转成 UserDTO 类型。这里也可以直接用工具类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/UserServiceImpl.java</span></span><br><span class="line"><span class="comment">// public Result login(LoginFormDTO loginForm, HttpSession session)</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));</span><br></pre></td></tr></table></figure>

<p>相应的，取用户信息的时候也应该用 UserDTO 类型接着。包括 ThreadLocal 里面也应该改成存入 UserDTO 信息。</p>
<p>这部分我就不一一阐述了，记不太清都有哪些要改了，反正就顺着改类型就行，UserDTO 也有 getId() 等方法。</p>
<p>现在在开发者模式看获取到的 UserDTO 信息格式如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241445854.png" alt="image-20250524144557746"></p>
<h2 id="Session-共享问题"><a href="#Session-共享问题" class="headerlink" title="Session 共享问题"></a>Session 共享问题</h2><p>Session 是存在服务器自身的内存空间的，所以多台 Tomcat 不共享 Session。</p>
<p>所以可能上一秒用户请求被负载均衡到服务器1，成功登陆，下一秒被负载均衡到服务器2又要重新登陆，非常影响使用体验。</p>
<p>解决方法：其实也不难嘛，多服务器 session 拷贝就行吗？并不是，会有很多内存和时间上的损失，拷贝过程中如果用户发送请求可能也会出错。</p>
<p>那么就需要找到 session 的替代方案，这个替代品需要满足：</p>
<ol>
<li>数据共享，因为我们就想解决这个问题。</li>
<li>内存存储，因为要和 session 有差不多的性能。</li>
<li>键值对形式，因为这种实现方法比较简单。</li>
</ol>
<p>答案就是 Redis 了。</p>
<h2 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h2><p>我们先盘点一下 Redis 实现相较 Session 实现的，不一样的问题：</p>
<ol>
<li>键值对设计。比如验证码，session 里面是让键&#x3D;code 值&#x3D;对应验证码数字，redis 我们可以让 String 表示验证码数字字符串，但是 key 不可以&#x3D;”code”，因为 session 对于每个不同的客户端都不一样，所以不同客户端的 session 验证码属性都叫 code 也不冲突，但是 redis 是一个键唯一的数据库，所以不能不同客户端的 key 都叫 “code”。可以用手机号代替，手机号也是唯一标识：”phone:xxx” 这样。</li>
<li>之前将用户数据保存到 session，我们的实现非常简单，直接存到 session，浏览器自动就把 session id 写到 cookie 里面，下次发过来的时候我们用 session id 去查找对应的 session 非常方便，但是换成 redis 这些部分就没有自动实现了，需要我们再根据用户提交的手机号作为 key 去 redis 数据库里查询。这个过程其实也顺带校验了手机号是否存在，因为把手机号作为 key，直接去 redis 里面查询 value，如果找不到对应的键值对，也说明了手机号错误。</li>
<li>存储用户数据用什么数据类型？存储对象常见两种方式，一种是 String JSON 形式，另一种是 Hash 存储每个字段。推荐 Hash 方法，因为可以对每个字段进行 CRUD，并且内存占用更少。</li>
<li>存储用户数据，键用什么？也可以用手机号，不过更推荐用 token （生成一个随机字符串）。当然，相比 session （浏览器自动将 session id 存入 cookie）的实现，我们还需要加一步，手动将 token 传回给前端保存，这样用户下次校验登录状态时该客户端才能拿着一样的 token 来取数据。而且相较于手机号更安全，前端可见。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241519713.png" alt="image-20250524151949549"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：黑马程序员 Redis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/05/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Redis/"
    >技术学习：黑马程序员 Redis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Redis/" class="article-date">
  <time datetime="2025-05-20T23:00:00.000Z" itemprop="datePublished">2025-05-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习自：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t/?p=2&share_source=copy_web&vd_source=dcdc734e318da0cd82bcccb180b12b40">【黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目】 </a></p>
<h2 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs. NoSQL"></a>SQL vs. NoSQL</h2><ul>
<li>S：结构化，比如在 MySQL 我们需要定义一个表，第一个属性是 id 第二个是 name 第三个是 age…… 定义好表之后所有新插入的数据都必须遵循这个结构，各个表还可能有外键等关联，所以总的来说不能随意修改表的属性。而 NoSQL 结构要求没那么严格，比如下面这种 Redis 定义方式也可以，就是没啥章法：</li>
</ul>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505211052874.png" alt="image-20250521105232832" style="zoom:67%;" />

<p>​	除了键值类型，还有文档类型，列类型，图类型等 NoSQL。</p>
<ul>
<li><p>R：关联的，SQL 数据库的各个属性之间有关联而 NoSQL 未必。</p>
</li>
<li><p>SQL 语句查询：关系型数据库都支持，而非关系型不支持。</p>
</li>
<li><p>ACID 事务：NoSQL 不支持。</p>
</li>
<li><p>存储位置：SQL 在硬盘，NoSQL 在内存。</p>
</li>
<li><p>SQL 对安全一致性要求较高，NoSQL 对性能要求较高。</p>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis Remote Dictionary Server 是一种基于内存的<strong>键值对</strong>数据库，被创造的原因就是 MySQL 性能太差。里面没有表什么的结构，就是存储一对一对的键值，所以是 NoSQL 数据库。值可以是复杂的数据形式，比如键是 1001，值是 {name: “xxx”, age:”19”}…… 这样的 json 格式。</p>
<p>Redis 是<strong>单线程</strong>的，但是效率仍然比 MySQL 高很多，因为内存存取速度远大于硬盘，C 语言编写，IO 多路复用等特点。</p>
<p>支持<strong>数据持久化</strong>，定期将数据从内存持久化到磁盘存储。</p>
<p>支持主从集群，分片集群。</p>
<p>支持多语言客户端。</p>
<h1 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h1><p>安装部分就跳过不做过多赘述了。</p>
<p>Redis 默认启动方式是前台启动，会阻塞整个会话窗口。可以通过修改配置文件的方式改为后台启动。或者在 system 文件夹内新建一个系统服务 .service 文件，实现开机自启动。</p>
<p>配置完成后，终端客户端连接：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">start</span> redis # 启动 redis 后台服务</span><br><span class="line">$ redis-cli -h <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> [-p port] [-a password] # 客户端终端方式连接 redis-cli</span><br><span class="line">&gt; AUTH password # 输入用户名和密码进行登录，也可以在上面 -a 那一步登录 不过这样不安全</span><br><span class="line">&gt; <span class="built_in">ping</span> # 如果成功登录了就会收到：PONG 否则会受到权限不够的提示</span><br><span class="line"></span><br><span class="line">&gt; SELECT <span class="number">1</span> # 选择一个库，<span class="number">0</span>-<span class="number">15</span></span><br><span class="line">&gt; get key # 获取某个键对应的值</span><br><span class="line">&gt; <span class="built_in">set</span> key value # 添加一个键值对</span><br></pre></td></tr></table></figure>

<p>图形化客户端连接：其实不是官方开发的是 Github 上有人发布的开源图形化客户端。</p>
<h2 id="Redis-通用命令"><a href="#Redis-通用命令" class="headerlink" title="Redis 通用命令"></a>Redis 通用命令</h2><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p><code>Keys pattern</code> 查询符合某种模式的键，比如 <code>keys a*</code> 是查询 a 打头的所有键值。</p>
<p>这个查询并不高效，而且会阻塞其他请求，所以在生产环境中尽量不要使用，特别是不要在主节点上使用。</p>
<h3 id="Del"><a href="#Del" class="headerlink" title="Del"></a>Del</h3><p><code>Del key1 key2 ...</code> 删除键值对。返回值是成功删除的键数量。</p>
<h3 id="MSet"><a href="#MSet" class="headerlink" title="MSet"></a>MSet</h3><p><code>msel k1 v1 k2 v2 ...</code> 批量添加键值对。</p>
<h3 id="Exists"><a href="#Exists" class="headerlink" title="Exists"></a>Exists</h3><p><code>exists key</code> 查询指定键是否存在。</p>
<h3 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h3><p>给键值对设定一个有效期，到期自动删除。</p>
<p><code>expire key seconds</code></p>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p><code>ttl key</code> 查询这个键还有多久过期。-1表示永久有效，-2表示已过期。</p>
<h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><p>key 一般是 string 类型，而 value 类型多种多样。</p>
<ul>
<li>String：字符串。</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>sortedset</li>
</ul>
<p>以上为基本数据类型。</p>
<ul>
<li>geo</li>
<li>bitmap</li>
<li>hyperlog</li>
</ul>
<p>以上为特殊数据类型。</p>
<p>在 redis 里面输入 <code>help @想要查询的 command 名称</code> 就可以进行查询。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>最简单的存储方式，字符串类型。具体可以分为三类：String，int，float。</p>
<p>是的 int 和 float 在 redis 里被视作属于 string。</p>
<p>这些底层存储方式都是字节数组，只不过数字会被直接转化为对应的二进制，这样能存储的范围更大。</p>
<table>
<thead>
<tr>
<th>字符串常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set key value</code></td>
<td>添加键值对，如果存在则覆盖</td>
</tr>
<tr>
<td><code>Get key</code></td>
<td>获取这个键的值</td>
</tr>
<tr>
<td><code>MSet k1 v1 k2 v2</code></td>
<td>批量添加</td>
</tr>
<tr>
<td><code>MGet k1 k2 k3</code></td>
<td>批量获取</td>
</tr>
<tr>
<td><code>INCR key</code></td>
<td>让一个整形 Key 对应的值自增1</td>
</tr>
<tr>
<td><code>INCRBY key step</code></td>
<td>指定步长的自增，如步长是2。可以指定为负数来取代 DECR 的功能。</td>
</tr>
<tr>
<td><code>INCRBYFLOAT key step</code></td>
<td>浮点数据的指定长度的自增</td>
</tr>
<tr>
<td><code>SETNX k v</code></td>
<td>添加一个 String 类型的键值对，如果存在则不执行返回0. 其实 <code>set key value nx</code> 也能实现同样的效果</td>
</tr>
<tr>
<td><code>SETEX k v seconds</code></td>
<td>添加一个 String 类型的键值对并指定有效期。<code>set key value ex</code> 也能实现同样的效果</td>
</tr>
</tbody></table>
<h4 id="Key-的层级格式"><a href="#Key-的层级格式" class="headerlink" title="Key 的层级格式"></a>Key 的层级格式</h4><p>Redis 没有 MySQL 的 Table，如何区分不同的 key 意义呢，比如一个商品 id 是1，一个顾客 id 也是1.</p>
<p>Redis 允许键值进行拼接，如：<code>项目名:业务名:类型:id</code> 这样。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:user:<span class="number">1</span> &#x27;&#123;&quot;id&quot;:<span class="number">1</span>, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;: <span class="number">21</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:user:<span class="number">2</span> &#x27;&#123;&quot;id&quot;:<span class="number">2</span>, &quot;name&quot;:&quot;Rose&quot;, &quot;age&quot;: <span class="number">18</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:product:<span class="number">1</span> &#x27;&#123;&quot;id&quot;:<span class="number">1</span>, &quot;name&quot;:&quot;小米<span class="number">11</span>&quot;, &quot;price&quot;: <span class="number">4999</span>&#125;&#x27;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:product:<span class="number">2</span> &#x27;&#123;&quot;id&quot;:<span class="number">2</span>, &quot;name&quot;:&quot;荣耀<span class="number">6</span>&quot;, &quot;price&quot;: <span class="number">2999</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看图形化客户端可以发现：Key 已经形成层级结构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212230806.png" alt="image-20250521223051719"></p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>无序字典，类似 java HashMap.</p>
<p>之前我们学过，String 处理对象的方式是变成 json 字符串，但是这样缺点是修改比较难操作。而 Hash 数据结构是可以真正将所有字段都分开存储方便操作。</p>
<table>
<thead>
<tr>
<th>Hash 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>HSET key field value</code></td>
<td>添加或者修改 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HGET key field</code></td>
<td>获取一个 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HMSET key f1 v1 ...</code></td>
<td>批量添加多个 hash 类型 key 的 field 的值（Redis 4.0+ 推荐用 HSET）</td>
</tr>
<tr>
<td><code>HMGET key f1 f2 ...</code></td>
<td>批量获取多个 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HGETALL key</code></td>
<td>获取一个 hash 类型的 key 中的所有的 field 和 value</td>
</tr>
<tr>
<td><code>HKEYS key</code></td>
<td>获取一个 hash 类型的 key 中的所有 field</td>
</tr>
<tr>
<td><code>HVALS key</code></td>
<td>获取一个 hash 类型的 key 中的所有 value</td>
</tr>
<tr>
<td><code>HINCRBY key field step</code></td>
<td>让一个 hash 类型 key 的字段值自增，并指定步长</td>
</tr>
<tr>
<td><code>HSETNX key field value</code></td>
<td>添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</td>
</tr>
</tbody></table>
<p>添加完字段之后，图形化界面中可视化结构：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212241594.png" alt="image-20250521224155538"></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>大致可以看做 java 的双向链表结构。有序，插入删除速度快，查询速度一般。</p>
<p>常常用于存储有顺序的数据，比如排队，朋友圈点赞列表等。</p>
<table>
<thead>
<tr>
<th>List 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>LPUSH key element ...</code></td>
<td>向列表左侧插入一个或多个元素</td>
</tr>
<tr>
<td><code>LPOP key</code></td>
<td>移除并返回列表左侧的第一个元素，没有则返回 nil</td>
</tr>
<tr>
<td><code>RPUSH key element ...</code></td>
<td>向列表右侧插入一个或多个元素</td>
</tr>
<tr>
<td><code>RPOP key</code></td>
<td>移除并返回列表右侧的第一个元素</td>
</tr>
<tr>
<td><code>LRANGE key start end</code></td>
<td>返回一段脚标范围内的所有元素（脚标从左0开始向右逐渐增加）</td>
</tr>
<tr>
<td><code>BLPOP key [key ...] timeout</code></td>
<td>与 LPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil</td>
</tr>
<tr>
<td><code>BRPOP key [key ...] timeout</code></td>
<td>与 RPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil</td>
</tr>
</tbody></table>
<p>用 List 模拟栈：只用 LPUSH 和 LPOP 或者 RPUSH RPOP 同向。</p>
<p>用 List 模拟队列：LPUSH+RPOP 或 RPUSH+LPOP 不同向。</p>
<p>用 List 模拟阻塞队列：首先需要入口和出口在不同边；其次出队使用 BLPOP 或者 BRPOP。</p>
<p><em>阻塞队列：当队列为空的时候，取元素的线程会等待一段时间直到队列非空。应用：线程池，待处理的任务先到等待队列，等待有空闲的线程时再开始被执行。这样不用一直创建新的线程，只利用现有的最大线程数，节约资源和响应速度。</em></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>类似 Java 中的 HashSet，无序，不重复，查找快，支持并集差集交集等运算。</p>
<table>
<thead>
<tr>
<th>Set 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD key member ...</code></td>
<td>向 set 中添加一个或多个元素</td>
</tr>
<tr>
<td><code>SREM key member ...</code></td>
<td>移除 set 中的指定元素</td>
</tr>
<tr>
<td><code>SCARD key</code></td>
<td>返回 set 中元素的个数</td>
</tr>
<tr>
<td><code>SISMEMBER key member</code></td>
<td>判断一个元素是否存在于 set 中</td>
</tr>
<tr>
<td><code>SMEMBERS key</code></td>
<td>获取 set 中的所有元素</td>
</tr>
<tr>
<td><code>SINTER key1 key2 ...</code></td>
<td>求 key1 与 key2 的交集</td>
</tr>
<tr>
<td><code>SDIFF key1 key2 ...</code></td>
<td>求 key1 与 key2 的差集</td>
</tr>
<tr>
<td><code>SUNION key1 key2 ...</code></td>
<td>求 key1 和 key2 的并集</td>
</tr>
</tbody></table>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>有点类似 java 的 treeset 但是底层逻辑差得很远。</p>
<p><em>java 的 treeset：一种有序集合，底层逻辑是红黑树。红黑树类似 AVL 树，这两种树在排序的同时也会保证树的左右子节点深度，数量差别不大以免树结构的复杂度变得和线性结构差不多，AVL 是规定左右子节点深度差不能超过1，而红黑树要求松一些，规定从根到叶子的最长路径不可能达到最短路径的2倍长，所以旋转操作相对 AVL 少一些，AVL 更适用于查找操作远多于插入删除操作数量的情况。</em></p>
<p>SortedSet 每个元素都带有一个 score 属性可以排序，通过跳表+hash表排序。</p>
<p><em>跳表结构大概如下，来加速单链表的查找效率。可以再多建几级索引。图源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Appleeatingboy/article/details/119948340">跳表的原理与实现 [图解]_跳表实现-CSDN博客</a></em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212313909.png" alt="img"></p>
<p>SortedSet 由于其排序效率高，常常被用于实现如排行榜这样的功能。</p>
<table>
<thead>
<tr>
<th>Sorted Set 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member</code></td>
<td>添加一个或多个元素到 sorted set，如果已经存在则更新其 score 值</td>
</tr>
<tr>
<td><code>ZREM key member</code></td>
<td>删除 sorted set 中的一个指定元素</td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>获取 sorted set 中指定元素的 score 值</td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>获取 sorted set 中指定元素的排名（从 0 开始）</td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取 sorted set 中的元素个数</td>
</tr>
<tr>
<td><code>ZCOUNT key min max</code></td>
<td>统计 score 值在指定范围内的元素个数</td>
</tr>
<tr>
<td><code>ZINCRBY key increment member</code></td>
<td>让 sorted set 中指定元素自增，步长为指定的 increment 值</td>
</tr>
<tr>
<td><code>ZRANGE key start stop</code></td>
<td>按 score 排序，获取指定排名范围内的元素 <em>如前十名</em></td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max</code></td>
<td>按 score 排序，获取指定 score 范围内的元素 <em>如60分~70分</em></td>
</tr>
<tr>
<td><code>ZDIFF / ZINTER / ZUNION</code></td>
<td>分别用于求差集、交集、并集</td>
</tr>
</tbody></table>
<p>以上都是升序，降序就在 Z 后面加 REV。</p>
<h2 id="Redis-的-Java-客户端"><a href="#Redis-的-Java-客户端" class="headerlink" title="Redis 的 Java 客户端"></a>Redis 的 Java 客户端</h2><p>主要有一下三种：</p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>简介</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Jedis</td>
<td>以 Redis 命令作为方法名称，学习成本低，简单实用。</td>
<td>实例非线程安全，多线程环境下需基于连接池使用。</td>
</tr>
<tr>
<td>Lettuce</td>
<td>基于 Netty 实现，支持同步、异步和响应式编程方式，线程安全。</td>
<td>支持 Redis 的哨兵模式、集群模式和管道模式。</td>
</tr>
<tr>
<td>Redisson</td>
<td>基于 Redis 实现的分布式、可伸缩 Java 数据结构集合。</td>
<td>提供如 <code>Map</code>、<code>Queue</code>、<code>Lock</code>、<code>Semaphore</code>、<code>AtomicLong</code> 等强大功能，适合分布式场景。</td>
</tr>
</tbody></table>
<p>spring data redis 整合了前两种。</p>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>使用方式很简单：引入依赖，建立连接，使用，释放资源。</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在 pom.xml 文件中粘贴：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505221740557.png" alt="image-20250522173946616"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一部分依赖是必须引入的，第二部分是测试用的。</p>
<p>执行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">SetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.73.129&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;369789&quot;</span>);</span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 插入hash数据</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line">        Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>Jedis 线程不安全，而且频繁创建销毁 Jedis 线程性能损耗比较大。</p>
<p><em>线程不安全的大概原因：每次 set 的时候都要调用 connect 方法。在 connect 方法里，一个实例的多个线程都共用一个 socket, inputstream, outputstream。所以如果线程1正在读写，线程2把 socket重新初始化了，那么1的连接就断了。或者两个线程同时读写，inputstream outputstream 共用可能就会导致输入或读取数据错误。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1678172">使用jedis面临的非线程安全问题-腾讯云开发者社区-腾讯云</a></em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505222302284.png" alt="img"></p>
<blockquote>
<p>图源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84481313">java客户端：Jedis和Jedis连接池的基本使用和配置 - 知乎</a></p>
</blockquote>
<p>创建连接池代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);<span class="comment">// 最大连接数</span></span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);<span class="comment">// 最大空闲连接数</span></span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);<span class="comment">// 最小空闲连接数，防止空闲连接被释放</span></span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.150.101&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建 Jedis 的时候改成使用连接池的获取代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis = JedisConnectionFactory.getJedis();</span><br></pre></td></tr></table></figure>

<p><code>jedis.close()</code> 函数底层如果判断有连接池的时候，就不会 close 关闭 Jedis 资源了，而是归还资源，所以不需要改。</p>
<h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h3><p>SpringData 是 Spring 的数据操作模块，其中的 Redis 集成模块叫做 SpringDataRedis。整合了多个 Redis 客户端，并提供了统一的访问 API。</p>
<p>支持 JDK json 字符串 对象等的序列化和反序列化，因为现在我们直接操作 Jedis 传入的都是 byte[] 数组，如果想传入 json 或者对象需要自己手动调整序列化。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>redisTemplate.opsForValue()</code></td>
<td><code>ValueOperations</code></td>
<td>操作 <code>String</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForHash()</code></td>
<td><code>HashOperations</code></td>
<td>操作 <code>Hash</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForList()</code></td>
<td><code>ListOperations</code></td>
<td>操作 <code>List</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForSet()</code></td>
<td><code>SetOperations</code></td>
<td>操作 <code>Set</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForZSet()</code></td>
<td><code>ZSetOperations</code></td>
<td>操作 <code>SortedSet</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate</code></td>
<td>-</td>
<td>通用的命令接口</td>
</tr>
</tbody></table>
<p>使用起来也非常简单。首先在 IDEA 里面创建项目的时候就可以创建 spring initilize 的项目，然后导入相关依赖（redis，连接池等），配置连接，直接使用。</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yaml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SpringDataRedis 默认引入了 Lettuce 的依赖，如果想在上面的配置文件中使用 jedis 也可以只不过就是需要在 pom.xml 里面也引入 jedis 的依赖。</p>
<p>代码测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;springtest&quot;</span>,<span class="string">&quot;springtest&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;springtest&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;value &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Redis 数据库中可见真正存入的数据形式其实是：\xAC\xED\x00\x05t\x00\x0Aspringtest，前面这一串可能就是 Spring Redis 的自动序列化用于记录对象格式的，反正 System.out.print 输出的是没有乱码的。</p>
<p><em>老师的案例里面，老师是写入的 name xxx 键值对，然后再去终端执行 redis 命令 <code>get name</code> 发现获取到的值并没有更新，也是一样的道理，因为老师实际存入的键也是类似 <code>\乱码 \乱码 name</code> 这样的形式，和 <code>get name</code> 访问的键不一样.</em></p>
<p>这种方式的主要两个问题：可读性差；内存占用大。Java 的 String 也会被视作是一种对象，而非单纯的 String。</p>
<h4 id="RedisTemplate-自定义和序列化"><a href="#RedisTemplate-自定义和序列化" class="headerlink" title="RedisTemplate 自定义和序列化"></a>RedisTemplate 自定义和序列化</h4><p>想要“写入什么值就存入什么值”，就必须去改写 RedisTemplate 的序列化方法（其实底层调用的是 <code>JDKSerializationRedisSerializer</code> 的序列化方法）。</p>
<p>对于字符串，或者键，可以将底层序列化方法改成：<code>StringRedisSerializer</code>，这个是专门处理字符串的序列化方法。</p>
<p>对于对象，可以用 <code>GenericJackson2JsonRedisSerializer</code> 转 JSON 字符串的序列化方法。</p>
<p>具体修改：新建一个 <code>RedisConfig</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123; <span class="comment">// 这里可见我们直接让 key 默认就是 String 类型了</span></span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具，用于对象处理</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是所有 key 都用字符串序列化方法，而所有的 value 都用 json 对象处理方法。</p>
<p>使用的时候，唯一区别就是声明要使用的 RedisTemplate 类是 &lt;String, Object&gt; 的，也就是我们刚刚生成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></pre></td></tr></table></figure>

<p>重新运行后发现数据库里面的键值都没有乱码了（值的话，可能 String Object 转换成 JSON 也是 String 的形式）。</p>
<p>尝试传入对象也非常顺利，假设新建了一个 User 对象，数据库中成功传入后的 json value 如下（第一句话就是帮助反序列化还原用的）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505231149205.png" alt="image-20250523114928080"></p>
<p>并且 java 输出里面自动反序列化成对象的输出形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value User(name=jingqing, age=22)</span><br></pre></td></tr></table></figure>

<p>但是可以看出，上面 class 那一行占用存储空间还是挺大的，比这个对象的其余部分内容都长。</p>
<p>不要这部分，就不能实现自动的反序列化了。要吧，又要占用内存空间。</p>
<h4 id="StringRedisTemplate-手动序列化"><a href="#StringRedisTemplate-手动序列化" class="headerlink" title="StringRedisTemplate 手动序列化"></a>StringRedisTemplate 手动序列化</h4><p>另一种实现方式是 <code>StringRedisTemplate</code> ，就是统一使用 String 序列化器。对于对象的存储，需要手动序列化或者反序列化。</p>
<p>实现起来也不是特别难，就是通过一个 <code>ObjectMapper</code> 将 String 映射成一个 json String 后传入数据库，传出的时候再通过映射类映射回来。也不需要自定义 RedisTemplate 的序列化方案了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 写入一条String数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取string数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以进一步将序列化后写入和读出后反序列化封装成工具类，用工具类直接写入和读出，这样代码复杂度上也降低了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：Software Engineering 软件工程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ASoftware%20Engineering%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"
    >北邮国院笔记：Software Engineering 软件工程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ASoftware%20Engineering%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="article-date">
  <time datetime="2024-12-01T00:00:00.000Z" itemprop="datePublished">2024-12-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="software-types"><a href="#software-types" class="headerlink" title="software types"></a>software types</h2><p>general: developed for a general market. (ps, office)</p>
<p>custom: developed for a particular aim. (embeded system)</p>
<h2 id="good-software-features"><a href="#good-software-features" class="headerlink" title="good software features"></a>good software features</h2><p>delivers required functionality</p>
<p>usable</p>
<p>efficient</p>
<p>dependable</p>
<p>maintainable</p>
<p>understandable</p>
<p>cost-effective</p>
<p>security</p>
<h2 id="what-is-software-engineering"><a href="#what-is-software-engineering" class="headerlink" title="what is software engineering?"></a>what is software engineering?</h2><p>using proper theories, tools, methods(organized and systematic), constraints to develop high quantity software.</p>
<h2 id="4-layers"><a href="#4-layers" class="headerlink" title="4 layers"></a>4 layers</h2><p>Tools, method, process, quality focus.</p>
<h2 id="Why-important"><a href="#Why-important" class="headerlink" title="Why important?"></a>Why important?</h2><p>large scale projects are hard to finish in time properly because of time, budget, disaster, etc. guiding scientific principles and universally applicable methods can reduce practice and frequent failures.</p>
<h2 id="General-issues-that-affect-software"><a href="#General-issues-that-affect-software" class="headerlink" title="General issues that affect software"></a>General issues that affect software</h2><p>Heterogeneity (distributed systems, different type of devices), business and social change, security and trust, scale.</p>
<h1 id="Software-process"><a href="#Software-process" class="headerlink" title="Software process"></a>Software process</h1><p>a set of structured activities to produce software.</p>
<p>includes: required specification, development(analysis, design, implementation), validation (test), evolution.</p>
<ul>
<li>required specification: what should this system do? a complete desc of the problem and environment constraints. contains: system function, future extension, documentation amount, time and preformance response</li>
<li>analysis: create a conceptual model.</li>
<li>design: implementable model (architecture, components of this system).</li>
<li>implementation: implementation of interfaces.</li>
<li>testing: unit, functional, integration, system, acceptance. test and implementation should run in parallel.</li>
<li>deployment: install, run and test on real environment.</li>
<li>evolution: corrective, adaptive, perfective, preventive.</li>
</ul>
<h2 id="process-models"><a href="#process-models" class="headerlink" title="process models"></a>process models</h2><p>a abstraction of process. activities must be modelled to be managed.</p>
<h3 id="waterfall"><a href="#waterfall" class="headerlink" title="waterfall"></a>waterfall</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332918.png" alt="1685629715429"></p>
<p>易于管理 monitor，结构化很好。前面的模块必须完成才能跳到下一个，也就要求我们在最初设计的时候对需求很清楚，但是很难不遇到一些问题，很难按照正常流程正常走。</p>
<h3 id="evolutionary-development"><a href="#evolutionary-development" class="headerlink" title="evolutionary development"></a>evolutionary development</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685629943510.png" alt="1685629943510"></p>
<p>交互性的活动，及时的反馈。核心需求能很好的满足，但是扩展性很差，结构性很差，缺少过程中的可见性。适合小型项目。</p>
<h3 id="rational-unified-process"><a href="#rational-unified-process" class="headerlink" title="rational unified process"></a>rational unified process</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685630556923.png" alt="1685630556923"></p>
<p>inception: 分析项目可行性。</p>
<p>elaboration: 分析风险，架构。</p>
<p>construction: iterative 迭代开发到 beta 版本为止。</p>
<p>transition: 交付到客户手中。</p>
<p>通用的完整流程，动态。但是开销大了。</p>
<h3 id="Agile-Software-Development"><a href="#Agile-Software-Development" class="headerlink" title="Agile Software Development"></a>Agile Software Development</h3><p>现代软件开发流程：敏捷开发。</p>
<p>Rapid software development 快速开发：争取每一版都交一个可以交付的东西给客户。</p>
<p>敏捷开发：系统在一次一次迭代小增量过程中建立而成。specification, design, implementation, testing 并行。专注于代码，轻量级代码频繁发布，维护简单。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/8a04dc9794b9fae3b772c1efab38b648.png" alt="image-20230507002834816"></p>
<p>Individuals and interactions over processes and tools </p>
<p>Working software over comprehensive documentation </p>
<p>Customer collaboration over contract negotiation </p>
<p>Responding to change over following a plan</p>
<p>敏捷开发需要程序员之外的项目经理，运营，测试……</p>
<p>敏捷开发重视价值，不要设计没价值的东西。实践一定要解决文分体，文档一定要有对应受众，不要过度设计系统。</p>
<p>敏捷开发注重 steer而不是percise prediction。由customer priorities 和 programmer estimates of  feature difficulty 共同制定不断迭代的计划。</p>
<p>开发原则：</p>
<p>• Emphasis on simple design and refactoring.</p>
<p>• Removing duplication.</p>
<p>• Increasing cohesion. </p>
<p>• Reducing coupling</p>
<p>常见的敏捷开发方法：如极限开发 Extreme Programming.</p>
<ul>
<li>每天构建几次新版本</li>
<li>每两周给用户提交一版增量</li>
<li>需求由用户描述</li>
<li>程序员Pair programming（两个人坐一起一起开发，效率差不多，而且对彼此代码更加了解）</li>
<li>先开发测试单元，再写代码</li>
<li>测试过了才算构建完成</li>
</ul>
<p>Test Driven Development (TDD): </p>
<ul>
<li>Define both an interface and a specification. </li>
<li>先写test后写code。</li>
<li>基于增量设计测试 Incremental。</li>
<li>每次构建后自动化测试 Automated。</li>
<li>客户参与测试 User involvement，测试包括程序员单元测试（unit test），客户确认测试（acceptance test，看是否符合需求）。</li>
</ul>
<p>敏捷开发的问题：</p>
<ul>
<li><p>客户易失去积极性 customers interests.</p>
</li>
<li><p>团队成员未必喜欢团队开发。</p>
</li>
<li><p>多方利益相关，prioritising change is difficult.</p>
</li>
<li><p>难维持简洁性，maintaining simplicity.</p>
</li>
<li><p>频繁变化，合同设计困难 contract。</p>
</li>
</ul>
<p>适用于多变的，客户要求明确的中小型系统。</p>
<h2 id="requirements"><a href="#requirements" class="headerlink" title="requirements"></a>requirements</h2><p>确定需求是软工设计中最重要的部分。</p>
<ul>
<li><p>feature to satisfy customer.</p>
</li>
<li><p>indicates what should this sys do.</p>
</li>
<li><p>可能是高层抽象的需求 high-level abstract 或者底层具体的 low-level specific.</p>
</li>
</ul>
<p>Stakeholder 利益相关者：受系统影响的组织或个人（当然有的软件可能是针对市场需求开发，而不存在具体的用户）。这些人站在不同角度上有不同见解。</p>
<p>客户不一定清晰描述其需求，也不一定清楚产品特性和功能，且其需求可能不断变化。</p>
<p>在确定需求环节投入的额外时间长远角度来看会节省更多的时间和金钱。</p>
<p>需求分为：functional 和 non functional.</p>
<h3 id="functional-requirements"><a href="#functional-requirements" class="headerlink" title="functional requirements"></a>functional requirements</h3><p>定义系统的需求，要干什么。比如教务系统对于老师和学生端提供的不同的服务。</p>
<p>这一部分要完整 completeness 清晰一致 consistency 的描述大需求，避免不必要的误解。</p>
<h3 id="non-functional-requirements"><a href="#non-functional-requirements" class="headerlink" title="non-functional requirements"></a>non-functional requirements</h3><p>这一部分比功能性更重要，相当于不满足这一部分系统错误，不满足功能需求系统有一些小bug。</p>
<p>Define system properties and constraints，比如时空复杂度，设备 capability。</p>
<p>Process requirements：比如质量标准，编程语言等。</p>
<p>Organisational requirements: 如系统要符合IT政策规定。</p>
<p>external requirements: 比如“用户密码不能泄露”。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332607.png" alt="1685634113657"></p>
<p>非功能性需求需要定量描述指标。不然比如“希望程序跑的快一点”这就很模糊。要有measure的方法区测量quantitative定量指标。</p>
<h3 id="Requirement-conflicts"><a href="#Requirement-conflicts" class="headerlink" title="Requirement conflicts"></a>Requirement conflicts</h3><p>要trade-off权衡需求，让所有人都同意一个最优需求。</p>
<h3 id="Requirement-document"><a href="#Requirement-document" class="headerlink" title="Requirement document"></a>Requirement document</h3><p>Software Requirements Specification (SRS) 软件需求规范，确认测试的参考规范，指明了应该实现的需求，但是不指明如何实现。</p>
<h3 id="Requirements-Capture"><a href="#Requirements-Capture" class="headerlink" title="Requirements Capture"></a>Requirements Capture</h3><p>Background Reading</p>
<p>Interviewing</p>
<p>Observation（观察用户使用系统的情况）</p>
<p>Document or Record Sampling（专业的observation）</p>
<p>Questionnaires</p>
<h2 id="敏捷开发中的需求"><a href="#敏捷开发中的需求" class="headerlink" title="敏捷开发中的需求"></a>敏捷开发中的需求</h2><h3 id="usr-stories"><a href="#usr-stories" class="headerlink" title="usr stories"></a>usr stories</h3><p>用户需求被称作用户故事，一两句话写在卡片上。</p>
<p>customer 给他们排序需求，development team分解实现任务。</p>
<p><em>As a user,  I want to backup my entire hard drive  so that I won’t lose any work.</em></p>
<p>写在 stories cards 上，按顺序贴在墙上大家讨论，注意重点不是记录而是大家的讨论。</p>
<h3 id="Project-glossary"><a href="#Project-glossary" class="headerlink" title="Project glossary"></a>Project glossary</h3><p>一些项目相关的专业术语，建议总结出来方便大家理解讨论。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230601235612956.png" alt="image-20230601235612956"></p>
<h3 id="Epics"><a href="#Epics" class="headerlink" title="Epics"></a>Epics</h3><p>大的 usr story。通常开始讨论前被拆分为小的块。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230601235720919.png" alt="image-20230601235720919"></p>
<h3 id="Acceptance-Criteria"><a href="#Acceptance-Criteria" class="headerlink" title="Acceptance Criteria"></a>Acceptance Criteria</h3><p>验收标准，通常写在故事卡背面，有助于理解需求和 invite negotiation with the team about the business  value that we are trying to create.</p>
<h3 id="Non-functional-Requirements-as-User-Stories"><a href="#Non-functional-Requirements-as-User-Stories" class="headerlink" title="Non-functional Requirements as User Stories"></a>Non-functional Requirements as User Stories</h3><p>比如用户表示：我希望电脑打cf fps高于100.</p>
<h3 id="usr-stories注意事项"><a href="#usr-stories注意事项" class="headerlink" title="usr stories注意事项"></a>usr stories注意事项</h3><ol>
<li>谁都能写，最好让更多的成员写。</li>
<li>整个 agile development 过程中都可以写。一开始开故事讨论会确定基本，后续随时可以添加。</li>
</ol>
<h3 id="Product-backlog"><a href="#Product-backlog" class="headerlink" title="Product backlog"></a>Product backlog</h3><p>需求按优先级排列的需求表。综合考虑多方因素。</p>
<p>MoSCoW：一种 dsdm 动态系统开发方法。</p>
<ul>
<li>must have：最重要的。</li>
<li>should have：如果时间资源超限可以被取代。</li>
<li>could have：用户期望的需求，完成后用户满意度会高。但是不必要。</li>
<li>want to have: 当前阶段不重要的。</li>
</ul>
<h3 id="Estimating"><a href="#Estimating" class="headerlink" title="Estimating"></a>Estimating</h3><p>估计项目用时。</p>
<blockquote>
<p> story point：故事点，用于表示完成一个产品待办项或者其他任何某项工作所需的所有工作量的估算结果。</p>
<p> 当采用故事点估算时，我们为每个待办项分配一个点数。待办项估算结果的原生数据并不重要，我们只关注最后得到的相对估算结果。一个估算值为2的用户故事应该是估算值为1的用户故事的2倍。而它也应该是另一个估算值为3的用户故事的三分之二。</p>
<p> 团队不要采用100、200、300，或者1百万、2百万、3百万，而要使用1、2、3。估算结果是比值，而不是绝对值。</p>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351172855">敏捷开发中到底什么是故事点（Story Point）？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="评判-good-usr-story"><a href="#评判-good-usr-story" class="headerlink" title="评判 good usr story"></a>评判 good usr story</h3><p>INVEST原则。</p>
<p>– Independent – Negotiable – Valuable – Estimatable – Small – Testable</p>
<h3 id="Prototyping"><a href="#Prototyping" class="headerlink" title="Prototyping"></a>Prototyping</h3><p>physical：比如画gui。</p>
<p>logical：元素，元素之间的关联……</p>
<p>Low-fidelity 低保真：最简单，比如手绘图，纸板做的，快速验证产品概念的可行性。</p>
<p>Medium-fidelity 中保真：数字模型。</p>
<p>high-fidelity：如3d打印，最接近产品但是制作麻烦。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685636483862.png" alt="1685636483862"></p>
<h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>仅仅从用户的需求来看得到的消息不全面，还需要分析。用户可能认为你明白了，或者他考虑不全面，觉得一些地方是不需要的。</p>
<p>因此我们需要分析来 Refining requirements。</p>
<p>gather requirements-analyse in real world context-develop the architecture</p>
<p>分析包括：Textual analysis (针对文档分析)，Entities and concepts（应用层面分析），Experience（过往经验分析）</p>
<h3 id="conceptual-model"><a href="#conceptual-model" class="headerlink" title="conceptual model"></a>conceptual model</h3><p>面向对象的UML图。</p>
<blockquote>
<p>边界类用于系统外部环境与内部交互进行建模的类。我的理解是不同系统之间的胶合层。能够减少系统之间的耦合。</p>
<p>控制类用于对一个或几个用例所特有的控制行为进行建模。控制类源于对用例场景中行为的定义。</p>
<p>实体类是对必须存储的信息和相关行为建模的类。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iron_sky/article/details/45478455">UML-分析类_Iron_Sky的博客-CSDN博客</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602013913446.png" alt="image-20230602013913446"></p>
<p>attributes: 属性和相应数据类型。比如姓名，字符串。</p>
<p>Operations：行为方法。一个operation一般只做一件事。</p>
<p>relationships: – Association – Inheritance.</p>
<ul>
<li>associations 指两个类之间存在双向联系。比如一个老师教多个学生。有1对1,1对多等关系。</li>
<li>Inheritance 继承，父类泛化子类特化。</li>
</ul>
<p>Activities:  </p>
<ol>
<li>Identify Entity, Boundary and Control classes </li>
<li>Identify class relationships </li>
<li>A conceptual class diagram </li>
<li>Identify attributes for each entity class </li>
<li>Add constraints</li>
</ol>
<h2 id="design"><a href="#design" class="headerlink" title="design"></a>design</h2><p>design 是把分析模型转换成设计模型，不是代码实现！implementation才是实现。</p>
<p>design must have a purpose: how things works.</p>
<p>A software design: enough information for a  development team to implement the solution.</p>
<h3 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h3><ul>
<li>finish non-functional requirements</li>
<li>break down the overall task.</li>
<li>Create a ‘skeleton’ of the system 创建易于实现的骨架结构。</li>
</ul>
<h3 id="Fundamental-Concepts"><a href="#Fundamental-Concepts" class="headerlink" title="Fundamental Concepts"></a>Fundamental Concepts</h3><ul>
<li>Abstraction：抽象类和行为的功能。</li>
<li>Encapsulation：information hiding。限制某些对象对内容的直接访问。</li>
<li>Modularity：封装成模块，提供接口给其他模块。</li>
<li>Coupling：耦合，模块间关系紧密程度。最好是loose 松耦合，这样不容易牵一发而动全身。</li>
<li>Cohesion：内聚，模块内部自己元素的相关度。最好是high的。</li>
<li>Refactoring：在代码正常完成要求的前提下修正代码减少重复。主要改进非功能属性。</li>
</ul>
<p>面向对象设计的好处：对象就是实体；对象可以重用，继承；有的系统对象是现实世界的明显映射。</p>
<h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><p>conceptual class diagram</p>
<p>Class Relationships</p>
<p>operations</p>
<p>Describing methods</p>
<p>Captures implementation requirements</p>
<p>Produce detailed design class diagram</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>分析和设计阶段基本上把创意都列出来了。实现就是比较机械地按照前面的设计去敲代码。</p>
<p>利用一些组件去实现。组件主要包括：excutable 可执行文件，file 源码和数据，document，table 数据库表。</p>
<p>implementing subsystem 实现部分功能，利用打包功能导出一个有接口的模块.</p>
<p>Integration Build Plan 迭代构建项目,每次构建指出构建实现的功能和构建需要的子系统、组件。</p>
<p>OOP：有类，对象，方法。但是关联不是双向的，而是只能单向的，比如：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332479.png" alt="1685692184183"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685692194908.png" alt="1685692194908"></p>
<p>一对多可以在一个类里包含另一个类的一个对象集合。</p>
<p>类的实现要从最小耦合到最大耦合 least  coupled to most coupled。</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>在交付给用户前尽可能发现错误，验证每个阶段的结果。测试占据了40%。</p>
<p>组件层面：开发者测试。</p>
<p>集成测试：测试工程师，专注于质量。</p>
<ul>
<li>Validation testing：验证测试，测试系统正常需求已经满足。</li>
<li>Defect testing：检测系统的缺陷。</li>
</ul>
<h3 id="Testing-policies"><a href="#Testing-policies" class="headerlink" title="Testing policies"></a>Testing policies</h3><p>我们不可能把所有可能情况都找到并且测试出来。因此只能选取有代表性的子集。</p>
<p>好的测试：测试人员能预料到可能哪里出错；没有多余的测试用例；应选取“最可能出错”的用例；合适的复杂程度。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685693050733.png" alt="1685693050733"></p>
<p>test case：输入的规范和预期的输出。</p>
<p>test data：输入。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685693215844.png" alt="1685693215844"></p>
<h3 id="testing-strategy"><a href="#testing-strategy" class="headerlink" title="testing strategy"></a>testing strategy</h3><p>what 测试用例？when 测试？how to 测试？如何比对输出是否正确？</p>
<p>test cases 示例（正确的输入。错误的输入比如学号输入英文）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602160905111.png" alt="image-20230602160905111"></p>
<p>Test Procedures 测试程序，通常设置为可通用的，便于之后修改重用。这个程序不一定是代码，可能以流程指导的形式（比如按下login按钮，输入账号99001122登录……）</p>
<p>test matrix: </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602161119974.png" alt="image-20230602161119974"></p>
<p>发现缺陷：比如上例，错误的密码也能登录，于是测试工程师把错误信息返回给开发者：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602161157432.png" alt="image-20230602161157432"></p>
<h3 id="Testing-Techniques"><a href="#Testing-Techniques" class="headerlink" title="Testing: Techniques"></a>Testing: Techniques</h3><p>黑盒测试，black box&#x2F;behavior test，即我们要测试的模块，对我们来说像一个内部结构不可见的黑盒子，我们重点关注他行为对不对，与外界的接口是否正确，访问外界数据库正不正确。</p>
<ul>
<li>Partition testing：典型的黑盒测试，把数据分成等效的几个区域，比如正数负数0.</li>
<li>Scenario-based testing：从用户角度触发，分析用户可能的正确和错误操作。</li>
<li>Regression Testing：集成测试，随着添加增量也不断添加新测试，每次运行所有测试用例，确保系统更新的时候以前的功能没有受干扰。</li>
</ul>
<p>白盒测试，white&#x2F;glass&#x2F;clear box test，主要关注程序内部结构按规范运行，所有内部组件都正确。</p>
<p>确保盒内的所有路径都被正确执行过；考虑正确和错误用例；在边界内外测试；尽量使用内部数据结构。</p>
<ul>
<li>Basis Path Testing：执行所有路径的最少用例数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685696256126.png" alt="1685696256126"></p>
<p>总体测试流程：白盒测试，建立 test harness 测试装置，测试正确性，测试健壮性；然后黑盒测试。</p>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="number">20</span>, student.getAge());<span class="comment">//判断返回值是不是20岁</span></span><br></pre></td></tr></table></figure>

<p>在开发代码前编写测试。 simple, short-cycled mechanism。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332492.png" alt="1685710646767"></p>
<p>small cycle：编写测试，编写代码，测试失败，修改代码，测试通过。</p>
<h1 id="Software-architecture"><a href="#Software-architecture" class="headerlink" title="Software architecture"></a>Software architecture</h1><p>功能需求和软件架构关系紧密，非功能需求是软件架构的选择结果（好的架构运行效率高之类的）。可以以表格或图的形式，比如UML图。</p>
<p>设计难以更改。敏捷开发的早期阶段就是设计系统架构。</p>
<p>好处：</p>
<ul>
<li>system analysis：利于分析系统是否满足非功能需求。</li>
<li>large-scale reuse：架构可重用，更安全、更快。</li>
<li>Stakeholder communication：可以 成为一个讨论点。</li>
</ul>
<h1 id="Project-management"><a href="#Project-management" class="headerlink" title="Project management"></a>Project management</h1><p>让项目能在有限的时间和预算范围内按预期保质落地。</p>
<p>软件工程比较灵活，没有标准的完全正确的方案，需要随机应变，敏锐的洞察力。</p>
<h2 id="Project-planning"><a href="#Project-planning" class="headerlink" title="Project planning"></a>Project planning</h2><p>最耗时的环节。</p>
<p>计划只有在项目完成时才算完成，因为计划在项目开发阶段也不断变化。</p>
<p>计划可能包括多种，如质量计划，员工开发计划……</p>
<h2 id="Activity-organisation"><a href="#Activity-organisation" class="headerlink" title="Activity organisation"></a>Activity organisation</h2><p>活动应该组织成切实的输出以及可以判断的进度。</p>
<p>milestone：标志阶段的结束，不一定是能输出给用户的成果。比如文档，或者逻辑阶段的结束。</p>
<p>Deliverables：可以交付给用户的设计，规格等成果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332283.png" alt="image-20230602221047262"></p>
<h2 id="Project-scheduling"><a href="#Project-scheduling" class="headerlink" title="Project scheduling"></a>Project scheduling</h2><p>估计项目时间预算的花费，并按顺序排布。</p>
<p>比较难估计。通常根据过往项目经验估计。</p>
<p>先把大项目分解为几个小项目，然后并发的组织任务——尽可能充分利用劳动力 workforce，以及 Minimise task dependencies 尽量减少因为前面的任务没完成对后面任务的延误。</p>
<p>要对错误有预期，没错误是不可能的。约30%预料到的问题+20%未预料到的问题。</p>
<p>通常用图表表示：</p>
<p>任务表：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724379869.png" alt="1685724379869"></p>
<p>活动网：最长的是关键路径，因为这条路径任务要是延期了，整个工期都要延期。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724395138.png" alt="1685724395138"></p>
<p>甘特图：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724424966.png" alt="1685724424966"></p>
<p>Monitoring&#x2F;Reporting：定期周会周报监督进度。</p>
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>代码行数，代码中的缺陷，测试用例通过情况。</p>
<h3 id="People-in-the-process"><a href="#People-in-the-process" class="headerlink" title="People in the process"></a>People in the process</h3><p>选择成员，管理，激励他们，解决大家遇到的技术和非技术问题。</p>
<ul>
<li>Consistency：对大家态度一致。</li>
<li>Respect：大家拥有技能不同，互相尊重。</li>
<li>Inclusion：让大家都参与进项目，聆听所有人的意见。</li>
<li>Honesty：进度保持诚实。</li>
</ul>
<h3 id="Group-working"><a href="#Group-working" class="headerlink" title="Group working"></a>Group working</h3><p>不仅仅是个人的集合。团队能力的组成，凝聚力，沟通，大型团队的层次结构。</p>
<p>敏捷开发的团队合作方法：Scrum approcah，有一个Scrum master，日会，跟随进度，记录决策，和客户等沟通。</p>
<p>项目被分解为易于管理和理解的小部分。不稳定的需求不影响项目进度。团队成员对项目把控更到位 visibility，客户能常常看到项目进度，双方交流更相信彼此。</p>
<h2 id="Risk-management"><a href="#Risk-management" class="headerlink" title="Risk management"></a>Risk management</h2><p>失败是常有的事。我们要做好备选方案，推迟时间或者放弃目标。</p>
<p>风险管理是预测可能的失败，决定该在什么地方制定备选方案 alternative plans 。</p>
<p>Project risks：项目开发或者资源的问题。比如项目员工走了；原材料没法及时收到了；项目要求时间提前了。</p>
<p>Product risks：产品质量和性能的问题。比如开发软件出bug了，开发出的软件质量不行，用户对gui不满意，有没考虑到的错误。</p>
<p>Business risks：开发，采购组织的问题。比如上市了发现其他公司的技术，竞品比我们的好；负责该系统的组织因财务原因倒闭了。</p>
<p>Project+Product：需求一直变；分析阶段太慢了；开发团队技能能力不行；项目比预想的要大。</p>
<h3 id="Risk-Identification"><a href="#Risk-Identification" class="headerlink" title="Risk Identification"></a>Risk Identification</h3><p>识别风险。</p>
<h3 id="Risk-Analysis"><a href="#Risk-Analysis" class="headerlink" title="Risk Analysis"></a>Risk Analysis</h3><p>评估风险的影响。</p>
<h3 id="Risk-Planning"><a href="#Risk-Planning" class="headerlink" title="Risk Planning"></a>Risk Planning</h3><p>制定应对风险的计划。</p>
<h3 id="Risk-Monitoring"><a href="#Risk-Monitoring" class="headerlink" title="Risk Monitoring"></a>Risk Monitoring</h3><p>在项目开发过程中监控风险。</p>
<h3 id="Avoidance-Strategies"><a href="#Avoidance-Strategies" class="headerlink" title="Avoidance Strategies"></a>Avoidance Strategies</h3><p>尽量使用熟悉的模式，但是也接受新技术，时刻关注市场动向；</p>
<p>对员工合理培训，确保技术没被掌握在一个人手中；创造良好的工作环境；</p>
<p>员工不要欺瞒进度，高管要时刻了解进度以及其对项目的重要性。</p>
<h3 id="Contingencies-突发事件"><a href="#Contingencies-突发事件" class="headerlink" title="Contingencies 突发事件"></a>Contingencies 突发事件</h3><p>换人，换工具，换资源。</p>
<p>改变，舍弃一部分目标。</p>
<p>争取做的改动最小，但是损失也降到最小。</p>
<p>我们知道敏捷开发持续提交小版本，因此经常进行测试修改当阶段错误。但是缺陷在于敏捷开发不注重长远眼光 long term planning，因此可能带来一些问题。</p>
<h2 id="Quality-Management"><a href="#Quality-Management" class="headerlink" title="Quality Management"></a>Quality Management</h2><p>对质量的评估，最好从软件开发过程中抽离出来。因为开发的过程会错误影响开发者自己对质量的评估（我都这么努力了，做出来的东西肯定很好吧）。</p>
<p>瀑布模型中在系统实现后单独测试软件质量。敏捷开发在每次发布新版本的时候测试。因为主要是在实际使用场合的测试，因此会比“为了达成测试而开发”的系统想的更多一些。</p>
<p>好的软件符合目的 Fitness for purpose，标准好，易于使用，高效，代码写的好（当然从用户角度来说他看不到这一层。但是代码写得好是前提，比如时间复杂度运行得快）。开发者需要考虑用户的需求前提下，自己用专业知识思维去想：这个需求实现合理吗。然后多喝用户沟通表达看法。</p>
<p>区分bug和特性：正常运行的是特性。有的时候哪怕系统除了意想不到的bug，但是功能意外的很合适，这也可以是特性。</p>
<p>特性很难移除，当用户开始依赖特性功能的时候，移除用户可能不乐意不习惯；而且向后（版本）兼容变得很难。</p>
<p>软件标准有很多好处，新员工快速入手，大家更熟悉项目等，但是标准可能对一些过去常常发生而现在不怎么出现的问题采取忽略的态度，从而兼容性上出现问题；而且可能浪费很多时间填文书。注重标准好的部分。</p>
<h2 id="Design-principle"><a href="#Design-principle" class="headerlink" title="Design principle"></a>Design principle</h2><p>设计的软件不仅要正确，高效运行，还要在限定时间，人力，软件，经济条件下。差代码后期可能要花很多时间弥补隐患；而且不同模块的代码经常交互，差代码还会有安全隐患。</p>
<p>我们仅仅想着怎么“正确”地编写代码是不够的，还要更省事省力地去开发。</p>
<p>Software lifespan：软件生命周期，软件是一直在持续开发的，比如新技术，客户新需求。</p>
<p>Software scale：项目大多数规格很大，很多人开发，代码多，多次修订。</p>
<p>Decomposition：项目分解为小模块开发。有Locality（实现一个模块可以不用检查其他模块的实现）和Modifiability（修改一个模块也不用考虑用使用这个模块的模块）的特点。</p>
<p>Specification and implementation：规范连接了设计和实现，规定了模块应该提供哪些服务以及如何使用服务。模块之间的交互应该仅仅限于规范，以此实现分解后模块的locality和modifiability。</p>
<p>Classes and Methods：面向对象思想中的模块为类。</p>
<p>Separation：分开考虑一个模块要实现的功能what和如何实现how。一个应用程序级别，一个实现级别。</p>
<p>Splitting Methods and Classes：设计方法和类的时候好好考虑如何拆分方法和类。类太大了考虑一下要不要拆，几个变量模式比较常用考虑一下要不要抽象成类。</p>
<p>Helper Methods and Classes：有一些方法和类只是为了抽象出来辅助拆分代码用的，这种一般是私有的helper method和嵌套的nested class，只在特定类里起作用，对其他类是private的。</p>
<p>Reuse：用以前的代码重复实现功能，节约代码，而且一改全改。重用代码可能厂商提供，编程语言提供，早期开发者开发。</p>
<p>Abstraction and generalisation：抽象是提取一些概念，比如接口，类；泛化是提取一些重复元素，以便代码重用，比如父类。</p>
<p>UML class diagrams：比代码更高的层次，是面向对象编程很重要的内容。</p>
<p>Static v. Dynamic：匹配静态内容和代码运行时产生的内容。对应UML中的类图 class diagram 和顺序图 sequence diagram。</p>
<p>图源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lingchen336/article/details/111400141#:~:text=UML%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%9B%BE%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%97%B6%EF%BC%8C%E4%BC%9A%E6%8C%89%E7%85%A7%E6%80%8E%E6%A0%B7%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E3%80%81%E9%82%A3%E4%BA%9B%E7%8E%B0%E8%B1%A1%E4%BC%9A%E4%BE%9D%E4%BB%80%E4%B9%88%E9%A1%BA%E5%BA%8F%E5%8F%91%E7%94%9F%E3%80%82,%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E2%80%9C%E4%B8%8D%E5%9B%A0%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%88%E9%9D%99%E6%80%81%E5%85%B3%E7%B3%BB%EF%BC%89%EF%BC%8C%E4%BA%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE%E5%88%99%E8%A1%A8%E7%A4%BA%E2%80%9D%E9%9A%8F%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A1%8C%E4%B8%BA%EF%BC%89%E2%80%9C%E3%80%82">UML类图与顺序图_顺序图和类图的关系_lingchen336的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/2020121909185527.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332627.png" alt="img"></p>
<p>class and objects：类和对象。对象是类的实例 instance。两者关系很像static 中的method和动态中的method call。</p>
<p>static：静态方法只能被类自己和其附加类调用。静态类实例化的对象是只有一个通用的对象，而不是实例化出无数个对象。</p>
<p>Variables and referencing：java中变量是对对象的引用，比如var2&#x3D;var1不是赋值而是改变var2指向var1的引用。包括一个变量的自带方法的</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332273.png" alt="image-20230603233317997"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685806438306.png" alt="1685806438306"></p>
<p>Scope and garbage collection：对象的作用域只要有变量还在引用这个对象，他就活着。没有人引用的时候就自动垃圾回收。</p>
<p>基本设计原则：设计对象指代目标；对象方法指代其能做的操作；Locality和Modifiability；对象只能通过方法调用交互。</p>
<p> Client-Contractor model：一种思想，一个对象调用其他对象的方法得到返回值来使用它，像客户和承包商一样。现代社会大进步的原因就是大家各专其职，因此项目中各个类各专其职也能在同样的量的前提下发挥更多的作用。</p>
<ul>
<li><p>客户给承包商的合同就类似定义类和方法的规范specification。代码编写者有义务Obligations拿了钱benefits，就确保软件正确执行，不做破坏的事等。</p>
</li>
<li><p>Design by Contract：一种思想。客户端代码应当满足承包商的先决需求pre-conditions；应当对异常做处理（exception）；后置条件post-conditions在测试中作为断言assertions合并到程序中。（前置条件：前提；后置条件：方法运行后的状态）</p>
</li>
</ul>
<h3 id="Single-Responsibility-Principle-SRP"><a href="#Single-Responsibility-Principle-SRP" class="headerlink" title="Single Responsibility Principle (SRP)"></a><strong>Single Responsibility Principle (SRP)</strong></h3><p>单一责任原则：每个类有一个职责 responsibility，其所有对象都服务于这个职责。Leads to highly cohesive 内聚性高</p>
<h3 id="Open-Closed-Principle-OCP"><a href="#Open-Closed-Principle-OCP" class="headerlink" title="Open-Closed Principle (OCP)"></a>Open-Closed Principle (OCP)</h3><p>开放闭合原则：模块（类和方法）open to extension，close to modification </p>
<p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>
<p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。比如一个类以不同对象形式表现这就是扩展，因为需求改变或者有新需求。</p>
<h3 id="Do-not-Repeat-Yourself-principle-DRY"><a href="#Do-not-Repeat-Yourself-principle-DRY" class="headerlink" title="Do not Repeat Yourself principle (DRY)"></a><strong>Do not Repeat Yourself principle (DRY)</strong></h3><p>不要复读机原则（不要重复自己原则）。本模块中如果发现重复内容，建议再抽象为方法和类。</p>
<h3 id="Liskov-Substitution-Principle-LSP"><a href="#Liskov-Substitution-Principle-LSP" class="headerlink" title="**Liskov Substitution Principle (LSP) **"></a>**Liskov Substitution Principle (LSP) **</h3><p>Liskov替代原理：重写方法，不应该抱着”修改其方法“的想法。不能加强 strengthen 前置条件，不能削弱 weaken 后置条件。</p>
<p>比如父类people方法AddPeople(String name, int age) 子类Student构造方法AddPeople(String name, int age)里先校验一下学生年龄，如果年龄大于25岁则不允许add，这就修改了原来方法。这就是前置条件加强了，要求年龄的限制多了。</p>
<p>后置条件比如原来返回值大于0，现在返回值可以小于0了，那么返回值限制弱了，后置条件削弱了，不满足里氏原则。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ITPower/p/14826144.html">设计模式六大原则(二)—-里式替换原则 - 盛开的太阳 - 博客园 (cnblogs.com)</a></p>
<p>Association, Aggregation and Composition：association是两个不同东西的对应，比如家长和孩子。另外两个是子集，aggregation是彼此可以独立存在，比如班级和学生。composition是可以彼此独立存在，比如house和room。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685957816284.png" alt="1685957816284"></p>
<p>有的时候继承满足不了LSP（比如令正方形为矩形的子类），可以使用聚类来防止破坏LSP。</p>
<h3 id="Interface-Segregation-Principle-ISP"><a href="#Interface-Segregation-Principle-ISP" class="headerlink" title="Interface-Segregation Principle (ISP)"></a><strong>Interface-Segregation Principle (ISP)</strong></h3><p>接口隔离原则：首先接口应该尽量分解为小接口。客户端每个类不应该依赖他不使用的方法。就是接口用啥实现啥，别多实现。</p>
<h3 id="Dependency-Inversion-Principle-DIP"><a href="#Dependency-Inversion-Principle-DIP" class="headerlink" title="Dependency-Inversion Principle (DIP)"></a>Dependency-Inversion Principle (DIP)</h3><p>依赖倒置原则：</p>
<blockquote>
<p>如果高层模块直接调用低层模块提供的服务，那么就是具体耦合关系，这样高层模块依赖于低层模块就不可避免。但是，如果我们使用抽象耦合关系，在高层模块和低层模块之间定义一个抽象接口，高层模块调用抽象接口定义的方法，低层模块实现该接口。这样，就消除了高层模块和低层模块之间的直接依赖关系。现在，高层模块就不依赖于低层模块了，二者都依赖于抽象。同时也实现了“抽象不应该依赖于细节，细节应该依赖于抽象”。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158391778">面向对象基础设计原则：4.依赖倒转原则 - 知乎 (zhihu.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/171757199427415.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaochundong/p/dependency_inversion_principle.html">依赖倒置原则（Dependency Inversion Principle） - sangmado - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h2 id="Design-Patterns"><a href="#Design-Patterns" class="headerlink" title="Design Patterns"></a>Design Patterns</h2><h3 id="Decorator-Design-pattern"><a href="#Decorator-Design-pattern" class="headerlink" title="Decorator Design pattern"></a>Decorator Design pattern</h3><p>用于扩展系统功能的装饰模式。</p>
<p>比如我们有一个鸭子类，可以调用其鸭子叫的方法。我们初始化了一个鸭子对象，如何统计这个对象叫了几次，也就是其鸭子叫方法被调用了几次？记住OCP原则不允许我们直接修改鸭子类。</p>
<p>我们可以用一个计数类来把鸭子类包住。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332689.png" alt="image-20230605183433552" style="zoom:67%;" />

<p>装饰模式实现一个接口，接口中的方法通过该变量的同一个参数去调用同一个方法，比如本例中是鸭子呱呱的计数，每次调用++。</p>
<h3 id="Adapter-design-patterns"><a href="#Adapter-design-patterns" class="headerlink" title="Adapter design patterns"></a>Adapter design patterns</h3><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332186.png" alt="1685983233527" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685983255642.png" alt="1685983255642"></p>
<p>这个例子包括了几个原则：</p>
<ol>
<li>首先不同接口功能尽量分开，ISP，也就是说鸭子叫和计数不要写一个方法里。</li>
<li>不能直接修改类，OCP。</li>
<li>如果想鸭子叫同时计数，直接调用包装类即可，DRY。</li>
<li>GooseAdapter 只访问了 Goose 的 honk 方法而不是对其完全访问，DIP。这里如果改成继承的子类，就有全部访问权了。</li>
</ol>
<h3 id="Wrapper-design-patterns"><a href="#Wrapper-design-patterns" class="headerlink" title="Wrapper design patterns"></a>Wrapper design patterns</h3><p>Wrapper 模式包括 decorator 和 adapter。decorator 主要是外面的包裹类和里面的类都实现一个接口，比如上例的鸭子嘎嘎。adapter 是内部类不需实现。</p>
<p>Immutable View：前面提过java引用的问题，比如两个变量引用同一个对象，一改都改。这样就相当于有引用的时候，该目标对象完全暴露出来了。在wrapper里我们可以限制包装类：禁止修改对象，修改则抛出异常。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685986070602.png" alt="1685986070602"></p>
<h3 id="Composite-Design-Pattern"><a href="#Composite-Design-Pattern" class="headerlink" title="Composite Design Pattern"></a>Composite Design Pattern</h3><p>包装了一个集合。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685985869548.png" alt="1685985869548"></p>
<h3 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h3><p>比如看到绿灯汽车知道该走了，这种观察者一个变量改变影响其他变量的实现。</p>
<p>java是提供了observable的api的，当对应变量值改变时触发函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332446.png" alt="1685986641156"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685986768769.png" alt="1685986768769"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332896.png" alt="1685986796502"></p>
<p>不过这种写法违反了OCP，因为我们修改了dogbot让他主动实现observer的update。我们可以采用decorator design 方法。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685989787205.png" alt="1685989787205"></p>
<p>如果dogbots是一个接口，dogwatcher 可以实现计数功能，还可以在文件，在gui中实现dogbots，实现集合的dogbots，两者代码几乎是分离的。</p>
<p>我们先用一个ObservableDogBot类继承Observable，且实现未完成的dogbots，然后写一个dogreporter实现observer。最后<code>rover.addObserver(reporter1);</code></p>
<h3 id="Factory-Methods"><a href="#Factory-Methods" class="headerlink" title="Factory Methods"></a>Factory Methods</h3><p>如果我们设定饥饿值大于6的狗要被构造为greedyDogBot是普通狗的子类，那么PlainDogBot和greedyDogBot都直接提供出来构造方法不太好。可以通过一个构造类来判断需要返回什么对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606123312445.png" alt="image-20230606123312445"></p>
<p>这个构造方法可以返回接口类，但是实际方法里返回的都是实现了接口类的具体类，这样可以隐藏返回类类型：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026157643.png" alt="1686026157643"></p>
<p>工厂类甚至自己可以包装好类然后送回来一个包装类：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332407.png" alt="1686026296136"></p>
<p>当然工厂方法除了静态的，也可以是非静态的工厂对象。我们可以利用不同的工厂对象包装不同的包装类，这样还能进一步隐藏返回对象的一些信息。</p>
<p>比如下一个例子中，spy狗多一个watcher。我们用多态方法初始化两个 Dog Factory，但是一个是实际SpyDogFactory类型的，一个实际是PlainDogFactory类型的，因此两者调用makeDogBot的时候会返回不同的狗。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026555327.png" alt="1686026555327"></p>
<p>像计数等额外包装功能，我们也可以不用“先用一个计数类包装普通类，再用工厂类包装计数类”，而是把计数内容包装在工厂类里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026955303.png" alt="1686026955303"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026838784.png" alt="1686026838784"></p>
<h3 id="Singleton-Design-Pattern"><a href="#Singleton-Design-Pattern" class="headerlink" title="Singleton Design Pattern"></a>Singleton Design Pattern</h3><p>构造方法不一定返回必须是新创建的对象，工厂类里可以返回已有的对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332922.png" alt="1686027588395"></p>
<p>注意LSP原则。</p>
<h3 id="Object-Pool-Design-Pattern"><a href="#Object-Pool-Design-Pattern" class="headerlink" title="Object Pool Design Pattern"></a>Object Pool Design Pattern</h3><p>对象池模式，保留一个对象列表，在需要的时候返回一个特定对象。</p>
<h3 id="Strategy-Design-Pattern"><a href="#Strategy-Design-Pattern" class="headerlink" title="Strategy Design Pattern"></a>Strategy Design Pattern</h3><p>选择要执行的策略。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686027938500.png" alt="1686027938500"></p>
<p>上图是狗执行几次action的函数。我们也可以利用重写的Comparator实现条件结构，比如比较ab两狗叫了几次，叫的少的补差。</p>
<h3 id="State-Design-Pattern"><a href="#State-Design-Pattern" class="headerlink" title="State Design Pattern"></a>State Design Pattern</h3><p>可以改变对象的状态类型。</p>
<p>下面改变的几个类型都是accountState抽象类的实现类，通过多态的方式初始化。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332513.png" alt="image-20230606180142747"></p>
<h3 id="Bridge-Design-Pattern"><a href="#Bridge-Design-Pattern" class="headerlink" title="Bridge Design Pattern"></a>Bridge Design Pattern</h3><p>解耦思想。比如我们需要12种颜色的画笔，可以选择12根固定颜色的蜡笔，或者1根毛笔和12种颜料。毛笔的例子就很好地解耦了画笔和颜色。</p>
<p>例子来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/LoveLion/article/details/7464183">处理多维度变化——桥接模式（一）_LoveLion的博客-CSDN博客</a></p>
<p>下例：求父子交集。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606181219816.png" alt="image-20230606181219816"></p>
<h3 id="Flyweight-Pattern"><a href="#Flyweight-Pattern" class="headerlink" title="Flyweight Pattern"></a>Flyweight Pattern</h3><p>将那些大量的，具有很多内部状态而外部状态很少的对象进行共享，可以以类似缓存的方式共享。</p>
<p>概念来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336732854">精读《设计模式 - Flyweight 享元模式》 - 知乎 (zhihu.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606181617881.png" alt="image-20230606181617881"></p>
<h1 id="Open-Source-Software"><a href="#Open-Source-Software" class="headerlink" title="Open Source Software"></a>Open Source Software</h1><p>free of charge, free of legal restrictions on usage. </p>
<p>也需要敏捷开发，但是开发方式略有不同，毕竟不是利益相关的模式。强调个人之间的密切交互 close personal interaction，开发者也是自己的客户，因此有很多人做测试，而且修改后的小版本可以很快发布；通常分的小模块很多，世界各地的大家分别开发。</p>
<p>世界各地大家通过电子方式互相交流 electronically。</p>
<p>整体协调者 overall co-ordinator 通常由志愿者负责。</p>
<p>商业软件和OSS就像大教堂和集市的区别，大教堂需要有一个整体的建造目标，大家一同努力。集市可能由城管那样的整体协调者管大家秩序，但是大家还是偏personal一点。</p>
<p>如果自己公司自己开发项目，当然需要大量人力财力开发和后期维护；选择闭源软件，就绑定在供应商身上了（垄断技术），他们需要进一步收费咱也得交。开源软件就不用担心支付费用这类问题或者供应商倒闭问题，但是不是是开源软件就能拿来用的，注意版权问题。</p>
<p>开源软件大多数有一小部分人在开发核心core以及新功能，大多数人在correcting  defects。大多数情况下开发者更愿意维护现有fork分支而不是一味开发新分支。</p>
<p>开源软件也有一个control structure，通常由最初提出项目的人拥有软件的最终决议权，由一些商业公司管理而并非个人（这样能多保质一点），比如安卓开源软件由谷歌掌握控制权，对于提交的fork和patch有权最终决定下一个版本更新的内容。</p>
<ul>
<li>contributor：OSS中做贡献的人。</li>
<li>developer：在软件平台上开发应用的人。</li>
<li>verifier：测试 change request 是否正确的人。</li>
<li>approver：决定这些修改是否要合并进大版本的人，和verifier都需要审核面试筛选。</li>
<li>Project leads：监督单个项目的工程。</li>
</ul>
<h2 id="software-freedom"><a href="#software-freedom" class="headerlink" title="software freedom"></a>software freedom</h2><ul>
<li><p>运行程序的自由 run the program</p>
</li>
<li><p>学习程序运行原理和按自己意愿修改代码的自由 study how this program works, change it so it does your compute as you wish （当然前提是能访问到源码）</p>
</li>
<li><p>分发软件副本的自由 redistribute copies</p>
</li>
<li><p>发布自己的版本给他人的自由  distribute copies of your modified versions to others。</p>
</li>
</ul>
<h2 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h2><p>只有制作者producer有权利制作副本和创建新内容 produce copies and create new work based on it，但是可以授权允许别人复制和改编该作品 make copies of the work and adapt it。制作者可以通过收费等方式赋予这些权力给他人，或者对改编的范围加限制，因为这算是加在producer身上的一种义务，有点回报也正常。</p>
<h2 id="Copyleft"><a href="#Copyleft" class="headerlink" title="Copyleft"></a>Copyleft</h2><p>但是OSS的版权声明采用的是copyleft，一种 free software license，并不是限定他人复制改编的权力，而是赋予他人这种权力。许可证内容包括：声明源代码可用，以及改编允许的范围。</p>
<h2 id="voting"><a href="#voting" class="headerlink" title="voting"></a>voting</h2><p>有权投票的人每人最多一票；没权投票的人不能投；有权投票且选择投票的人不能被阻止投票；其须拥有充足的选择 full choice；其投票结果必须被正确统计不能被别人篡改；总票数正确相加，不能篡改；大多数时候没有人能知道任何一个投票者的选择。</p>
<p>电子投票有风险，比如数据容易被篡改，被伪造等。</p>
<h1 id="Software-Development-Tools"><a href="#Software-Development-Tools" class="headerlink" title="Software Development Tools"></a>Software Development Tools</h1><h2 id="Software-Craftsmanship-and-Clean-Code"><a href="#Software-Craftsmanship-and-Clean-Code" class="headerlink" title="Software Craftsmanship and Clean Code"></a>Software Craftsmanship and Clean Code</h2><p>注意代码整洁，比如格式、注释等。</p>
<h2 id="Saying-“No”"><a href="#Saying-“No”" class="headerlink" title="Saying “No”"></a>Saying “No”</h2><p>不要一直盲目答应老板和客户的需求，程序员更熟悉代码，而且需要帮老板规避可能发生的错误。</p>
<h2 id="Learning-from-Mistakes"><a href="#Learning-from-Mistakes" class="headerlink" title="Learning from Mistakes"></a>Learning from Mistakes</h2><h2 id="Microsoft’s-Best-Practices"><a href="#Microsoft’s-Best-Practices" class="headerlink" title="Microsoft’s Best Practices"></a>Microsoft’s Best Practices</h2><h3 id="Revision-Control-System"><a href="#Revision-Control-System" class="headerlink" title="Revision Control System"></a>Revision Control System</h3><p>版本控制。</p>
<p>roll-back：版本回滚。</p>
<p>check-out：开发者拉下来代码。</p>
<p>check-in：开发者提交自己的修订版。</p>
<p>conflict：两个人的提交出冲突了。</p>
<p>merge：合并入主分支。</p>
<h3 id="Daily-Build"><a href="#Daily-Build" class="headerlink" title="Daily Build"></a>Daily Build</h3><p>每日构建一次代码，编译链接源代码，进行一些测试，确保第二天大家能使用最新版本。</p>
<h3 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h3><p>开发人员也建议每天check-in一次。</p>
<h3 id="Build-Verification-Tests"><a href="#Build-Verification-Tests" class="headerlink" title="Build Verification Tests"></a>Build Verification Tests</h3><p>断言和单元测试。</p>
<h3 id="Bug-Database"><a href="#Bug-Database" class="headerlink" title="Bug Database"></a>Bug Database</h3><p>记录以前的bug记录，解决方法，严重程度，优先级等信息。</p>
<h3 id="War-Team-and-Bug-Triage"><a href="#War-Team-and-Bug-Triage" class="headerlink" title="War Team and Bug Triage"></a>War Team and Bug Triage</h3><p>发布前，作战小组确认系统“好到可以发布”。检查运行是否正常，剩余的bug严重程度等。</p>
<h3 id="Code-reviews-and-coding-guidelines"><a href="#Code-reviews-and-coding-guidelines" class="headerlink" title="Code reviews and coding guidelines"></a>Code reviews and coding guidelines</h3><p>团队对彼此代码进行彻底审查。</p>
<h3 id="Globalisation-and-Localisation"><a href="#Globalisation-and-Localisation" class="headerlink" title="Globalisation and Localisation"></a>Globalisation and Localisation</h3><p>针对不同语言、脚本的差异处理。</p>
<h3 id="Documentation-Generators"><a href="#Documentation-Generators" class="headerlink" title="Documentation Generators"></a>Documentation Generators</h3><p>文档生成。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Software/" rel="tag">Software</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：存算一体芯片的潜力与挑战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/29/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/"
    >技术学习：存算一体芯片的潜力与挑战</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/29/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/" class="article-date">
  <time datetime="2024-01-29T00:00:00.000Z" itemprop="datePublished">2024-01-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文学习自：存算一体芯片深度产业报告——作者：量子位</p>
<p>报告链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/557673211">存算一体是啥新趋势？值得教授学者纷纷下海造芯 | 附报告下载 - 知乎 (zhihu.com)</a>，侵删！</p>
<h2 id="存算一体技术概述"><a href="#存算一体技术概述" class="headerlink" title="存算一体技术概述"></a>存算一体技术概述</h2><p>“存算一体”技术的起因在于传统冯诺依曼架构芯片无法满足不断提升的算力与低功耗需求。随着晶体管的体积越来越小，摩尔定律逐渐失效（会引发量子隧穿等反应），导致存储器与处理器之间的数据传输成为 CPU 性能的瓶颈，相对较长时间的数据搬运导致算力受限。</p>
<p>为了解决这个问题，我们需要新的芯片架构。主要有三种解决方式：</p>
<ol>
<li>近存计算：缩短处理器芯片与存储器芯片的距离，减少数据搬运损耗。</li>
<li>内存储计算：处理器和存储器位于同一芯片的不同电路单元中。</li>
<li>内存执行计算：通过在存储器颗粒上嵌入算法，由存储器芯片内部的存储单元完成计算操作。</li>
</ol>
<h2 id="产业分析"><a href="#产业分析" class="headerlink" title="产业分析"></a>产业分析</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20240129171851417.png" alt="image-20240129171851417"></p>
<p>存算一体芯片落地的优势在于在算力提高的同时，芯片体积的减小和数据传输功耗的减少，使得芯片良率、成本、功耗等都有所改善。然而，实际应用的挑战主要在于评估市场需求和客户转换成本。重要的考量是，大规模采用新型芯片是否能够在成本和能耗方面带来足够的改进，以证明其经济效益；新架构芯片的先进生产工艺制造能力；客户对低功耗和高算力的需求；以及封装、测试、工具链、EDA 等相辅相成的产业链生态仍缺乏相应的研发公司。</p>
<p>当下大多数初创公司的思路是先聚焦特定场景，在垂直领域内站稳脚跟后技术外溢到更丰富的应用场景。主要的应用场景包括小算力低功耗场景（知存科技、九天睿芯和闪易半导体等）和大算力场景（千芯科技，后摩智能等）。</p>
<p>目前已知的商业模式主要分为三种：IP授权，定制&#x2F;联合开发以及自主SoC芯片。</p>
<p>当前国内外存算一体技术发展特征如下：</p>
<ul>
<li>成立时间不同会影响技术路线选择，国内外实现产品化的公司数量不多，离规模化还有一定距离</li>
<li>技术路线：大公司选择最容易落地的，初创公司在确保技术先进性基础上选择最容易落地的</li>
<li>国外已形成完整的自研技术链，大规模量产上国内外均未实现突破</li>
<li>不同的业务场景均已呈现出各自的优势，在商业模式上国内外都处在探索阶段</li>
<li>虽然业内尚未形成完整的生态，产业链部分环节已经出现针对存算一体进行技术研发的公司</li>
</ul>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>为了推动存算一体技术的未来发展，重点应放在解决关键技术难题上，并且寻找适合快速应用推广的场景。随着新型存储器技术，尤其是RRAM和MRAM的不断进步，预计将大幅推进存算一体架构的发展。这些技术的应用，尤其是在终端推理和物联网领域，预示着存算一体技术将在这些领域发挥重要作用。为了实现从初步商业化到大规模商业化的转变，技术创新与产业发展必须紧密协同，共同推动这一技术的成熟和应用普及。</p>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>作为一名物联网工程专业的大学生，深入了解存算一体技术让我领略了科技创新的魅力及其在未来应用的广阔前景。虽然我尚缺乏商业模式和产品上市的实践经验，但这次学习经历让我认识到理论与实践结合的重要性，以及跨学科知识对于技术创新的贡献。</p>
<p>通过研究这一技术，我明白了在物联网设备设计中，如何有效融合硬件和软件来提高性能同时降低能耗的重要性。这一认识不仅提升了我的专业技能，也激发了我对如何将技术创新转化为实际应用的深入思考。</p>
<p>此外，我也看到了自己在商业知识和市场分析方面的不足，这提示我在未来的学习中需更多关注这些领域。我期待将这次学习的感悟转化为动力，在未来的学习和工作中不断探索、学习和创新，为智能化世界贡献我的力量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chip/" rel="tag">Chip</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：STM32 F407 霸天虎开发板"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/26/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9ASTM32%20F407%20%E9%9C%B8%E5%A4%A9%E8%99%8E%E5%BC%80%E5%8F%91%E6%9D%BF/"
    >技术学习：STM32 F407 霸天虎开发板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/26/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9ASTM32%20F407%20%E9%9C%B8%E5%A4%A9%E8%99%8E%E5%BC%80%E5%8F%91%E6%9D%BF/" class="article-date">
  <time datetime="2023-11-26T00:00:00.000Z" itemprop="datePublished">2023-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博主开始探索嵌入式以来，其实很早就开始玩 stm32 了。但是学了一段时间之后总是感觉还是很没有头绪，不知道在学什么。前前后后分别尝试了江协科技、正点原子、野火霸天虎三次 stm32 的课程学习。江协科技的 stm32f103c8t6 课程看了一段时间，感觉对一些外设的调用方法有一个基础的认知了，但是没有很明白到底在学什么；正点原子则是有点听不懂，半字也借给同学了就有一段时间没学，感觉自认为 stm32 学的有两把刷子了。后来听前辈说江协科技的 stm32 课程不如 51 单片机的质量好，其实课程讲的一般，我就想：是不是应该重新好好学一下 stm32 课程了。</p>
<p>这次选择的是野火的  F407 霸天虎课程，第一是听大家说，入门选野火或者正点最好。第二是野火的大师进阶篇的一些内容，涉及到一些原理等的学习讲解，我觉得对我会非常有帮助，因此正好就买了这款开发板从入门到中级到大师原理一起学习了。</p>
<p>本系列博文笔记主要基于野火相应课程，b站地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vt411X7PK/?spm_id_from=333.337.search-card.all.click&vd_source=05baa16b109824edfe68909895264c33">野火F407开发板-霸天虎视频-【入门篇】_哔哩哔哩_bilibili</a> ，仅供学习参考不做任何商业用途使用，侵删！</p>
<h3 id="调试器介绍"><a href="#调试器介绍" class="headerlink" title="调试器介绍"></a>调试器介绍</h3><p>我选择的是高速版，支持 SW 和 JTAG 两种连接方式。SW 模式则只需要连接 VREF（3V3）, TMS（数据）, TCK, RESET, GND 五个引脚。</p>
<h3 id="程序烧录配置"><a href="#程序烧录配置" class="headerlink" title="程序烧录配置"></a>程序烧录配置</h3><p>芯片型号：STM32F407ZGTX。</p>
<p><strong>DAP 仿真烧录</strong>自然非常简单。</p>
<p><strong>串口一键下载 ISP</strong> 下载速度慢，不能调试，但是成本很低。可以使用 FlyMcu 等软件。</p>
<p><strong>2023.11.2 补充。</strong></p>
<p><strong>警告，建议如果 flymcu 不能烧录，就不要尝试这种玩法了，看看课学学得了。因为我自己乱捣鼓一通后把开发板锁了。</strong></p>
<p><strong>下面的内容我不太清楚具体是哪一步出现了锁死 flash 的问题，总之不要尝试！学习一下理论得啦。</strong></p>
<p><strong>如果和我一样锁死了，请见野火大师篇程序，里面有一个解除写保护的代码，运行一下。</strong></p>
<p>ISP 下载方式：允许我们不拆下芯片来下载。对于上个世纪嵌入式学习来说这是一个很大的突破，因为当时是要把芯片拆下来烧录编程的。</p>
<p>ISP 厂商出产的时候就选定了一种串行外设对芯片内部 FLASH 进行编程，我们不能修改。常用串口下载方式，成本低，但是不能调试仿真。</p>
<p>普通 ISP 需要手动配置 boot loader，一键 ISP 不用，硬件电路和上位机配合达到一键下载的效果（手动配置：00是用户闪存启动，10是系统 SRAM&#x2F;ISP 启动，普通 ISP 要手动改跳线帽）。</p>
<p>一键下载电路的具体原理流程如下：</p>
<ol>
<li>RTS 低电平，Q1 是一个 PNP 三极管，导通，BOOT0 拉高。</li>
<li>DTS 高电平，Q2 NPN 导通，U18 是一个由 EN 控制开关的模拟开关，2 脚被导通为低电平，连接1脚拉低 NRST 复位。程序下载执行。</li>
<li>U18 模拟开关的作用是稳定电路。开发板复位的时候 DTR RTS 是不稳定的状态，如果没有这个模拟开关，DTR RTS 可能进入 ISP 状态，复位，进入 ISP 状态，复位，进入……一直运行不起来了。模拟开关右侧电容使得 VCC 需要花一点时间充电给 EN，而不是立刻激活 EN（EN 1.8V 左右）。这时候 DTR RTS 已经稳定了，可以导通 U18 12 引脚来给 NRST 复位了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698858387784.png" alt="1698858387784"></p>
<p>不过 FlyMcu 实际配置方式是反过来的，因为他的协议是 232（+3<del>+15 是 0，-3</del>-15 是 1），和 TTL（3.3v 是1,0v 是0）正相反。</p>
<p><em>但是实际操作的时候可能遇到一种状况：部分开发板无法使用 FlyMcu 写入。我就碰到了。解决办法是使用 stm32 cube programmer 烧录程序。</em></p>
<p><em>配置如下：开发板上 boot 连接 3v3，RTS DTR&#x3D;0，选中 read unprotect，建立连接后再烧录程序。</em></p>
<p><em>但是不知道是波特率或者校验位的问题，我每次能成功烧录进去，然后过一会就显示断开找不到设备了。可能是因为波特率没有76800的选项。</em></p>
<h2 id="STM32-介绍"><a href="#STM32-介绍" class="headerlink" title="STM32 介绍"></a>STM32 介绍</h2><blockquote>
<p>正点原子网课：单片机和电脑的类比：内存是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SRAM&spm=1001.2101.3001.7020">SRAM</a>，硬盘是 FLASH，主板是外设。</p>
</blockquote>
<p>st：意法半导体公司，SoC 厂商。</p>
<p>m：微控制器。微控制器和微处理器相比性能比较拉一点，主频低，微处理器能跑一些大 os（linux）。</p>
<p>32：32位微控制器。</p>
<blockquote>
<p>正点原子网课：8051，X86 属于 CISC；ARM, MIPS, RISC-V 属于 RISC.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012212735.png" alt="image-20230401221223643"></p>
<p>冯诺依曼和哈佛结构的主要区别：程序存储器和数据存储器是否分开存储。不分开是冯诺依曼，分开是哈佛。哈佛执行效率更高，冯诺伊曼资源占据更少。</p>
<p>CORTEX-M 系列介绍<br>ARM 公司（做精简指令集计算机的）只设计内核架构和授权知识产权，不参与设计芯片，给其他合作公司授权设计芯片。半导体厂商再根据架构完善周边电路并制作芯片。现在95%手机、平板都是 ARM 架构的， ARM 公司是真的牛。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012216885.png" alt="image-20230401221658811"></p>
<p>其优点在于低功耗低成本高性能，且支持16&#x2F;32位双指令集。</p>
<p>ARM 有9个版本，从 v6 开始出现 cortex 的命名。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012219288.png" alt="image-20230401221918218"></p>
</blockquote>
<p>随着需求不断发展，stm32 在一众 8&#x2F;16位 MCU 中脱颖而出。</p>
<p>stm32 自带许多通信接口，如 spi i2c uart 等；扫地机，无人机，手环等都可以是 stm32 的作品。</p>
<p>如何选型？以下是几大类 stm32 的特点。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013709264.png" alt="image-20231102013709264"></p>
<p>本课程学习使用的开发板命名方式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013830412.png" alt="image-20231102013830412"></p>
<p>选型：满足项目需求的前提下，尽可能选便宜的，比如主频低，功耗低，引脚少，flash 少。</p>
<p>引脚分配：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860405030.png" alt="1698860405030"></p>
<p>看手册的重点：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860693691.png" alt="1698860693691"></p>
<p>外设资源，芯片功能，引脚，引脚大致分类，内存，封装……</p>
<p>哎想起前两天面试被问，如果选型 MCU 我应该看哪些因素。我只想到了外设和内存hhh。属于是只会写代码的笨比了。这也是我开始重新看野火课程的原因之一。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>虽然正式编程没有必要用寄存器编程，通常都是库函数或者 hal 库。但是还是有必要学一下原理的。</p>
<h3 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h3><p>芯片视图如下。</p>
<p>丝印：芯片上印的信息。型号，内核，生产批次等。</p>
<p>引脚：左上角是有小圆点的，从左上-左下-右下-右上逆时针看。或者如果没有小圆点，把丝印方向摆正，从左上角开始看。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121423731.png" alt="image-20231102121423731"></p>
<p>芯片内部组成：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121841662.png" alt="image-20231102121841662"></p>
<p>寄存器映射：32位，2^32^&#x3D;4GB，因此所有程序都需要通过内存 4GB 去映射访问。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102122058475.png" alt="image-20231102122058475"></p>
<p>block7：M4 芯片内外设，比如一些通信总线这些都算外设。</p>
<p>block1：内存。</p>
<p>block0：代码。不过实际上由于设计工艺的问题，block0 block1 都只用了很少的一部分来存代码或者作为内存。</p>
<p>外设寄存器放在 block2 中。根据不同块速度不一样，又具体分为不同速度的外设（AHB APB）。</p>
<p>总线速度：AHB&gt;APB2&gt;APB1. APB1 是较低速的外设，包括 I2C UART SPI 看门狗等。</p>
<p>我们想要操作特定的外设，其实就是控制他的寄存器。控制寄存器就要找到寄存器相应的地址往里面写入数据，寄存器地址就是内存中的地址映射。</p>
<p>比如 GPIOF 我们想让其端口全部输出高电平。我们查找 stm32f407 手册，发现 GPIOF 的地址是 0x40021400，GPIOF 的 ODR（output data register）相对起始地址的偏移地址是14，则我们需要给 0x40021414 的地址写入数据 0xFFFF.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102123404182.png" alt="image-20231102123404148"></p>
<p>51 单片机库函数中封装的 reg51.h 中，利用 sfr 定义寄存器地址；而 stm32 库函数中使用宏定义，这些就是寄存器映射操作。<strong>对芯片里一个特殊功能的内存单元起别名的过程就是寄存器映射。</strong> 给这个地址再分配一个地址交重映射，stm32 中不咋常用。</p>
<h3 id="C语言对寄存器的封装"><a href="#C语言对寄存器的封装" class="headerlink" title="C语言对寄存器的封装"></a>C语言对寄存器的封装</h3><p>这样逐个地址，哪怕已经进行了寄存器映射，还是很复杂。</p>
<p>c 语言库函数实际进行的封装操作是使用结构体批量定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIO 外设基地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BASE (AHB1PERIPH_BASE + 0x0000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE (AHB1PERIPH_BASE + 0x0400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_BASE (AHB1PERIPH_BASE + 0x0800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_BASE (AHB1PERIPH_BASE + 0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE (AHB1PERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE (AHB1PERIPH_BASE + 0x1400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_BASE (AHB1PERIPH_BASE + 0x1800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH_BASE (AHB1PERIPH_BASE + 0x1C00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO 寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER; <span class="comment">/*GPIO 模式寄存器 地址偏移: 0x00 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER; <span class="comment">/*GPIO 输出类型寄存器 地址偏移: 0x04 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR; <span class="comment">/*GPIO 输出速度寄存器 地址偏移: 0x08 */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR; <span class="comment">/*GPIO 上拉/下拉寄存器 地址偏移: 0x0C */</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR; <span class="comment">/*GPIO 输入数据寄存器 地址偏移: 0x10 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR; <span class="comment">/*GPIO 输出数据寄存器 地址偏移: 0x14 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL; <span class="comment">/*GPIO 置位/复位寄存器低 16 位部分 地址偏移: 0x18 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH; <span class="comment">/*GPIO 置位/复位寄存器高 16 位部分 地址偏移: 0x1A */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR; <span class="comment">/*GPIO 配置锁定寄存器 地址偏移: 0x1C */</span></span><br><span class="line">	<span class="type">uint32_t</span> AFR[<span class="number">2</span>]; <span class="comment">/*GPIO 复用功能配置寄存器 地址偏移: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 GPIO_TypeDef 把地址强制转换成指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA ((GPIO_TypeDef *) GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB ((GPIO_TypeDef *) GPIOB_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC ((GPIO_TypeDef *) GPIOC_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD ((GPIO_TypeDef *) GPIOD_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE ((GPIO_TypeDef *) GPIOE_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF ((GPIO_TypeDef *) GPIOF_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG ((GPIO_TypeDef *) GPIOG_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH ((GPIO_TypeDef *) GPIOH_BASE)</span></span><br></pre></td></tr></table></figure>

<p>所有外设都是如此，首先定义总线 APB AHB 地址，然后每个外设在其基础上进行偏移，每个外设的不同部分再在该外设基址上进行偏移。</p>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><h3 id="寄存器方式"><a href="#寄存器方式" class="headerlink" title="寄存器方式"></a>寄存器方式</h3><p>要命啊，一看名字我就不想试。寄存器新建不得麻烦死。</p>
<p>哎算了为了学习原理，干了。</p>
<p>我们尝试自己写一个寄存器的库函数来引用。</p>
<p>首先我们需要引用 st 官方启动文件 stmf4xx.s，具体用途后面章节再展开讲解。然后我们自己新建一个 stm32f4xx.h 文件来映射寄存器。不过只是把这个文件包含进项目，编译会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Objects\led_reg.axf: Error: L6218E: Undefined symbol SystemInit (referred from startup_stm32f40xx.o).</span><br></pre></td></tr></table></figure>

<p>进入启动文件后，可以看到这么一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>import 的作用相当于 extern，所以没有找到这个函数的定义，需要我们自己去定义。这就是为什么简单引入了启动文件会报错。</p>
<p>而 __main 是当我们定义了 main() 函数后，编译器会自动链接一些c语言库定义好的函数，用于初始化堆栈并且调用我们的 main().</p>
<p><strong>注意，如果想要生成 __main 函数，必须勾选下面这一项。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102200243099.png" alt="image-20231102200243099"></p>
<p>野火你讲的是真好啊。我之前草草学了学 stm32 单片机用法，比赛的时候自己想移植代码，改了启动文件也不好使，就是报错。原来是这个原因。</p>
<p>那么我们只需要定义这么一个函数，哪怕内容是空都无所谓。</p>
<p>最终我们定义的初步项目框架如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698926683862.png" alt="1698926683862"></p>
<p>stm32f4xx.h：内容为空，有这么个东西就行。</p>
<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个程序可以烧录到板子上的。烧录成功之后没有任何反应（因为本来程序也没做什么哈哈），但是这就是一个大进步了。</p>
<h4 id="点灯——51单片机版"><a href="#点灯——51单片机版" class="headerlink" title="点灯——51单片机版"></a>点灯——51单片机版</h4><p>51单片机版就是引用 reg51.h 头文件，在其中声明了各个引脚的地址。我们只需要直接给引脚赋值即可。</p>
<p>调用代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 0 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	PA0=<span class="number">0xFE</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来我们需要定义 LED 灯的寄存器位置。阅读原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698939342199.png" alt="1698939342199"></p>
<p>大致可以看出，板子上的这个 RGB LED 通过三个引脚来控制 RGB 亮度。输出低电平则导通点亮。</p>
<p>具体输出方式是通过 ODR 进行输出。查找 stm32f4xx 中文参考手册可见：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940158585.png" alt="1698940158585"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940257044.png" alt="1698940257044"></p>
<p>那么我们就要给 0x4002 1400 +14 的地址赋值，让 1&lt;&lt;6 1&lt;&lt;7 1&lt;&lt;8 的位分别赋值为低电平.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	 *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这样也不亮。亮就怪了，stm32 寄存器是需要先做初始化配置的。</p>
<h4 id="点灯——stm32-版"><a href="#点灯——stm32-版" class="headerlink" title="点灯——stm32 版"></a>点灯——stm32 版</h4><p>首先我们要设置 GPIO 模式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940961543.png" alt="1698940961543"></p>
<p>想点灯 输出高低电平，是 01 通用输出模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br></pre></td></tr></table></figure>

<p>意思是先把 PF6 模式位置为00，然后赋值为01通用输出。</p>
<p>配置完模式之后，还需要配置时钟，stm32 每个外设都需要配置时钟。</p>
<p>前面提到过 GPIO 是在 AHB1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103516061.png" alt="1699103516061"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103724261.png" alt="1699103724261"></p>
<p>全部代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40023800</span>+<span class="number">0x30</span>)|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们把这几个地址值提取出来，宏定义映射寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx.h</span></span><br><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1_ENR    *(unsigned int *)(0x40023800+0x30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER     *(unsigned int *)(0x40021400+0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR       *(unsigned int *)(0x40021400+0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点灯——流水灯闪烁"><a href="#点灯——流水灯闪烁" class="headerlink" title="点灯——流水灯闪烁"></a>点灯——流水灯闪烁</h4><p>利用软件延时实现 RGB 流水灯闪烁。很简单，前面已经看了3个 LED 通道 PF678 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>));   </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>); </span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//毫秒级的延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span></span><br><span class="line">&#123;    </span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">while</span>(time--)</span><br><span class="line">   &#123;</span><br><span class="line">      i=<span class="number">4000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--) ;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点灯——GPIO-具体功能框图对应"><a href="#点灯——GPIO-具体功能框图对应" class="headerlink" title="点灯——GPIO 具体功能框图对应"></a>点灯——GPIO 具体功能框图对应</h4><p>GPIO：通用输入输出引脚。我们可以通过编程来输出或者读取数据。大部分 GPIO 是已经连接、定义好了一些功能（比如上面尝试过的 PF6 LED），有的引脚有多个功能支持重新映射。</p>
<p>STM32 GPIO 除了 adc 是 3.3v，其他 GPIO 都是 5v 容忍。</p>
<p>GPIO 框图（<strong>重点</strong>）如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231104221140325.png" alt="image-20231104221140325"></p>
<p>先从输出开始看。最右侧的 IO 引脚是连接在芯片周围一圈的144个引脚之一。除了 IO 引脚，此图中其他所有部分都是封装在芯片内部我们看不到的。</p>
<p>往左有两个保护二极管。当电压大于 5V，电流会往上 VDD_FT 走。当电压为负电压，电流会由 VSS 往 IO 引脚走。</p>
<p>上下拉电阻：比武外接一个低电平工作的设备，但是我们不希望一上电外设就工作，可以设置上拉电阻，稳定一段时间。</p>
<p>GPIO 输出的数据来源：复位寄存器 BSRR，或者 ODR 设置（图中的3下路部分）。复位寄存器高16位复位（写1置0）低16位置位（写1置1），置位优先级更高。</p>
<p>配置 GPIO 模式（输入&#x2F;输出，选择哪一路）通过前面用过的 MODER 配置。</p>
<p>输出模式（图中输出控制部分）配置端口输出类型寄存器 OTYPER，比如推挽输出，开漏输出。</p>
<p>推挽输出：有直接驱动能力，输出0就是低电平，输出1就输出可以工作的高电平。原理是采用了一个放大的电路？</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699356797818.png" alt="1699356797818"></p>
<p>输入（INT）为高电平时，反向后 PMOS 导通，输出高电平。输入为低电平时，反向后 NMOS 导通，输出低电平。我们可以用一个小电流去驱动出来一个大电流。</p>
<p>开漏输出：自己本身没有输出高电平的手段。低电平可以接地，高电平没有 PMOS 管，是浮空状态。需要外接一个电阻。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357078909.png" alt="1699357078909"></p>
<p>stm32 输出 5V 电压的方法就是开漏输出外接电阻。通过接两个三极管的方式反向。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357296750.png" alt="1699357296750"></p>
<p>框图中的模拟部分输入输出则不用配置这些模式信息，直接由外设接到保护二极管再接到输出引脚。</p>
<p>框图中的输入部分经过保护电压后，还需要施密特触发器调整一下。比如原来电压的数值并非精确的0或 3.3V，施密特触发器将高于 1.8V 的全部视作1，低于的全部视作0后输入芯片。模拟部分则不需要经过施密特触发器。</p>
<p>因此配置 GPIO 输出的步骤如下：</p>
<ol>
<li>GPIO 功能，通用输出、复用功能、模拟输入等 MODER；</li>
<li>输出推挽 or 开漏 OTYPER；</li>
<li>输出速度 OSPEEDR；</li>
<li>上下拉电阻是否需要开启 PUPDR；</li>
<li>具体输出内容 BSRR or ODR.</li>
</ol>
<p>输入部分后面输入实验介绍~</p>
<p>按整个流程重新串一遍代码，如下：（其实和前面差不多，就是重新按照流程串了一遍）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE    (unsigned int *)    0x40023800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE  (unsigned int *)    0x40021400</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1ENR         *(RCC_BASE+0x30)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER         *(GPIOF_BASE+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OSPEEDR       *(GPIOF_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_PUPDR         *(GPIOF_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR           *(GPIOF_BASE+0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BSRR          *(GPIOF_BASE+0x18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_AHB1ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    GPIOF_MODER &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    GPIOF_MODER |= (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录前记得勾选：use MicroLib.</p>
<h3 id="构建库方式"><a href="#构建库方式" class="headerlink" title="构建库方式"></a>构建库方式</h3><h4 id="点灯——自己尝试构建库函数版"><a href="#点灯——自己尝试构建库函数版" class="headerlink" title="点灯——自己尝试构建库函数版"></a>点灯——自己尝试构建库函数版</h4><p>寄存器方法了解到这里就好，野火课程主要是库函数写代码。首先我们自己尝试构建一下库函数。</p>
<p>还是基于上次实验代码修改即可。首先对 .h 文件做一些修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个是防止多次引用头文件重复定义。</p>
<p>然后，像之前一条条定义太麻烦了。其实我们注意到每个寄存器都是4字节，我们可以用固定大小的结构体定义。比如 GPIO ABCDEF 结构都一样，我们只需要统一定义结构体和各自的基址即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span>	<span class="comment">// 包含了 uint32_t uint16_t</span></span></span><br><span class="line"><span class="comment">/* GPIO寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER;    <span class="comment">/*GPIO模式寄存器						地址偏移: 0x00      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*GPIO输出类型寄存器				地址偏移: 0x04      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*GPIO输出速度寄存器				地址偏移: 0x08      */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*GPIO上拉/下拉寄存器			地址偏移: 0x0C      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR;      <span class="comment">/*GPIO输入数据寄存器				地址偏移: 0x10      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR;      <span class="comment">/*GPIO输出数据寄存器				地址偏移: 0x14      		*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL;    <span class="comment">/*GPIO置位/复位寄存器 低16位部分	地址偏移: 0x18 	*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH;    <span class="comment">/*GPIO置位/复位寄存器 高16位部分	地址偏移: 0x1A  */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR;     <span class="comment">/*GPIO配置锁定寄存器				地址偏移: 0x1C      */</span></span><br><span class="line">    <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*GPIO复用功能配置寄存器		地址偏移: 0x20-0x24 		*/</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GPIOF ((GPIO_TypeDef *)GPIOF_BASE)</span></span><br></pre></td></tr></table></figure>

<p>main.c 中可以把对应寄存器替换为 GPIOF-&gt;寄存器名了。</p>
<p>然后我们直接对寄存器做操作，还是有点直接了，最好是我们不需要关注寄存器有哪些，直接调用一个 GPIO 设置函数即可使用，封装性可移植性都会好很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRL=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRH=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>比如首先我们简单写了这样一个置位函数，使用方法为 <code>GPIO_SetBits(GPIOF_Base,1&lt;&lt;6)</code> .</p>
<p>以及我们可以在 <code>stm32f4xx_gpio.h</code> 里批量定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6          (uint16_t)(1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7          (uint16_t)(1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8          (uint16_t)(1&lt;&lt;8)</span></span><br></pre></td></tr></table></figure>

<p>这样 GPIO 使用用 Set Reset 函数已经非常规范了。那么初始化操作我们也可以封装成一个函数。</p>
<p>初始化需要设置 MODER PUPDR OSPEEDR OTYPER，我们可以定义一个结构体用于存储这些初始化变量，初始化的时候新建一个这样的结构体并赋值，传入初始化函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="comment">//每个模块具体的值可以定义一个枚举类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Mode_IN=<span class="number">0x00</span>;</span><br><span class="line">    GPIO_Mode_OUT=<span class="number">0x01</span>;</span><br><span class="line">    GPIO_Mode_AF=<span class="number">0x02</span>;</span><br><span class="line">    GPIO_Mode_AN=<span class="number">0x03</span>;</span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;</span><br><span class="line">    GPIOMode_TypeDef MODER;</span><br><span class="line">    GPIOPuPd_TypeDef PUPDR;</span><br><span class="line">    GPIOOType_TypeDef OTYPER;</span><br><span class="line">    GPIOOSpeed_TypeDef OSPEEDR;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>具体使用的时候首先我们初始化一个 GPIO_InitTypeDef 变量，并且给其中的每一个子元素都赋值。然后传入 GPIO_Init 函数中，里面就是一系列根据手册而来的位操作，这里我感觉前面原理懂差不多就不用非跟着敲了。</p>
<h4 id="分析-stm32-固件库函数"><a href="#分析-stm32-固件库函数" class="headerlink" title="分析 stm32 固件库函数"></a>分析 stm32 固件库函数</h4><p>前面基本上都是了解固件库编程，从51过渡到 stm32. 后面所有固件编程固件库的使用方法都和前面的 GPIO 类似。</p>
<p>固件是什么？其实就是程序，固化到 EEPROM 或 FLASH 中，操作最底层的设备。<strong>不是具体的应用，而是只操作最底层的设备。比如点灯算应用，给应用工程师提供库函数的工作是固件工程师的。</strong></p>
<p>stm32 官方 stmf4 固件库下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/zh/embedded-software/stm32-standard-peripheral-libraries/products.html?querycriteria=productId=LN1939">STM32标准外设软件库: 相关产品</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231108222206160.png" alt="image-20231108222206160"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     22:16                Libraries</span><br><span class="line">d-----         2023/11/8     22:16                Project</span><br><span class="line">d-----         2023/11/8     22:17                Utilities</span><br><span class="line">d-----         2023/11/8     22:17                _htmresc</span><br><span class="line">-ar---         2023/11/8     22:15          88007 Package_license.html</span><br><span class="line">-ar---         2023/11/8     22:15          19611 Package_license.md</span><br><span class="line">-ar---         2023/11/8     22:15         152599 Release_Notes.html</span><br><span class="line">-ar---         2023/11/8     22:15       37185187 stm32f4xx_dsp_stdperiph_lib_um.chm</span><br></pre></td></tr></table></figure>

<p>.chm：使用帮助文档。</p>
<p>.html .md：一些版本更新，包许可证相关信息。</p>
<p>Utilities：一些第三方其他软件。</p>
<p>Project：样例，模板。</p>
<p>Libraries：库，CMSIS 是一些 ARM 公司的标准，Driver 是固件。inc 是头文件，src 是c文件。</p>
<p>我们根据上节课写的项目来进行库函数文件功能分析。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>所属类别</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>startup_stm32f40xx.s</td>
<td>片上外设</td>
<td>汇编启动文件</td>
</tr>
<tr>
<td>stm32f4xx.h</td>
<td>片上外设</td>
<td>外设寄存器映射</td>
</tr>
<tr>
<td>system_stm32f4xx.c &#x2F; system_stm32f4xx.h</td>
<td>片上外设</td>
<td>初始化系统时钟</td>
</tr>
<tr>
<td>stm32f4xx_xxxx.c &#x2F; stm32f4xx_xxxx.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cm4.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cmFunc.h &#x2F; core_cmSimd.h</td>
<td>内核</td>
<td>内核外设的一些操作函数</td>
</tr>
<tr>
<td>misc.c &#x2F; misc.h</td>
<td>内核</td>
<td>中断相关函数（优先级分组，系统中断）</td>
</tr>
<tr>
<td>stm32f4xx_it.c &#x2F; stm32f4xx_it.h</td>
<td>内核</td>
<td>中断服务函数（所有中断入口）</td>
</tr>
<tr>
<td>main.c</td>
<td></td>
<td>main 函数</td>
</tr>
</tbody></table>
<ol>
<li>startupxxxx.s：启动文件。</li>
<li>stm32f4xx.h：外设寄存器映射。</li>
<li>跳到 system_Init 函数，这个函数当时我们为了执行只写了一个空函数，而 stm32 官方固件库模板里面是有的，在 system_stm32f4xx.c 里，初始化系统时钟。</li>
<li>stm32f4xx.c：具体外设驱动，比如上节课写的 gpio。</li>
<li>core_cm4.h：内核寄存器映射。</li>
<li>misc：中断。</li>
</ol>
<h4 id="构建库函数"><a href="#构建库函数" class="headerlink" title="构建库函数"></a>构建库函数</h4><p>创建一个通用的模板，后面写程序直接使用这个模板。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     23:27                Libraries</span><br><span class="line">d-----         2023/11/8     23:27                Listing</span><br><span class="line">d-----         2023/11/8     23:27                Output</span><br><span class="line">d-----         2023/11/8     23:27                Project</span><br><span class="line">d-----         2023/11/8     23:27                User</span><br><span class="line">-a----         2020/2/27     13:45            401 keilkill.bat</span><br></pre></td></tr></table></figure>

<p>前面都是新建的文件夹，keilkill.bat 是从 keil 编译程序中复制出来的一个脚本，可以删掉中间文件。</p>
<p>把固件库 Lib 里的 CMSIS 和 Driver 文件拷贝到 Libraries 文件夹中。CMSIS 中只保留 Device Include 文件夹。Device 中包含外设相关（比如 stm32f4xx.h system_stm32f4xx），Include 中只包含内核相关。</p>
<p>把 main.c stm32f4xx_it.c &#x2F; stm32f4xx_it.h stm32f4xx_conf.h 拷贝到 User 文件夹中。</p>
<p>在 Project 文件夹里可以包含多给项目文件，不光只有 Keil 的。比如 IAR 的我们新建一个 IAR 文件夹，Keil 我们新建一个 RVMDK(uv5) 文件夹。RealView 是包含不止 MDK 的开发工具集合的称呼，MDK 是 MCU 开发工具集成包，uVersion 是 IDE，Keil 是公司名字。</p>
<p>uVision 里新建工程，新建在 RVMDK(uv5) 文件夹下。</p>
<p>新建组、添加文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002542997.png" alt="image-20231109002542997"></p>
<p>STM32F4xx_StdPeriph_Driver 添加 STM32F4xx_StdPeriph_Driver&#x2F;src 下的所有文件，屏蔽掉 dma2d fmc ltdc，后两个是 sd 和 lcd 屏幕组件。</p>
<p>头文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002823229.png" alt="image-20231109002823229"></p>
<p>宏定义如下：</p>
<p>USE_STDPERIPH_DRIVER,STM32F40_41xxx</p>
<p>我现在好想明白为什么宏定义在这里了，这样后面换单片机型号的时候可以直接修改这个宏定义。</p>
<p><strong>PS：我下载的是 1.8.1 版本 stm32f4xx.h 库函数，里面出现了一段重复定义导致编译产生了200多个 warning。我把下面那一段删掉了就好了。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/true" alt="jingqing3948_1-1699463889291.png"></p>
<p>Output 里设置 Output 文件夹，不然都在 Proj 里太乱。</p>
<p>记得勾选 MicroLib。</p>
<h4 id="点灯——官方库函数版"><a href="#点灯——官方库函数版" class="headerlink" title="点灯——官方库函数版"></a>点灯——官方库函数版</h4><p>在 User 文件夹中新建 LED 文件夹，里面新建 bsp_led.c，代表板级支持包 LED 代码，也就是只针对我们当前这一款开发板的点灯程序。</p>
<ol>
<li><p>设置时钟：rcc 时钟，在 stm32f4xx_rcc.c 中：</p>
</li>
<li><pre><code class="c">/**
  * @brief  Enables or disables the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.   
  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
  *            @arg RCC_AHB1Periph_CRC:         CRC clock
  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
  *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其他部分基本也是参照库函数（主要是 stm32f4xx_gpio.h）最终呈现如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &quot;bsp_led.h&quot;</span><br><span class="line"></span><br><span class="line">void LED_GPIO_Config(void)&#123;</span><br><span class="line">    //RCC set function in stm32f4xx_rcc.h</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        //Init structure</span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">        GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;</span><br><span class="line">        GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;</span><br><span class="line">        GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        //init function</span><br><span class="line">        GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

置位可以使用 `GPIO_SetBits` 或 `GPIO_ResetBits`。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      GPIO_ResetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">      GPIO_SetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

没有上下拉的时候推挽输出会直接被 ODR 值所影响，哪怕没有赋值其中本来的值也会影响。所以推挽输出无上下拉，不置位 LED 也会被点亮，因为 ODR 默认值0.
</code></pre>
</li>
</ol>
<h3 id="输入——按键点灯"><a href="#输入——按键点灯" class="headerlink" title="输入——按键点灯"></a>输入——按键点灯</h3><p>开发板按键电路如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109191525189.png" alt="image-20231109191525189"></p>
<p>按键未按下接地，按下后为高电平。电容起到消抖作用，软件处理就不需要手动延时消抖了。</p>
<p>编程没啥难度，就是改了一下输入模式。使用 <code>ReadInputDataBits</code> 读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsp_button.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Button_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_InitTypeDef GPIOInitStruct;</span><br><span class="line">        GPIOInitStruct.GPIO_Mode=GPIO_Mode_IN;</span><br><span class="line">        GPIOInitStruct.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">        GPIOInitStruct.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIOInitStruct.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;</span><br><span class="line">        </span><br><span class="line">        GPIO_Init(GPIOA,&amp;GPIOInitStruct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0))GPIO_SetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        <span class="keyword">else</span> GPIO_ResetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现按键按下后翻转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET)&#123;</span><br><span class="line">            <span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET);</span><br><span class="line">            GPIO_ToggleBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要等到按键松开的时候再翻转，轮询直到松开。</p>
<h3 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h3><p>之前51单片机常见位定义。比如 PA 引脚有8个 IO 口，我们可以定义 <code>sbit LED1=PA^0</code> 这样单独操作某一位。</p>
<p>stm32 里没有直接的位定义方式。一种解决办法是我们利用与或操作不影响其他位的同时操作特定位；另一种就是位带操作。</p>
<p>stm32 里有一部分别名区域，用于映射外设、SRAM 中特定的位带区，我们操作这一部分别名区域时就可以实现对外设、SRAM 位带区与的位操作。</p>
<p>片上外设位带区：0X4000 0000<del>0X400F 0000，别名区：0X4200 0000</del>0X43FF FFFF，包含 APB12，AHB1 外设。</p>
<p>SRAM 位带区：0X2000 0000<del>0X200F 0000，别名区：0X2200 0000</del>0X23FF FFFF</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109220918350.png" alt="image-20231109220918350"></p>
<p>外设地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x42000000+ (A-0x40000000)<em>8</em>4 +n*4  （n是位序号）</p>
<p>SRAM 地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x22000000+ (A-0x20000000)<em>8</em>4 +n*4</p>
<p>扩大了32倍，可以对32位寄存器中的每一位进行操作。</p>
<p>统一公式：<code>\#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</code></p>
<p>使用：比如我们操作一个 GPIO 的位操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br><span class="line"><span class="comment">// 把一个地址转换成一个指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr) *((volatile unsigned long *)(addr))</span></span><br><span class="line"><span class="comment">// 把位带别名区地址转换成指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO ODR 和 IDR 寄存器地址映射</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR_Addr (GPIOF_BASE+20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_IDR_Addr (GPIOF_BASE+16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独操作 GPIO 的某一个 IO 口，n(0,1,2...15),</span></span><br><span class="line"><span class="comment">// n 表示具体是哪一个 IO 口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFout(n) BIT_ADDR(GPIOF_ODR_Addr,n) <span class="comment">//输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFin(n) BIT_ADDR(GPIOF_IDR_Addr,n) <span class="comment">//输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line">PFout(<span class="number">6</span>)= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这个概念学学就好，好像实际应用没啥意义。我们微处理器考试也考过hh。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-效率提升：Win11磁贴配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%EF%BC%9AWin11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/"
    >效率提升：Win11磁贴配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%EF%BC%9AWin11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B8%8F%E6%98%9F%E9%80%90%E8%B7%AF%EF%BC%88%E5%88%9B%E6%96%B0%E6%8E%A2%E7%B4%A2%EF%BC%89/">踏星逐路（创新探索）</a> / <a class="article-category-link" href="/categories/%E8%B8%8F%E6%98%9F%E9%80%90%E8%B7%AF%EF%BC%88%E5%88%9B%E6%96%B0%E6%8E%A2%E7%B4%A2%EF%BC%89/Efficiency/">Efficiency</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近电脑还是升级到 win11 了。我之前采用的美化方案是桌面上的图标全部移到 win10 开始菜单里的全屏菜单上，用磁贴贴一排。每次要访问文件的时候都去开始菜单里找，而不是放在桌面上，这样桌面也可以空出来欣赏壁纸。参考配置链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/45120814/answer/1007955630">如何让Windows 10系统桌面变得更好看？ - 知乎 (zhihu.com)</a></p>
<p>但是升级到 win11 对我而言影响最大的就是压根没有全屏桌面和磁贴功能了。因此我搜了很多解决方案，加上一些自己的改进，最终把桌面磁贴恢复成如上图所示。一个自己喜欢看的桌面还是会对生产力的提高有很大帮助的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712234132339.png" alt="image-20230712234132339"></p>
<h2 id="软件安装：start11"><a href="#软件安装：start11" class="headerlink" title="软件安装：start11"></a>软件安装：start11</h2><p>首先，恢复开始菜单这一操作最离不开的就是 start11 这款软件。他让 win11 的开始菜单又有了全屏菜单选项，也支持了自定义磁贴在上面。虽然调整磁贴位置的时候偶尔会花几秒重启，但大多数时候还是没问题的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235022366.png" alt="image-20230712235022366"></p>
<p>正版软件是免费试用的，欢迎付费支持原作者。或采用博主的同款方案：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru">https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru</a><br>提取码：1fru<br>–来自百度网盘超级会员V2的分享</p>
<h2 id="xxxxxxxxxx-int-zong-int-i-纵坐标y1-double-x-i-51-double-y-12-0-sin-x-7-int-y1-int-15-y-return-y1-​int-heng-int-i-横坐标j-int-j-i-if-i-101-i202-i303-i"><a href="#xxxxxxxxxx-int-zong-int-i-纵坐标y1-double-x-i-51-double-y-12-0-sin-x-7-int-y1-int-15-y-return-y1-​int-heng-int-i-横坐标j-int-j-i-if-i-101-i202-i303-i" class="headerlink" title="xxxxxxxxxx int zong(int i)&#x2F;&#x2F;纵坐标y1{    double x&#x3D;(i-51);    double y&#x3D;12.0*sin(x&#x2F;7);    int y1&#x3D;(int)(15-y);    return y1;}​int heng(int i)&#x2F;&#x2F;横坐标j{    int j&#x3D;i;    if(i&gt;101&amp;&amp;i&lt;&#x3D;202)j&#x3D;203-i;    else if(i&gt;202&amp;&amp;i&lt;&#x3D;303)j&#x3D;i-202;    else if(i&gt;303&amp;&amp;i&lt;&#x3D;404)j&#x3D;405-i;    return j;}​void dayin(char ch,int j,int y1)&#x2F;&#x2F;在(y1,j)处输出给定字符{        gotoxy(y1,j);        if(ch&#x3D;&#x3D;’ ‘)        {            if(y1&#x3D;&#x3D;15)printf(“-“);            else if(j&#x3D;&#x3D;51)printf(“|”);            else printf(“ “);        }        else printf(“#”);        gotoxy(29-y1,102-j);        if(ch&#x3D;&#x3D;’ ‘)&#x2F;&#x2F;防止坐标点和坐标轴被空格覆盖        {            if(29-y1&#x3D;&#x3D;15)printf(“-“);            else if(102-j&#x3D;&#x3D;51)printf(“|”);            else if(29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;49)printf(“-“);            else if((29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;50)||(29-y1&#x3D;&#x3D;3&amp;&amp;102-j&#x3D;&#x3D;50))printf(“1”);            else if(29-y1&#x3D;&#x3D;16&amp;&amp;102-j&#x3D;&#x3D;100)printf(“X”);            else printf(“ “);        }        else printf(“#”);        gotoxy(1,1);}​​​​int main(){    float x,y;    int tim&#x3D;20;    system(“color F0”);    system(“mode con cols&#x3D;101 lines&#x3D;30”);    clear();        for(int i&#x3D;0;i&lt;&#x3D;100;i++)&#x2F;&#x2F;打印x轴     {        gotoxy(15,i+1);        if(i!&#x3D;50)printf(“-“);        else printf(“+”);        gotoxy(1,1);        rest(1);    }        for(int i&#x3D;29;i&gt;&#x3D;0;i–)&#x2F;&#x2F;打印y轴     {        gotoxy(i+1,51);        if(i!&#x3D;14)printf(“|”);        gotoxy(1,1);         rest(1);    }    &#x2F;&#x2F;打印轴上的点    gotoxy(16,52); printf(“O”);        gotoxy(16,100);printf(“X”);        gotoxy(1,49);printf(“Y”);        gotoxy(3,50);printf(“1”);        gotoxy(26,49);printf(“-1”);                    int i&#x3D;0,j,y1;​    for(i&#x3D;52;i&lt;&#x3D;404;i++)&#x2F;&#x2F;打印函数     {        j&#x3D;heng(i),y1&#x3D;zong(i);        dayin(‘#’,j,y1);        rest(4);                if(i-51-tim&gt;0)        {            y1&#x3D;zong(i-tim);            j&#x3D;heng(i-tim);            dayin(‘ ‘,j,y1);        }    }       for(int r&#x3D;i-tim;r&lt;&#x3D;i;r++)    {        j&#x3D;heng(r);        y1&#x3D;zong(r);        dayin(‘ ‘,j,y1);        rest(4);    }     gotoxy(1,1);    rest(1000);    return 0;}c"></a>xxxxxxxxxx int zong(int i)&#x2F;&#x2F;纵坐标y1{    double x&#x3D;(i-51);    double y&#x3D;12.0*sin(x&#x2F;7);    int y1&#x3D;(int)(15-y);    return y1;}​int heng(int i)&#x2F;&#x2F;横坐标j{    int j&#x3D;i;    if(i&gt;101&amp;&amp;i&lt;&#x3D;202)j&#x3D;203-i;    else if(i&gt;202&amp;&amp;i&lt;&#x3D;303)j&#x3D;i-202;    else if(i&gt;303&amp;&amp;i&lt;&#x3D;404)j&#x3D;405-i;    return j;}​void dayin(char ch,int j,int y1)&#x2F;&#x2F;在(y1,j)处输出给定字符{        gotoxy(y1,j);        if(ch&#x3D;&#x3D;’ ‘)        {            if(y1&#x3D;&#x3D;15)printf(“-“);            else if(j&#x3D;&#x3D;51)printf(“|”);            else printf(“ “);        }        else printf(“#”);        gotoxy(29-y1,102-j);        if(ch&#x3D;&#x3D;’ ‘)&#x2F;&#x2F;防止坐标点和坐标轴被空格覆盖        {            if(29-y1&#x3D;&#x3D;15)printf(“-“);            else if(102-j&#x3D;&#x3D;51)printf(“|”);            else if(29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;49)printf(“-“);            else if((29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;50)||(29-y1&#x3D;&#x3D;3&amp;&amp;102-j&#x3D;&#x3D;50))printf(“1”);            else if(29-y1&#x3D;&#x3D;16&amp;&amp;102-j&#x3D;&#x3D;100)printf(“X”);            else printf(“ “);        }        else printf(“#”);        gotoxy(1,1);}​​​​int main(){    float x,y;    int tim&#x3D;20;    system(“color F0”);    system(“mode con cols&#x3D;101 lines&#x3D;30”);    clear();        for(int i&#x3D;0;i&lt;&#x3D;100;i++)&#x2F;&#x2F;打印x轴     {        gotoxy(15,i+1);        if(i!&#x3D;50)printf(“-“);        else printf(“+”);        gotoxy(1,1);        rest(1);    }        for(int i&#x3D;29;i&gt;&#x3D;0;i–)&#x2F;&#x2F;打印y轴     {        gotoxy(i+1,51);        if(i!&#x3D;14)printf(“|”);        gotoxy(1,1);         rest(1);    }    &#x2F;&#x2F;打印轴上的点    gotoxy(16,52); printf(“O”);        gotoxy(16,100);printf(“X”);        gotoxy(1,49);printf(“Y”);        gotoxy(3,50);printf(“1”);        gotoxy(26,49);printf(“-1”);                    int i&#x3D;0,j,y1;​    for(i&#x3D;52;i&lt;&#x3D;404;i++)&#x2F;&#x2F;打印函数     {        j&#x3D;heng(i),y1&#x3D;zong(i);        dayin(‘#’,j,y1);        rest(4);                if(i-51-tim&gt;0)        {            y1&#x3D;zong(i-tim);            j&#x3D;heng(i-tim);            dayin(‘ ‘,j,y1);        }    }       for(int r&#x3D;i-tim;r&lt;&#x3D;i;r++)    {        j&#x3D;heng(r);        y1&#x3D;zong(r);        dayin(‘ ‘,j,y1);        rest(4);    }     gotoxy(1,1);    rest(1000);    return 0;}c</h2><p>首先如果是按博主的磁贴方法配置，就要选“win10配置”。或者你觉得其他风格也还不错都可以选。并且 ENABLE start11.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235704628.png" alt="image-20230712235704628"></p>
<p>点击“配置菜单”，进行如下配置：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235738298.png" alt="image-20230712235738298"></p>
<p>在“自定义菜单视觉外观”里，可以设置全屏菜单的颜色、透明度等，比如我使用的是有一定透明度的毛玻璃的样式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000601091.png" alt="image-20230713000601091"></p>
<p>然后在“控制”栏里设定如何打开 start11，确保可以打开：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235840844.png"></p>
<p>接着，点击 win 图标就可以打开全屏菜单了。</p>
<h2 id="磁贴配置"><a href="#磁贴配置" class="headerlink" title="磁贴配置"></a>磁贴配置</h2><p>对于大部分软件，只要右键-固定到开始屏幕&#x2F;固定到 start11，就可以在全屏菜单里看到刚刚贴上的磁贴了。</p>
<p>如果贴失败，可以尝试以下的方法：</p>
<ul>
<li>右键快捷方式，点击“打开文件所在位置”，再尝试把该文件的 .exe 文件固定到开始屏幕。</li>
<li>反复尝试，因为可能有一定的延迟。可以取消固定再次固定，等待一会看开始菜单是否出现。</li>
</ul>
<p>然后可以手动分组磁贴（把他们移到临近的位置），调整磁贴背景色，调整磁贴大小（有小正方形，中正方形，长方形，大正方形四种可以选择），调整磁贴布局位置。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000428410.png" alt="image-20230713000428410"></p>
<h2 id="图片磁贴配置"><a href="#图片磁贴配置" class="headerlink" title="图片磁贴配置"></a>图片磁贴配置</h2><p>这里是最自由发挥的部分。高情商：自由发挥。低情商：都要自己做很麻烦。</p>
<p>之前 win10 是有一款快捷工具可以输入自定义图片，按自己想要的格式裁剪并自动在全屏菜单中输出的，叫 Tile Genie.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000854968.png" alt="image-20230713000854968"></p>
<p>但是它好像并不能在 start11 中使用。我尝试了一下导出的都是不能显示的图片块，所以只能放弃这种方法。如果读者的 Tile Genie 是没有问题可以正常显示图片那再好不过了，后面的内容都可以不用看了。</p>
<p>如果导出失败……我采用的方法是手动裁剪固定图片。很笨，但是有结果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001102790.png" alt="image-20230713001102790"></p>
<p>首先，自行裁剪图片，计算公式为：中正方形 150*150，长方形 306*150，大正方形 306*306，边界线是6（像素）.</p>
<p>我采用的图像裁剪方法是：<a target="_blank" rel="noopener" href="https://www.iloveimg.com/zh-cn/crop-image">免费在线裁剪图像文件 (iloveimg.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178422454.png" alt="1689178422454"></p>
<p>然后把导出图片找一个合适的地方存储起来，注意贴上磁贴之后就不能再移动修改这些图片了。</p>
<p>在全屏菜单中右键-固定文件，选定文件路径添加。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001454756.png" alt="image-20230713001454756"></p>
<p>刚固定上是这种形式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178534062.png" alt="1689178534062"></p>
<p>然后右键-调整大小，调整为想要的大小。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001613170.png" alt="image-20230713001613170"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001632462.png" alt="image-20230713001632462"></p>
<p>最后一步，右键-图标-选择自定义磁贴图像，再次选择此文件，然后他就被当做图标全屏显示了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001653804.png" alt="image-20230713001653804"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-问题解决：ubuntu 安装 emscripten 时 install latest 安装报错"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"
    >问题解决：ubuntu 安装 emscripten 时 install latest 安装报错</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A0%B4%E6%B5%AA%EF%BC%88%E9%81%87%E5%88%B0%E7%9A%84bug%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/">破浪（遇到的bug及解决方案）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>学习官网参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm">Compiling a New C&#x2F;C++ Module to WebAssembly - WebAssembly | MDN (mozilla.org)</a></p>
<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>形如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Downloading URL &#x27;https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2&#x27;: &lt;urlopen error [Errno 104] Connection reset by peer&gt;</span><br><span class="line">error: installation failed!</span><br></pre></td></tr></table></figure>

<p>OS：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux jingqing 5.19.0-35-generic #36~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 17 15:17:25 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="产生错误原因分析"><a href="#产生错误原因分析" class="headerlink" title="产生错误原因分析"></a>产生错误原因分析</h2><blockquote>
<p>emsdk install latest报错（因为从谷歌中下载，cmd中命令形式访问不到google）<br>版权声明：本文为CSDN博主「小白啥时候能进阶成功」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34754747/article/details/103815349">https://blog.csdn.net/qq_34754747/article/details/103815349</a></p>
</blockquote>
<p>非常感谢博主的答疑解惑，不过我没有看得太懂原文中的解决方案，网上搜到的大多数方案也是 windows 环境下的解决方案，因此我决定自己写一个 ubuntu 系统下的补安装。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>说白了就是我自己复制链接到浏览器里，下载安装这几个包，放到 emsdk 的指定位置。</p>
<p>这里有两个要注意的点，这一部分主要是分析，不想看的同学可以直接跳到<a href="#solution">具体步骤</a>处：</p>
<ol>
<li><p>emsdk install 的默认安装规则是：不管你有没有安装过这些包，我 install latest 都是重新安装，保证最新版本。但是现在问题是 install latest 有问题，我要手动安装包放进去。<br>我们打开 emsdk.py 通过搜索关键词可以找到报错信息的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:675</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On success, returns the filename on the disk pointing to the destination file that was produced</span></span><br><span class="line"><span class="comment"># On failure, returns None.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, dstpath, download_even_if_exists=<span class="literal">False</span>, filename_prefix=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">  debug_print(<span class="string">&#x27;download_file(url=&#x27;</span> + url + <span class="string">&#x27;, dstpath=&#x27;</span> + dstpath + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  file_name = get_download_target(url, dstpath, filename_prefix)</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(file_name) <span class="keyword">and</span> <span class="keyword">not</span> download_even_if_exists:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File &#x27;&quot;</span> + file_name + <span class="string">&quot;&#x27; already downloaded, skipping.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> file_name</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    u = urlopen(url)</span><br><span class="line">    mkdir_p(os.path.dirname(file_name))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      file_size = get_content_length(u)</span><br><span class="line">      <span class="keyword">if</span> file_size &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s, %s Bytes&quot;</span> % (file_name, url, file_size))</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s&quot;</span> % (file_name, url))</span><br><span class="line"></span><br><span class="line">      file_size_dl = <span class="number">0</span></span><br><span class="line">      <span class="comment"># Draw a progress bar 80 chars wide (in non-TTY mode)</span></span><br><span class="line">      progress_max = <span class="number">80</span> - <span class="number">4</span></span><br><span class="line">      progress_shown = <span class="number">0</span></span><br><span class="line">      block_sz = <span class="number">256</span> * <span class="number">1024</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27; [&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          buffer = u.read(block_sz)</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> buffer:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          file_size_dl += <span class="built_in">len</span>(buffer)</span><br><span class="line">          f.write(buffer)</span><br><span class="line">          <span class="keyword">if</span> file_size:</span><br><span class="line">              percent = file_size_dl * <span class="number">100.0</span> / file_size</span><br><span class="line">              <span class="keyword">if</span> TTY_OUTPUT:</span><br><span class="line">                  status = <span class="string">r&quot; %10d  [%3.02f%%]&quot;</span> % (file_size_dl, percent)</span><br><span class="line">                  <span class="built_in">print</span>(status, end=<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">while</span> progress_shown &lt; progress_max * percent / <span class="number">100</span>:</span><br><span class="line">                      <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                      sys.stdout.flush()</span><br><span class="line">                      progress_shown += <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    errlog(<span class="string">&quot;Error: Downloading URL &#x27;&quot;</span> + url + <span class="string">&quot;&#x27;: &quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;SSL: CERTIFICATE_VERIFY_FAILED&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e) <span class="keyword">or</span> <span class="string">&quot;urlopen error unknown url type: https&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e):</span><br><span class="line">      errlog(<span class="string">&quot;Warning: Possibly SSL/TLS issue. Update or install Python SSL root certificates (2048-bit or greater) supplied in Python folder or https://pypi.org/project/certifi/ and try again.&quot;</span>)</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    exit_with_error(<span class="string">&quot;aborted by user, exiting&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> file_name</span><br></pre></td></tr></table></figure>

<p>大致一看能看明白逻辑，如果 download_even_if_exists &#x3D; True 那么无论包是否已经存在都要安装，否则为 False 就只安装不存在的包，我们需要为 False。</p>
<p>搜索函数名查看在哪里使用了这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:1411</span></span><br><span class="line"></span><br><span class="line">received_download_target = download_file(url, download_dir, <span class="keyword">not</span> KEEP_DOWNLOADS, filename_prefix)</span><br></pre></td></tr></table></figure>

<p>这个 KEEP_DOWNLOADS 是一个环境变量，默认为0，我们需要他为1，传入函数的参数则为0（False），即已存在文件不再重复下载。</p>
<p>在终端输入 <code>./emsdk --help</code> 可以看到提示信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment:</span><br><span class="line">      EMSDK_KEEP_DOWNLOADS=1     - if you want to keep the downloaded archives.</span><br><span class="line">      EMSDK_NOTTY=1              - override isatty() result (mainly to log progress).</span><br><span class="line">      EMSDK_NUM_CORES=n          - limit parallelism to n cores.</span><br><span class="line">      EMSDK_VERBOSE=1            - very verbose output, useful for debugging.</span><br></pre></td></tr></table></figure>

<p>也就是说只要安装时单独指定此变量值为1即可。</p>
</li>
<li><p>第二步就是如何下载文件了。下载什么文件？放到哪个目录下？</p>
<p>这里大家可以通过 download_file 的 print debug 调试来查看他校验文件是否存在是去哪里校验的，我就不再具体展开讲调试步骤了，结论就是：他在 emsdk&#x2F;downloads&#x2F; 目录下先查找一下待下载的压缩包是否存在，那么我们复制报错信息中的 url 下载文件到这个 downloads 文件夹下即可（没有就新建）。</p>
</li>
</ol>
<h2 id="solution">具体步骤</h2>

<ol>
<li><p>首先要安装所缺的所有包，一个个安装，报错信息里提示什么安装什么。比如文章开头的报错信息中下载链接是：<a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2%EF%BC%8C%E5%B0%B1%E5%85%88%E5%AE%89%E8%A3%85%E8%BF%99%E4%B8%AA%E3%80%82">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2，就先安装这个。</a></p>
<p>node: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>wasm-binaries: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>安装完成后要重命名 b90507fcf011da61bacfca613569d882f7749552-wasm-binaries.tbz2。</p>
</li>
<li><p>移入 emsdk&#x2F;downloads 文件夹下，不用解压。</p>
</li>
<li><p>执行 <code>EMSDK_KEEP_DOWNLOADS=1</code> 变量赋值。</p>
</li>
<li><p>执行 <code>./emsdk install latest</code>  。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jingqing3948@jingqing:~/Webassembly/emsdk$ ./emsdk install latest</span><br><span class="line">Resolving SDK alias &#x27;latest&#x27; to &#x27;3.1.44&#x27;</span><br><span class="line">Resolving SDK version &#x27;3.1.44&#x27; to &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;</span><br><span class="line">Installing SDK &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;..</span><br><span class="line">Skipped installing node-16.20.0-64bit, already installed.</span><br><span class="line">Skipped installing releases-b90507fcf011da61bacfca613569d882f7749552-64bit, already installed.</span><br><span class="line">All SDK components already installed: &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;.</span><br></pre></td></tr></table></figure>

<p>好哎，看来是自己单独安装的文件包都可以用，他会自己解压文件包后提示 All SDK components already installed。</p>
<p>接下来就是下一步：<code>./emsdk activate latest</code>.</p>
<p>最后是 <code>source ./emsdk_env.sh</code> 配置好环境变量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：RFID"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ARFID/"
    >北邮国院笔记：RFID</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ARFID/" class="article-date">
  <time datetime="2023-07-24T23:00:00.000Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要围绕提纲里的所有问题展开，没有拓展内容，Exam oriented Study。</p>
<p>关注微信公众号：灰海宽松，回复 “RFID” 可获取本文pdf格式。</p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h2 id="Comparison-of-different-automatic-identification-technologies"><a href="#Comparison-of-different-automatic-identification-technologies" class="headerlink" title="Comparison of different automatic identification technologies"></a>Comparison of different automatic identification technologies</h2><p>首先明确一下比较对象。human identification（cost too high）是人力识别就不用说了。</p>
<p>fingerprint identification: </p>
<ul>
<li>stability 稳定，精确度高；</li>
<li>high speed, 快速匹配；</li>
<li><strong>security issues</strong>: 容易被复制。</li>
</ul>
<p>face recognition:</p>
<ul>
<li>easy to be influenced by surroundings, hair, age…</li>
</ul>
<p>speech recognition:</p>
<ul>
<li>easy to use and accept by user;</li>
<li>not involve privacy;</li>
<li>due to international standards, is hard to promoting</li>
</ul>
<p>1d barcode:</p>
<ul>
<li>limit storage capacity, 点线组合少;</li>
<li>need to combine with database;</li>
<li>barcode size is large;</li>
<li>poor fault tolerance, 本来就需要摄像头可见，如果被污损遮挡很容易就无法识别;</li>
</ul>
<p>2d barcode recognition:</p>
<ul>
<li>larger storage capacity;</li>
<li>high information density;</li>
<li>powerful fault tolerance;</li>
<li>support for encryption 容量大了就支持更多编码解码等安全措施了。</li>
</ul>
<p>rfid：</p>
<ul>
<li>low cost;</li>
<li>low power consumption;</li>
<li>high accuracy;</li>
<li>non-contract, fast speed; 不用接触（哪怕是visual，薄纱条码）</li>
<li>certain computing and storage capabilities;</li>
</ul>
<p>主要考虑各个的缺点，人脸和声音特征点多速度慢，而且人脸容易被影响，声音由于国际标准技术难以提升；条码需要视觉可见；指纹容易被盗取。</p>
<h2 id="The-main-features-of-RFID"><a href="#The-main-features-of-RFID" class="headerlink" title="The main features of RFID"></a>The main features of RFID</h2><ul>
<li><p>Non-contact automatic and rapid identification 快速薄纱复杂的人脸和声音，无接触薄纱条码和指纹</p>
</li>
<li><p>Permanently store a certain amount of data 永久存储一定量数据</p>
</li>
<li><p>Simple logical processing 其包含的简单逻辑电路允许做一定的逻辑处理，比如安全协议、算法</p>
</li>
<li><p>Reflection signal strength is affected by the distance  and other factors significantly 信号受到距离，读写器功率，其他信号，其他标签的干扰</p>
</li>
<li><p>Low cost, can be deployed at a large scale</p>
</li>
</ul>
<h2 id="Constraints-of-RFID-technology"><a href="#Constraints-of-RFID-technology" class="headerlink" title="Constraints of RFID technology"></a>Constraints of RFID technology</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687019780697.png" alt="1687019780697"></p>
<h2 id="Core-technologies-of-RFID"><a href="#Core-technologies-of-RFID" class="headerlink" title="Core technologies of RFID"></a>Core technologies of RFID</h2><p>Anti-collision mechanism：rfid并不支持传统的cmsa&#x2F;ca无线通信协议，需要采取一些措施防碰撞（reader-reader, tag-reader, tag-tag)</p>
<p>Efficient information storage, retrieval and mining: 尽量节能的信息存储，检索，挖掘</p>
<p>Make full use of the attenuation laws of backscatter signal to assist in positioning and mobile behavior sensing: 我们知道rfid信号会随着距离衰减。反之我们也可以利用这一点来定位物体位置和移动行为感知。</p>
<p>Security certification and privacy protection: 如何利用逻辑门电路校验安全性。</p>
<h2 id="The-advantage-of-RFID-in-IoT-and-the-development-trend"><a href="#The-advantage-of-RFID-in-IoT-and-the-development-trend" class="headerlink" title="The advantage of RFID in IoT, and the development trend"></a>The advantage of RFID in IoT, and the development trend</h2><p>充电方式：Backscatter, small node and indefinitely time of endurance. but rely on reader, one to many centralized communication 利用无线电 ratio signal 充电的方式</p>
<p>ptp communication: 建立 channel awareness technologies 使得支持被动点对点通信来建立分布式系统</p>
<p>Combine with Sensors: 开发更多应用方式。</p>
<p>RFID and IoT:</p>
<ul>
<li>embed intelligence in the physical object, so that simple physical objects can also “say”. </li>
<li>allows a physical object to be uniquely identified in a way similar to the “IP address” of a computing node in the Internet. </li>
<li>provides a low-cost communication way to achieve effective communication between nodes. </li>
<li>makes the physical objects in a passive environment achieve “passive intelligence“, providing fundamental guarantee for the “thing-thing connection”</li>
</ul>
<h1 id="2-Identification"><a href="#2-Identification" class="headerlink" title="2. Identification"></a>2. Identification</h1><p>简单说RFID就是物体上贴tag，用reader上的antenna去读取，这三个是主要组成。</p>
<h2 id="Reader’s-function"><a href="#Reader’s-function" class="headerlink" title="Reader’s function"></a>Reader’s function</h2><p>Energy supply: 比如有的标签自身不带能量需要reader提供信号中蕴含的能量</p>
<p>Communication: 最基本的功能，和tag识别，通信</p>
<p>Security Assurance: 比如加密解密</p>
<p>扩展功能：比如自组网 ad-hoc, 管理天线 antenna management 中间件接口 interface of middle components 连接外设 connecting peripherals</p>
<h2 id="Reader’s-classification"><a href="#Reader’s-classification" class="headerlink" title="Reader’s classification"></a>Reader’s classification</h2><p>按频率：LF HF算低频，UHF和SHF算高频（ultra super)，高频数据传输速度快，距离远，但是衰减快 signal attenuation，收到障碍物影响大  sensitive to obstacles。</p>
<p>按外观：</p>
<ul>
<li>Fixed 固定有线的，高度集成，快速启动 set up</li>
<li>portable 可移动的像手持手机一样，small, charging battery, easy to move</li>
<li>Industrial 为工厂目的而生，比如集成其他 sensor</li>
</ul>
<h2 id="Influencing-factors-of-R-W-range"><a href="#Influencing-factors-of-R-W-range" class="headerlink" title="Influencing factors of R&amp;W range"></a>Influencing factors of R&amp;W range</h2><p>许多东西都有说明书，规范，来提醒我们怎么不把东西玩坏比如手机提示不要放水里玩。</p>
<p>RFID的R&amp;W range是其中一种。影响因素如下：</p>
<ul>
<li><p>The way that antenna is coupled 天线耦合方式，比如把两个天线绑一起太近互相干扰。</p>
</li>
<li><p>The output power of the reader’s RF signal 功率，太低可能无法激发tags</p>
</li>
<li><p>The frequency of RF carrier signal 合适的频率</p>
</li>
<li><p>Antenna direction 天线，读取器天线和标签天线极性方向 polarization 相匹配时识别范围最大</p>
</li>
<li><p>Operation environment condition</p>
</li>
<li><p>Movement speed of tags</p>
</li>
</ul>
<h2 id="Reader’s-components-and-their-functions"><a href="#Reader’s-components-and-their-functions" class="headerlink" title="Reader’s components and their functions"></a>Reader’s components and their functions</h2><p>Signal Processing and Control Module: 主要是控制功能，协调一些本地计算</p>
<ul>
<li>Communicate with upper computer,  and execute command from it</li>
<li>Control communication process with tags</li>
<li>Encode and decode signal</li>
<li>Perform anti-collision algorithm</li>
<li>Encrypt and decrypt the data  transferred between reader and tag</li>
<li>Identity certification between reader and tag</li>
</ul>
<p>Inductively Coupled RF Module: 主要是产生能量和调制发送信号功能</p>
<ul>
<li>Generate high frequency send energy, activate RF tags and  provide energy (passive RF tags) </li>
<li>Modulate signal to sent,  transferring data to RF tags</li>
<li>Receive and demodulate RF signal  from RF tags.</li>
</ul>
<h2 id="Tag’s-functions"><a href="#Tag’s-functions" class="headerlink" title="Tag’s functions"></a>Tag’s functions</h2><ul>
<li>data storage</li>
<li>energy harvesting 吸收能量，与reader的 energy supply 对应</li>
<li>contactless with R&amp;W 不用接触就能通信，与 reader 的 communication with tags 对应</li>
<li>Security Encryption 与 reader 的 Security Assurance 对应</li>
<li>Collision Concessions 碰撞让步</li>
</ul>
<h2 id="Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability"><a href="#Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability" class="headerlink" title="Tag classification: by package form, by power source, by work frequency, by R&amp;W capability"></a>Tag classification: by package form, by power source, by work frequency, by R&amp;W capability</h2><p>Package form 也就是外观上的分类：</p>
<ul>
<li>card-like</li>
<li>label-like</li>
<li>Implantable, 比如动物植物体内</li>
<li>Accessories-like 附件类标签，比如纽扣型的，这一类主要是方便携带</li>
</ul>
<p>By Power Source 按能源供应方式分类：</p>
<ul>
<li>active 自己有电池供电</li>
<li>passive 依靠 carrier signal 读取器发来的载波信号获取能量</li>
<li>semi-passive 有电池作为后备隐藏能源，平时主要是passive 方式</li>
</ul>
<p>By Work Frequency</p>
<p>LF HF UHF。UHF读写性能，距离最好，更多会使用 active 型。</p>
<p>By R&amp;W Capability</p>
<p>read-only 和 R&amp;W 两种，结构复杂度也有所不同</p>
<h2 id="Two-work-modes-of-RFID-middleware"><a href="#Two-work-modes-of-RFID-middleware" class="headerlink" title="Two work modes of RFID middleware"></a>Two work modes of RFID middleware</h2><p>interactive, independent。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618045820043.png" alt="image-20230618045820043"></p>
<p>交互模式大概就是一直接收主机的命令，你让我读我就读，读完把结果还给你。</p>
<p>独立模式是可以不接收主机命令自行按预设的程序和读取到的结果信息循环执行指令，并将结果返回给主机。</p>
<h1 id="3-Wireless-Communication-Principle-of-RFID"><a href="#3-Wireless-Communication-Principle-of-RFID" class="headerlink" title="3. Wireless Communication Principle of RFID"></a>3. Wireless Communication Principle of RFID</h1><h2 id="Different-work-principles-of-different-carrier-frequency"><a href="#Different-work-principles-of-different-carrier-frequency" class="headerlink" title="Different work principles of different carrier frequency"></a>Different work principles of different carrier frequency</h2><p>不同频率载波也适用不同的工作原则。</p>
<p>前面已经有所涉及，比如LF HF适用于近距离，UHF SHF适合远距离。</p>
<p>前者适用 Inductively Coupled RF Module 电感耦合，通过感应方式获取能量。</p>
<p>后者适用 Electromagnetic Backscatter Coupled RF Module 电磁反向散射耦合，持续不断发送射频信号来供给能量。backscatter 指的是接收机信号调制后通过发送机天线产生可被识别的信号。</p>
<p>两者的能量消耗都和距离平方成正比 squared distance</p>
<h2 id="Signal-voltage-and-energy-dB-dBm，重点：如何计算"><a href="#Signal-voltage-and-energy-dB-dBm，重点：如何计算" class="headerlink" title="Signal voltage and energy: dB, dBm，重点：如何计算"></a>Signal voltage and energy: dB, dBm，重点：如何计算</h2><p>变化的电压通常用 $V(t)&#x3D;v_0cos(\omega t)$ 表示。</p>
<p>功率P&#x3D;VI&#x3D;V^2&#x2F;R这不用多说。平均功率 $&#x3D;\frac{v_0^2}{2R}$ 很简单推因为正余弦平均就是&#x2F;根2.</p>
<p>相对变化 The relative change，这是一个比较新鲜的而且信号变化中比较重要的指标。</p>
<p>$G_{dB}&#x3D;10log_{10}\frac{P2}{P1}$ </p>
<p>参考功率 referenced power $dBm&#x3D;10log_{10}\frac{P}{10^{-3}}$</p>
<p>dBm单位是功率的W，GdB单位是dB，代表一个比值。</p>
<h2 id="Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0"><a href="#Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0" class="headerlink" title="Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0"></a>Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0</h2><p>一些阅读器通过调制使得正弦电压信号携带信息的方法。</p>
<p>OOK：on off keying，高功率1低功率0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036831437.png" alt="1687036831437"></p>
<p>问题在于，低功率0的部分标签没法被激活，也无法正常工作。也就是说0信号标签压根启动不了，没法接收0信号。</p>
<p>PIE解决方法：长高功率是1，短高功率是0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036892748.png" alt="1687036892748"></p>
<p>然后涉及到tags对reader发来的信号进行解码。空间中的信号发过来是有方向的矢量叠加，tags如何通过编码机制识别信号？</p>
<p>FM0编码方式：位窗起始处翻转信号表示1，中间翻转表示0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687037382818.png" alt="1687037382818"></p>
<p>FM0属于 FSK frequent shift key 通过信号变化频率来识别的机制。</p>
<h2 id="Link-budget-重点"><a href="#Link-budget-重点" class="headerlink" title="Link budget (重点)"></a>Link budget (重点)</h2><p>Link budget: forward link budget  and backward link budget 发射过程中能量增减的总和</p>
<p>reader transmit energy(+) path loss(-) tag activate energy(-)</p>
<ul>
<li>pass loss: 读取器天线向360度的发送能量。其中只有一部分区域可以被tags antenna读取到，这一部分被称作 Effective  Aperture (Ae) of the tag antenna。能量&#x3D;有效面积*密度 $P_t&#x3D;\rho A_e$ 。总共发送的能量比收到的能量就等于总表面积比有效面积 $\frac{P_{TX}}{P_{RX}}&#x3D;\frac{A_e}{4\pi r^2}$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618174327976.png" alt="image-20230618174327976"></p>
<p>来看上例，发送方30dBm对应1W，tag接收到-10dBm对应10^-4W. 然后5dB的衰减到-15dBm。这个5dB衰减就是两个dBm做差得到的。</p>
<p>所以，dBm相当于对功率P的另一种衡量方式，为什么这么麻烦的要用log来表示？因为两个dBm的差值就是分贝（放大系数），所以由一个dBm能量转到另一个只需要加减两者间差的分贝即可，很方便。</p>
<p>从tags反射回来的信号 reflection link 和路径四次方成反比 inversely proportional. $P_{RX,back}:\frac{1}{r^4}$</p>
<h2 id="Antenna-gain-and-polarization-EIRP"><a href="#Antenna-gain-and-polarization-EIRP" class="headerlink" title="Antenna gain and polarization, EIRP"></a>Antenna gain and polarization, EIRP</h2><p>antenna gain: 输入条件相同情况下，实际情况某一点能量密度&#x2F;理想条件下的密度单元。反应了天线 concentrates the input power 的能力。就比如把阅读器放中间，标签围一圈，360度去读取周围标签对能量消耗就大，可能因此传输距离也近；但是如果把标签集中放在一块区域，周围放置的 reader 利用定向天线 Directional antenna，固定读取某一个角度范围内的tags能量利用效率就高。</p>
<p>Polarization：事物在一定条件下发生极化 polarization，使得其表现的和原有状态不一样  its properties deviate from the  original state。</p>
<p>EIRP, Equivalent Isotropic Radiated Power: 天线在所指方向上获得最大增益效果 maximum gain effect 所需要的能量。</p>
<p>For example, FCC regulations in the United States, a non-irradiated  transmitter can transmit 1W of energy signals, and can use 6dBi antenna; antenna gain increased by 1dB, transmission energy needs to  be reduced by 1dB. In fact, FCC is not more than  36dBm(30dBm+6dBi).</p>
<h2 id="Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式"><a href="#Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式" class="headerlink" title="Effects of antenna gain，重点：分析 link budget，几个计算公式"></a>Effects of antenna gain，重点：分析 link budget，几个计算公式</h2><p>directional gain: radiation density of one direction d &#x2F; average value in all direction</p>
<p>power gain: radiation efficiency of that direction G</p>
<p>平面角：单位rad，比如圆周180度单位角&#x3D;2pi rad</p>
<p>立体角：单位sr，比如球面立体角&#x3D;4pi sr</p>
<p>能量增益G的计算方法是4pi&#x2F;立体角大小。比如波束宽度72°也就是2pi&#x2F;5大概是1.25rad， $G&#x3D;\frac{4\pi}{1.25^2}$</p>
<p>dipole antenna: 垂直于轴沿各个方向发送信号，比全向天线 omnidirectional antenna 小2.2dB。</p>
<p>Effective aperture $A&#x3D;G\frac{\lambda ^2}{4\pi}$</p>
<p>$P_{RX}&#x3D;P_{TX}G_{RX}G_{TX}(\frac{\lambda}{4\pi r})^2$</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619104251622.png" alt="image-20230619104251622"></p>
<p>$R_{forward}&#x3D;\frac{\lambda}{4\pi}\sqrt{\frac{P_{TX,reader}T_bG_{reader}G_{tag}}{P_{min,tag}}}$</p>
<p>$R_{reverse}&#x3D;\frac{\lambda}{4\pi}\sqrt[4]{\frac{P_{TX,reader}T_bG_{reader}^2G_{tag}^2}{P_{min,reader}}}$</p>
<h1 id="4-Tag-Identification-Protocol"><a href="#4-Tag-Identification-Protocol" class="headerlink" title="4. Tag Identification Protocol"></a>4. <strong>Tag</strong> Identification Protocol</h1><h2 id="Checksum-procedure-parity-checks-LRC-CRC"><a href="#Checksum-procedure-parity-checks-LRC-CRC" class="headerlink" title="Checksum procedure: parity checks, LRC, CRC"></a>Checksum procedure: parity checks, LRC, CRC</h2><p>奇偶校验不多说，查1的个数，poor error recognition。电路通过所有位异或是偶校验，结果为1说明有错误；再取反是奇校验。</p>
<p>LRC longitudinal redundancy check (LRC) procedure 循环冗余检测，所有字节进行异或运算，得到的结果是LRC校验码。也就是说数据发送到终点后，所有字节（数据和LRC）进行字节异或运算结果应该为0. 也有一些错误无法纠正，主要用于小的数据块校验。</p>
<p>CRC (cyclic redundancy check) procedure</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142701838.png" alt="1687142701838"></p>
<p>接收方计算原数据+CRC数据拼接起来的CRC数据值，应该为0. 不能纠错，不过检错效率很高。</p>
<h2 id="ASK-FSK-PSK"><a href="#ASK-FSK-PSK" class="headerlink" title="ASK, FSK, PSK"></a>ASK, FSK, PSK</h2><p>amplitude Shift Keying: 幅度调制，y轴上的调制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142836442.png" alt="1687142836442"></p>
<p>计算方法2：duty factor: $m&#x3D;1-\frac{u_1}{u_0}$</p>
<p>$U_{ASK}(t) &#x3D;(m·u_{code}(t)+1−m)·u_{HF}(t)$</p>
<p>Frequency shift keying: 频率上的改变。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143205258.png" alt="1687143205258"></p>
<p>Phase shift keying: 频率相位翻转180.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143252934.png" alt="1687143252934"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143276722.png" alt="1687143276722"></p>
<h2 id="Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags"><a href="#Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags" class="headerlink" title="Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags"></a>Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags</h2><p>Compared with the reader, limited by hardware resources, tags have very limited storage capacity and computing. </p>
<p>标签受制于硬件资源，存储容量和计算能力都不高。</p>
<h2 id="TDMA-FDMA-CSMA"><a href="#TDMA-FDMA-CSMA" class="headerlink" title="TDMA, FDMA, CSMA"></a>TDMA, FDMA, CSMA</h2><p>首先主要有两种方式，一个是reader broadcast 广播到诸多 tags，一个是多个 tags Multi-access 每个tags单独访问reader。</p>
<p>TDMA FDMA是multi-access, CSMA是broadcast</p>
<p>FDMA: 多个频率通道 several frequency channels 传输数据。</p>
<p>TDMA: </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619212501183.png" alt="image-20230619212501183"></p>
<h2 id="ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程"><a href="#ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程" class="headerlink" title="ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程"></a>ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程</h2><p>Pure ALOHA algorithm：收到成功确认 ack 后就不再发送。否则一直随机等待后继续发送。简单但是通道利用率 channel utilization 低，poor performance.</p>
<p>offered load G：单位时间 tau 里同时发送的应答器数量</p>
<p>s-aloha: 规定时间片 slot，一个时间片只能发一次，冲突就下一次时间片去发。channel utilization 几乎是 pure 的两倍。</p>
<p>$S &#x3D; G × e^{-G}$ G&#x3D;1最大</p>
<p>frame S-ALOHA: 规定一个周期 frame，包含若干个 slots，会更加有组织有秩序。reader 广播一个 frame length，tags 自己选择组织时间片（0~f-1），每个时间片开始 reader 轮询一下tag里sn信号是不是0，是0就发送，不是0就-1.</p>
<p>conflict slot, single slot, idle slot（空）</p>
<p>逻辑，电路设计，内存都比较简单，但是 frame length 长度不固定。tags 远远多于 frame length 冲突时间片就太多，tags 太少空时间片太多太浪费。负载 G&#x3D;1 也就是 length&#x3D;tags 利用率最好。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620001137399.png" alt="image-20230620001137399"></p>
<p>DFSA：利用以前的 frame 冲突反馈结果，和一些机器学习算法推测合适的 frame length。</p>
<p>EPC Global（第五章介绍）规范里使用了一种Q算法。简单说就是如果冲突太多了，当前 frame 就别继续了，中断，新开一个大容量 frame. 同理 空闲太多了就新开一个小 frame。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620002424045.png" alt="image-20230620002424045"></p>
<p>Qfp是指定的初始值。每次先取整，然后发起 query。</p>
<p>没有回复：Qfp-C C是一个参数，比如0.1.</p>
<p>有冲突&gt;1：+C。注意有上下限。</p>
<p>ALOHA 算法公平。<strong>但是可能发生饥饿</strong> ，比如有一个 tag 每次都是有冲突的 slot，一直没有办法被处理。</p>
<h2 id="Binary-tree-based-protocols-BT-QT-重点：执行过程"><a href="#Binary-tree-based-protocols-BT-QT-重点：执行过程" class="headerlink" title="Binary tree based protocols: BT, QT, 重点：执行过程"></a>Binary tree based protocols: BT, QT, 重点：执行过程</h2><p>第二种算法，基于二进制数。就像二叉树不断拆分冲突的结点变为两个结点，直到节点里只有一个 tag。</p>
<p>random binary tree BT：随机。</p>
<p>binary query tree QT：排序，查询。</p>
<p>每一个 tag 需要有一个计数器来记录自己的状态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620003431357.png" alt="image-20230620003431357"></p>
<p>每一个tag都会被识别，不会饥饿，但是需要存储每个tag的状态。</p>
<p>比如看下面的例子：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620004226401.png" alt="image-20230620004226401"></p>
<p>首先 tag1234 随机选一个数，比如选了0010，SN分别加自己选的数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010150624.png" alt="image-20230620010150624"></p>
<p>找SN&#x3D;0的，发现有是有，但是他们几个都冲突了。那么继续分，比如1011，SN&#x3D;1021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010254069.png" alt="image-20230620010254069"></p>
<p>2的SN&#x3D;0而且不冲突，把2读取了之后2不再继续参与。然后当有tag读取后，所有其他SN-&#x3D;1</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010408026.png" alt="image-20230620010408026"></p>
<p>&#x3D;0的是14，但是他俩冲突。然后再重新划分一下，比如011, SN&#x3D;0021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010452073.png" alt="image-20230620010452073"></p>
<p>然后处理1，其他-&#x3D;1，处理4，其他-&#x3D;1，处理3.</p>
<p>QT 不需要存储状态，如何实现？读取tag的序列号比较。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010802734.png" alt="image-20230620010802734"></p>
<p>不会饿死，也不需要一个可以读写的cnt，识别的时间和 tag id 有关。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011058481.png" alt="image-20230620011058481"></p>
<h2 id="Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程"><a href="#Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程" class="headerlink" title="Binary search: Manchester code instead of NRZ code, 重点：执行过程"></a>Binary search: Manchester code instead of NRZ code, 重点：执行过程</h2><p>具体分辨哪一位有冲突。1代表冲突。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011804411.png" alt="image-20230620011804411"></p>
<p>NRZ混合没法检测错误。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011902936.png" alt="image-20230620011902936"></p>
<p>曼彻斯特可以，一个上升一个下降，合起来是0或者1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011942870.png" alt="image-20230620011942870"></p>
<p>查询的流程：</p>
<ul>
<li>request：发送一个序列号给tags的transponder，如果tags的序列号小于给定序列号返回。</li>
<li>select：给定一个特定序列号，返回等序列号的tag。</li>
<li>read_data：返回所选tag的信息。</li>
<li>unselect：读取完data了，这个tag退出选择流程。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620012706251.png" alt="image-20230620012706251"></p>
<p>第一次迭代：返回uplink是所有transponder的id的共同信息（通过曼彻斯特编码找出没有冲突的位）。046位冲突了（从右往左），8个可能。</p>
<p>第二次迭代：限定 bit6 为0的request。发现有3个还是冲突04位（最高位冲突位&#x3D;0，其他冲突位&#x3D;1，如果range是大于等于，则正好相反）。</p>
<p>第三次迭代：限定bit4为0的request……</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620013603192.png" alt="image-20230620013603192"></p>
<p>长度 L(N)&#x3D;log2(N)+1</p>
<h2 id="Dynamic-binary-search-重点：执行过程"><a href="#Dynamic-binary-search-重点：执行过程" class="headerlink" title="Dynamic binary search, 重点：执行过程"></a>Dynamic binary search, 重点：执行过程</h2><p>Binary Search 是每次都传输完整二进制字符串. 其实我们只需要动态改变的部分.</p>
<p>比如我们查询1010 1111 1111, 那返回值前面一定是1010呀, 就不用传输了. 前缀叫 NVB, Number of Valid Bits</p>
<p>每次请求发送的信息: Request+NVB&#x3D;4+1010</p>
<h2 id="Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of ALOHA based anti-collision algorithm"></a>Advantages and disadvantages of ALOHA based anti-collision algorithm</h2><p>simple</p>
<p>good identification performance</p>
<p>results can be statistically analyzed 结果可以被统计化分析</p>
<p>缺点就是可能 starvation 饥饿，delay trend to ∞</p>
<h2 id="Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of binary tree based anti-collision algorithm"></a>Advantages and disadvantages of binary tree based anti-collision algorithm</h2><p>simple</p>
<p>intermediate state variables 不需要存储中间状态变量（QT）</p>
<p>缺点：查询时间受到 tags id 和 长度限制，比如二叉树沿着一个方向一直偏。</p>
<h1 id="5-EPCglobal-Standard-protocol"><a href="#5-EPCglobal-Standard-protocol" class="headerlink" title="5. EPCglobal Standard &amp; protocol"></a>5. EPCglobal Standard &amp; protocol</h1><h2 id="Concept-of-EPC-global-network"><a href="#Concept-of-EPC-global-network" class="headerlink" title="Concept of EPC global network"></a>Concept of EPC global network</h2><p>EPCglobal Network: a technology that </p>
<ul>
<li>allows trading partners to document and determine the location of individual goods </li>
<li>if possible in real time</li>
<li>additional information: such as 生产使用日期，能否被贸易伙伴交换</li>
</ul>
<h2 id="Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network"><a href="#Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network" class="headerlink" title="Five basic services of EPC global network, interaction of different components of EPCglobal network"></a>Five basic services of EPC global network, interaction of different components of EPCglobal network</h2><p>Electronic product code (EPC)</p>
<p>The identification system</p>
<p>EPCglobal Middleware</p>
<p>Discovery Service (DS)</p>
<p>EPC Information Services (EPCIS)</p>
<p>EPC码是唯一标识对象的代码。识别系统包括对象上的可被读取的包含EPC码的transponder和读取器reader可以识别EPC，然后通过EPCglobal Middleware传到网上，通过DS在 EPCglobal network 查找EPC码的相关信息（包括object naming service）。可以通过EPCIS和其他贸易伙伴交换EPC相关信息。</p>
<p>这其中的交互：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619112053963.png" alt="image-20230619112053963"></p>
<p>transponder and reader : data acquisition</p>
<p>Middleware</p>
<p>Discovery services</p>
<p>EPC Information Services : access to EPC-related data</p>
<h2 id="EPC-code-组成"><a href="#EPC-code-组成" class="headerlink" title="EPC code 组成"></a>EPC code 组成</h2><p>Domain Manager Number + Object Class Number + Serial Number</p>
<h2 id="Basic-procedures-of-the-EPC-Network"><a href="#Basic-procedures-of-the-EPC-Network" class="headerlink" title="Basic procedures of the EPC Network"></a>Basic procedures of the EPC Network</h2><p>EPC码用于标识对应对象</p>
<p>all information about the object 在EPCGlobal Network里注册 administer</p>
<p>each company in the EPCglobal Network: 各个公司管理数据集和数据对象</p>
<p>access rights to object data: 包含在EPCIS里，指明了trading partners 之间访问权限</p>
<ol>
<li><p>the manufacturer：把transponder和product绑定</p>
</li>
<li><p>all data assigned to the product：在EPCIS里</p>
</li>
<li><p>EPCIS registers the entries with EPC Discovery Services：注册了DS之后方能找得到EPCIS</p>
</li>
<li><p>product：卖给零售商 retailer</p>
</li>
<li><p>At the retailer’s goods-in point 数据存储在零售商EPCIS中</p>
</li>
<li><p>registered by EPCIS with EPC Discovery Services </p>
</li>
<li><p>The company prefix send to root EPCIS</p>
</li>
<li><p>root -&gt; local -&gt; the EPCIS</p>
</li>
</ol>
<h2 id="Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0"><a href="#Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0" class="headerlink" title="Binary tree based variant algorithm for EPCglobal Class 0"></a>Binary tree based variant algorithm for EPCglobal Class 0</h2><p>这种tag是只读的，制造商赋值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687148304873.png" alt="1687148304873"></p>
<h2 id="EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs"><a href="#EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs" class="headerlink" title="EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs"></a>EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs</h2><p>EPC C1G1：查询tags EPC的一种标准。</p>
<p>被动标签，支持kill和lock两种操作。</p>
<p>pingID：掩码，用于查询tag EPC</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197150310.png" alt="1687197150310"></p>
<p>EPC C1G2 有 OSI 的七层模型，两条数据链路（R-T）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197271532.png" alt="1687197271532"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687198440696.png" alt="1687198440696"></p>
<p>上电 ready</p>
<p>发 query 命令，aribtrate 仲裁。选择随机数生成时间片。</p>
<p>slot&#x3D;0 的开始 reply </p>
<p>tag 发 ack 给 reader，acknowledged 状态。</p>
<p>tag 收到 reader 的命令后进入 open，校验后进入 secured，完成 killed。</p>
<p>4个识别 tags 的命令：Select command, Query command, QueryRep command, QueryAdjust command</p>
<p>select 指明要查哪些 tags 的集合。</p>
<p>query 启动新的识别过程。</p>
<p>Rep 开启下一轮 slot 查询，标签 SN–，到0时读取。</p>
<p>Adjust 调整时隙数，选择新的时隙计数器等。</p>
<p>两大性能问题：</p>
<ul>
<li>Build a set of tags involved in the recognition process，如何建立正确的tags集合来查询（select 和 query 负责）</li>
<li>Select the way of data encoding, for the readerto-tag, the tag-to-reader, the reader itself and the  tag itself 根据环境调整编码方式</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RFID/" rel="tag">RFID</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：Microprocessor 微处理器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/14/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMicroprocessor%20%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"
    >北邮国院笔记：Microprocessor 微处理器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/14/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMicroprocessor%20%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="article-date">
  <time datetime="2023-07-13T23:00:00.000Z" itemprop="datePublished">2023-07-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要围绕提纲里的所有问题展开，没有拓展内容，Exam oriented Study。</p>
<p>关注微信公众号：灰海宽松，回复 “微处理器” 可获取本文pdf格式。</p>
<h1 id="Introduction-随便聊"><a href="#Introduction-随便聊" class="headerlink" title="Introduction-随便聊"></a>Introduction-随便聊</h1><p>嵌入式系统是什么？专用的计算机系统。为专门功能可能对计算机架构，外设等做出一些取舍。</p>
<p>通常的限制：Cost（比如大量部署传感器节点），Size and weight limits（特定应用场景，比如下水道流量检测系统，需要体积小的节点），Power and energy limits（比如部署在极端环境下，喜马拉雅山顶采集节点，不方便去充电），Environment（防水，防高温等）</p>
<p>MCU MPU两种嵌入式系统区别：focus on 控制 还是 处理。控制比如点灯，机械臂，电机这些都是。处理比如摄像头采集到的数据进行图像处理。</p>
<p>编程语言：靠近计算机底层，主要使用汇编和c。</p>
<p>OS：嵌入式系统里不一定有操作系统结构。操作系统这个东西说白了就是更好地帮助管理计算机资源调度用的。现在我们来分析一下我们lab2的代码主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//background</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IRQ_Handler</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//interrupt handler function, frontground</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台部分：一个循环，重复去执行要做的任务。</p>
<p>这种方法乍一看也没啥问题。但是想想这样的计算机能做什么，只能按顺序执行一遍又一遍所有任务，甚至没法变顺序。</p>
<p>前台部分：中断处理，我们lab2里的uart_rx_isr函数，一般也用IRQ_Handler（实际上如果对lab2里的uart_rx_isr溯源一下，就会发现其实他也是被IRQ_Handler调用的，这个方法在启动对应中断时，触发中断就会自动调用）。</p>
<p>前后台合起来的系统还是一个裸机无os系统，只不过加了中断之后允许我们用中断的任务去打断后台轮询，改变一下执行顺序。比如串口中断发个数过来，CPU把手头后台的事情放下，去处理一下前台中断，处理完了再回来。</p>
<p>我们课程仅限于裸机开发的内容。</p>
<h1 id="计算机系统简要介绍"><a href="#计算机系统简要介绍" class="headerlink" title="计算机系统简要介绍"></a>计算机系统简要介绍</h1><h2 id="Von-Neumann-Architecture"><a href="#Von-Neumann-Architecture" class="headerlink" title="Von Neumann Architecture"></a>Von Neumann Architecture</h2><p>运算器控制器 (合在CPU中) 存储器 main memory 输入设备输出设备 IO，以及三条传输总线：数据，控制，地址 data bus &#x2F; control bus &#x2F; address bus.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686650488954.png" alt="1686650488954"></p>
<p>前面介绍过MPU重点在于数据计算处理，MCU则是控制，因此MPU不需要一些外设去控制外接的组件。</p>
<h2 id="Harvard-Architecture"><a href="#Harvard-Architecture" class="headerlink" title="Harvard Architecture"></a>Harvard Architecture</h2><p>和冯诺依曼区别就是在于指令和数据分开存储。这样寻指取指取数效率高。</p>
<h2 id="Stored-Program-Concept"><a href="#Stored-Program-Concept" class="headerlink" title="Stored Program Concept"></a>Stored Program Concept</h2><p>主要两个部分：RAM存储程序和数据，ROM存储不变只读的程序和数据。</p>
<p>cpu执行指令就是三个步骤的重复执行：fetch decode execute 取指解码执行</p>
<h2 id="assembly"><a href="#assembly" class="headerlink" title="assembly"></a>assembly</h2><p>如果高级语言相当于人话翻译给计算机，汇编语言相当于计算机语言翻译给我们。更贴近底层，因此运行效率也更高，而且可以直接操作硬件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD r3, r1, r2 	;r3 = r1 + r2</span><br><span class="line">SUB r3, r0, r3 </span><br><span class="line">MOV r2, r1 		;r2 = r1</span><br></pre></td></tr></table></figure>

<p>; 是注释。变量r123是寄存器register，是可以操纵硬件的部分，我们可以通过对其赋值来操作硬件。</p>
<p>高级语言通过 compiler 翻译为汇编语言，汇编语言通过 assembler翻译为二进制机器语言。</p>
<h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h1><p>ARM是一个指令集，前面讲的几个汇编指令这些都算做指令。</p>
<p>ARM公司有意思的地方是，他们不做ARM设备，他们只设计指令集架构，然后授权（知识产权核，IP核）给其他半导体厂商做。</p>
<p>A：application，主打高性能，手机电脑有许多就是ARM架构的。</p>
<p>R：realtime，主打实时，比如车联网对实时性要求很高。</p>
<p>M：microcontroller，应用于小型嵌入式系统，我们使用的板子。</p>
<p>m系列有m0到m7（简单说就是性能逐渐增加？），而且向下兼容即m7兼容m0~m6.</p>
<h2 id="SoC"><a href="#SoC" class="headerlink" title="SoC"></a>SoC</h2><p>我们的板子上有一个黑色的小芯片，上面写着stm32blabla一串字符。这个就是整个板子的核心，相当于囊括了上文提到的计算机架构的芯片结构，system on chips。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686658267695.png" alt="1686658267695"></p>
<p>设计soc规则：首先选用IP核，设计ARM处理器，外加一系列存储、IO外设结构，全部集成在黑芯片上。</p>
<p>ARM处理器 processor 是 architecture 的具体涵盖，多了很多新内容比如定时器。</p>
<p>我们主要学习m4架构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686658682835.png" alt="1686658682835"></p>
<p>只看非optional大概了解即可，处理器核访问代码，数据接口。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>前面我们已经简单介绍了register。事实上如果想对内存中数据做处理，也要先拿到处理器核中的寄存器里做运算，然后返回回去。</p>
<p>arm register 如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686659016141.png" alt="1686659016141"></p>
<p>通用寄存器：临时变量，可以存储计算数据之类的。</p>
<p>SP：栈顶指针寄存器，指向栈顶。</p>
<p>LR：函数返回用，保存返回地址。比如要调用函数了，把PC的值存入LR，然后PC跳转到函数起始位置；函数返回的时候LR的值还给PC。</p>
<p>PC：指向程序当前执行到的位置（下一个要执行的指令的地址）程序计数器。每条指令取了之后PC自动加一条指令，比如32位指令集PC+&#x3D;4B。</p>
<p>PSR系列是状态寄存器，指明当前程序状态。比如当前是用户模式还是内核模式？IPSR指明当前是否允许中断？等。</p>
<p>xPSR包括：</p>
<ul>
<li>APSR：计算用，如标志是否进位，结果是否为0，是否为负，是否溢出等。</li>
<li>IPSR：中断处理相关。</li>
<li>EPSR：执行相关，指明指令集，中断是否继续等信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686659814546.png" alt="1686659814546"></p>
<h2 id="Memory-Map"><a href="#Memory-Map" class="headerlink" title="Memory Map"></a>Memory Map</h2><p>m4有4g的内存空间默认映射到一片空间中，用户也可以根据自己喜好修改。有存储代码的code region，存储数据的sram region，存储外设的peripheral region，external ram region，external device region，Internal Private Peripheral Bus (PPB)。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686669411390.png" alt="1686669411390"></p>
<h2 id="Bit-band-Operations"><a href="#Bit-band-Operations" class="headerlink" title="Bit-band Operations"></a>Bit-band Operations</h2><p>位带操作。</p>
<p>如果我们要读写32位数据中的某一位，比如第三位（从左往右是31:0，第三位是右边第4个），有的寄存器允许我们直接获取r[3]，但是大多数是不允许直接获取的。</p>
<p>如何处理？如果写入1，那么r|0000 0000 0000 0000 0000 0000 0000 1000.</p>
<p>如果写入0，那么 r &amp; 1111 1111 1111 1111 1111 1111 1111 0111.</p>
<p>读取：看 r &amp; 0000 0000 0000 0000 0000 0000 0000 1000 结果是否为0.</p>
<p>这样很麻烦，比如我们要给0x2000 0000处的数据第3位写1，详细汇编代码：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232342659.png" alt="image-20230613232342659"></p>
<p>LDR是把后面的数据加载到前面的寄存器中，[R1]是把R1的值当做一个地址，取得其中存储的数据。</p>
<p>这样挺麻烦的，但是因为有内存映射我们可以直接写入和获取“位带别名地址”中的数据。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232721037.png" alt="image-20230613232721037"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232713587.png" alt="image-20230613232713587"></p>
<p>0x2000 0000处的第0位到第31位分别是：</p>
<p>0x2200 0000</p>
<p>0x2200 0004</p>
<p>0x2200 0008</p>
<p>0x2200 000c……</p>
<p>0x2200 007c</p>
<p>所以直接获取，修改0x2200 000c的数据即可。</p>
<p>0x2000 0000映射到0x2200 0000是 sram 区域映射，0x4000 0000映射到0x4200 0000是外设 peripheral 区域映射。</p>
<p>操作更快，指令更少，而且只访问一位更安全，比如刚取出0x2000 0000的32位数据，这时候中断修改了0x2000 0000的数据，这时我们取得的数据就是旧的错误数据了，修改完第3位再写回去，相当于中断白改了。</p>
<h2 id="Program-Image"><a href="#Program-Image" class="headerlink" title="Program Image"></a>Program Image</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686670722574.png" alt="1686670722574"></p>
<p>vector：向量表，存储比如main堆栈的地址（MSP），异常的地址等信息。</p>
<p>start-up：板子上电或rst时的启动代码。</p>
<p>program code：我们烧进去的程序代码。</p>
<p>c lib code：库函数代码。</p>
<p>复位时，先读取 msp 地址找到 main 在哪。然后读取 reset vector 执行 BIOS 初始化代码，再开始读取第一条，第二条指令……</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686670972039.png" alt="1686670972039"></p>
<h2 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h2><p>两种存储规范。</p>
<p>比如十进制数字，1234，一千二百三十四。然后我们记录到数据库中，地址从低到高存储为4321，权值大的位1存在地址最高处，这就是大端存储 Big endian。否则，权值大的位存在地址低处，1234地址从低到高，就是小端存储 Little endian。m4两种方法都支持。</p>
<blockquote>
<p>术语“little endian(小端)”和“big endian(大端)”出自Jonathan Swift的《格列佛游记》（Gulliver’s Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。</p>
<p>一下是Jonathan Swift在1726年关于大小端之争历史的描述：</p>
<p><em>“……下面要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由Blefuscu的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”（此段译文摘自网上蒋剑锋译的 《格列佛游记》第一卷第4章。）</em></p>
<p>在他那个时代，Swift是在讽刺英国（Lilliput）和法国（Blefuscu）之间的持续的冲突。Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了.</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/316347205">大端、小端基础知识 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="Instruction-Set"><a href="#Instruction-Set" class="headerlink" title="Instruction Set"></a>Instruction Set</h2><p>指令集。早期arm指令集32位，性能好能实现的功能强大。但是太长了处理效率低。</p>
<p>thumb-1 指令集16位，处理效率高了，性能也降了。早期arm架构如果是支持两种指令集的，就要频繁切换模式，效率低。</p>
<p>后来thumb-2指令集包含早期16位和新的32位，和arm指令集的混合指令集性能没减太多，代码量和处理效率还高了。</p>
<h1 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h1><p>汇编语法。</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">label							; 可省略，用于跳转到此位置</span><br><span class="line">	助记符 operand1, operand2, … ; Comments</span><br><span class="line">	</span><br><span class="line">MOV r1, #0x01					; 数据0x01放入r1</span><br><span class="line">MOV r1, #&#x27;A&#x27;					; 数据A的ascii码放入r1</span><br><span class="line">MOV R0, R1 						; move R1 into R0</span><br><span class="line">MOVS R0, R1 					; move R1 into R0, 并且更新APSR的状态</span><br><span class="line"></span><br><span class="line">LDR R1, [R0]					; R0存的是一个地址值如0x2000 0000, 这个指令是取出R0代表的地址中的数据存入R1</span><br><span class="line">STR R1, [R0]					; 写回去</span><br><span class="line">LDR R0, =0x12345678 			; Set R0 to 0x12345678</span><br><span class="line">; 等效于：</span><br><span class="line">; LDR R0, [PC, #offset] </span><br><span class="line">; ...</span><br><span class="line">; DCD 0x12345678</span><br><span class="line">; 也就是先在文档末尾的一条指令里写入数据0x12345678，然后编译器自动计算PC+多少offset到达DCD的位置，把其值返给R0</span><br><span class="line">; DCD是声明一个字 32bit，DCB是声明一个Byte</span><br><span class="line">; 如果多个数值的声明可以用标签声明</span><br><span class="line">LDR R3, =MY_NUMBER</span><br><span class="line"></span><br><span class="line">ALIGN 4 ; 字要先用这个声明，代表停止长度</span><br><span class="line">MY_NUMBER DCD 0x2000ABCC</span><br><span class="line">HELLO_TEXT DCB “Hello\n”, 0 ; Null terminated string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDRB R1, [R0]					; B: 只写8位，就是说R0地址处的数据写入R1后，R1高24位清零</span><br><span class="line">SDRH R1, [R0]					; H: 只写16位</span><br><span class="line"></span><br><span class="line">LDRSH R1, [R0]					; 视作signed有符号数，写16位</span><br><span class="line"></span><br><span class="line">LDRB R0, [R1, #0x3]				; 从R1+3读取一个字节给R0</span><br><span class="line">LDR R3, [R0, R2, LSL #2]		; 从R0+（R2&lt;&lt;2)读取一个字节给R3</span><br><span class="line">LDR R0, [R1], #4				; 赋完值后，令R1=R1+4</span><br><span class="line"></span><br><span class="line">ADD R0, R0, R1</span><br><span class="line">ADDS R0, R0, R1					; 加完更新APSR状态，比如有溢出或者进位则更新</span><br><span class="line">ADC R0, R1, R2					; R1+R2还要+APSR的carry位</span><br><span class="line"></span><br><span class="line">; SUB SBC类似</span><br><span class="line"></span><br><span class="line">MUL R0, R1, R2</span><br><span class="line">UDIV R0, R1, R2</span><br><span class="line">SDIV R0, R1, R2					; signed</span><br></pre></td></tr></table></figure>

<p>例题：应该是因为有可能减成负的所以signed</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686672985123.png" alt="1686672985123" style="zoom:50%;" />

<p>指令有1字长，半字长的。hw1是指明功能用的，hw2是一些拓展比如立即数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686713591015.png" alt="1686713591015"></p>
<p>地址从低到高分别是：4F F0 0A 00 0A 68 10 44……</p>
<p>PC每次取到半个字 hw，就+2B跳转到下一个hw。</p>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	CMP R0, R1						; 相当于if，比较后更新APSR。EQ= LT&lt; GT&gt; LE&lt;= GE &gt;=</span><br><span class="line">	BEQ BRANCH_1					; B是跳转，BL是跳转到函数执行完后返回，BX是根据地址最低位判断目标地址是arm还是thumb在决定跳转到整字还是半字。bx操作数不能是立即数，必须是寄存器</span><br><span class="line">	B BRANCH_2</span><br><span class="line">	</span><br><span class="line">BRANCH_1</span><br><span class="line">	...</span><br><span class="line">	B IFEND							; 不写这个就继续执行BRANCH_2了，像switch的break</span><br><span class="line">BRANCH_2</span><br><span class="line">	...</span><br><span class="line">B IFEND</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WHILE_BEGIN </span><br><span class="line">	UDIV R2, R0, R1 ; R2 = n / x</span><br><span class="line">	MUL R3, R2, R1 ; R3 = R2 * x</span><br><span class="line">	CMP R0, R3 ; n == (n / x) * x</span><br><span class="line">	BEQ WHILE_END</span><br><span class="line">	SUBS R1, R1, #1 ; x--</span><br><span class="line">	B WHILE_BEGIN ; loop back</span><br><span class="line">WHILE_END</span><br></pre></td></tr></table></figure>

<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>内存中有一片内存空间类似栈的数据结构。SP指针指向栈顶。</p>
<p>这个栈地址是从高到低的，也就是存入数据 SP–，取出数据 SP++，类似一个翻转过来的，倒着的书堆。</p>
<p>满堆栈：sp指针指向最后一个栈顶数据。</p>
<p>空堆栈：指向最后一个数据的下一个要放入数据的空位置。</p>
<p>我们的课程中使用空堆栈，指向下一个空位置，存数据就先存入再SP-4，取数据就先SP+4再出栈。不过这两条指令都不需要我们手动执行，有专门的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0, R4-R7&#125; 	; Push r0, r4, r5, r6, r7</span><br><span class="line">POP &#123;R2-R3, R5&#125; 	; Pop to r2, r3, r5。入栈出栈顺序不是按照书写顺序而是自动根据寄存器地址，高地址值给高地址寄存器</span><br></pre></td></tr></table></figure>

<p>存入5个数据和取出3个数据。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>BL先保存当前PC值到LR，然后PC跳转到函数地址，</p>
<p>BX LR跳转到LR中的地址用于函数返回。</p>
<p>Architecture Procedure Call Standard (AAPCS) ：规范定义哪些寄存器主函数和函数通用，哪些是独有的。</p>
<p>arm AAPCS规定：r0-r3是通用寄存器（类似全局变量），但main和函数的R4 – R8, R10-R11不通用（类似临时变量，到了函数里这些值就变了，不是原函数的），要压入栈保存。函数调用和返回的时候要保存和恢复通用寄存器值。这些由调用原函数的子函数 callee-procedure 执行。</p>
<p>简单的参数的函数调用：传参给R0-R3作为函数参数，R4-R11压入栈，然后跳转到函数处。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686733381292.png" alt="1686733381292"></p>
<h2 id="Program-Memory-Use"><a href="#Program-Memory-Use" class="headerlink" title="Program Memory Use"></a>Program Memory Use</h2><p>ROM里都是只读数据，比如常量常数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686733480351.png" alt="1686733480351"></p>
<h2 id="const-static-volatile"><a href="#const-static-volatile" class="headerlink" title="const, static, volatile"></a>const, static, volatile</h2><p>貌似是不会过多涉及具体代码实现的部分，就先简单介绍一下了。</p>
<p>const 就是定义常量变量，定义后无法再次修改。</p>
<p>static 通常定义静态函数，静态函数里的值是通用的，也就是每次调用该函数其值都是接着上次调用该函数的值继续。</p>
<p>volatile：一个在嵌入式里挺重要的东西，软考题里出现过几次。大概就是禁止编译器优化该变量来防止不必要的错误。</p>
<p>比如编译器优化num变量，这样每次修改num变量的值的时候都不会立刻写入内存中，可能会先把修改时的值写入寄存器，函数返回时写回内存。</p>
<p>现在比如我们在main中num+&#x3D;5, 修改值后的num暂时存在寄存器里。然后我们调用中断，从内存中读取当前num的值并+1.但是内存中值还没改，还是原值。返回后，main再把自己手中的num值写回内存，最后内存中num值只+5，而不是我们期望的+6.</p>
<p>volatile 声明后的变量不会做这样的优化，值改变了就立刻写回内存，虽然可能效率低但是安全。</p>
<h1 id="Interrupts"><a href="#Interrupts" class="headerlink" title="Interrupts"></a>Interrupts</h1><p>比如我们程序的逻辑是按键按下的时候点亮小灯。第一种做法是 Polling 轮询，一直看：按键按下了吗？没有。按下了吗？没。按下了吗？……</p>
<p>这样主要是效率低浪费CPU资源，如果为了节约资源轮询间隔大了，又不能及时响应。</p>
<p>中断允许CPU专心处理background的事情，触发中断的时候先放下后台处理前台。对于无os的裸机也能实现简单的多线程切换。</p>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><ol>
<li><p>结束当前正在执行的指令。</p>
</li>
<li><p>当前模式寄存器值压栈保存。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230614171134845.png" alt="image-20230614171134845"></p>
</li>
<li><p>切换模式。</p>
</li>
<li><p>PC LR更新（根据异常处理器提供的值）。PC去查中断向量表，看要跳到哪里，EXC_RETURN Code赋值给LR。</p>
</li>
<li><p>更新IPSR状态。</p>
</li>
<li><p>开始执行异常代码。</p>
</li>
<li><p>退出，BX LR把 EXC_RETURN Code 值返回给PC。</p>
</li>
<li><p>出栈。</p>
</li>
</ol>
<h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h2><p>中断执行也是耗时的，需要一定的时间保存源程序状态，执行中断，恢复。</p>
<p>FMax_Int：最大中断执行频率，即：单位时间内最多执行几次中断。</p>
<p>F_CPU：CPU频率，即：单位时间内CPU有多少次指令周期。</p>
<p>C_ISR：执行中断内容需要多少周期。</p>
<p>C_Overhd：中断保存、恢复数据等准备工作用多少周期。</p>
<p>中断一次执行所需周期：C_Overhd+C_ISR</p>
<p>因此， $F_{Max_Int&#x3D;}F_{CPU}&#x2F;(C_{ISR}+C_{Overhd})$</p>
<p>U_int：中断处理实际消耗的利用率，上面那个毕竟是最大值。</p>
<p>$U_{int}&#x3D;F_{Int}&#x2F;F_{Max_Int}$</p>
<p>中断执行速度（和频率一样）：F_Int</p>
<p>非中断执行速度：(1-U_Int)*F_Int</p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><p>General Purpose Input Output, </p>
<h2 id="Memory-Mapped-IO"><a href="#Memory-Mapped-IO" class="headerlink" title="Memory-Mapped IO"></a>Memory-Mapped IO</h2><p>把设备，控制等寄存器映射到内存里。好处就是访问设备方式和内存一样，也不用设计复杂的IO电路，便捷；缺点在于占用了内存空间。</p>
<h2 id="Peripheral-Mapped-IO"><a href="#Peripheral-Mapped-IO" class="headerlink" title="Peripheral-Mapped IO"></a>Peripheral-Mapped IO</h2><p>IO有一块专门的存储区域，和内存不一样，也有专门的不同的电路指令去访问IO。好处就是节省内存空间，也能清晰的知道什么时候发生IO了；缺点在于开发、设计上的造价增加。</p>
<h2 id="GPIO-1"><a href="#GPIO-1" class="headerlink" title="GPIO"></a>GPIO</h2><p>通用IO可以判断引脚高低电平，可以给引脚赋值高低电平进行控制。</p>
<p>stm32有几组GPIO，每个有16个Pin，可以配置为input output pullin pullup等模式，以及定时器、串口、中断等功能。</p>
<p>什么是上下拉模式？如果不设置为上下拉，引脚浮空的时候（没有设置输入为高或低电平的时候）浮空引脚可能收到电磁波干扰等等问题导致输入状态不确定，有0有1的，容易造成错误。</p>
<p>下拉：三极管控制默认接地，无输入的时候默认低电平。</p>
<p>上拉：三极管控制默认接Vdd 芯片工作电压。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686742220470.png" alt="1686742220470"></p>
<p>大多数引脚是这两个功能都有的，我们初始化GPIO的时候选用一个，寄存器根据值控制接通相应电路。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230614193552367.png" alt="image-20230614193552367"></p>
<p>输入输出信号真的可以被称为“信号”。输入规定为0-0.5视作低电平，0.5-Vdd视作高电平，范围以外的值无效。输出电流也只有5mA左右是没有能力直接驱动一些设备的，我们可以通过一些电路比如三极管，放大器等，电路接收到信号得知”需要输出驱动电流了“然后输出大电流。</p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p>每个GPIO口有：</p>
<p>4 * 32bit configuration registers: 配置相关信息，比如in&#x2F;out，上啦下拉，开漏输出或推挽输出，输出频率等。</p>
<ul>
<li>推挽输出 push-pull：能输出高低电平。</li>
<li>开漏输出 open-drain：没有能力输出高电平，想输出高电平需要设置上拉电路来输出。</li>
</ul>
<p>2 * 32bit data registers: 输入输出数据寄存器。</p>
<p>1 * 32bit set&#x2F;reset registers: 设置或复位寄存器。</p>
<p>1 * 32bit locking registers: 锁定寄存器。</p>
<p>2 * 32bit alternate function selection register.</p>
<h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>如图，32个Pin，每个两位来设置4种模式（in out 可选 模拟）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743308300.png" alt="1686743308300"></p>
<h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>只有3种模式（无pull，上拉，下拉）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743360055.png" alt="1686743360055"></p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>输入输出数据寄存器分开的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743538223.png" alt="1686743538223"></p>
<h2 id="CMSIS"><a href="#CMSIS" class="headerlink" title="CMSIS"></a>CMSIS</h2><p>先说一下考试定义：</p>
<p>CMSIS transforms memory mapped registers  into C structs </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT0 ((struct PORT*)0x2000030)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686747214412.png" alt="1686747214412"></p>
<p>再说一下和一些嵌入式前辈讨论的理解，以下内容不许考试写：</p>
<blockquote>
<p>李肯老师：arm-M推出的一系列API和软件组件，包括核心功能、DSP库、RTOS支持和调试接口等。</p>
<p>李肯老师：如果芯片厂不想再多一层，CMSIS就够用；但有的厂商会再在上面封一层，可能叫driver层。</p>
<p>李肯老师：另外CMSIS有个限定，就是ARM的ARM Cortex-M处理器；虽然它很常见，但并不是所有的处理器都是这个内核；这个需要注意。</p>
<p>榊：这种与内核相关的文件，比如启动文件，内核文件是CMSIS规定。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/a6953d9ebb72f2ecd6cc4dbf569d406.png" alt="a6953d9ebb72f2ecd6cc4dbf569d406"></p>
<p>榊：对比STM32F103和GD32E23的启动文件，我们会发现是一样的：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/711dd8daa73cb3dd198e50f32f6f86a.png" alt="711dd8daa73cb3dd198e50f32f6f86a"></p>
<p>榊：而芯片厂商要做的是根据这个arm规定的接口二次开发库函数。</p>
</blockquote>
<p>李肯老师c站账号：<a target="_blank" rel="noopener" href="https://blog.csdn.net/szullc">架构师李肯的博客_CSDN博客-程序人生,粉丝福利领域博主</a></p>
<p>榊老师c站账号：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63922192">风正豪的博客_CSDN博客-C语言,MSP430F5529,Linux领域博主</a></p>
<p>平时李肯老师的交流群会讨论很多嵌入式相关问题，欢迎有兴趣的同学来学习[Doge]</p>
<p>以上内容感兴趣的看个乐呵。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">Reset, <span class="comment">//!&lt; Resets the pin-mode to the default value.</span></span><br><span class="line">Input, <span class="comment">//!&lt; Sets the pin as an input with no pull-up or pull-down.</span></span><br><span class="line">Output, <span class="comment">//!&lt; Sets the pin as a low impedance output.</span></span><br><span class="line">PullUp, <span class="comment">//!&lt; Enables the internal pull-up resistor and sets as input.</span></span><br><span class="line">PullDown <span class="comment">//!&lt; Enables the internal pull-down resistor and sets as input.</span></span><br><span class="line">&#125; PinMode;</span><br><span class="line"></span><br><span class="line">gpio_set_mode(P1_10, Input);</span><br><span class="line">gpio_set_mode(P2_8, Output);</span><br><span class="line"><span class="type">int</span> PBstatus=gpio_get(P1_10); </span><br><span class="line">gpio_set(P2_8, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码是老师提供的driver，大意就是选定pin，传入特定参数，即可设置模式，设置输出。</p>
<p>感兴趣可以看看我的这篇文章，如果使用arm定义的cmsis直接去开发也是可以的：</p>
<p><a target="_blank" rel="noopener" href="https://jingqing3948.blog.csdn.net/article/details/130299783">STM32 学习笔记_4 GPIO：LED，蜂鸣器，按键，传感器的使用_灰海宽松的博客-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 控制gpio需要三个步骤：开启rcc时钟，初始化，输入输出函数控制 */</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_0);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>drivers二次开发，可以帮助简化。</p>
<p>当然这一段都是题外话了。考试就理解为“cmsis是变量宏定义直接映射到寄存器上；drivers是对其添加进一步行为”即可。</p>
<h1 id="Serial-Communication"><a href="#Serial-Communication" class="headerlink" title="Serial Communication"></a>Serial Communication</h1><p>串口通信，一种发送消息的通信方式。</p>
<p>串，指的是发数据的方式：一位一位串行发，并行是可能有多路通道，每路同时发一个数据，多路同时到达。</p>
<p>串口通信有单工 Simplex，半双工 Half Duplex，全双工 Full Duplex。</p>
<p>两种传输方式：同步 Synchronous，共用一个时钟；异步 Asynchronous，有各自的时钟。</p>
<p>同步很简单，发送方接收方比如都规定时钟信号下降沿收发。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686749582568.png" alt="1686749582568"></p>
<p>异步：需要通过异步通讯协议 Asynchronous Comm. Protocol 来协调。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686749956698.png" alt="1686749956698"></p>
<p>1位起始位标志开始传输，7&#x2F;8&#x2F;9位数据位，1位可选奇偶校验位，1位停止位。</p>
<p>RT两方需要有相同的波特率。</p>
<p>当然这只是最简单的串口通信因为只有双方。如果更多方通信我们需要校验地址来判断是哪个发给哪个；数据需要更复杂的校验方式。</p>
<p>异步通信不需要同步时钟之类电路，开销小，但是开发起来难度大一些因为需要起始结束位啥的。</p>
<h2 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h2><p>异步通信，Reversed Polarity 标准电压（-3<del>-15是1,3</del>15是0.还有一些其他标准比如TTL是+5为1，-5为0.）</p>
<p>发送数据有两种类型，ascii码和二进制，都得转化为二进制传输。</p>
<h2 id="uart"><a href="#uart" class="headerlink" title="uart"></a>uart</h2><p>针对stm32f401.</p>
<p>全双工异步串口。</p>
<p>为了处理RT缓冲数据（因为发收数据需要时间）我们可以通过缓冲区数组，头指针表示已经发到的位置，尾指针表示要发的数据的结尾。增加新数据，尾指针++；发一个数据，头指针++直到碰到尾。</p>
<p>原来发送方一直是发高电平，start frame 起始帧是1帧低电平来表示开始发数据了。</p>
<p>如何判断是1帧低电平？通过在这一帧里多次采样判断是不是真的是一帧低电平。</p>
<p>为什么多次采样？因为异步两个信号有一定的偏移，多次采样准，能确定是不是真的一整帧都低电平。</p>
<p>采样是有一定采样率的，不是说真的能像模拟信号一样一直采。</p>
<p>采样率 oversampling&#x3D;16: 这个是最大可以达到的采样频率而不是真的一帧采了16次。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686756691253.png" alt="1686756691253"></p>
<p>接收方首先第一次检测到0位，开始怀疑：有可能是串口有消息。这是start frame的第一次采样。</p>
<p>然后每隔一帧检测一次，3 5 7检测3次，如果2个都是0，说明确实有可能。</p>
<p>然后连着检测8910，如果还是2个0，说明确实是start frame。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686756881390.png" alt="1686756881390"></p>
<p>8采样率因为采样间隔长了，更容易碰到左右边界的高电平，所以容错率低。但是速度更快。</p>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>波特率计算：</p>
<p>$T_x&#x2F;R_x(baud)&#x3D;\frac{f_{PCLK}}{8*(2-OVER8)*USARTDIV}$</p>
<p>OVER8是过采样率，fPCLK是时钟频率。</p>
<p>USARTDIV是一个浮点数</p>
<p>USARTDIV浮点数怎么存储？通过算法转化为十六进制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686759124660.png" alt="1686759124660"></p>
<p>小数部分用一个16进制位表示，比如例1是C也就是12，转换后即为12&#x2F;16也就是0.75.</p>
<p>例2转换为一位16进制，就是0.62*16约等于10也就是A。</p>
<p>整数部分直接转换十六进制即可，例2的25转为19，例1的27转为1B。</p>
<p>然后整数小数部分拼接起来（最多3个整数位，1个小数位，32位寄存器）。</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>想让程序定时运行，比如led 1s闪烁一次。如何做到？</p>
<p>第一种方法是愚蠢的delay延时，我自己估算一下：嗯，delay(2000)差不多1s。然后在程序中delay，点亮，delay，熄灭……</p>
<p>太浪费资源了。</p>
<p>第二种方法，32是有定时器中断的。</p>
<p>定时器中断大概原理是，32上有时钟晶振按固定频率周期输出0101010……定时器里有一个cnt，收到一个时钟晶振就++。</p>
<p>我们可以设置定时器溢出值，比如溢出值是1000，cnt加到1000会自动触发定时器中断。然后归0，继续++。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230615014136641.png" alt="image-20230615014136641"></p>
<p>执行周期数量：1+1+1+1+(0xFFFFFFFF一直-1-1-1直到变为0x00FFFFFF的循环次数)+(r0+1的执行次数，1次)</p>
<p>定时器也有一些扩展方法，比如我们可以设定++还是–；可以设定信号源是时钟或者外部输入的方波信号；可以读取计数值……</p>
<p><strong>我们课件常用方法好像是–到0触发中断，然后恢复初值。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686764952191.png" alt="1686764952191"></p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>PWM这个东西是什么？</p>
<p>PWM（Pulse Width Modulation）脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域。</p>
<p>就好比说，你骑自行车速度只能是100和0，模拟电信号只能输出高低。</p>
<p>但是呢，你骑自行车是有惯性的，以100速度蹬一脚，以0速度蹬1脚，100速度蹬一脚……</p>
<p>整体来看你的自行车平均速度是50（我们假设加速度不需要时间哈）</p>
<p>这个应用场景有很多，比如设定led闪烁频率：高低高低高低……，因为频率极高，我们肉眼看不出来在闪，给我们呈现的视觉效果就是以一半的亮度在亮。高低低高低低就是1&#x2F;3亮度。</p>
<p>比如电机通过这个方式调速度。</p>
<p>那么他有什么应用场景。第一，输入捕获 Input capture。</p>
<p>对于一个这种有惯性的系统，我们也可以反过来读取其波形来判断其速度。比如电机放一个转速检测传感器，把输入波形作为定时器的时钟源信号，定时器一直++：检测上升下降沿时记录cnt值，通过差值比较计算时间间隔。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230615020829378.png" alt="image-20230615020829378"></p>
<p>第二，输出比较 output compare。</p>
<p>定时器一直++，与预先设定好的阈值比较，如果相等触发中断输出。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686767856060.png" alt="1686767856060"></p>
<p>这就是PWM。占空比相当好算。</p>
<h2 id="Low-Power-Timer"><a href="#Low-Power-Timer" class="headerlink" title="Low Power Timer"></a>Low Power Timer</h2><p>我们目前假设的是CPU一直运作的，只是在后台和前台之间切换。有一种低功耗定时器使得没有发生定时器中断的时候CPU被置为低功耗状态，只有发生定时器中断的时候才启动。（使用 __WFI() wait for instruction 指令）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235021294.png" alt="image-20230621235021294"></p>
<h2 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h2><p>M系列自带的一个系统时钟，使用处理器时钟或者参考时钟作为时钟源。</p>
<p>有四位寄存器：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235527699.png" alt="image-20230621235527699"></p>
<p>每次赋值是load，一直–到0时重新load赋值。ctrl是控制启用系统时钟。这个是CMSIS有提供的数据结构和相关操作函数的时钟处理部分。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235805628.png" alt="image-20230621235805628"></p>
<p>init 参数是中断间隔的毫秒数。timer_set_callback() 里跟一个可以是自己定义的函数，使得触发定时器中断时该函数被执行。以上代码意思是每隔100ms LED灯翻转一次，且 CPU 常态下处于低功耗状态。</p>
<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><p>连接多个模块的传输方案：I2C，使用两根总线。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622000302459.png" alt="image-20230622000302459"></p>
<p>两根总线分别是时钟总线 SCL 和数据总线 SDA。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>现在我们串一遍I2C上一个模块（master）要给另一个模块（slave）发消息的过程。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687363434463.png" alt="1687363434463"></p>
<ol>
<li>MCU 使用一定的方法标识自己开始传输了。</li>
<li>MCU 发送 LCD slave 的地址+一位读写位，其他模块接收到发现地址不是自己的，就不做处理。</li>
<li>LCD 接收到后知道目标是自己，于是返回 ack。</li>
<li>MCU 收到 ACK 后发送一帧数据。</li>
<li>发送完 MCU 等着 ACK，收到 ACK 后继续发送下一帧数据。</li>
<li>一直发送到发送停止位 stop 结束。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622000920336.png" alt="image-20230622000920336"></p>
<p>数据长度可以设置，比如789.</p>
<p>总线上的器件是开漏输出的半双工通信。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713135505107.png" alt="image-20230713135505107"></p>
<p>默认总线是上拉电阻拉成高电平。</p>
<p>当器件输出 out 为低电平时，总线导通到接地，总线被拉低（整条总线都被拉低）。江协科技老师举的例子很好，就像公交车上的一根横杆，有人拉住横杆拽下来，整条横杆都被拉低了，其他人都知道“横杆被一个人拉低了，说明有人正在使用总线”。</p>
<p>然后是总线传输数据的方式，SCL SDA 两根总线在何种情况下表示 start stop 0 1 bit? </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713140225426.png" alt="image-20230713140225426"></p>
<p>首先都是 SCL 为高电平时 SDA 的数值才有意义。</p>
<p>SDA 从高到低，表示 start 位。从低到高，表示 stop 位。</p>
<p>start 位后，SDA 高电平表示1，低电平表示0.</p>
<p>发送完 1byte 数据后，总线保持拉高状态。如果接收方把总线拉低了，发送方发现总线1→0了（不是发送方自己拉的，是接收方给他拉下来的，但是发送方能察觉到），说明接收方成功接收了并且拉了拉总线以示“收到”。如果 SDA 还是保持在高电平，说明接收方没有成功收到或者成功发送 ACK。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713140822834.png" alt="image-20230713140822834"></p>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>I2C 是一种很简单的主从通信协议了，但是局限性也很多，比如7 bit 的地址线只允许 2^7 个设备；一次顶多两个设备主从通信；一个设备的快慢会影响到整条总线的通信等。</p>
<p>问题1：从设备处理速度太慢了，赶不及在下一个时钟周期接收新数据帧怎么办？</p>
<p>方法：clock stretching, 拉低一段时间 SCL 假装下一个时钟周期还没到。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713141906054.png" alt="image-20230713141906054"></p>
<p>问题2：多个设备同时发数据冲突了怎么办？</p>
<p>方法：Bus Aribitation，前面我们知道总线被一个设备拉低了，所有设备都能接收到总线拉低的信号。因此如果两个设备同时开始发信息，前面数据一致都无所谓，等到第一次数据不一致的时候，一个设备发送数据0，一个发送数据1，这时 SDA 总线被 DATA2 的0拉低了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713142029471.png" alt="image-20230713142029471"></p>
<p>发送 DATA1 数据的设备就明白了：有人同时在和我一起发数据，因此总线不是我预期的1而是被他拉低为0了。那我 quit，你发吧。然后就只有 DATA2 发送的数据了。</p>
<p>问题3：以上发送的数据每次都是 1byte 8bits 很正好。那如果要发送的地址不是 8bits 呢？</p>
<p>方法：少于 8bits 用一些固定的额外的 start 位填充，多于 8bits 的地址用两个 bytes，不够的也是用额外的 start 位填充。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143052018.png" alt="image-20230713143052018"></p>
<p>问题3：如果我 master 发完数据，想紧接着再收数据，变成 slave，可行吗？</p>
<p>方法：通过一个 sr 信号，也就是 repeat start 重发 start 位，来标识自己是 read 而不再是 write 了重新开始通信。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143601570.png" alt="image-20230713143601570"></p>
<h2 id="编址格式"><a href="#编址格式" class="headerlink" title="编址格式"></a>编址格式</h2><p>slave 地址编址有一些固定格式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143744619.png" alt="image-20230713143744619"></p>
<p>0000 000 0：广播，对所有 slave 结点讲话。如果 slave 无视（NACK），就不会参与广播。如果返回 ACK 就参与进来了。不过多个 slave 都返回 ACK 的话 master 是不知道都有谁回应了的。</p>
<p>第二个 byte 发送一些行为相关，比如：start，clear，reset software</p>
<h2 id="编程应用"><a href="#编程应用" class="headerlink" title="编程应用"></a>编程应用</h2><p>slave mode: </p>
<ul>
<li>I2C 设备默认工作在 slave mode。</li>
<li>外设时钟在 I2C_CR2 寄存器中编程。频率介于 2kHz~100kHz。</li>
<li>硬件自动等待发过来的 start 和 addr 信息。</li>
<li>如果 addr 信息和  OAR1 中存储的地址相同，说明目标是自己。如果 ACK 位为1，则发送 ack pulse。</li>
<li>设置 ADDR 位，1表示匹配。</li>
<li>如果 ITEVFEN 就是中断事件 flag 为1，则生成中断。</li>
<li>TRA 位标明 slave 是 R 还是 T 模式（收 or 发）。</li>
<li>BTF 位标识收没收完。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689255491311.png" alt="1689255491311"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713214410998.png" alt="image-20230713214410998"></p>
<p>这么说起来还是有点混乱 I2C 到底经历了哪些才顺利发送了数据？</p>
<p>首先，从主模式的概念。master 主模式驱动时钟信号，发起传输；slave 从模式响应传输。</p>
<h2 id="主模式"><a href="#主模式" class="headerlink" title="主模式"></a>主模式</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/Figure-1-4.png" alt="用于主发送数据的 I2C 传输序列图"></p>
<p>发送：</p>
<p>所有 EV 事件都会拉低 SCL，直到相应软件序列执行完成。</p>
<p>S：start 事件。比如CR2 寄存器中设置外设时钟，配置时钟寄存器，上升时钟寄存器，使能 CR1 来启用时钟，CR1 中设置 start 位，等待总线被拉低表示就绪，发送启动信号，并切换为主模式。</p>
<p>EV5：启动事件成功进行，设置 SB 寄存器&#x3D;1. SB 寄存器&#x3D;1后才可以进行地址阶段，执行完地址阶段会自动清除 SB 和 EV5 事件。</p>
<p>Address：地址阶段。传输7位地址+1位读写位，然后等待从机的 ack。收到 ack 进入 EV6.</p>
<p>EV6：设置 addr 位&#x3D;1代表地址阶段顺利执行， master 收到 ack了。清除 EV6 后自动进入 EV8.</p>
<p>EV8：设置 TxE ，准备写入主机要传入的数据。TxE 表示数据寄存器为空可以写入。每次数据写入 DR 都会清空 TxE 和 EV8 事件。写完数据数据传过去了，主机收到 ack 后继续传输。以 BTF&#x3D;1 表示数据传输的结尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_write</span><span class="params">(<span class="type">uint8_t</span> address, <span class="type">uint8_t</span> *buffer, <span class="type">int</span> buff_len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Send in sequence: Start bit, Contents of buffer 0..buff_len, Stop</span></span><br><span class="line">    <span class="keyword">while</span> (((I2C1-&gt;SR2&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>)); <span class="comment">// wait until I2C1 is not busy anymore</span></span><br><span class="line">    I2C_GenerateSTART(I2C1, ENABLE); <span class="comment">// Send I2C1 START condition</span></span><br><span class="line">    <span class="comment">// wait for I2C1 EV5 --&gt; Slave has acknowledged start condition</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));</span><br><span class="line">    <span class="comment">// Send slave Address for write then wait for EV6</span></span><br><span class="line">    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Transmitter);</span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));</span><br><span class="line">    <span class="keyword">while</span> (i &lt; buff_len)&#123;</span><br><span class="line">        I2C_SendData(I2C1, buffer[i]); <span class="comment">// send data then wait for EV8_2</span></span><br><span class="line">        <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_GenerateSTOP(I2C1, ENABLE); <span class="comment">// send stop bit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230714110003657.png" alt="image-20230714110003657"></p>
<p>接收：</p>
<p>前面和 master transmit 都一样。</p>
<p>TxE 改为 RxE 了，&#x3D;1标识接收到了数据。</p>
<p>master 自己设置 stop 事件后（发送 NACK）停止接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_read</span><span class="params">(<span class="type">uint8_t</span> address, <span class="type">uint8_t</span> *buffer, <span class="type">int</span> buff_len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Start bit, Contents of buffer from 0..buff_len, sending a NACK</span></span><br><span class="line">    <span class="comment">// for the last item and an ACK otherwise, Stop bit</span></span><br><span class="line">    I2C_GenerateSTART(I2C1, ENABLE);</span><br><span class="line">    <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); <span class="comment">//EV5</span></span><br><span class="line">    <span class="comment">// Send slave Address for write then wait for EV6</span></span><br><span class="line">    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Receiver);</span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));</span><br><span class="line">    I2C_AcknowledgeConfig(I2C1, ENABLE); <span class="comment">// going to send ACK</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; buff_len - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); <span class="comment">//EV7</span></span><br><span class="line">        buffer[i] = I2C_ReceiveData(I2C1); <span class="comment">// get data byte</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_AcknowledgeConfig(I2C1, DISABLE); <span class="comment">// going to send NACK</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); <span class="comment">//EV7</span></span><br><span class="line">    buffer[i] = I2C_ReceiveData(I2C1); <span class="comment">// get the last byte</span></span><br><span class="line">    I2C_GenerateSTOP(I2C1, ENABLE); <span class="comment">// send stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从模式"><a href="#从模式" class="headerlink" title="从模式"></a>从模式</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689259086166.png" alt="1689259086166"></p>
<p>发送：</p>
<p>start 启动事件由 master 发起。从机校验地址并决定是否发送 ack 位。</p>
<p>EV1：设置 addr 位表示地址匹配。</p>
<p>EV3-1：设置 TxE 位，开始传入数据。一直到主机返回 NACK 表示不想再要数据了，或者 AF&#x3D;1 说明 ack 失败了为止。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689259113895.png" alt="1689259113895"></p>
<p>接收：</p>
<p>前面到 EV1 和 slave transmit 都一样。</p>
<ol>
<li>数据从 DR 寄存器中读。</li>
<li>读入一个 byte 后，如果 ack 位已经设置，则返回 ack 信息。</li>
<li>RxE 位是接收数据的状态寄存器。</li>
<li>主机生成停止条件时停止。</li>
</ol>
<p>异常情况：</p>
<p>总线错误，NACK，仲裁失败，时钟异常超时。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230714110916968.png" alt="image-20230714110916968"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Miprocessor/" rel="tag">Miprocessor</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：瑞萨开发板"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/06/24/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%91%9E%E8%90%A8%E5%BC%80%E5%8F%91%E6%9D%BF/"
    >技术学习：瑞萨开发板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/06/24/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%91%9E%E8%90%A8%E5%BC%80%E5%8F%91%E6%9D%BF/" class="article-date">
  <time datetime="2023-06-23T23:00:00.000Z" itemprop="datePublished">2023-06-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这回参加的是csdn李肯老师的攻城狮计划，简单说就是我白嫖板子，输出学习笔记。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/a3cc9258486e875c183b4fbbb1ce5fbe.jpeg" alt="552ca9fa46d8c1c7f192cdad4d207d4"></p>
<p>板子是瑞萨的CPK_RA2E1，还有触摸元件，看起来很有意思hh。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>一开始决定采取vscode搭建的方式。后期进行到最后一步——cmake build的时候一直显示语法错误，肯哥表示是环境配置不全，但是我反反复复根据官网和其他博主的文章检查了不下10遍都不知道问题何在。最终决定还是老老实实用keil。</p>
<ol>
<li><p>keil导入瑞萨包。官网下载地址：<a target="_blank" rel="noopener" href="https://www.keil.arm.com/vendors/renesas/packs/">Arm Keil | Renesas</a></p>
</li>
<li><p>下载rasc软件。对于这个东西我的理解是类似stm32cubemx，可以快速初始化项目的软件。该软件可以在瑞萨官网下载：<a target="_blank" rel="noopener" href="https://www2.renesas.cn/kr/en/software-tool/ra-smart-configurator">https://www2.renesas.cn/kr/en/software-tool/ra-smart-configurator</a></p>
</li>
<li><p>接下来我们尝试新建编译一个项目。这是我第一次没有跟着一块有完整开发流程的板子的视频课，而几乎完全是自己检索资料探索尝试的项目构建，因此碰到了很多弯路。首先rasc软件我们新建一个项目。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1d1872b93bd272401e7d2a90a943d622.png" alt="项目起名"></p>
<p>板子型号这里是根据我的学习板设置的。IDE一定记得改为keil。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/091c255e2177162e613b3635d9e8128b.png" alt="image-20230601022545320"></p>
</li>
</ol>
<p>后两页选择 no rtos 和 minimal 即可，因为我们现在的目的只是尝试编译通过一个项目。</p>
<ol start="4">
<li><p>添加完成后，点击generate code 生成相关的项目代码。然后用keil打开，尝试编译。</p>
</li>
<li><p>我第一次遇到的问题是报了19个错。我还以为是pack导入的不对，但是后来搜了一下发现不是那么回事，是编译方式选错了。参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20017379/article/details/119523286">keil出现大量未知语法错误（系统移植）_portforce_inline_IT小生lkc的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/73a1e19aee6d2d2b7837c180d17939dc.png" alt="image-20230601022913830"></p>
</li>
<li><p>于是我把编译器改为version5，编译到一半，再次报错：error: A3903U: Argument ‘Cortex-M7.fp.sp’ not permitted for option  cpu’.。这个问题原因是因为编译器版本太低，于是我又去下载了新的keil5.</p>
</li>
<li><p>再次编译的时候提示我，不能用version5，新版本已经不支持了。于是我又改为version6进行编译。这次非常顺利！</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/d34a7cfbf5f7e0bdbb55a0063df5887f.png" alt="image-20230601023151749"></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>终于考完试了，然而攻城狮的截止期限也快到了QAQ，得尽快水（划掉）写几篇文章了！</p>
<p>先争取可以成功下载一个空的程序。</p>
<p>先对上一篇文章下载 DFP 也就是 keil MDK Software Packs 做一个补充。我们要下载的是 RA_DFP，下载地址为：<a target="_blank" rel="noopener" href="https://www.keil.arm.com/packs/ra_dfp-renesas/versions/">Arm Keil | Renesas RA_DFP</a></p>
<p>至于版本我看到有前辈使用 3.5.0 的版本可以成功运行，而我下载的是4+的版本也可以。只不过在选择 device 的时候会有一点不同：<br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622160103209.png" alt="image-20230622160103209"></p>
<p>可以看到 4.1.0 的版本无法细化选择到 R7FA2E1A92DFM，只能选择大类 A9. 不过经过下面的烧录尝试，是没有问题的。</p>
<p>流程：基于上次的空项目，用keil打开，编译，下载成功。</p>
<p>一直到编译的步骤前面都做完了。下载主要需要以下几个步骤：</p>
<ol>
<li>引入项目的 src 文件夹。在 options for target - c&#x2F;c++ 里引入即可很简单。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622154546545.png" alt="image-20230622154546545"></li>
<li>debug 模式设置为 jlink 模式。设置完之后插上板子设置配置，这里因为我的jlink版本太低出现了一个报错：unkown to this version of the jlink software。解决办法就是在官网上下载了一个新版本的jlink（官网链接：<a target="_blank" rel="noopener" href="https://www.segger.com/downloads/jlink%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AF">https://www.segger.com/downloads/jlink，我选择的是</a> windows 版本），下载好后直接会提示“检测到你电脑里的 keil 环境，请问是否更新其 jlink 调试器”，更新后重新启动就没有问题了。</li>
<li>上一步参考文章: <a target="_blank" rel="noopener" href="https://blog.csdn.net/wsq_666/article/details/124367141">keil识别不到芯片，提示unkown to this version of the jlink software_keil识别不到单片机_王小琪0712的博客-CSDN博客</a> 里面也有如果没有提示自动更新 jlink 调试器的选项如何手动进行更新的步骤，建议多多支持原作者。</li>
<li>只是选择了 jlink 调试器也并不算设置完成。如果这个时候点击下载，会提示“找不到 flash”，也就是还没有配置完成，需要设置闪存。首先确保插上了板子，然后打开 jlink 的setting：<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155204869.png" alt="image-20230622155204869"></li>
<li>如果显示下图说明板子被正常识别。如果没有显示这些数据，可能是 jlink 的版本还是过低，或者线坏了，或者还未下载对应 rcsa 包。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155322848.png" alt="image-20230622155322848"></li>
<li>接下来我们配置 flash download. 打开这个页面后点击 add，添加图中所示的这款型号芯片，然后 start 和 size 应该就会自动配置成和图中一样的情形，这样就算成功了。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155451715.png" alt="image-20230622155451715"></li>
<li>点击 load，如果显示如下信息说明成功下载程序。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155546525.png" alt="image-20230622155546525"></li>
</ol>
<p>刚插上板子的时候板子上是有白色的 power 指示灯和一个红蓝交替闪烁灯。下载空程序之后，应该只有电源指示灯还在亮。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/de933bcec619535b3e8b7fe60f61238.jpg" alt="de933bcec619535b3e8b7fe60f61238"></p>
<h1 id="点亮LED"><a href="#点亮LED" class="headerlink" title="点亮LED"></a>点亮LED</h1><p>本文主要参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/oxygen23333/article/details/130306105">【致敬未来的攻城狮计划】— 连续打卡第十一天：FSP固件库开发点亮第一个灯。_嵌入式up的博客-CSDN博客</a></p>
<p>在32阶段我们已经接触过类似做法了。初始化引脚模式（可以手动库函数，或者在工具包图形化界面里配置），设置引脚输出值。</p>
<h2 id="设置-FSP-Smart-Configurator"><a href="#设置-FSP-Smart-Configurator" class="headerlink" title="设置 FSP Smart Configurator"></a>设置 FSP Smart Configurator</h2><p>像上次一样创建一个项目。</p>
<p>首先我们翻一下RA2E1的数据手册看看led在哪。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624005444720.png" alt="image-20230624005444720"></p>
<p>如图所示，一红一蓝，502 501，输出高电平亮。</p>
<p>因此 configurator 里的pin如图所示设置501 502为output initial high</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624005611958.png" alt="image-20230624005611958"></p>
<p>配置完成后点击右上角 generate project content，输出更新配置到该项目中。</p>
<h2 id="Keil代码编写"><a href="#Keil代码编写" class="headerlink" title="Keil代码编写"></a>Keil代码编写</h2><p>接下来就是编写keil里，驱动两个led灯输出高电平的部分了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624011259206.png" alt="image-20230624011259206"></p>
<p>hal_entry.c 是相当于 main.c 的入口函数。其他都是 configurator 提供的配置函数。</p>
<p>引脚设置已经设置好了。我们打开 pin_data.c 可以看到：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624011748710.png" alt="image-20230624011748710"></p>
<p>这就代表确实初始化配置加进代码里了。</p>
<p>然后在 hal_entry.c 里是通过这个 open 函数在 warm_start 里初始化了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624012345948.png" alt="image-20230624012345948"></p>
<p>接下来我们需要一个写入位函数。在 r_ioport.c 里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624012543274.png" alt="image-20230624012543274"></p>
<p>参数1：固定参数，传入 &amp;p_ctrl。</p>
<p>参数2：引脚，老方法 goto the definition</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013133790.png" alt="image-20230624013133790"></p>
<p>参数3：电平。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013206720.png" alt="image-20230624013206720"></p>
<p>然后就简单了，只需要在主函数里调用write函数写亮led。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hal_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> add your own code here */</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				 R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);</span><br><span class="line">				 R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BSP_TZ_SECURE_BUILD</span></span><br><span class="line">    <span class="comment">/* Enter non-secure code */</span></span><br><span class="line">    R_BSP_NonSecureEnter();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013456059.png" alt="image-20230624013456059"></p>
<h1 id="按键模块"><a href="#按键模块" class="headerlink" title="按键模块"></a>按键模块</h1><h2 id="后台轮询"><a href="#后台轮询" class="headerlink" title="后台轮询"></a>后台轮询</h2><p>按键也是一个比较简单的模块，主要是为了学习IO输入模式。</p>
<p>查看RA2E1电路图可见：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624133704709.png" alt="image-20230624133704709"></p>
<p>按键相关引脚是004引脚，默认上拉高电平，按下接地为低电平。</p>
<p>首先第一步还是设置对应引脚。类似上一期设置LED的方式，只不过Mode改为Input mode。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624133750237.png" alt="image-20230624133750237"></p>
<p>设置好之后仍然是记得generate。</p>
<p>然后就是程序编写。首先还是明确一下开发流程。首先我们尝试后台轮询的按键检测。在while里不断检测按键电平，如果为高点亮蓝灯，如果为低点亮红灯。</p>
<p>点亮好写，上一次已经尝试过write函数。那么我们接下来再去看类似的read函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624135423601.png" alt="image-20230624135423601"></p>
<p>第一个参数还是传入固定的&amp;g_ioport_ctrl。第二个是引脚。第三个是存放我们要存储的读取按键的值。比如传入变量state的地址 &amp;state，函数执行结束后state的值就是读取的按键电平。</p>
<p>主函数编写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hal_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bsp_io_level_t</span> state;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> add your own code here */</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			R_IOPORT_PinRead(&amp;g_ioport_ctrl, BSP_IO_PORT_00_PIN_04,&amp;state);</span><br><span class="line">			<span class="keyword">if</span>(state==BSP_IO_LEVEL_HIGH)&#123;</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_LOW);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_LOW);</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BSP_TZ_SECURE_BUILD</span></span><br><span class="line">    <span class="comment">/* Enter non-secure code */</span></span><br><span class="line">    R_BSP_NonSecureEnter();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/8d99e5ae0be2c97e2e2bb44a1ed92f6.jpg" alt="8d99e5ae0be2c97e2e2bb44a1ed92f6"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/59b0f842762bb1349190932bdcb4e74.jpg" alt="59b0f842762bb1349190932bdcb4e74"></p>
<h1 id="活动总结"><a href="#活动总结" class="headerlink" title="活动总结"></a>活动总结</h1><p>一转眼攻城狮计划就已经到了最后一天了。<br>5月我还处在一个迷茫期，那时候刚刚入坑嵌入式，只学了几款电子积木，对整个体系也不是很清楚，也不知道应该学些什么。因为刚刚转到硬件领域，也缺少相关经历和能力证明，科研实习面试都失败了。</p>
<p>一开始得到的少许鼓励来源于C站推荐的一系列交流会活动。我去参加了RTThread的学习营，第一次尝试在单片机开发中加入RTOS系统，也算是跳脱出自己当时缓慢的按部就班学习路线，如井底之蛙般弹出脑袋窥探了一眼外面的风景。</p>
<p>后来偶然收到李肯老师的攻城狮活动邀请。虽然因为选在了期末周，自己又比较懒，基本没更几篇文章hh。但是借助李肯老师的交流活动认识了很多嵌入式领域的前辈，同伴，从每天的交流话题中也能学到很多。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624180328147.png" alt="image-20230624180328147"></p>
<p>现如今，虽然学到的知识相比之前可能没有太多，但是整个系统的框架，从硬件到ISA，操作系统解释器等系统软件，汇编语言和机器语言的转化等……确实见识到了很多。</p>
<p>再聊到本次活动。虽然自己没有做过多的尝试，但是因为之前我也只尝试过51和32的库函数开发，rcsa的configurator配置本身对我来说就是一种新奇的开发模式。与32的hal库对比更能让我体会到这些driver的便捷之处，也开始适应这种开发方式。</p>
<p>非常感谢给予这次机会的李肯老大！也期望自己能保持这股热情继续学下去~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=1357960253&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>