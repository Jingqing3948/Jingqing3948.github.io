<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title> 灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">灰海宽松的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['没有一条路无风无浪', '常应常静，常清净矣', 'Love the Life You Live'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-未来计算的革命：探索存算一体芯片的潜力与挑战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/29/%E6%9C%AA%E6%9D%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E9%9D%A9%E5%91%BD%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/"
    >未来计算的革命：探索存算一体芯片的潜力与挑战</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/29/%E6%9C%AA%E6%9D%A5%E8%AE%A1%E7%AE%97%E7%9A%84%E9%9D%A9%E5%91%BD%EF%BC%9A%E6%8E%A2%E7%B4%A2%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/" class="article-date">
  <time datetime="2024-01-29T00:00:00.000Z" itemprop="datePublished">2024-01-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Embeded-System/">Embeded System</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="未来计算的革命：探索存算一体芯片的潜力与挑战"><a href="#未来计算的革命：探索存算一体芯片的潜力与挑战" class="headerlink" title="未来计算的革命：探索存算一体芯片的潜力与挑战"></a>未来计算的革命：探索存算一体芯片的潜力与挑战</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文学习自：存算一体芯片深度产业报告——作者：量子位</p>
<p>报告链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/557673211">存算一体是啥新趋势？值得教授学者纷纷下海造芯 | 附报告下载 - 知乎 (zhihu.com)</a>，侵删！</p>
<h2 id="存算一体技术概述"><a href="#存算一体技术概述" class="headerlink" title="存算一体技术概述"></a>存算一体技术概述</h2><p>“存算一体”技术的起因在于传统冯诺依曼架构芯片无法满足不断提升的算力与低功耗需求。随着晶体管的体积越来越小，摩尔定律逐渐失效（会引发量子隧穿等反应），导致存储器与处理器之间的数据传输成为 CPU 性能的瓶颈，相对较长时间的数据搬运导致算力受限。</p>
<p>为了解决这个问题，我们需要新的芯片架构。主要有三种解决方式：</p>
<ol>
<li>近存计算：缩短处理器芯片与存储器芯片的距离，减少数据搬运损耗。</li>
<li>内存储计算：处理器和存储器位于同一芯片的不同电路单元中。</li>
<li>内存执行计算：通过在存储器颗粒上嵌入算法，由存储器芯片内部的存储单元完成计算操作。</li>
</ol>
<h2 id="产业分析"><a href="#产业分析" class="headerlink" title="产业分析"></a>产业分析</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20240129171851417.png" alt="image-20240129171851417"></p>
<p>存算一体芯片落地的优势在于在算力提高的同时，芯片体积的减小和数据传输功耗的减少，使得芯片良率、成本、功耗等都有所改善。然而，实际应用的挑战主要在于评估市场需求和客户转换成本。重要的考量是，大规模采用新型芯片是否能够在成本和能耗方面带来足够的改进，以证明其经济效益；新架构芯片的先进生产工艺制造能力；客户对低功耗和高算力的需求；以及封装、测试、工具链、EDA 等相辅相成的产业链生态仍缺乏相应的研发公司。</p>
<p>当下大多数初创公司的思路是先聚焦特定场景，在垂直领域内站稳脚跟后技术外溢到更丰富的应用场景。主要的应用场景包括小算力低功耗场景（知存科技、九天睿芯和闪易半导体等）和大算力场景（千芯科技，后摩智能等）。</p>
<p>目前已知的商业模式主要分为三种：IP授权，定制&#x2F;联合开发以及自主SoC芯片。</p>
<p>当前国内外存算一体技术发展特征如下：</p>
<ul>
<li>成立时间不同会影响技术路线选择，国内外实现产品化的公司数量不多，离规模化还有一定距离</li>
<li>技术路线：大公司选择最容易落地的，初创公司在确保技术先进性基础上选择最容易落地的</li>
<li>国外已形成完整的自研技术链，大规模量产上国内外均未实现突破</li>
<li>不同的业务场景均已呈现出各自的优势，在商业模式上国内外都处在探索阶段</li>
<li>虽然业内尚未形成完整的生态，产业链部分环节已经出现针对存算一体进行技术研发的公司</li>
</ul>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>为了推动存算一体技术的未来发展，重点应放在解决关键技术难题上，并且寻找适合快速应用推广的场景。随着新型存储器技术，尤其是RRAM和MRAM的不断进步，预计将大幅推进存算一体架构的发展。这些技术的应用，尤其是在终端推理和物联网领域，预示着存算一体技术将在这些领域发挥重要作用。为了实现从初步商业化到大规模商业化的转变，技术创新与产业发展必须紧密协同，共同推动这一技术的成熟和应用普及。</p>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>作为一名物联网工程专业的大学生，深入了解存算一体技术让我领略了科技创新的魅力及其在未来应用的广阔前景。虽然我尚缺乏商业模式和产品上市的实践经验，但这次学习经历让我认识到理论与实践结合的重要性，以及跨学科知识对于技术创新的贡献。</p>
<p>通过研究这一技术，我明白了在物联网设备设计中，如何有效融合硬件和软件来提高性能同时降低能耗的重要性。这一认识不仅提升了我的专业技能，也激发了我对如何将技术创新转化为实际应用的深入思考。</p>
<p>此外，我也看到了自己在商业知识和市场分析方面的不足，这提示我在未来的学习中需更多关注这些领域。我期待将这次学习的感悟转化为动力，在未来的学习和工作中不断探索、学习和创新，为智能化世界贡献我的力量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chip/" rel="tag">Chip</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-STM32入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/26/STM32%E5%85%A5%E9%97%A8/"
    >STM32入门——基于野火 F407 霸天虎课程学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/26/STM32%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2023-11-26T00:00:00.000Z" itemprop="datePublished">2023-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Embeded-System/">Embeded System</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博主开始探索嵌入式以来，其实很早就开始玩 stm32 了。但是学了一段时间之后总是感觉还是很没有头绪，不知道在学什么。前前后后分别尝试了江协科技、正点原子、野火霸天虎三次 stm32 的课程学习。江协科技的 stm32f103c8t6 课程看了一段时间，感觉对一些外设的调用方法有一个基础的认知了，但是没有很明白到底在学什么；正点原子则是有点听不懂，半字也借给同学了就有一段时间没学，感觉自认为 stm32 学的有两把刷子了。后来听前辈说江协科技的 stm32 课程不如 51 单片机的质量好，其实课程讲的一般，我就想：是不是应该重新好好学一下 stm32 课程了。</p>
<p>这次选择的是野火的  F407 霸天虎课程，第一是听大家说，入门选野火或者正点最好。第二是野火的大师进阶篇的一些内容，涉及到一些原理等的学习讲解，我觉得对我会非常有帮助，因此正好就买了这款开发板从入门到中级到大师原理一起学习了。</p>
<p>本系列博文笔记主要基于野火相应课程，b站地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vt411X7PK/?spm_id_from=333.337.search-card.all.click&vd_source=05baa16b109824edfe68909895264c33">野火F407开发板-霸天虎视频-【入门篇】_哔哩哔哩_bilibili</a> ，仅供学习参考不做任何商业用途使用，侵删！</p>
<h3 id="调试器介绍"><a href="#调试器介绍" class="headerlink" title="调试器介绍"></a>调试器介绍</h3><p>我选择的是高速版，支持 SW 和 JTAG 两种连接方式。SW 模式则只需要连接 VREF（3V3）, TMS（数据）, TCK, RESET, GND 五个引脚。</p>
<h3 id="程序烧录配置"><a href="#程序烧录配置" class="headerlink" title="程序烧录配置"></a>程序烧录配置</h3><p>芯片型号：STM32F407ZGTX。</p>
<p><strong>DAP 仿真烧录</strong>自然非常简单。</p>
<p><strong>串口一键下载 ISP</strong> 下载速度慢，不能调试，但是成本很低。可以使用 FlyMcu 等软件。</p>
<p><strong>2023.11.2 补充。</strong></p>
<p><strong>警告，建议如果 flymcu 不能烧录，就不要尝试这种玩法了，看看课学学得了。因为我自己乱捣鼓一通后把开发板锁了。</strong></p>
<p><strong>下面的内容我不太清楚具体是哪一步出现了锁死 flash 的问题，总之不要尝试！学习一下理论得啦。</strong></p>
<p><strong>如果和我一样锁死了，请见野火大师篇程序，里面有一个解除写保护的代码，运行一下。</strong></p>
<p>ISP 下载方式：允许我们不拆下芯片来下载。对于上个世纪嵌入式学习来说这是一个很大的突破，因为当时是要把芯片拆下来烧录编程的。</p>
<p>ISP 厂商出产的时候就选定了一种串行外设对芯片内部 FLASH 进行编程，我们不能修改。常用串口下载方式，成本低，但是不能调试仿真。</p>
<p>普通 ISP 需要手动配置 boot loader，一键 ISP 不用，硬件电路和上位机配合达到一键下载的效果（手动配置：00是用户闪存启动，10是系统 SRAM&#x2F;ISP 启动，普通 ISP 要手动改跳线帽）。</p>
<p>一键下载电路的具体原理流程如下：</p>
<ol>
<li>RTS 低电平，Q1 是一个 PNP 三极管，导通，BOOT0 拉高。</li>
<li>DTS 高电平，Q2 NPN 导通，U18 是一个由 EN 控制开关的模拟开关，2 脚被导通为低电平，连接1脚拉低 NRST 复位。程序下载执行。</li>
<li>U18 模拟开关的作用是稳定电路。开发板复位的时候 DTR RTS 是不稳定的状态，如果没有这个模拟开关，DTR RTS 可能进入 ISP 状态，复位，进入 ISP 状态，复位，进入……一直运行不起来了。模拟开关右侧电容使得 VCC 需要花一点时间充电给 EN，而不是立刻激活 EN（EN 1.8V 左右）。这时候 DTR RTS 已经稳定了，可以导通 U18 12 引脚来给 NRST 复位了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698858387784.png" alt="1698858387784"></p>
<p>不过 FlyMcu 实际配置方式是反过来的，因为他的协议是 232（+3<del>+15 是 0，-3</del>-15 是 1），和 TTL（3.3v 是1,0v 是0）正相反。</p>
<p><em>但是实际操作的时候可能遇到一种状况：部分开发板无法使用 FlyMcu 写入。我就碰到了。解决办法是使用 stm32 cube programmer 烧录程序。</em></p>
<p><em>配置如下：开发板上 boot 连接 3v3，RTS DTR&#x3D;0，选中 read unprotect，建立连接后再烧录程序。</em></p>
<p><em>但是不知道是波特率或者校验位的问题，我每次能成功烧录进去，然后过一会就显示断开找不到设备了。可能是因为波特率没有76800的选项。</em></p>
<h2 id="STM32-介绍"><a href="#STM32-介绍" class="headerlink" title="STM32 介绍"></a>STM32 介绍</h2><blockquote>
<p>正点原子网课：单片机和电脑的类比：内存是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SRAM&spm=1001.2101.3001.7020">SRAM</a>，硬盘是 FLASH，主板是外设。</p>
</blockquote>
<p>st：意法半导体公司，SoC 厂商。</p>
<p>m：微控制器。微控制器和微处理器相比性能比较拉一点，主频低，微处理器能跑一些大 os（linux）。</p>
<p>32：32位微控制器。</p>
<blockquote>
<p>正点原子网课：8051，X86 属于 CISC；ARM, MIPS, RISC-V 属于 RISC.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012212735.png" alt="image-20230401221223643"></p>
<p>冯诺依曼和哈佛结构的主要区别：程序存储器和数据存储器是否分开存储。不分开是冯诺依曼，分开是哈佛。哈佛执行效率更高，冯诺伊曼资源占据更少。</p>
<p>CORTEX-M 系列介绍<br>ARM 公司（做精简指令集计算机的）只设计内核架构和授权知识产权，不参与设计芯片，给其他合作公司授权设计芯片。半导体厂商再根据架构完善周边电路并制作芯片。现在95%手机、平板都是 ARM 架构的， ARM 公司是真的牛。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012216885.png" alt="image-20230401221658811"></p>
<p>其优点在于低功耗低成本高性能，且支持16&#x2F;32位双指令集。</p>
<p>ARM 有9个版本，从 v6 开始出现 cortex 的命名。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012219288.png" alt="image-20230401221918218"></p>
</blockquote>
<p>随着需求不断发展，stm32 在一众 8&#x2F;16位 MCU 中脱颖而出。</p>
<p>stm32 自带许多通信接口，如 spi i2c uart 等；扫地机，无人机，手环等都可以是 stm32 的作品。</p>
<p>如何选型？以下是几大类 stm32 的特点。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013709264.png" alt="image-20231102013709264"></p>
<p>本课程学习使用的开发板命名方式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013830412.png" alt="image-20231102013830412"></p>
<p>选型：满足项目需求的前提下，尽可能选便宜的，比如主频低，功耗低，引脚少，flash 少。</p>
<p>引脚分配：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860405030.png" alt="1698860405030"></p>
<p>看手册的重点：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860693691.png" alt="1698860693691"></p>
<p>外设资源，芯片功能，引脚，引脚大致分类，内存，封装……</p>
<p>哎想起前两天面试被问，如果选型 MCU 我应该看哪些因素。我只想到了外设和内存hhh。属于是只会写代码的笨比了。这也是我开始重新看野火课程的原因之一。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>虽然正式编程没有必要用寄存器编程，通常都是库函数或者 hal 库。但是还是有必要学一下原理的。</p>
<h3 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h3><p>芯片视图如下。</p>
<p>丝印：芯片上印的信息。型号，内核，生产批次等。</p>
<p>引脚：左上角是有小圆点的，从左上-左下-右下-右上逆时针看。或者如果没有小圆点，把丝印方向摆正，从左上角开始看。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121423731.png" alt="image-20231102121423731"></p>
<p>芯片内部组成：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121841662.png" alt="image-20231102121841662"></p>
<p>寄存器映射：32位，2^32^&#x3D;4GB，因此所有程序都需要通过内存 4GB 去映射访问。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102122058475.png" alt="image-20231102122058475"></p>
<p>block7：M4 芯片内外设，比如一些通信总线这些都算外设。</p>
<p>block1：内存。</p>
<p>block0：代码。不过实际上由于设计工艺的问题，block0 block1 都只用了很少的一部分来存代码或者作为内存。</p>
<p>外设寄存器放在 block2 中。根据不同块速度不一样，又具体分为不同速度的外设（AHB APB）。</p>
<p>总线速度：AHB&gt;APB2&gt;APB1. APB1 是较低速的外设，包括 I2C UART SPI 看门狗等。</p>
<p>我们想要操作特定的外设，其实就是控制他的寄存器。控制寄存器就要找到寄存器相应的地址往里面写入数据，寄存器地址就是内存中的地址映射。</p>
<p>比如 GPIOF 我们想让其端口全部输出高电平。我们查找 stm32f407 手册，发现 GPIOF 的地址是 0x40021400，GPIOF 的 ODR（output data register）相对起始地址的偏移地址是14，则我们需要给 0x40021414 的地址写入数据 0xFFFF.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102123404182.png" alt="image-20231102123404148"></p>
<p>51 单片机库函数中封装的 reg51.h 中，利用 sfr 定义寄存器地址；而 stm32 库函数中使用宏定义，这些就是寄存器映射操作。<strong>对芯片里一个特殊功能的内存单元起别名的过程就是寄存器映射。</strong> 给这个地址再分配一个地址交重映射，stm32 中不咋常用。</p>
<h3 id="C语言对寄存器的封装"><a href="#C语言对寄存器的封装" class="headerlink" title="C语言对寄存器的封装"></a>C语言对寄存器的封装</h3><p>这样逐个地址，哪怕已经进行了寄存器映射，还是很复杂。</p>
<p>c 语言库函数实际进行的封装操作是使用结构体批量定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIO 外设基地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BASE (AHB1PERIPH_BASE + 0x0000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE (AHB1PERIPH_BASE + 0x0400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_BASE (AHB1PERIPH_BASE + 0x0800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_BASE (AHB1PERIPH_BASE + 0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE (AHB1PERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE (AHB1PERIPH_BASE + 0x1400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_BASE (AHB1PERIPH_BASE + 0x1800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH_BASE (AHB1PERIPH_BASE + 0x1C00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO 寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER; <span class="comment">/*GPIO 模式寄存器 地址偏移: 0x00 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER; <span class="comment">/*GPIO 输出类型寄存器 地址偏移: 0x04 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR; <span class="comment">/*GPIO 输出速度寄存器 地址偏移: 0x08 */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR; <span class="comment">/*GPIO 上拉/下拉寄存器 地址偏移: 0x0C */</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR; <span class="comment">/*GPIO 输入数据寄存器 地址偏移: 0x10 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR; <span class="comment">/*GPIO 输出数据寄存器 地址偏移: 0x14 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL; <span class="comment">/*GPIO 置位/复位寄存器低 16 位部分 地址偏移: 0x18 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH; <span class="comment">/*GPIO 置位/复位寄存器高 16 位部分 地址偏移: 0x1A */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR; <span class="comment">/*GPIO 配置锁定寄存器 地址偏移: 0x1C */</span></span><br><span class="line">	<span class="type">uint32_t</span> AFR[<span class="number">2</span>]; <span class="comment">/*GPIO 复用功能配置寄存器 地址偏移: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 GPIO_TypeDef 把地址强制转换成指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA ((GPIO_TypeDef *) GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB ((GPIO_TypeDef *) GPIOB_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC ((GPIO_TypeDef *) GPIOC_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD ((GPIO_TypeDef *) GPIOD_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE ((GPIO_TypeDef *) GPIOE_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF ((GPIO_TypeDef *) GPIOF_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG ((GPIO_TypeDef *) GPIOG_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH ((GPIO_TypeDef *) GPIOH_BASE)</span></span><br></pre></td></tr></table></figure>

<p>所有外设都是如此，首先定义总线 APB AHB 地址，然后每个外设在其基础上进行偏移，每个外设的不同部分再在该外设基址上进行偏移。</p>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><h3 id="寄存器方式"><a href="#寄存器方式" class="headerlink" title="寄存器方式"></a>寄存器方式</h3><p>要命啊，一看名字我就不想试。寄存器新建不得麻烦死。</p>
<p>哎算了为了学习原理，干了。</p>
<p>我们尝试自己写一个寄存器的库函数来引用。</p>
<p>首先我们需要引用 st 官方启动文件 stmf4xx.s，具体用途后面章节再展开讲解。然后我们自己新建一个 stm32f4xx.h 文件来映射寄存器。不过只是把这个文件包含进项目，编译会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Objects\led_reg.axf: Error: L6218E: Undefined symbol SystemInit (referred from startup_stm32f40xx.o).</span><br></pre></td></tr></table></figure>

<p>进入启动文件后，可以看到这么一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>import 的作用相当于 extern，所以没有找到这个函数的定义，需要我们自己去定义。这就是为什么简单引入了启动文件会报错。</p>
<p>而 __main 是当我们定义了 main() 函数后，编译器会自动链接一些c语言库定义好的函数，用于初始化堆栈并且调用我们的 main().</p>
<p><strong>注意，如果想要生成 __main 函数，必须勾选下面这一项。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102200243099.png" alt="image-20231102200243099"></p>
<p>野火你讲的是真好啊。我之前草草学了学 stm32 单片机用法，比赛的时候自己想移植代码，改了启动文件也不好使，就是报错。原来是这个原因。</p>
<p>那么我们只需要定义这么一个函数，哪怕内容是空都无所谓。</p>
<p>最终我们定义的初步项目框架如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698926683862.png" alt="1698926683862"></p>
<p>stm32f4xx.h：内容为空，有这么个东西就行。</p>
<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个程序可以烧录到板子上的。烧录成功之后没有任何反应（因为本来程序也没做什么哈哈），但是这就是一个大进步了。</p>
<h4 id="点灯——51单片机版"><a href="#点灯——51单片机版" class="headerlink" title="点灯——51单片机版"></a>点灯——51单片机版</h4><p>51单片机版就是引用 reg51.h 头文件，在其中声明了各个引脚的地址。我们只需要直接给引脚赋值即可。</p>
<p>调用代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 0 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	PA0=<span class="number">0xFE</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来我们需要定义 LED 灯的寄存器位置。阅读原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698939342199.png" alt="1698939342199"></p>
<p>大致可以看出，板子上的这个 RGB LED 通过三个引脚来控制 RGB 亮度。输出低电平则导通点亮。</p>
<p>具体输出方式是通过 ODR 进行输出。查找 stm32f4xx 中文参考手册可见：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940158585.png" alt="1698940158585"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940257044.png" alt="1698940257044"></p>
<p>那么我们就要给 0x4002 1400 +14 的地址赋值，让 1&lt;&lt;6 1&lt;&lt;7 1&lt;&lt;8 的位分别赋值为低电平.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	 *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这样也不亮。亮就怪了，stm32 寄存器是需要先做初始化配置的。</p>
<h4 id="点灯——stm32-版"><a href="#点灯——stm32-版" class="headerlink" title="点灯——stm32 版"></a>点灯——stm32 版</h4><p>首先我们要设置 GPIO 模式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940961543.png" alt="1698940961543"></p>
<p>想点灯 输出高低电平，是 01 通用输出模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br></pre></td></tr></table></figure>

<p>意思是先把 PF6 模式位置为00，然后赋值为01通用输出。</p>
<p>配置完模式之后，还需要配置时钟，stm32 每个外设都需要配置时钟。</p>
<p>前面提到过 GPIO 是在 AHB1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103516061.png" alt="1699103516061"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103724261.png" alt="1699103724261"></p>
<p>全部代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40023800</span>+<span class="number">0x30</span>)|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们把这几个地址值提取出来，宏定义映射寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx.h</span></span><br><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1_ENR    *(unsigned int *)(0x40023800+0x30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER     *(unsigned int *)(0x40021400+0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR       *(unsigned int *)(0x40021400+0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点灯——流水灯闪烁"><a href="#点灯——流水灯闪烁" class="headerlink" title="点灯——流水灯闪烁"></a>点灯——流水灯闪烁</h4><p>利用软件延时实现 RGB 流水灯闪烁。很简单，前面已经看了3个 LED 通道 PF678 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>));   </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>); </span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//毫秒级的延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span></span><br><span class="line">&#123;    </span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">while</span>(time--)</span><br><span class="line">   &#123;</span><br><span class="line">      i=<span class="number">4000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--) ;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点灯——GPIO-具体功能框图对应"><a href="#点灯——GPIO-具体功能框图对应" class="headerlink" title="点灯——GPIO 具体功能框图对应"></a>点灯——GPIO 具体功能框图对应</h4><p>GPIO：通用输入输出引脚。我们可以通过编程来输出或者读取数据。大部分 GPIO 是已经连接、定义好了一些功能（比如上面尝试过的 PF6 LED），有的引脚有多个功能支持重新映射。</p>
<p>STM32 GPIO 除了 adc 是 3.3v，其他 GPIO 都是 5v 容忍。</p>
<p>GPIO 框图（<strong>重点</strong>）如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231104221140325.png" alt="image-20231104221140325"></p>
<p>先从输出开始看。最右侧的 IO 引脚是连接在芯片周围一圈的144个引脚之一。除了 IO 引脚，此图中其他所有部分都是封装在芯片内部我们看不到的。</p>
<p>往左有两个保护二极管。当电压大于 5V，电流会往上 VDD_FT 走。当电压为负电压，电流会由 VSS 往 IO 引脚走。</p>
<p>上下拉电阻：比武外接一个低电平工作的设备，但是我们不希望一上电外设就工作，可以设置上拉电阻，稳定一段时间。</p>
<p>GPIO 输出的数据来源：复位寄存器 BSRR，或者 ODR 设置（图中的3下路部分）。复位寄存器高16位复位（写1置0）低16位置位（写1置1），置位优先级更高。</p>
<p>配置 GPIO 模式（输入&#x2F;输出，选择哪一路）通过前面用过的 MODER 配置。</p>
<p>输出模式（图中输出控制部分）配置端口输出类型寄存器 OTYPER，比如推挽输出，开漏输出。</p>
<p>推挽输出：有直接驱动能力，输出0就是低电平，输出1就输出可以工作的高电平。原理是采用了一个放大的电路？</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699356797818.png" alt="1699356797818"></p>
<p>输入（INT）为高电平时，反向后 PMOS 导通，输出高电平。输入为低电平时，反向后 NMOS 导通，输出低电平。我们可以用一个小电流去驱动出来一个大电流。</p>
<p>开漏输出：自己本身没有输出高电平的手段。低电平可以接地，高电平没有 PMOS 管，是浮空状态。需要外接一个电阻。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357078909.png" alt="1699357078909"></p>
<p>stm32 输出 5V 电压的方法就是开漏输出外接电阻。通过接两个三极管的方式反向。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357296750.png" alt="1699357296750"></p>
<p>框图中的模拟部分输入输出则不用配置这些模式信息，直接由外设接到保护二极管再接到输出引脚。</p>
<p>框图中的输入部分经过保护电压后，还需要施密特触发器调整一下。比如原来电压的数值并非精确的0或 3.3V，施密特触发器将高于 1.8V 的全部视作1，低于的全部视作0后输入芯片。模拟部分则不需要经过施密特触发器。</p>
<p>因此配置 GPIO 输出的步骤如下：</p>
<ol>
<li>GPIO 功能，通用输出、复用功能、模拟输入等 MODER；</li>
<li>输出推挽 or 开漏 OTYPER；</li>
<li>输出速度 OSPEEDR；</li>
<li>上下拉电阻是否需要开启 PUPDR；</li>
<li>具体输出内容 BSRR or ODR.</li>
</ol>
<p>输入部分后面输入实验介绍~</p>
<p>按整个流程重新串一遍代码，如下：（其实和前面差不多，就是重新按照流程串了一遍）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE    (unsigned int *)    0x40023800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE  (unsigned int *)    0x40021400</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1ENR         *(RCC_BASE+0x30)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER         *(GPIOF_BASE+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OSPEEDR       *(GPIOF_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_PUPDR         *(GPIOF_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR           *(GPIOF_BASE+0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BSRR          *(GPIOF_BASE+0x18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_AHB1ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    GPIOF_MODER &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    GPIOF_MODER |= (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录前记得勾选：use MicroLib.</p>
<h3 id="构建库方式"><a href="#构建库方式" class="headerlink" title="构建库方式"></a>构建库方式</h3><h4 id="点灯——自己尝试构建库函数版"><a href="#点灯——自己尝试构建库函数版" class="headerlink" title="点灯——自己尝试构建库函数版"></a>点灯——自己尝试构建库函数版</h4><p>寄存器方法了解到这里就好，野火课程主要是库函数写代码。首先我们自己尝试构建一下库函数。</p>
<p>还是基于上次实验代码修改即可。首先对 .h 文件做一些修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个是防止多次引用头文件重复定义。</p>
<p>然后，像之前一条条定义太麻烦了。其实我们注意到每个寄存器都是4字节，我们可以用固定大小的结构体定义。比如 GPIO ABCDEF 结构都一样，我们只需要统一定义结构体和各自的基址即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span>	<span class="comment">// 包含了 uint32_t uint16_t</span></span></span><br><span class="line"><span class="comment">/* GPIO寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER;    <span class="comment">/*GPIO模式寄存器						地址偏移: 0x00      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*GPIO输出类型寄存器				地址偏移: 0x04      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*GPIO输出速度寄存器				地址偏移: 0x08      */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*GPIO上拉/下拉寄存器			地址偏移: 0x0C      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR;      <span class="comment">/*GPIO输入数据寄存器				地址偏移: 0x10      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR;      <span class="comment">/*GPIO输出数据寄存器				地址偏移: 0x14      		*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL;    <span class="comment">/*GPIO置位/复位寄存器 低16位部分	地址偏移: 0x18 	*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH;    <span class="comment">/*GPIO置位/复位寄存器 高16位部分	地址偏移: 0x1A  */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR;     <span class="comment">/*GPIO配置锁定寄存器				地址偏移: 0x1C      */</span></span><br><span class="line">    <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*GPIO复用功能配置寄存器		地址偏移: 0x20-0x24 		*/</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GPIOF ((GPIO_TypeDef *)GPIOF_BASE)</span></span><br></pre></td></tr></table></figure>

<p>main.c 中可以把对应寄存器替换为 GPIOF-&gt;寄存器名了。</p>
<p>然后我们直接对寄存器做操作，还是有点直接了，最好是我们不需要关注寄存器有哪些，直接调用一个 GPIO 设置函数即可使用，封装性可移植性都会好很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRL=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRH=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>比如首先我们简单写了这样一个置位函数，使用方法为 <code>GPIO_SetBits(GPIOF_Base,1&lt;&lt;6)</code> .</p>
<p>以及我们可以在 <code>stm32f4xx_gpio.h</code> 里批量定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6          (uint16_t)(1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7          (uint16_t)(1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8          (uint16_t)(1&lt;&lt;8)</span></span><br></pre></td></tr></table></figure>

<p>这样 GPIO 使用用 Set Reset 函数已经非常规范了。那么初始化操作我们也可以封装成一个函数。</p>
<p>初始化需要设置 MODER PUPDR OSPEEDR OTYPER，我们可以定义一个结构体用于存储这些初始化变量，初始化的时候新建一个这样的结构体并赋值，传入初始化函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="comment">//每个模块具体的值可以定义一个枚举类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Mode_IN=<span class="number">0x00</span>;</span><br><span class="line">    GPIO_Mode_OUT=<span class="number">0x01</span>;</span><br><span class="line">    GPIO_Mode_AF=<span class="number">0x02</span>;</span><br><span class="line">    GPIO_Mode_AN=<span class="number">0x03</span>;</span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;</span><br><span class="line">    GPIOMode_TypeDef MODER;</span><br><span class="line">    GPIOPuPd_TypeDef PUPDR;</span><br><span class="line">    GPIOOType_TypeDef OTYPER;</span><br><span class="line">    GPIOOSpeed_TypeDef OSPEEDR;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>具体使用的时候首先我们初始化一个 GPIO_InitTypeDef 变量，并且给其中的每一个子元素都赋值。然后传入 GPIO_Init 函数中，里面就是一系列根据手册而来的位操作，这里我感觉前面原理懂差不多就不用非跟着敲了。</p>
<h4 id="分析-stm32-固件库函数"><a href="#分析-stm32-固件库函数" class="headerlink" title="分析 stm32 固件库函数"></a>分析 stm32 固件库函数</h4><p>前面基本上都是了解固件库编程，从51过渡到 stm32. 后面所有固件编程固件库的使用方法都和前面的 GPIO 类似。</p>
<p>固件是什么？其实就是程序，固化到 EEPROM 或 FLASH 中，操作最底层的设备。<strong>不是具体的应用，而是只操作最底层的设备。比如点灯算应用，给应用工程师提供库函数的工作是固件工程师的。</strong></p>
<p>stm32 官方 stmf4 固件库下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/zh/embedded-software/stm32-standard-peripheral-libraries/products.html?querycriteria=productId=LN1939">STM32标准外设软件库: 相关产品</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231108222206160.png" alt="image-20231108222206160"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     22:16                Libraries</span><br><span class="line">d-----         2023/11/8     22:16                Project</span><br><span class="line">d-----         2023/11/8     22:17                Utilities</span><br><span class="line">d-----         2023/11/8     22:17                _htmresc</span><br><span class="line">-ar---         2023/11/8     22:15          88007 Package_license.html</span><br><span class="line">-ar---         2023/11/8     22:15          19611 Package_license.md</span><br><span class="line">-ar---         2023/11/8     22:15         152599 Release_Notes.html</span><br><span class="line">-ar---         2023/11/8     22:15       37185187 stm32f4xx_dsp_stdperiph_lib_um.chm</span><br></pre></td></tr></table></figure>

<p>.chm：使用帮助文档。</p>
<p>.html .md：一些版本更新，包许可证相关信息。</p>
<p>Utilities：一些第三方其他软件。</p>
<p>Project：样例，模板。</p>
<p>Libraries：库，CMSIS 是一些 ARM 公司的标准，Driver 是固件。inc 是头文件，src 是c文件。</p>
<p>我们根据上节课写的项目来进行库函数文件功能分析。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>所属类别</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>startup_stm32f40xx.s</td>
<td>片上外设</td>
<td>汇编启动文件</td>
</tr>
<tr>
<td>stm32f4xx.h</td>
<td>片上外设</td>
<td>外设寄存器映射</td>
</tr>
<tr>
<td>system_stm32f4xx.c &#x2F; system_stm32f4xx.h</td>
<td>片上外设</td>
<td>初始化系统时钟</td>
</tr>
<tr>
<td>stm32f4xx_xxxx.c &#x2F; stm32f4xx_xxxx.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cm4.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cmFunc.h &#x2F; core_cmSimd.h</td>
<td>内核</td>
<td>内核外设的一些操作函数</td>
</tr>
<tr>
<td>misc.c &#x2F; misc.h</td>
<td>内核</td>
<td>中断相关函数（优先级分组，系统中断）</td>
</tr>
<tr>
<td>stm32f4xx_it.c &#x2F; stm32f4xx_it.h</td>
<td>内核</td>
<td>中断服务函数（所有中断入口）</td>
</tr>
<tr>
<td>main.c</td>
<td></td>
<td>main 函数</td>
</tr>
</tbody></table>
<ol>
<li>startupxxxx.s：启动文件。</li>
<li>stm32f4xx.h：外设寄存器映射。</li>
<li>跳到 system_Init 函数，这个函数当时我们为了执行只写了一个空函数，而 stm32 官方固件库模板里面是有的，在 system_stm32f4xx.c 里，初始化系统时钟。</li>
<li>stm32f4xx.c：具体外设驱动，比如上节课写的 gpio。</li>
<li>core_cm4.h：内核寄存器映射。</li>
<li>misc：中断。</li>
</ol>
<h4 id="构建库函数"><a href="#构建库函数" class="headerlink" title="构建库函数"></a>构建库函数</h4><p>创建一个通用的模板，后面写程序直接使用这个模板。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     23:27                Libraries</span><br><span class="line">d-----         2023/11/8     23:27                Listing</span><br><span class="line">d-----         2023/11/8     23:27                Output</span><br><span class="line">d-----         2023/11/8     23:27                Project</span><br><span class="line">d-----         2023/11/8     23:27                User</span><br><span class="line">-a----         2020/2/27     13:45            401 keilkill.bat</span><br></pre></td></tr></table></figure>

<p>前面都是新建的文件夹，keilkill.bat 是从 keil 编译程序中复制出来的一个脚本，可以删掉中间文件。</p>
<p>把固件库 Lib 里的 CMSIS 和 Driver 文件拷贝到 Libraries 文件夹中。CMSIS 中只保留 Device Include 文件夹。Device 中包含外设相关（比如 stm32f4xx.h system_stm32f4xx），Include 中只包含内核相关。</p>
<p>把 main.c stm32f4xx_it.c &#x2F; stm32f4xx_it.h stm32f4xx_conf.h 拷贝到 User 文件夹中。</p>
<p>在 Project 文件夹里可以包含多给项目文件，不光只有 Keil 的。比如 IAR 的我们新建一个 IAR 文件夹，Keil 我们新建一个 RVMDK(uv5) 文件夹。RealView 是包含不止 MDK 的开发工具集合的称呼，MDK 是 MCU 开发工具集成包，uVersion 是 IDE，Keil 是公司名字。</p>
<p>uVision 里新建工程，新建在 RVMDK(uv5) 文件夹下。</p>
<p>新建组、添加文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002542997.png" alt="image-20231109002542997"></p>
<p>STM32F4xx_StdPeriph_Driver 添加 STM32F4xx_StdPeriph_Driver&#x2F;src 下的所有文件，屏蔽掉 dma2d fmc ltdc，后两个是 sd 和 lcd 屏幕组件。</p>
<p>头文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002823229.png" alt="image-20231109002823229"></p>
<p>宏定义如下：</p>
<p>USE_STDPERIPH_DRIVER,STM32F40_41xxx</p>
<p>我现在好想明白为什么宏定义在这里了，这样后面换单片机型号的时候可以直接修改这个宏定义。</p>
<p><strong>PS：我下载的是 1.8.1 版本 stm32f4xx.h 库函数，里面出现了一段重复定义导致编译产生了200多个 warning。我把下面那一段删掉了就好了。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/true" alt="jingqing3948_1-1699463889291.png"></p>
<p>Output 里设置 Output 文件夹，不然都在 Proj 里太乱。</p>
<p>记得勾选 MicroLib。</p>
<h4 id="点灯——官方库函数版"><a href="#点灯——官方库函数版" class="headerlink" title="点灯——官方库函数版"></a>点灯——官方库函数版</h4><p>在 User 文件夹中新建 LED 文件夹，里面新建 bsp_led.c，代表板级支持包 LED 代码，也就是只针对我们当前这一款开发板的点灯程序。</p>
<ol>
<li><p>设置时钟：rcc 时钟，在 stm32f4xx_rcc.c 中：</p>
</li>
<li><pre><code class="c">/**
  * @brief  Enables or disables the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.   
  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
  *            @arg RCC_AHB1Periph_CRC:         CRC clock
  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
  *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其他部分基本也是参照库函数（主要是 stm32f4xx_gpio.h）最终呈现如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &quot;bsp_led.h&quot;</span><br><span class="line"></span><br><span class="line">void LED_GPIO_Config(void)&#123;</span><br><span class="line">    //RCC set function in stm32f4xx_rcc.h</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        //Init structure</span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">        GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;</span><br><span class="line">        GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;</span><br><span class="line">        GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        //init function</span><br><span class="line">        GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

置位可以使用 `GPIO_SetBits` 或 `GPIO_ResetBits`。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      GPIO_ResetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">      GPIO_SetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

没有上下拉的时候推挽输出会直接被 ODR 值所影响，哪怕没有赋值其中本来的值也会影响。所以推挽输出无上下拉，不置位 LED 也会被点亮，因为 ODR 默认值0.
</code></pre>
</li>
</ol>
<h3 id="输入——按键点灯"><a href="#输入——按键点灯" class="headerlink" title="输入——按键点灯"></a>输入——按键点灯</h3><p>开发板按键电路如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109191525189.png" alt="image-20231109191525189"></p>
<p>按键未按下接地，按下后为高电平。电容起到消抖作用，软件处理就不需要手动延时消抖了。</p>
<p>编程没啥难度，就是改了一下输入模式。使用 <code>ReadInputDataBits</code> 读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsp_button.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Button_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_InitTypeDef GPIOInitStruct;</span><br><span class="line">        GPIOInitStruct.GPIO_Mode=GPIO_Mode_IN;</span><br><span class="line">        GPIOInitStruct.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">        GPIOInitStruct.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIOInitStruct.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;</span><br><span class="line">        </span><br><span class="line">        GPIO_Init(GPIOA,&amp;GPIOInitStruct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0))GPIO_SetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        <span class="keyword">else</span> GPIO_ResetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现按键按下后翻转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET)&#123;</span><br><span class="line">            <span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET);</span><br><span class="line">            GPIO_ToggleBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要等到按键松开的时候再翻转，轮询直到松开。</p>
<h3 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h3><p>之前51单片机常见位定义。比如 PA 引脚有8个 IO 口，我们可以定义 <code>sbit LED1=PA^0</code> 这样单独操作某一位。</p>
<p>stm32 里没有直接的位定义方式。一种解决办法是我们利用与或操作不影响其他位的同时操作特定位；另一种就是位带操作。</p>
<p>stm32 里有一部分别名区域，用于映射外设、SRAM 中特定的位带区，我们操作这一部分别名区域时就可以实现对外设、SRAM 位带区与的位操作。</p>
<p>片上外设位带区：0X4000 0000<del>0X400F 0000，别名区：0X4200 0000</del>0X43FF FFFF，包含 APB12，AHB1 外设。</p>
<p>SRAM 位带区：0X2000 0000<del>0X200F 0000，别名区：0X2200 0000</del>0X23FF FFFF</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109220918350.png" alt="image-20231109220918350"></p>
<p>外设地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x42000000+ (A-0x40000000)<em>8</em>4 +n*4  （n是位序号）</p>
<p>SRAM 地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x22000000+ (A-0x20000000)<em>8</em>4 +n*4</p>
<p>扩大了32倍，可以对32位寄存器中的每一位进行操作。</p>
<p>统一公式：<code>\#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</code></p>
<p>使用：比如我们操作一个 GPIO 的位操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br><span class="line"><span class="comment">// 把一个地址转换成一个指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr) *((volatile unsigned long *)(addr))</span></span><br><span class="line"><span class="comment">// 把位带别名区地址转换成指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO ODR 和 IDR 寄存器地址映射</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR_Addr (GPIOF_BASE+20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_IDR_Addr (GPIOF_BASE+16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独操作 GPIO 的某一个 IO 口，n(0,1,2...15),</span></span><br><span class="line"><span class="comment">// n 表示具体是哪一个 IO 口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFout(n) BIT_ADDR(GPIOF_ODR_Addr,n) <span class="comment">//输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFin(n) BIT_ADDR(GPIOF_IDR_Addr,n) <span class="comment">//输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line">PFout(<span class="number">6</span>)= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这个概念学学就好，好像实际应用没啥意义。我们微处理器考试也考过hh。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-Win11磁贴配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/Win11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/"
    >Win11磁贴配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/Win11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Explore/">Explore</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近电脑还是升级到 win11 了。我之前采用的美化方案是桌面上的图标全部移到 win10 开始菜单里的全屏菜单上，用磁贴贴一排。每次要访问文件的时候都去开始菜单里找，而不是放在桌面上，这样桌面也可以空出来欣赏壁纸。参考配置链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/45120814/answer/1007955630">如何让Windows 10系统桌面变得更好看？ - 知乎 (zhihu.com)</a></p>
<p>但是升级到 win11 对我而言影响最大的就是压根没有全屏桌面和磁贴功能了。因此我搜了很多解决方案，加上一些自己的改进，最终把桌面磁贴恢复成如上图所示。一个自己喜欢看的桌面还是会对生产力的提高有很大帮助的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712234132339.png" alt="image-20230712234132339"></p>
<h2 id="软件安装：start11"><a href="#软件安装：start11" class="headerlink" title="软件安装：start11"></a>软件安装：start11</h2><p>首先，恢复开始菜单这一操作最离不开的就是 start11 这款软件。他让 win11 的开始菜单又有了全屏菜单选项，也支持了自定义磁贴在上面。虽然调整磁贴位置的时候偶尔会花几秒重启，但大多数时候还是没问题的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235022366.png" alt="image-20230712235022366"></p>
<p>正版软件是免费试用的，欢迎付费支持原作者。或采用博主的同款方案：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru">https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru</a><br>提取码：1fru<br>–来自百度网盘超级会员V2的分享</p>
<h2 id="start11-配置"><a href="#start11-配置" class="headerlink" title="start11 配置"></a>start11 配置</h2><p>首先如果是按博主的磁贴方法配置，就要选“win10配置”。或者你觉得其他风格也还不错都可以选。并且 ENABLE start11.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235704628.png" alt="image-20230712235704628"></p>
<p>点击“配置菜单”，进行如下配置：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235738298.png" alt="image-20230712235738298"></p>
<p>在“自定义菜单视觉外观”里，可以设置全屏菜单的颜色、透明度等，比如我使用的是有一定透明度的毛玻璃的样式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000601091.png" alt="image-20230713000601091"></p>
<p>然后在“控制”栏里设定如何打开 start11，确保可以打开：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235840844.png"></p>
<p>接着，点击 win 图标就可以打开全屏菜单了。</p>
<h2 id="磁贴配置"><a href="#磁贴配置" class="headerlink" title="磁贴配置"></a>磁贴配置</h2><p>对于大部分软件，只要右键-固定到开始屏幕&#x2F;固定到 start11，就可以在全屏菜单里看到刚刚贴上的磁贴了。</p>
<p>如果贴失败，可以尝试以下的方法：</p>
<ul>
<li>右键快捷方式，点击“打开文件所在位置”，再尝试把该文件的 .exe 文件固定到开始屏幕。</li>
<li>反复尝试，因为可能有一定的延迟。可以取消固定再次固定，等待一会看开始菜单是否出现。</li>
</ul>
<p>然后可以手动分组磁贴（把他们移到临近的位置），调整磁贴背景色，调整磁贴大小（有小正方形，中正方形，长方形，大正方形四种可以选择），调整磁贴布局位置。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000428410.png" alt="image-20230713000428410"></p>
<h2 id="图片磁贴配置"><a href="#图片磁贴配置" class="headerlink" title="图片磁贴配置"></a>图片磁贴配置</h2><p>这里是最自由发挥的部分。高情商：自由发挥。低情商：都要自己做很麻烦。</p>
<p>之前 win10 是有一款快捷工具可以输入自定义图片，按自己想要的格式裁剪并自动在全屏菜单中输出的，叫 Tile Genie.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000854968.png" alt="image-20230713000854968"></p>
<p>但是它好像并不能在 start11 中使用。我尝试了一下导出的都是不能显示的图片块，所以只能放弃这种方法。如果读者的 Tile Genie 是没有问题可以正常显示图片那再好不过了，后面的内容都可以不用看了。</p>
<p>如果导出失败……我采用的方法是手动裁剪固定图片。很笨，但是有结果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001102790.png" alt="image-20230713001102790"></p>
<p>首先，自行裁剪图片，计算公式为：中正方形 150*150，长方形 306*150，大正方形 306*306，边界线是6（像素）.</p>
<p>我采用的图像裁剪方法是：<a target="_blank" rel="noopener" href="https://www.iloveimg.com/zh-cn/crop-image">免费在线裁剪图像文件 (iloveimg.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178422454.png" alt="1689178422454"></p>
<p>然后把导出图片找一个合适的地方存储起来，注意贴上磁贴之后就不能再移动修改这些图片了。</p>
<p>在全屏菜单中右键-固定文件，选定文件路径添加。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001454756.png" alt="image-20230713001454756"></p>
<p>刚固定上是这种形式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178534062.png" alt="1689178534062"></p>
<p>然后右键-调整大小，调整为想要的大小。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001613170.png" alt="image-20230713001613170"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001632462.png" alt="image-20230713001632462"></p>
<p>最后一步，右键-图标-选择自定义磁贴图像，再次选择此文件，然后他就被当做图标全屏显示了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001653804.png" alt="image-20230713001653804"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-ubuntu 安装 emscripten 时 install latest 安装报错问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/ubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"
    >ubuntu 安装 emscripten 时 install latest 安装报错问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/ubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Problems-Solved/">Problems Solved</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>学习官网参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm">Compiling a New C&#x2F;C++ Module to WebAssembly - WebAssembly | MDN (mozilla.org)</a></p>
<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>形如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Downloading URL &#x27;https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2&#x27;: &lt;urlopen error [Errno 104] Connection reset by peer&gt;</span><br><span class="line">error: installation failed!</span><br></pre></td></tr></table></figure>

<p>OS：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux jingqing 5.19.0-35-generic #36~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 17 15:17:25 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="产生错误原因分析"><a href="#产生错误原因分析" class="headerlink" title="产生错误原因分析"></a>产生错误原因分析</h2><blockquote>
<p>emsdk install latest报错（因为从谷歌中下载，cmd中命令形式访问不到google）<br>版权声明：本文为CSDN博主「小白啥时候能进阶成功」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34754747/article/details/103815349">https://blog.csdn.net/qq_34754747/article/details/103815349</a></p>
</blockquote>
<p>非常感谢博主的答疑解惑，不过我没有看得太懂原文中的解决方案，网上搜到的大多数方案也是 windows 环境下的解决方案，因此我决定自己写一个 ubuntu 系统下的补安装。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>说白了就是我自己复制链接到浏览器里，下载安装这几个包，放到 emsdk 的指定位置。</p>
<p>这里有两个要注意的点，这一部分主要是分析，不想看的同学可以直接跳到<a href="#solution">具体步骤</a>处：</p>
<ol>
<li><p>emsdk install 的默认安装规则是：不管你有没有安装过这些包，我 install latest 都是重新安装，保证最新版本。但是现在问题是 install latest 有问题，我要手动安装包放进去。<br>我们打开 emsdk.py 通过搜索关键词可以找到报错信息的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:675</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On success, returns the filename on the disk pointing to the destination file that was produced</span></span><br><span class="line"><span class="comment"># On failure, returns None.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, dstpath, download_even_if_exists=<span class="literal">False</span>, filename_prefix=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">  debug_print(<span class="string">&#x27;download_file(url=&#x27;</span> + url + <span class="string">&#x27;, dstpath=&#x27;</span> + dstpath + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  file_name = get_download_target(url, dstpath, filename_prefix)</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(file_name) <span class="keyword">and</span> <span class="keyword">not</span> download_even_if_exists:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File &#x27;&quot;</span> + file_name + <span class="string">&quot;&#x27; already downloaded, skipping.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> file_name</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    u = urlopen(url)</span><br><span class="line">    mkdir_p(os.path.dirname(file_name))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      file_size = get_content_length(u)</span><br><span class="line">      <span class="keyword">if</span> file_size &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s, %s Bytes&quot;</span> % (file_name, url, file_size))</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s&quot;</span> % (file_name, url))</span><br><span class="line"></span><br><span class="line">      file_size_dl = <span class="number">0</span></span><br><span class="line">      <span class="comment"># Draw a progress bar 80 chars wide (in non-TTY mode)</span></span><br><span class="line">      progress_max = <span class="number">80</span> - <span class="number">4</span></span><br><span class="line">      progress_shown = <span class="number">0</span></span><br><span class="line">      block_sz = <span class="number">256</span> * <span class="number">1024</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27; [&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          buffer = u.read(block_sz)</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> buffer:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          file_size_dl += <span class="built_in">len</span>(buffer)</span><br><span class="line">          f.write(buffer)</span><br><span class="line">          <span class="keyword">if</span> file_size:</span><br><span class="line">              percent = file_size_dl * <span class="number">100.0</span> / file_size</span><br><span class="line">              <span class="keyword">if</span> TTY_OUTPUT:</span><br><span class="line">                  status = <span class="string">r&quot; %10d  [%3.02f%%]&quot;</span> % (file_size_dl, percent)</span><br><span class="line">                  <span class="built_in">print</span>(status, end=<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">while</span> progress_shown &lt; progress_max * percent / <span class="number">100</span>:</span><br><span class="line">                      <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                      sys.stdout.flush()</span><br><span class="line">                      progress_shown += <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    errlog(<span class="string">&quot;Error: Downloading URL &#x27;&quot;</span> + url + <span class="string">&quot;&#x27;: &quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;SSL: CERTIFICATE_VERIFY_FAILED&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e) <span class="keyword">or</span> <span class="string">&quot;urlopen error unknown url type: https&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e):</span><br><span class="line">      errlog(<span class="string">&quot;Warning: Possibly SSL/TLS issue. Update or install Python SSL root certificates (2048-bit or greater) supplied in Python folder or https://pypi.org/project/certifi/ and try again.&quot;</span>)</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    exit_with_error(<span class="string">&quot;aborted by user, exiting&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> file_name</span><br></pre></td></tr></table></figure>

<p>大致一看能看明白逻辑，如果 download_even_if_exists &#x3D; True 那么无论包是否已经存在都要安装，否则为 False 就只安装不存在的包，我们需要为 False。</p>
<p>搜索函数名查看在哪里使用了这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:1411</span></span><br><span class="line"></span><br><span class="line">received_download_target = download_file(url, download_dir, <span class="keyword">not</span> KEEP_DOWNLOADS, filename_prefix)</span><br></pre></td></tr></table></figure>

<p>这个 KEEP_DOWNLOADS 是一个环境变量，默认为0，我们需要他为1，传入函数的参数则为0（False），即已存在文件不再重复下载。</p>
<p>在终端输入 <code>./emsdk --help</code> 可以看到提示信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment:</span><br><span class="line">      EMSDK_KEEP_DOWNLOADS=1     - if you want to keep the downloaded archives.</span><br><span class="line">      EMSDK_NOTTY=1              - override isatty() result (mainly to log progress).</span><br><span class="line">      EMSDK_NUM_CORES=n          - limit parallelism to n cores.</span><br><span class="line">      EMSDK_VERBOSE=1            - very verbose output, useful for debugging.</span><br></pre></td></tr></table></figure>

<p>也就是说只要安装时单独指定此变量值为1即可。</p>
</li>
<li><p>第二步就是如何下载文件了。下载什么文件？放到哪个目录下？</p>
<p>这里大家可以通过 download_file 的 print debug 调试来查看他校验文件是否存在是去哪里校验的，我就不再具体展开讲调试步骤了，结论就是：他在 emsdk&#x2F;downloads&#x2F; 目录下先查找一下待下载的压缩包是否存在，那么我们复制报错信息中的 url 下载文件到这个 downloads 文件夹下即可（没有就新建）。</p>
</li>
</ol>
<h2 id="solution">具体步骤</h2>

<ol>
<li><p>首先要安装所缺的所有包，一个个安装，报错信息里提示什么安装什么。比如文章开头的报错信息中下载链接是：<a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2%EF%BC%8C%E5%B0%B1%E5%85%88%E5%AE%89%E8%A3%85%E8%BF%99%E4%B8%AA%E3%80%82">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2，就先安装这个。</a></p>
<p>node: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>wasm-binaries: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>安装完成后要重命名 b90507fcf011da61bacfca613569d882f7749552-wasm-binaries.tbz2。</p>
</li>
<li><p>移入 emsdk&#x2F;downloads 文件夹下，不用解压。</p>
</li>
<li><p>执行 <code>EMSDK_KEEP_DOWNLOADS=1</code> 变量赋值。</p>
</li>
<li><p>执行 <code>./emsdk install latest</code>  。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jingqing3948@jingqing:~/Webassembly/emsdk$ ./emsdk install latest</span><br><span class="line">Resolving SDK alias &#x27;latest&#x27; to &#x27;3.1.44&#x27;</span><br><span class="line">Resolving SDK version &#x27;3.1.44&#x27; to &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;</span><br><span class="line">Installing SDK &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;..</span><br><span class="line">Skipped installing node-16.20.0-64bit, already installed.</span><br><span class="line">Skipped installing releases-b90507fcf011da61bacfca613569d882f7749552-64bit, already installed.</span><br><span class="line">All SDK components already installed: &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;.</span><br></pre></td></tr></table></figure>

<p>好哎，看来是自己单独安装的文件包都可以用，他会自己解压文件包后提示 All SDK components already installed。</p>
<p>接下来就是下一步：<code>./emsdk activate latest</code>.</p>
<p>最后是 <code>source ./emsdk_env.sh</code> 配置好环境变量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院物联网RFID课程笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%89%A9%E8%81%94%E7%BD%91RFID%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"
    >北邮国院物联网RFID课程笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%89%A9%E8%81%94%E7%BD%91RFID%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-07-24T23:00:00.000Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/BUPT/">BUPT</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<p>主要围绕提纲里的所有问题展开，没有拓展内容，Exam oriented Study。</p>
<p>关注微信公众号：灰海宽松，回复 “RFID” 可获取本文pdf格式。</p>
<h1 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h1><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h2 id="Comparison-of-different-automatic-identification-technologies"><a href="#Comparison-of-different-automatic-identification-technologies" class="headerlink" title="Comparison of different automatic identification technologies"></a>Comparison of different automatic identification technologies</h2><p>首先明确一下比较对象。human identification（cost too high）是人力识别就不用说了。</p>
<p>fingerprint identification: </p>
<ul>
<li>stability 稳定，精确度高；</li>
<li>high speed, 快速匹配；</li>
<li><strong>security issues</strong>: 容易被复制。</li>
</ul>
<p>face recognition:</p>
<ul>
<li>easy to be influenced by surroundings, hair, age…</li>
</ul>
<p>speech recognition:</p>
<ul>
<li>easy to use and accept by user;</li>
<li>not involve privacy;</li>
<li>due to international standards, is hard to promoting</li>
</ul>
<p>1d barcode:</p>
<ul>
<li>limit storage capacity, 点线组合少;</li>
<li>need to combine with database;</li>
<li>barcode size is large;</li>
<li>poor fault tolerance, 本来就需要摄像头可见，如果被污损遮挡很容易就无法识别;</li>
</ul>
<p>2d barcode recognition:</p>
<ul>
<li>larger storage capacity;</li>
<li>high information density;</li>
<li>powerful fault tolerance;</li>
<li>support for encryption 容量大了就支持更多编码解码等安全措施了。</li>
</ul>
<p>rfid：</p>
<ul>
<li>low cost;</li>
<li>low power consumption;</li>
<li>high accuracy;</li>
<li>non-contract, fast speed; 不用接触（哪怕是visual，薄纱条码）</li>
<li>certain computing and storage capabilities;</li>
</ul>
<p>主要考虑各个的缺点，人脸和声音特征点多速度慢，而且人脸容易被影响，声音由于国际标准技术难以提升；条码需要视觉可见；指纹容易被盗取。</p>
<h2 id="The-main-features-of-RFID"><a href="#The-main-features-of-RFID" class="headerlink" title="The main features of RFID"></a>The main features of RFID</h2><ul>
<li><p>Non-contact automatic and rapid identification 快速薄纱复杂的人脸和声音，无接触薄纱条码和指纹</p>
</li>
<li><p>Permanently store a certain amount of data 永久存储一定量数据</p>
</li>
<li><p>Simple logical processing 其包含的简单逻辑电路允许做一定的逻辑处理，比如安全协议、算法</p>
</li>
<li><p>Reflection signal strength is affected by the distance  and other factors significantly 信号受到距离，读写器功率，其他信号，其他标签的干扰</p>
</li>
<li><p>Low cost, can be deployed at a large scale</p>
</li>
</ul>
<h2 id="Constraints-of-RFID-technology"><a href="#Constraints-of-RFID-technology" class="headerlink" title="Constraints of RFID technology"></a>Constraints of RFID technology</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687019780697.png" alt="1687019780697"></p>
<h2 id="Core-technologies-of-RFID"><a href="#Core-technologies-of-RFID" class="headerlink" title="Core technologies of RFID"></a>Core technologies of RFID</h2><p>Anti-collision mechanism：rfid并不支持传统的cmsa&#x2F;ca无线通信协议，需要采取一些措施防碰撞（reader-reader, tag-reader, tag-tag)</p>
<p>Efficient information storage, retrieval and mining: 尽量节能的信息存储，检索，挖掘</p>
<p>Make full use of the attenuation laws of backscatter signal to assist in positioning and mobile behavior sensing: 我们知道rfid信号会随着距离衰减。反之我们也可以利用这一点来定位物体位置和移动行为感知。</p>
<p>Security certification and privacy protection: 如何利用逻辑门电路校验安全性。</p>
<h2 id="The-advantage-of-RFID-in-IoT-and-the-development-trend"><a href="#The-advantage-of-RFID-in-IoT-and-the-development-trend" class="headerlink" title="The advantage of RFID in IoT, and the development trend"></a>The advantage of RFID in IoT, and the development trend</h2><p>充电方式：Backscatter, small node and indefinitely time of endurance. but rely on reader, one to many centralized communication 利用无线电 ratio signal 充电的方式</p>
<p>ptp communication: 建立 channel awareness technologies 使得支持被动点对点通信来建立分布式系统</p>
<p>Combine with Sensors: 开发更多应用方式。</p>
<p>RFID and IoT:</p>
<ul>
<li>embed intelligence in the physical object, so that simple physical objects can also “say”. </li>
<li>allows a physical object to be uniquely identified in a way similar to the “IP address” of a computing node in the Internet. </li>
<li>provides a low-cost communication way to achieve effective communication between nodes. </li>
<li>makes the physical objects in a passive environment achieve “passive intelligence“, providing fundamental guarantee for the “thing-thing connection”</li>
</ul>
<h1 id="2-Identification"><a href="#2-Identification" class="headerlink" title="2. Identification"></a>2. Identification</h1><p>简单说RFID就是物体上贴tag，用reader上的antenna去读取，这三个是主要组成。</p>
<h2 id="Reader’s-function"><a href="#Reader’s-function" class="headerlink" title="Reader’s function"></a>Reader’s function</h2><p>Energy supply: 比如有的标签自身不带能量需要reader提供信号中蕴含的能量</p>
<p>Communication: 最基本的功能，和tag识别，通信</p>
<p>Security Assurance: 比如加密解密</p>
<p>扩展功能：比如自组网 ad-hoc, 管理天线 antenna management 中间件接口 interface of middle components 连接外设 connecting peripherals</p>
<h2 id="Reader’s-classification"><a href="#Reader’s-classification" class="headerlink" title="Reader’s classification"></a>Reader’s classification</h2><p>按频率：LF HF算低频，UHF和SHF算高频（ultra super)，高频数据传输速度快，距离远，但是衰减快 signal attenuation，收到障碍物影响大  sensitive to obstacles。</p>
<p>按外观：</p>
<ul>
<li>Fixed 固定有线的，高度集成，快速启动 set up</li>
<li>portable 可移动的像手持手机一样，small, charging battery, easy to move</li>
<li>Industrial 为工厂目的而生，比如集成其他 sensor</li>
</ul>
<h2 id="Influencing-factors-of-R-W-range"><a href="#Influencing-factors-of-R-W-range" class="headerlink" title="Influencing factors of R&amp;W range"></a>Influencing factors of R&amp;W range</h2><p>许多东西都有说明书，规范，来提醒我们怎么不把东西玩坏比如手机提示不要放水里玩。</p>
<p>RFID的R&amp;W range是其中一种。影响因素如下：</p>
<ul>
<li><p>The way that antenna is coupled 天线耦合方式，比如把两个天线绑一起太近互相干扰。</p>
</li>
<li><p>The output power of the reader’s RF signal 功率，太低可能无法激发tags</p>
</li>
<li><p>The frequency of RF carrier signal 合适的频率</p>
</li>
<li><p>Antenna direction 天线，读取器天线和标签天线极性方向 polarization 相匹配时识别范围最大</p>
</li>
<li><p>Operation environment condition</p>
</li>
<li><p>Movement speed of tags</p>
</li>
</ul>
<h2 id="Reader’s-components-and-their-functions"><a href="#Reader’s-components-and-their-functions" class="headerlink" title="Reader’s components and their functions"></a>Reader’s components and their functions</h2><p>Signal Processing and Control Module: 主要是控制功能，协调一些本地计算</p>
<ul>
<li>Communicate with upper computer,  and execute command from it</li>
<li>Control communication process with tags</li>
<li>Encode and decode signal</li>
<li>Perform anti-collision algorithm</li>
<li>Encrypt and decrypt the data  transferred between reader and tag</li>
<li>Identity certification between reader and tag</li>
</ul>
<p>Inductively Coupled RF Module: 主要是产生能量和调制发送信号功能</p>
<ul>
<li>Generate high frequency send energy, activate RF tags and  provide energy (passive RF tags) </li>
<li>Modulate signal to sent,  transferring data to RF tags</li>
<li>Receive and demodulate RF signal  from RF tags.</li>
</ul>
<h2 id="Tag’s-functions"><a href="#Tag’s-functions" class="headerlink" title="Tag’s functions"></a>Tag’s functions</h2><ul>
<li>data storage</li>
<li>energy harvesting 吸收能量，与reader的 energy supply 对应</li>
<li>contactless with R&amp;W 不用接触就能通信，与 reader 的 communication with tags 对应</li>
<li>Security Encryption 与 reader 的 Security Assurance 对应</li>
<li>Collision Concessions 碰撞让步</li>
</ul>
<h2 id="Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability"><a href="#Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability" class="headerlink" title="Tag classification: by package form, by power source, by work frequency, by R&amp;W capability"></a>Tag classification: by package form, by power source, by work frequency, by R&amp;W capability</h2><p>Package form 也就是外观上的分类：</p>
<ul>
<li>card-like</li>
<li>label-like</li>
<li>Implantable, 比如动物植物体内</li>
<li>Accessories-like 附件类标签，比如纽扣型的，这一类主要是方便携带</li>
</ul>
<p>By Power Source 按能源供应方式分类：</p>
<ul>
<li>active 自己有电池供电</li>
<li>passive 依靠 carrier signal 读取器发来的载波信号获取能量</li>
<li>semi-passive 有电池作为后备隐藏能源，平时主要是passive 方式</li>
</ul>
<p>By Work Frequency</p>
<p>LF HF UHF。UHF读写性能，距离最好，更多会使用 active 型。</p>
<p>By R&amp;W Capability</p>
<p>read-only 和 R&amp;W 两种，结构复杂度也有所不同</p>
<h2 id="Two-work-modes-of-RFID-middleware"><a href="#Two-work-modes-of-RFID-middleware" class="headerlink" title="Two work modes of RFID middleware"></a>Two work modes of RFID middleware</h2><p>interactive, independent。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618045820043.png" alt="image-20230618045820043"></p>
<p>交互模式大概就是一直接收主机的命令，你让我读我就读，读完把结果还给你。</p>
<p>独立模式是可以不接收主机命令自行按预设的程序和读取到的结果信息循环执行指令，并将结果返回给主机。</p>
<h1 id="3-Wireless-Communication-Principle-of-RFID"><a href="#3-Wireless-Communication-Principle-of-RFID" class="headerlink" title="3. Wireless Communication Principle of RFID"></a>3. Wireless Communication Principle of RFID</h1><h2 id="Different-work-principles-of-different-carrier-frequency"><a href="#Different-work-principles-of-different-carrier-frequency" class="headerlink" title="Different work principles of different carrier frequency"></a>Different work principles of different carrier frequency</h2><p>不同频率载波也适用不同的工作原则。</p>
<p>前面已经有所涉及，比如LF HF适用于近距离，UHF SHF适合远距离。</p>
<p>前者适用 Inductively Coupled RF Module 电感耦合，通过感应方式获取能量。</p>
<p>后者适用 Electromagnetic Backscatter Coupled RF Module 电磁反向散射耦合，持续不断发送射频信号来供给能量。backscatter 指的是接收机信号调制后通过发送机天线产生可被识别的信号。</p>
<p>两者的能量消耗都和距离平方成正比 squared distance</p>
<h2 id="Signal-voltage-and-energy-dB-dBm，重点：如何计算"><a href="#Signal-voltage-and-energy-dB-dBm，重点：如何计算" class="headerlink" title="Signal voltage and energy: dB, dBm，重点：如何计算"></a>Signal voltage and energy: dB, dBm，重点：如何计算</h2><p>变化的电压通常用 $V(t)&#x3D;v_0cos(\omega t)$ 表示。</p>
<p>功率P&#x3D;VI&#x3D;V^2&#x2F;R这不用多说。平均功率 $&#x3D;\frac{v_0^2}{2R}$ 很简单推因为正余弦平均就是&#x2F;根2.</p>
<p>相对变化 The relative change，这是一个比较新鲜的而且信号变化中比较重要的指标。</p>
<p>$G_{dB}&#x3D;10log_{10}\frac{P2}{P1}$ </p>
<p>参考功率 referenced power $dBm&#x3D;10log_{10}\frac{P}{10^{-3}}$</p>
<p>dBm单位是功率的W，GdB单位是dB，代表一个比值。</p>
<h2 id="Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0"><a href="#Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0" class="headerlink" title="Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0"></a>Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0</h2><p>一些阅读器通过调制使得正弦电压信号携带信息的方法。</p>
<p>OOK：on off keying，高功率1低功率0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036831437.png" alt="1687036831437"></p>
<p>问题在于，低功率0的部分标签没法被激活，也无法正常工作。也就是说0信号标签压根启动不了，没法接收0信号。</p>
<p>PIE解决方法：长高功率是1，短高功率是0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036892748.png" alt="1687036892748"></p>
<p>然后涉及到tags对reader发来的信号进行解码。空间中的信号发过来是有方向的矢量叠加，tags如何通过编码机制识别信号？</p>
<p>FM0编码方式：位窗起始处翻转信号表示1，中间翻转表示0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687037382818.png" alt="1687037382818"></p>
<p>FM0属于 FSK frequent shift key 通过信号变化频率来识别的机制。</p>
<h2 id="Link-budget-重点"><a href="#Link-budget-重点" class="headerlink" title="Link budget (重点)"></a>Link budget (重点)</h2><p>Link budget: forward link budget  and backward link budget 发射过程中能量增减的总和</p>
<p>reader transmit energy(+) path loss(-) tag activate energy(-)</p>
<ul>
<li>pass loss: 读取器天线向360度的发送能量。其中只有一部分区域可以被tags antenna读取到，这一部分被称作 Effective  Aperture (Ae) of the tag antenna。能量&#x3D;有效面积*密度 $P_t&#x3D;\rho A_e$ 。总共发送的能量比收到的能量就等于总表面积比有效面积 $\frac{P_{TX}}{P_{RX}}&#x3D;\frac{A_e}{4\pi r^2}$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618174327976.png" alt="image-20230618174327976"></p>
<p>来看上例，发送方30dBm对应1W，tag接收到-10dBm对应10^-4W. 然后5dB的衰减到-15dBm。这个5dB衰减就是两个dBm做差得到的。</p>
<p>所以，dBm相当于对功率P的另一种衡量方式，为什么这么麻烦的要用log来表示？因为两个dBm的差值就是分贝（放大系数），所以由一个dBm能量转到另一个只需要加减两者间差的分贝即可，很方便。</p>
<p>从tags反射回来的信号 reflection link 和路径四次方成反比 inversely proportional. $P_{RX,back}:\frac{1}{r^4}$</p>
<h2 id="Antenna-gain-and-polarization-EIRP"><a href="#Antenna-gain-and-polarization-EIRP" class="headerlink" title="Antenna gain and polarization, EIRP"></a>Antenna gain and polarization, EIRP</h2><p>antenna gain: 输入条件相同情况下，实际情况某一点能量密度&#x2F;理想条件下的密度单元。反应了天线 concentrates the input power 的能力。就比如把阅读器放中间，标签围一圈，360度去读取周围标签对能量消耗就大，可能因此传输距离也近；但是如果把标签集中放在一块区域，周围放置的 reader 利用定向天线 Directional antenna，固定读取某一个角度范围内的tags能量利用效率就高。</p>
<p>Polarization：事物在一定条件下发生极化 polarization，使得其表现的和原有状态不一样  its properties deviate from the  original state。</p>
<p>EIRP, Equivalent Isotropic Radiated Power: 天线在所指方向上获得最大增益效果 maximum gain effect 所需要的能量。</p>
<p>For example, FCC regulations in the United States, a non-irradiated  transmitter can transmit 1W of energy signals, and can use 6dBi antenna; antenna gain increased by 1dB, transmission energy needs to  be reduced by 1dB. In fact, FCC is not more than  36dBm(30dBm+6dBi).</p>
<h2 id="Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式"><a href="#Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式" class="headerlink" title="Effects of antenna gain，重点：分析 link budget，几个计算公式"></a>Effects of antenna gain，重点：分析 link budget，几个计算公式</h2><p>directional gain: radiation density of one direction d &#x2F; average value in all direction</p>
<p>power gain: radiation efficiency of that direction G</p>
<p>平面角：单位rad，比如圆周180度单位角&#x3D;2pi rad</p>
<p>立体角：单位sr，比如球面立体角&#x3D;4pi sr</p>
<p>能量增益G的计算方法是4pi&#x2F;立体角大小。比如波束宽度72°也就是2pi&#x2F;5大概是1.25rad， $G&#x3D;\frac{4\pi}{1.25^2}$</p>
<p>dipole antenna: 垂直于轴沿各个方向发送信号，比全向天线 omnidirectional antenna 小2.2dB。</p>
<p>Effective aperture $A&#x3D;G\frac{\lambda ^2}{4\pi}$</p>
<p>$P_{RX}&#x3D;P_{TX}G_{RX}G_{TX}(\frac{\lambda}{4\pi r})^2$</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619104251622.png" alt="image-20230619104251622"></p>
<p>$R_{forward}&#x3D;\frac{\lambda}{4\pi}\sqrt{\frac{P_{TX,reader}T_bG_{reader}G_{tag}}{P_{min,tag}}}$</p>
<p>$R_{reverse}&#x3D;\frac{\lambda}{4\pi}\sqrt[4]{\frac{P_{TX,reader}T_bG_{reader}^2G_{tag}^2}{P_{min,reader}}}$</p>
<h1 id="4-Tag-Identification-Protocol"><a href="#4-Tag-Identification-Protocol" class="headerlink" title="4. Tag Identification Protocol"></a>4. <strong>Tag</strong> Identification Protocol</h1><h2 id="Checksum-procedure-parity-checks-LRC-CRC"><a href="#Checksum-procedure-parity-checks-LRC-CRC" class="headerlink" title="Checksum procedure: parity checks, LRC, CRC"></a>Checksum procedure: parity checks, LRC, CRC</h2><p>奇偶校验不多说，查1的个数，poor error recognition。电路通过所有位异或是偶校验，结果为1说明有错误；再取反是奇校验。</p>
<p>LRC longitudinal redundancy check (LRC) procedure 循环冗余检测，所有字节进行异或运算，得到的结果是LRC校验码。也就是说数据发送到终点后，所有字节（数据和LRC）进行字节异或运算结果应该为0. 也有一些错误无法纠正，主要用于小的数据块校验。</p>
<p>CRC (cyclic redundancy check) procedure</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142701838.png" alt="1687142701838"></p>
<p>接收方计算原数据+CRC数据拼接起来的CRC数据值，应该为0. 不能纠错，不过检错效率很高。</p>
<h2 id="ASK-FSK-PSK"><a href="#ASK-FSK-PSK" class="headerlink" title="ASK, FSK, PSK"></a>ASK, FSK, PSK</h2><p>amplitude Shift Keying: 幅度调制，y轴上的调制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142836442.png" alt="1687142836442"></p>
<p>计算方法2：duty factor: $m&#x3D;1-\frac{u_1}{u_0}$</p>
<p>$U_{ASK}(t) &#x3D;(m·u_{code}(t)+1−m)·u_{HF}(t)$</p>
<p>Frequency shift keying: 频率上的改变。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143205258.png" alt="1687143205258"></p>
<p>Phase shift keying: 频率相位翻转180.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143252934.png" alt="1687143252934"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143276722.png" alt="1687143276722"></p>
<h2 id="Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags"><a href="#Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags" class="headerlink" title="Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags"></a>Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags</h2><p>Compared with the reader, limited by hardware resources, tags have very limited storage capacity and computing. </p>
<p>标签受制于硬件资源，存储容量和计算能力都不高。</p>
<h2 id="TDMA-FDMA-CSMA"><a href="#TDMA-FDMA-CSMA" class="headerlink" title="TDMA, FDMA, CSMA"></a>TDMA, FDMA, CSMA</h2><p>首先主要有两种方式，一个是reader broadcast 广播到诸多 tags，一个是多个 tags Multi-access 每个tags单独访问reader。</p>
<p>TDMA FDMA是multi-access, CSMA是broadcast</p>
<p>FDMA: 多个频率通道 several frequency channels 传输数据。</p>
<p>TDMA: </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619212501183.png" alt="image-20230619212501183"></p>
<h2 id="ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程"><a href="#ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程" class="headerlink" title="ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程"></a>ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程</h2><p>Pure ALOHA algorithm：收到成功确认 ack 后就不再发送。否则一直随机等待后继续发送。简单但是通道利用率 channel utilization 低，poor performance.</p>
<p>offered load G：单位时间 tau 里同时发送的应答器数量</p>
<p>s-aloha: 规定时间片 slot，一个时间片只能发一次，冲突就下一次时间片去发。channel utilization 几乎是 pure 的两倍。</p>
<p>$S &#x3D; G × e^{-G}$ G&#x3D;1最大</p>
<p>frame S-ALOHA: 规定一个周期 frame，包含若干个 slots，会更加有组织有秩序。reader 广播一个 frame length，tags 自己选择组织时间片（0~f-1），每个时间片开始 reader 轮询一下tag里sn信号是不是0，是0就发送，不是0就-1.</p>
<p>conflict slot, single slot, idle slot（空）</p>
<p>逻辑，电路设计，内存都比较简单，但是 frame length 长度不固定。tags 远远多于 frame length 冲突时间片就太多，tags 太少空时间片太多太浪费。负载 G&#x3D;1 也就是 length&#x3D;tags 利用率最好。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620001137399.png" alt="image-20230620001137399"></p>
<p>DFSA：利用以前的 frame 冲突反馈结果，和一些机器学习算法推测合适的 frame length。</p>
<p>EPC Global（第五章介绍）规范里使用了一种Q算法。简单说就是如果冲突太多了，当前 frame 就别继续了，中断，新开一个大容量 frame. 同理 空闲太多了就新开一个小 frame。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620002424045.png" alt="image-20230620002424045"></p>
<p>Qfp是指定的初始值。每次先取整，然后发起 query。</p>
<p>没有回复：Qfp-C C是一个参数，比如0.1.</p>
<p>有冲突&gt;1：+C。注意有上下限。</p>
<p>ALOHA 算法公平。<strong>但是可能发生饥饿</strong> ，比如有一个 tag 每次都是有冲突的 slot，一直没有办法被处理。</p>
<h2 id="Binary-tree-based-protocols-BT-QT-重点：执行过程"><a href="#Binary-tree-based-protocols-BT-QT-重点：执行过程" class="headerlink" title="Binary tree based protocols: BT, QT, 重点：执行过程"></a>Binary tree based protocols: BT, QT, 重点：执行过程</h2><p>第二种算法，基于二进制数。就像二叉树不断拆分冲突的结点变为两个结点，直到节点里只有一个 tag。</p>
<p>random binary tree BT：随机。</p>
<p>binary query tree QT：排序，查询。</p>
<p>每一个 tag 需要有一个计数器来记录自己的状态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620003431357.png" alt="image-20230620003431357"></p>
<p>每一个tag都会被识别，不会饥饿，但是需要存储每个tag的状态。</p>
<p>比如看下面的例子：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620004226401.png" alt="image-20230620004226401"></p>
<p>首先 tag1234 随机选一个数，比如选了0010，SN分别加自己选的数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010150624.png" alt="image-20230620010150624"></p>
<p>找SN&#x3D;0的，发现有是有，但是他们几个都冲突了。那么继续分，比如1011，SN&#x3D;1021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010254069.png" alt="image-20230620010254069"></p>
<p>2的SN&#x3D;0而且不冲突，把2读取了之后2不再继续参与。然后当有tag读取后，所有其他SN-&#x3D;1</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010408026.png" alt="image-20230620010408026"></p>
<p>&#x3D;0的是14，但是他俩冲突。然后再重新划分一下，比如011, SN&#x3D;0021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010452073.png" alt="image-20230620010452073"></p>
<p>然后处理1，其他-&#x3D;1，处理4，其他-&#x3D;1，处理3.</p>
<p>QT 不需要存储状态，如何实现？读取tag的序列号比较。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010802734.png" alt="image-20230620010802734"></p>
<p>不会饿死，也不需要一个可以读写的cnt，识别的时间和 tag id 有关。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011058481.png" alt="image-20230620011058481"></p>
<h2 id="Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程"><a href="#Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程" class="headerlink" title="Binary search: Manchester code instead of NRZ code, 重点：执行过程"></a>Binary search: Manchester code instead of NRZ code, 重点：执行过程</h2><p>具体分辨哪一位有冲突。1代表冲突。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011804411.png" alt="image-20230620011804411"></p>
<p>NRZ混合没法检测错误。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011902936.png" alt="image-20230620011902936"></p>
<p>曼彻斯特可以，一个上升一个下降，合起来是0或者1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011942870.png" alt="image-20230620011942870"></p>
<p>查询的流程：</p>
<ul>
<li>request：发送一个序列号给tags的transponder，如果tags的序列号小于给定序列号返回。</li>
<li>select：给定一个特定序列号，返回等序列号的tag。</li>
<li>read_data：返回所选tag的信息。</li>
<li>unselect：读取完data了，这个tag退出选择流程。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620012706251.png" alt="image-20230620012706251"></p>
<p>第一次迭代：返回uplink是所有transponder的id的共同信息（通过曼彻斯特编码找出没有冲突的位）。046位冲突了（从右往左），8个可能。</p>
<p>第二次迭代：限定 bit6 为0的request。发现有3个还是冲突04位（最高位冲突位&#x3D;0，其他冲突位&#x3D;1，如果range是大于等于，则正好相反）。</p>
<p>第三次迭代：限定bit4为0的request……</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620013603192.png" alt="image-20230620013603192"></p>
<p>长度 L(N)&#x3D;log2(N)+1</p>
<h2 id="Dynamic-binary-search-重点：执行过程"><a href="#Dynamic-binary-search-重点：执行过程" class="headerlink" title="Dynamic binary search, 重点：执行过程"></a>Dynamic binary search, 重点：执行过程</h2><p>Binary Search 是每次都传输完整二进制字符串. 其实我们只需要动态改变的部分.</p>
<p>比如我们查询1010 1111 1111, 那返回值前面一定是1010呀, 就不用传输了. 前缀叫 NVB, Number of Valid Bits</p>
<p>每次请求发送的信息: Request+NVB&#x3D;4+1010</p>
<h2 id="Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of ALOHA based anti-collision algorithm"></a>Advantages and disadvantages of ALOHA based anti-collision algorithm</h2><p>simple</p>
<p>good identification performance</p>
<p>results can be statistically analyzed 结果可以被统计化分析</p>
<p>缺点就是可能 starvation 饥饿，delay trend to ∞</p>
<h2 id="Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of binary tree based anti-collision algorithm"></a>Advantages and disadvantages of binary tree based anti-collision algorithm</h2><p>simple</p>
<p>intermediate state variables 不需要存储中间状态变量（QT）</p>
<p>缺点：查询时间受到 tags id 和 长度限制，比如二叉树沿着一个方向一直偏。</p>
<h1 id="5-EPCglobal-Standard-protocol"><a href="#5-EPCglobal-Standard-protocol" class="headerlink" title="5. EPCglobal Standard &amp; protocol"></a>5. EPCglobal Standard &amp; protocol</h1><h2 id="Concept-of-EPC-global-network"><a href="#Concept-of-EPC-global-network" class="headerlink" title="Concept of EPC global network"></a>Concept of EPC global network</h2><p>EPCglobal Network: a technology that </p>
<ul>
<li>allows trading partners to document and determine the location of individual goods </li>
<li>if possible in real time</li>
<li>additional information: such as 生产使用日期，能否被贸易伙伴交换</li>
</ul>
<h2 id="Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network"><a href="#Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network" class="headerlink" title="Five basic services of EPC global network, interaction of different components of EPCglobal network"></a>Five basic services of EPC global network, interaction of different components of EPCglobal network</h2><p>Electronic product code (EPC)</p>
<p>The identification system</p>
<p>EPCglobal Middleware</p>
<p>Discovery Service (DS)</p>
<p>EPC Information Services (EPCIS)</p>
<p>EPC码是唯一标识对象的代码。识别系统包括对象上的可被读取的包含EPC码的transponder和读取器reader可以识别EPC，然后通过EPCglobal Middleware传到网上，通过DS在 EPCglobal network 查找EPC码的相关信息（包括object naming service）。可以通过EPCIS和其他贸易伙伴交换EPC相关信息。</p>
<p>这其中的交互：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619112053963.png" alt="image-20230619112053963"></p>
<p>transponder and reader : data acquisition</p>
<p>Middleware</p>
<p>Discovery services</p>
<p>EPC Information Services : access to EPC-related data</p>
<h2 id="EPC-code-组成"><a href="#EPC-code-组成" class="headerlink" title="EPC code 组成"></a>EPC code 组成</h2><p>Domain Manager Number + Object Class Number + Serial Number</p>
<h2 id="Basic-procedures-of-the-EPC-Network"><a href="#Basic-procedures-of-the-EPC-Network" class="headerlink" title="Basic procedures of the EPC Network"></a>Basic procedures of the EPC Network</h2><p>EPC码用于标识对应对象</p>
<p>all information about the object 在EPCGlobal Network里注册 administer</p>
<p>each company in the EPCglobal Network: 各个公司管理数据集和数据对象</p>
<p>access rights to object data: 包含在EPCIS里，指明了trading partners 之间访问权限</p>
<ol>
<li><p>the manufacturer：把transponder和product绑定</p>
</li>
<li><p>all data assigned to the product：在EPCIS里</p>
</li>
<li><p>EPCIS registers the entries with EPC Discovery Services：注册了DS之后方能找得到EPCIS</p>
</li>
<li><p>product：卖给零售商 retailer</p>
</li>
<li><p>At the retailer’s goods-in point 数据存储在零售商EPCIS中</p>
</li>
<li><p>registered by EPCIS with EPC Discovery Services </p>
</li>
<li><p>The company prefix send to root EPCIS</p>
</li>
<li><p>root -&gt; local -&gt; the EPCIS</p>
</li>
</ol>
<h2 id="Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0"><a href="#Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0" class="headerlink" title="Binary tree based variant algorithm for EPCglobal Class 0"></a>Binary tree based variant algorithm for EPCglobal Class 0</h2><p>这种tag是只读的，制造商赋值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687148304873.png" alt="1687148304873"></p>
<h2 id="EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs"><a href="#EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs" class="headerlink" title="EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs"></a>EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs</h2><p>EPC C1G1：查询tags EPC的一种标准。</p>
<p>被动标签，支持kill和lock两种操作。</p>
<p>pingID：掩码，用于查询tag EPC</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197150310.png" alt="1687197150310"></p>
<p>EPC C1G2 有 OSI 的七层模型，两条数据链路（R-T）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197271532.png" alt="1687197271532"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687198440696.png" alt="1687198440696"></p>
<p>上电 ready</p>
<p>发 query 命令，aribtrate 仲裁。选择随机数生成时间片。</p>
<p>slot&#x3D;0 的开始 reply </p>
<p>tag 发 ack 给 reader，acknowledged 状态。</p>
<p>tag 收到 reader 的命令后进入 open，校验后进入 secured，完成 killed。</p>
<p>4个识别 tags 的命令：Select command, Query command, QueryRep command, QueryAdjust command</p>
<p>select 指明要查哪些 tags 的集合。</p>
<p>query 启动新的识别过程。</p>
<p>Rep 开启下一轮 slot 查询，标签 SN–，到0时读取。</p>
<p>Adjust 调整时隙数，选择新的时隙计数器等。</p>
<p>两大性能问题：</p>
<ul>
<li>Build a set of tags involved in the recognition process，如何建立正确的tags集合来查询（select 和 query 负责）</li>
<li>Select the way of data encoding, for the readerto-tag, the tag-to-reader, the reader itself and the  tag itself 根据环境调整编码方式</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RFID/" rel="tag">RFID</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院物联网Microprocessor微处理器笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/14/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%89%A9%E8%81%94%E7%BD%91Microprocessor%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B0/"
    >北邮国院物联网Microprocessor微处理器笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/14/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%89%A9%E8%81%94%E7%BD%91Microprocessor%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2023-07-13T23:00:00.000Z" itemprop="datePublished">2023-07-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/BUPT/">BUPT</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<p>主要围绕提纲里的所有问题展开，没有拓展内容，Exam oriented Study。</p>
<p>关注微信公众号：灰海宽松，回复 “微处理器” 可获取本文pdf格式。</p>
<h1 id="Introduction-随便聊"><a href="#Introduction-随便聊" class="headerlink" title="Introduction-随便聊"></a>Introduction-随便聊</h1><p>嵌入式系统是什么？专用的计算机系统。为专门功能可能对计算机架构，外设等做出一些取舍。</p>
<p>通常的限制：Cost（比如大量部署传感器节点），Size and weight limits（特定应用场景，比如下水道流量检测系统，需要体积小的节点），Power and energy limits（比如部署在极端环境下，喜马拉雅山顶采集节点，不方便去充电），Environment（防水，防高温等）</p>
<p>MCU MPU两种嵌入式系统区别：focus on 控制 还是 处理。控制比如点灯，机械臂，电机这些都是。处理比如摄像头采集到的数据进行图像处理。</p>
<p>编程语言：靠近计算机底层，主要使用汇编和c。</p>
<p>OS：嵌入式系统里不一定有操作系统结构。操作系统这个东西说白了就是更好地帮助管理计算机资源调度用的。现在我们来分析一下我们lab2的代码主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//background</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IRQ_Handler</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//interrupt handler function, frontground</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台部分：一个循环，重复去执行要做的任务。</p>
<p>这种方法乍一看也没啥问题。但是想想这样的计算机能做什么，只能按顺序执行一遍又一遍所有任务，甚至没法变顺序。</p>
<p>前台部分：中断处理，我们lab2里的uart_rx_isr函数，一般也用IRQ_Handler（实际上如果对lab2里的uart_rx_isr溯源一下，就会发现其实他也是被IRQ_Handler调用的，这个方法在启动对应中断时，触发中断就会自动调用）。</p>
<p>前后台合起来的系统还是一个裸机无os系统，只不过加了中断之后允许我们用中断的任务去打断后台轮询，改变一下执行顺序。比如串口中断发个数过来，CPU把手头后台的事情放下，去处理一下前台中断，处理完了再回来。</p>
<p>我们课程仅限于裸机开发的内容。</p>
<h1 id="计算机系统简要介绍"><a href="#计算机系统简要介绍" class="headerlink" title="计算机系统简要介绍"></a>计算机系统简要介绍</h1><h2 id="Von-Neumann-Architecture"><a href="#Von-Neumann-Architecture" class="headerlink" title="Von Neumann Architecture"></a>Von Neumann Architecture</h2><p>运算器控制器 (合在CPU中) 存储器 main memory 输入设备输出设备 IO，以及三条传输总线：数据，控制，地址 data bus &#x2F; control bus &#x2F; address bus.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686650488954.png" alt="1686650488954"></p>
<p>前面介绍过MPU重点在于数据计算处理，MCU则是控制，因此MPU不需要一些外设去控制外接的组件。</p>
<h2 id="Harvard-Architecture"><a href="#Harvard-Architecture" class="headerlink" title="Harvard Architecture"></a>Harvard Architecture</h2><p>和冯诺依曼区别就是在于指令和数据分开存储。这样寻指取指取数效率高。</p>
<h2 id="Stored-Program-Concept"><a href="#Stored-Program-Concept" class="headerlink" title="Stored Program Concept"></a>Stored Program Concept</h2><p>主要两个部分：RAM存储程序和数据，ROM存储不变只读的程序和数据。</p>
<p>cpu执行指令就是三个步骤的重复执行：fetch decode execute 取指解码执行</p>
<h2 id="assembly"><a href="#assembly" class="headerlink" title="assembly"></a>assembly</h2><p>如果高级语言相当于人话翻译给计算机，汇编语言相当于计算机语言翻译给我们。更贴近底层，因此运行效率也更高，而且可以直接操作硬件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD r3, r1, r2 	;r3 = r1 + r2</span><br><span class="line">SUB r3, r0, r3 </span><br><span class="line">MOV r2, r1 		;r2 = r1</span><br></pre></td></tr></table></figure>

<p>; 是注释。变量r123是寄存器register，是可以操纵硬件的部分，我们可以通过对其赋值来操作硬件。</p>
<p>高级语言通过 compiler 翻译为汇编语言，汇编语言通过 assembler翻译为二进制机器语言。</p>
<h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h1><p>ARM是一个指令集，前面讲的几个汇编指令这些都算做指令。</p>
<p>ARM公司有意思的地方是，他们不做ARM设备，他们只设计指令集架构，然后授权（知识产权核，IP核）给其他半导体厂商做。</p>
<p>A：application，主打高性能，手机电脑有许多就是ARM架构的。</p>
<p>R：realtime，主打实时，比如车联网对实时性要求很高。</p>
<p>M：microcontroller，应用于小型嵌入式系统，我们使用的板子。</p>
<p>m系列有m0到m7（简单说就是性能逐渐增加？），而且向下兼容即m7兼容m0~m6.</p>
<h2 id="SoC"><a href="#SoC" class="headerlink" title="SoC"></a>SoC</h2><p>我们的板子上有一个黑色的小芯片，上面写着stm32blabla一串字符。这个就是整个板子的核心，相当于囊括了上文提到的计算机架构的芯片结构，system on chips。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686658267695.png" alt="1686658267695"></p>
<p>设计soc规则：首先选用IP核，设计ARM处理器，外加一系列存储、IO外设结构，全部集成在黑芯片上。</p>
<p>ARM处理器 processor 是 architecture 的具体涵盖，多了很多新内容比如定时器。</p>
<p>我们主要学习m4架构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686658682835.png" alt="1686658682835"></p>
<p>只看非optional大概了解即可，处理器核访问代码，数据接口。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>前面我们已经简单介绍了register。事实上如果想对内存中数据做处理，也要先拿到处理器核中的寄存器里做运算，然后返回回去。</p>
<p>arm register 如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686659016141.png" alt="1686659016141"></p>
<p>通用寄存器：临时变量，可以存储计算数据之类的。</p>
<p>SP：栈顶指针寄存器，指向栈顶。</p>
<p>LR：函数返回用，保存返回地址。比如要调用函数了，把PC的值存入LR，然后PC跳转到函数起始位置；函数返回的时候LR的值还给PC。</p>
<p>PC：指向程序当前执行到的位置（下一个要执行的指令的地址）程序计数器。每条指令取了之后PC自动加一条指令，比如32位指令集PC+&#x3D;4B。</p>
<p>PSR系列是状态寄存器，指明当前程序状态。比如当前是用户模式还是内核模式？IPSR指明当前是否允许中断？等。</p>
<p>xPSR包括：</p>
<ul>
<li>APSR：计算用，如标志是否进位，结果是否为0，是否为负，是否溢出等。</li>
<li>IPSR：中断处理相关。</li>
<li>EPSR：执行相关，指明指令集，中断是否继续等信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686659814546.png" alt="1686659814546"></p>
<h2 id="Memory-Map"><a href="#Memory-Map" class="headerlink" title="Memory Map"></a>Memory Map</h2><p>m4有4g的内存空间默认映射到一片空间中，用户也可以根据自己喜好修改。有存储代码的code region，存储数据的sram region，存储外设的peripheral region，external ram region，external device region，Internal Private Peripheral Bus (PPB)。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686669411390.png" alt="1686669411390"></p>
<h2 id="Bit-band-Operations"><a href="#Bit-band-Operations" class="headerlink" title="Bit-band Operations"></a>Bit-band Operations</h2><p>位带操作。</p>
<p>如果我们要读写32位数据中的某一位，比如第三位（从左往右是31:0，第三位是右边第4个），有的寄存器允许我们直接获取r[3]，但是大多数是不允许直接获取的。</p>
<p>如何处理？如果写入1，那么r|0000 0000 0000 0000 0000 0000 0000 1000.</p>
<p>如果写入0，那么 r &amp; 1111 1111 1111 1111 1111 1111 1111 0111.</p>
<p>读取：看 r &amp; 0000 0000 0000 0000 0000 0000 0000 1000 结果是否为0.</p>
<p>这样很麻烦，比如我们要给0x2000 0000处的数据第3位写1，详细汇编代码：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232342659.png" alt="image-20230613232342659"></p>
<p>LDR是把后面的数据加载到前面的寄存器中，[R1]是把R1的值当做一个地址，取得其中存储的数据。</p>
<p>这样挺麻烦的，但是因为有内存映射我们可以直接写入和获取“位带别名地址”中的数据。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232721037.png" alt="image-20230613232721037"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232713587.png" alt="image-20230613232713587"></p>
<p>0x2000 0000处的第0位到第31位分别是：</p>
<p>0x2200 0000</p>
<p>0x2200 0004</p>
<p>0x2200 0008</p>
<p>0x2200 000c……</p>
<p>0x2200 007c</p>
<p>所以直接获取，修改0x2200 000c的数据即可。</p>
<p>0x2000 0000映射到0x2200 0000是 sram 区域映射，0x4000 0000映射到0x4200 0000是外设 peripheral 区域映射。</p>
<p>操作更快，指令更少，而且只访问一位更安全，比如刚取出0x2000 0000的32位数据，这时候中断修改了0x2000 0000的数据，这时我们取得的数据就是旧的错误数据了，修改完第3位再写回去，相当于中断白改了。</p>
<h2 id="Program-Image"><a href="#Program-Image" class="headerlink" title="Program Image"></a>Program Image</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686670722574.png" alt="1686670722574"></p>
<p>vector：向量表，存储比如main堆栈的地址（MSP），异常的地址等信息。</p>
<p>start-up：板子上电或rst时的启动代码。</p>
<p>program code：我们烧进去的程序代码。</p>
<p>c lib code：库函数代码。</p>
<p>复位时，先读取 msp 地址找到 main 在哪。然后读取 reset vector 执行 BIOS 初始化代码，再开始读取第一条，第二条指令……</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686670972039.png" alt="1686670972039"></p>
<h2 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h2><p>两种存储规范。</p>
<p>比如十进制数字，1234，一千二百三十四。然后我们记录到数据库中，地址从低到高存储为4321，权值大的位1存在地址最高处，这就是大端存储 Big endian。否则，权值大的位存在地址低处，1234地址从低到高，就是小端存储 Little endian。m4两种方法都支持。</p>
<blockquote>
<p>术语“little endian(小端)”和“big endian(大端)”出自Jonathan Swift的《格列佛游记》（Gulliver’s Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。</p>
<p>一下是Jonathan Swift在1726年关于大小端之争历史的描述：</p>
<p><em>“……下面要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由Blefuscu的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”（此段译文摘自网上蒋剑锋译的 《格列佛游记》第一卷第4章。）</em></p>
<p>在他那个时代，Swift是在讽刺英国（Lilliput）和法国（Blefuscu）之间的持续的冲突。Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了.</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/316347205">大端、小端基础知识 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="Instruction-Set"><a href="#Instruction-Set" class="headerlink" title="Instruction Set"></a>Instruction Set</h2><p>指令集。早期arm指令集32位，性能好能实现的功能强大。但是太长了处理效率低。</p>
<p>thumb-1 指令集16位，处理效率高了，性能也降了。早期arm架构如果是支持两种指令集的，就要频繁切换模式，效率低。</p>
<p>后来thumb-2指令集包含早期16位和新的32位，和arm指令集的混合指令集性能没减太多，代码量和处理效率还高了。</p>
<h1 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h1><p>汇编语法。</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">label							; 可省略，用于跳转到此位置</span><br><span class="line">	助记符 operand1, operand2, … ; Comments</span><br><span class="line">	</span><br><span class="line">MOV r1, #0x01					; 数据0x01放入r1</span><br><span class="line">MOV r1, #&#x27;A&#x27;					; 数据A的ascii码放入r1</span><br><span class="line">MOV R0, R1 						; move R1 into R0</span><br><span class="line">MOVS R0, R1 					; move R1 into R0, 并且更新APSR的状态</span><br><span class="line"></span><br><span class="line">LDR R1, [R0]					; R0存的是一个地址值如0x2000 0000, 这个指令是取出R0代表的地址中的数据存入R1</span><br><span class="line">STR R1, [R0]					; 写回去</span><br><span class="line">LDR R0, =0x12345678 			; Set R0 to 0x12345678</span><br><span class="line">; 等效于：</span><br><span class="line">; LDR R0, [PC, #offset] </span><br><span class="line">; ...</span><br><span class="line">; DCD 0x12345678</span><br><span class="line">; 也就是先在文档末尾的一条指令里写入数据0x12345678，然后编译器自动计算PC+多少offset到达DCD的位置，把其值返给R0</span><br><span class="line">; DCD是声明一个字 32bit，DCB是声明一个Byte</span><br><span class="line">; 如果多个数值的声明可以用标签声明</span><br><span class="line">LDR R3, =MY_NUMBER</span><br><span class="line"></span><br><span class="line">ALIGN 4 ; 字要先用这个声明，代表停止长度</span><br><span class="line">MY_NUMBER DCD 0x2000ABCC</span><br><span class="line">HELLO_TEXT DCB “Hello\n”, 0 ; Null terminated string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDRB R1, [R0]					; B: 只写8位，就是说R0地址处的数据写入R1后，R1高24位清零</span><br><span class="line">SDRH R1, [R0]					; H: 只写16位</span><br><span class="line"></span><br><span class="line">LDRSH R1, [R0]					; 视作signed有符号数，写16位</span><br><span class="line"></span><br><span class="line">LDRB R0, [R1, #0x3]				; 从R1+3读取一个字节给R0</span><br><span class="line">LDR R3, [R0, R2, LSL #2]		; 从R0+（R2&lt;&lt;2)读取一个字节给R3</span><br><span class="line">LDR R0, [R1], #4				; 赋完值后，令R1=R1+4</span><br><span class="line"></span><br><span class="line">ADD R0, R0, R1</span><br><span class="line">ADDS R0, R0, R1					; 加完更新APSR状态，比如有溢出或者进位则更新</span><br><span class="line">ADC R0, R1, R2					; R1+R2还要+APSR的carry位</span><br><span class="line"></span><br><span class="line">; SUB SBC类似</span><br><span class="line"></span><br><span class="line">MUL R0, R1, R2</span><br><span class="line">UDIV R0, R1, R2</span><br><span class="line">SDIV R0, R1, R2					; signed</span><br></pre></td></tr></table></figure>

<p>例题：应该是因为有可能减成负的所以signed</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686672985123.png" alt="1686672985123" style="zoom:50%;" />

<p>指令有1字长，半字长的。hw1是指明功能用的，hw2是一些拓展比如立即数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686713591015.png" alt="1686713591015"></p>
<p>地址从低到高分别是：4F F0 0A 00 0A 68 10 44……</p>
<p>PC每次取到半个字 hw，就+2B跳转到下一个hw。</p>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	CMP R0, R1						; 相当于if，比较后更新APSR。EQ= LT&lt; GT&gt; LE&lt;= GE &gt;=</span><br><span class="line">	BEQ BRANCH_1					; B是跳转，BL是跳转到函数执行完后返回，BX是根据地址最低位判断目标地址是arm还是thumb在决定跳转到整字还是半字。bx操作数不能是立即数，必须是寄存器</span><br><span class="line">	B BRANCH_2</span><br><span class="line">	</span><br><span class="line">BRANCH_1</span><br><span class="line">	...</span><br><span class="line">	B IFEND							; 不写这个就继续执行BRANCH_2了，像switch的break</span><br><span class="line">BRANCH_2</span><br><span class="line">	...</span><br><span class="line">B IFEND</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WHILE_BEGIN </span><br><span class="line">	UDIV R2, R0, R1 ; R2 = n / x</span><br><span class="line">	MUL R3, R2, R1 ; R3 = R2 * x</span><br><span class="line">	CMP R0, R3 ; n == (n / x) * x</span><br><span class="line">	BEQ WHILE_END</span><br><span class="line">	SUBS R1, R1, #1 ; x--</span><br><span class="line">	B WHILE_BEGIN ; loop back</span><br><span class="line">WHILE_END</span><br></pre></td></tr></table></figure>

<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>内存中有一片内存空间类似栈的数据结构。SP指针指向栈顶。</p>
<p>这个栈地址是从高到低的，也就是存入数据 SP–，取出数据 SP++，类似一个翻转过来的，倒着的书堆。</p>
<p>满堆栈：sp指针指向最后一个栈顶数据。</p>
<p>空堆栈：指向最后一个数据的下一个要放入数据的空位置。</p>
<p>我们的课程中使用空堆栈，指向下一个空位置，存数据就先存入再SP-4，取数据就先SP+4再出栈。不过这两条指令都不需要我们手动执行，有专门的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0, R4-R7&#125; 	; Push r0, r4, r5, r6, r7</span><br><span class="line">POP &#123;R2-R3, R5&#125; 	; Pop to r2, r3, r5。入栈出栈顺序不是按照书写顺序而是自动根据寄存器地址，高地址值给高地址寄存器</span><br></pre></td></tr></table></figure>

<p>存入5个数据和取出3个数据。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>BL先保存当前PC值到LR，然后PC跳转到函数地址，</p>
<p>BX LR跳转到LR中的地址用于函数返回。</p>
<p>Architecture Procedure Call Standard (AAPCS) ：规范定义哪些寄存器主函数和函数通用，哪些是独有的。</p>
<p>arm AAPCS规定：r0-r3是通用寄存器（类似全局变量），但main和函数的R4 – R8, R10-R11不通用（类似临时变量，到了函数里这些值就变了，不是原函数的），要压入栈保存。函数调用和返回的时候要保存和恢复通用寄存器值。这些由调用原函数的子函数 callee-procedure 执行。</p>
<p>简单的参数的函数调用：传参给R0-R3作为函数参数，R4-R11压入栈，然后跳转到函数处。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686733381292.png" alt="1686733381292"></p>
<h2 id="Program-Memory-Use"><a href="#Program-Memory-Use" class="headerlink" title="Program Memory Use"></a>Program Memory Use</h2><p>ROM里都是只读数据，比如常量常数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686733480351.png" alt="1686733480351"></p>
<h2 id="const-static-volatile"><a href="#const-static-volatile" class="headerlink" title="const, static, volatile"></a>const, static, volatile</h2><p>貌似是不会过多涉及具体代码实现的部分，就先简单介绍一下了。</p>
<p>const 就是定义常量变量，定义后无法再次修改。</p>
<p>static 通常定义静态函数，静态函数里的值是通用的，也就是每次调用该函数其值都是接着上次调用该函数的值继续。</p>
<p>volatile：一个在嵌入式里挺重要的东西，软考题里出现过几次。大概就是禁止编译器优化该变量来防止不必要的错误。</p>
<p>比如编译器优化num变量，这样每次修改num变量的值的时候都不会立刻写入内存中，可能会先把修改时的值写入寄存器，函数返回时写回内存。</p>
<p>现在比如我们在main中num+&#x3D;5, 修改值后的num暂时存在寄存器里。然后我们调用中断，从内存中读取当前num的值并+1.但是内存中值还没改，还是原值。返回后，main再把自己手中的num值写回内存，最后内存中num值只+5，而不是我们期望的+6.</p>
<p>volatile 声明后的变量不会做这样的优化，值改变了就立刻写回内存，虽然可能效率低但是安全。</p>
<h1 id="Interrupts"><a href="#Interrupts" class="headerlink" title="Interrupts"></a>Interrupts</h1><p>比如我们程序的逻辑是按键按下的时候点亮小灯。第一种做法是 Polling 轮询，一直看：按键按下了吗？没有。按下了吗？没。按下了吗？……</p>
<p>这样主要是效率低浪费CPU资源，如果为了节约资源轮询间隔大了，又不能及时响应。</p>
<p>中断允许CPU专心处理background的事情，触发中断的时候先放下后台处理前台。对于无os的裸机也能实现简单的多线程切换。</p>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><ol>
<li><p>结束当前正在执行的指令。</p>
</li>
<li><p>当前模式寄存器值压栈保存。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230614171134845.png" alt="image-20230614171134845"></p>
</li>
<li><p>切换模式。</p>
</li>
<li><p>PC LR更新（根据异常处理器提供的值）。PC去查中断向量表，看要跳到哪里，EXC_RETURN Code赋值给LR。</p>
</li>
<li><p>更新IPSR状态。</p>
</li>
<li><p>开始执行异常代码。</p>
</li>
<li><p>退出，BX LR把 EXC_RETURN Code 值返回给PC。</p>
</li>
<li><p>出栈。</p>
</li>
</ol>
<h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h2><p>中断执行也是耗时的，需要一定的时间保存源程序状态，执行中断，恢复。</p>
<p>FMax_Int：最大中断执行频率，即：单位时间内最多执行几次中断。</p>
<p>F_CPU：CPU频率，即：单位时间内CPU有多少次指令周期。</p>
<p>C_ISR：执行中断内容需要多少周期。</p>
<p>C_Overhd：中断保存、恢复数据等准备工作用多少周期。</p>
<p>中断一次执行所需周期：C_Overhd+C_ISR</p>
<p>因此， $F_{Max_Int&#x3D;}F_{CPU}&#x2F;(C_{ISR}+C_{Overhd})$</p>
<p>U_int：中断处理实际消耗的利用率，上面那个毕竟是最大值。</p>
<p>$U_{int}&#x3D;F_{Int}&#x2F;F_{Max_Int}$</p>
<p>中断执行速度（和频率一样）：F_Int</p>
<p>非中断执行速度：(1-U_Int)*F_Int</p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><p>General Purpose Input Output, </p>
<h2 id="Memory-Mapped-IO"><a href="#Memory-Mapped-IO" class="headerlink" title="Memory-Mapped IO"></a>Memory-Mapped IO</h2><p>把设备，控制等寄存器映射到内存里。好处就是访问设备方式和内存一样，也不用设计复杂的IO电路，便捷；缺点在于占用了内存空间。</p>
<h2 id="Peripheral-Mapped-IO"><a href="#Peripheral-Mapped-IO" class="headerlink" title="Peripheral-Mapped IO"></a>Peripheral-Mapped IO</h2><p>IO有一块专门的存储区域，和内存不一样，也有专门的不同的电路指令去访问IO。好处就是节省内存空间，也能清晰的知道什么时候发生IO了；缺点在于开发、设计上的造价增加。</p>
<h2 id="GPIO-1"><a href="#GPIO-1" class="headerlink" title="GPIO"></a>GPIO</h2><p>通用IO可以判断引脚高低电平，可以给引脚赋值高低电平进行控制。</p>
<p>stm32有几组GPIO，每个有16个Pin，可以配置为input output pullin pullup等模式，以及定时器、串口、中断等功能。</p>
<p>什么是上下拉模式？如果不设置为上下拉，引脚浮空的时候（没有设置输入为高或低电平的时候）浮空引脚可能收到电磁波干扰等等问题导致输入状态不确定，有0有1的，容易造成错误。</p>
<p>下拉：三极管控制默认接地，无输入的时候默认低电平。</p>
<p>上拉：三极管控制默认接Vdd 芯片工作电压。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686742220470.png" alt="1686742220470"></p>
<p>大多数引脚是这两个功能都有的，我们初始化GPIO的时候选用一个，寄存器根据值控制接通相应电路。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230614193552367.png" alt="image-20230614193552367"></p>
<p>输入输出信号真的可以被称为“信号”。输入规定为0-0.5视作低电平，0.5-Vdd视作高电平，范围以外的值无效。输出电流也只有5mA左右是没有能力直接驱动一些设备的，我们可以通过一些电路比如三极管，放大器等，电路接收到信号得知”需要输出驱动电流了“然后输出大电流。</p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p>每个GPIO口有：</p>
<p>4 * 32bit configuration registers: 配置相关信息，比如in&#x2F;out，上啦下拉，开漏输出或推挽输出，输出频率等。</p>
<ul>
<li>推挽输出 push-pull：能输出高低电平。</li>
<li>开漏输出 open-drain：没有能力输出高电平，想输出高电平需要设置上拉电路来输出。</li>
</ul>
<p>2 * 32bit data registers: 输入输出数据寄存器。</p>
<p>1 * 32bit set&#x2F;reset registers: 设置或复位寄存器。</p>
<p>1 * 32bit locking registers: 锁定寄存器。</p>
<p>2 * 32bit alternate function selection register.</p>
<h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>如图，32个Pin，每个两位来设置4种模式（in out 可选 模拟）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743308300.png" alt="1686743308300"></p>
<h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>只有3种模式（无pull，上拉，下拉）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743360055.png" alt="1686743360055"></p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>输入输出数据寄存器分开的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743538223.png" alt="1686743538223"></p>
<h2 id="CMSIS"><a href="#CMSIS" class="headerlink" title="CMSIS"></a>CMSIS</h2><p>先说一下考试定义：</p>
<p>CMSIS transforms memory mapped registers  into C structs </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT0 ((struct PORT*)0x2000030)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686747214412.png" alt="1686747214412"></p>
<p>再说一下和一些嵌入式前辈讨论的理解，以下内容不许考试写：</p>
<blockquote>
<p>李肯老师：arm-M推出的一系列API和软件组件，包括核心功能、DSP库、RTOS支持和调试接口等。</p>
<p>李肯老师：如果芯片厂不想再多一层，CMSIS就够用；但有的厂商会再在上面封一层，可能叫driver层。</p>
<p>李肯老师：另外CMSIS有个限定，就是ARM的ARM Cortex-M处理器；虽然它很常见，但并不是所有的处理器都是这个内核；这个需要注意。</p>
<p>榊：这种与内核相关的文件，比如启动文件，内核文件是CMSIS规定。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/a6953d9ebb72f2ecd6cc4dbf569d406.png" alt="a6953d9ebb72f2ecd6cc4dbf569d406"></p>
<p>榊：对比STM32F103和GD32E23的启动文件，我们会发现是一样的：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/711dd8daa73cb3dd198e50f32f6f86a.png" alt="711dd8daa73cb3dd198e50f32f6f86a"></p>
<p>榊：而芯片厂商要做的是根据这个arm规定的接口二次开发库函数。</p>
</blockquote>
<p>李肯老师c站账号：<a target="_blank" rel="noopener" href="https://blog.csdn.net/szullc">架构师李肯的博客_CSDN博客-程序人生,粉丝福利领域博主</a></p>
<p>榊老师c站账号：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63922192">风正豪的博客_CSDN博客-C语言,MSP430F5529,Linux领域博主</a></p>
<p>平时李肯老师的交流群会讨论很多嵌入式相关问题，欢迎有兴趣的同学来学习[Doge]</p>
<p>以上内容感兴趣的看个乐呵。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">Reset, <span class="comment">//!&lt; Resets the pin-mode to the default value.</span></span><br><span class="line">Input, <span class="comment">//!&lt; Sets the pin as an input with no pull-up or pull-down.</span></span><br><span class="line">Output, <span class="comment">//!&lt; Sets the pin as a low impedance output.</span></span><br><span class="line">PullUp, <span class="comment">//!&lt; Enables the internal pull-up resistor and sets as input.</span></span><br><span class="line">PullDown <span class="comment">//!&lt; Enables the internal pull-down resistor and sets as input.</span></span><br><span class="line">&#125; PinMode;</span><br><span class="line"></span><br><span class="line">gpio_set_mode(P1_10, Input);</span><br><span class="line">gpio_set_mode(P2_8, Output);</span><br><span class="line"><span class="type">int</span> PBstatus=gpio_get(P1_10); </span><br><span class="line">gpio_set(P2_8, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码是老师提供的driver，大意就是选定pin，传入特定参数，即可设置模式，设置输出。</p>
<p>感兴趣可以看看我的这篇文章，如果使用arm定义的cmsis直接去开发也是可以的：</p>
<p><a target="_blank" rel="noopener" href="https://jingqing3948.blog.csdn.net/article/details/130299783">STM32 学习笔记_4 GPIO：LED，蜂鸣器，按键，传感器的使用_灰海宽松的博客-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 控制gpio需要三个步骤：开启rcc时钟，初始化，输入输出函数控制 */</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_0);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>drivers二次开发，可以帮助简化。</p>
<p>当然这一段都是题外话了。考试就理解为“cmsis是变量宏定义直接映射到寄存器上；drivers是对其添加进一步行为”即可。</p>
<h1 id="Serial-Communication"><a href="#Serial-Communication" class="headerlink" title="Serial Communication"></a>Serial Communication</h1><p>串口通信，一种发送消息的通信方式。</p>
<p>串，指的是发数据的方式：一位一位串行发，并行是可能有多路通道，每路同时发一个数据，多路同时到达。</p>
<p>串口通信有单工 Simplex，半双工 Half Duplex，全双工 Full Duplex。</p>
<p>两种传输方式：同步 Synchronous，共用一个时钟；异步 Asynchronous，有各自的时钟。</p>
<p>同步很简单，发送方接收方比如都规定时钟信号下降沿收发。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686749582568.png" alt="1686749582568"></p>
<p>异步：需要通过异步通讯协议 Asynchronous Comm. Protocol 来协调。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686749956698.png" alt="1686749956698"></p>
<p>1位起始位标志开始传输，7&#x2F;8&#x2F;9位数据位，1位可选奇偶校验位，1位停止位。</p>
<p>RT两方需要有相同的波特率。</p>
<p>当然这只是最简单的串口通信因为只有双方。如果更多方通信我们需要校验地址来判断是哪个发给哪个；数据需要更复杂的校验方式。</p>
<p>异步通信不需要同步时钟之类电路，开销小，但是开发起来难度大一些因为需要起始结束位啥的。</p>
<h2 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h2><p>异步通信，Reversed Polarity 标准电压（-3<del>-15是1,3</del>15是0.还有一些其他标准比如TTL是+5为1，-5为0.）</p>
<p>发送数据有两种类型，ascii码和二进制，都得转化为二进制传输。</p>
<h2 id="uart"><a href="#uart" class="headerlink" title="uart"></a>uart</h2><p>针对stm32f401.</p>
<p>全双工异步串口。</p>
<p>为了处理RT缓冲数据（因为发收数据需要时间）我们可以通过缓冲区数组，头指针表示已经发到的位置，尾指针表示要发的数据的结尾。增加新数据，尾指针++；发一个数据，头指针++直到碰到尾。</p>
<p>原来发送方一直是发高电平，start frame 起始帧是1帧低电平来表示开始发数据了。</p>
<p>如何判断是1帧低电平？通过在这一帧里多次采样判断是不是真的是一帧低电平。</p>
<p>为什么多次采样？因为异步两个信号有一定的偏移，多次采样准，能确定是不是真的一整帧都低电平。</p>
<p>采样是有一定采样率的，不是说真的能像模拟信号一样一直采。</p>
<p>采样率 oversampling&#x3D;16: 这个是最大可以达到的采样频率而不是真的一帧采了16次。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686756691253.png" alt="1686756691253"></p>
<p>接收方首先第一次检测到0位，开始怀疑：有可能是串口有消息。这是start frame的第一次采样。</p>
<p>然后每隔一帧检测一次，3 5 7检测3次，如果2个都是0，说明确实有可能。</p>
<p>然后连着检测8910，如果还是2个0，说明确实是start frame。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686756881390.png" alt="1686756881390"></p>
<p>8采样率因为采样间隔长了，更容易碰到左右边界的高电平，所以容错率低。但是速度更快。</p>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>波特率计算：</p>
<p>$T_x&#x2F;R_x(baud)&#x3D;\frac{f_{PCLK}}{8*(2-OVER8)*USARTDIV}$</p>
<p>OVER8是过采样率，fPCLK是时钟频率。</p>
<p>USARTDIV是一个浮点数</p>
<p>USARTDIV浮点数怎么存储？通过算法转化为十六进制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686759124660.png" alt="1686759124660"></p>
<p>小数部分用一个16进制位表示，比如例1是C也就是12，转换后即为12&#x2F;16也就是0.75.</p>
<p>例2转换为一位16进制，就是0.62*16约等于10也就是A。</p>
<p>整数部分直接转换十六进制即可，例2的25转为19，例1的27转为1B。</p>
<p>然后整数小数部分拼接起来（最多3个整数位，1个小数位，32位寄存器）。</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>想让程序定时运行，比如led 1s闪烁一次。如何做到？</p>
<p>第一种方法是愚蠢的delay延时，我自己估算一下：嗯，delay(2000)差不多1s。然后在程序中delay，点亮，delay，熄灭……</p>
<p>太浪费资源了。</p>
<p>第二种方法，32是有定时器中断的。</p>
<p>定时器中断大概原理是，32上有时钟晶振按固定频率周期输出0101010……定时器里有一个cnt，收到一个时钟晶振就++。</p>
<p>我们可以设置定时器溢出值，比如溢出值是1000，cnt加到1000会自动触发定时器中断。然后归0，继续++。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230615014136641.png" alt="image-20230615014136641"></p>
<p>执行周期数量：1+1+1+1+(0xFFFFFFFF一直-1-1-1直到变为0x00FFFFFF的循环次数)+(r0+1的执行次数，1次)</p>
<p>定时器也有一些扩展方法，比如我们可以设定++还是–；可以设定信号源是时钟或者外部输入的方波信号；可以读取计数值……</p>
<p><strong>我们课件常用方法好像是–到0触发中断，然后恢复初值。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686764952191.png" alt="1686764952191"></p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>PWM这个东西是什么？</p>
<p>PWM（Pulse Width Modulation）脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域。</p>
<p>就好比说，你骑自行车速度只能是100和0，模拟电信号只能输出高低。</p>
<p>但是呢，你骑自行车是有惯性的，以100速度蹬一脚，以0速度蹬1脚，100速度蹬一脚……</p>
<p>整体来看你的自行车平均速度是50（我们假设加速度不需要时间哈）</p>
<p>这个应用场景有很多，比如设定led闪烁频率：高低高低高低……，因为频率极高，我们肉眼看不出来在闪，给我们呈现的视觉效果就是以一半的亮度在亮。高低低高低低就是1&#x2F;3亮度。</p>
<p>比如电机通过这个方式调速度。</p>
<p>那么他有什么应用场景。第一，输入捕获 Input capture。</p>
<p>对于一个这种有惯性的系统，我们也可以反过来读取其波形来判断其速度。比如电机放一个转速检测传感器，把输入波形作为定时器的时钟源信号，定时器一直++：检测上升下降沿时记录cnt值，通过差值比较计算时间间隔。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230615020829378.png" alt="image-20230615020829378"></p>
<p>第二，输出比较 output compare。</p>
<p>定时器一直++，与预先设定好的阈值比较，如果相等触发中断输出。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686767856060.png" alt="1686767856060"></p>
<p>这就是PWM。占空比相当好算。</p>
<h2 id="Low-Power-Timer"><a href="#Low-Power-Timer" class="headerlink" title="Low Power Timer"></a>Low Power Timer</h2><p>我们目前假设的是CPU一直运作的，只是在后台和前台之间切换。有一种低功耗定时器使得没有发生定时器中断的时候CPU被置为低功耗状态，只有发生定时器中断的时候才启动。（使用 __WFI() wait for instruction 指令）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235021294.png" alt="image-20230621235021294"></p>
<h2 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h2><p>M系列自带的一个系统时钟，使用处理器时钟或者参考时钟作为时钟源。</p>
<p>有四位寄存器：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235527699.png" alt="image-20230621235527699"></p>
<p>每次赋值是load，一直–到0时重新load赋值。ctrl是控制启用系统时钟。这个是CMSIS有提供的数据结构和相关操作函数的时钟处理部分。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235805628.png" alt="image-20230621235805628"></p>
<p>init 参数是中断间隔的毫秒数。timer_set_callback() 里跟一个可以是自己定义的函数，使得触发定时器中断时该函数被执行。以上代码意思是每隔100ms LED灯翻转一次，且 CPU 常态下处于低功耗状态。</p>
<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><p>连接多个模块的传输方案：I2C，使用两根总线。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622000302459.png" alt="image-20230622000302459"></p>
<p>两根总线分别是时钟总线 SCL 和数据总线 SDA。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>现在我们串一遍I2C上一个模块（master）要给另一个模块（slave）发消息的过程。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687363434463.png" alt="1687363434463"></p>
<ol>
<li>MCU 使用一定的方法标识自己开始传输了。</li>
<li>MCU 发送 LCD slave 的地址+一位读写位，其他模块接收到发现地址不是自己的，就不做处理。</li>
<li>LCD 接收到后知道目标是自己，于是返回 ack。</li>
<li>MCU 收到 ACK 后发送一帧数据。</li>
<li>发送完 MCU 等着 ACK，收到 ACK 后继续发送下一帧数据。</li>
<li>一直发送到发送停止位 stop 结束。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622000920336.png" alt="image-20230622000920336"></p>
<p>数据长度可以设置，比如789.</p>
<p>总线上的器件是开漏输出的半双工通信。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713135505107.png" alt="image-20230713135505107"></p>
<p>默认总线是上拉电阻拉成高电平。</p>
<p>当器件输出 out 为低电平时，总线导通到接地，总线被拉低（整条总线都被拉低）。江协科技老师举的例子很好，就像公交车上的一根横杆，有人拉住横杆拽下来，整条横杆都被拉低了，其他人都知道“横杆被一个人拉低了，说明有人正在使用总线”。</p>
<p>然后是总线传输数据的方式，SCL SDA 两根总线在何种情况下表示 start stop 0 1 bit? </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713140225426.png" alt="image-20230713140225426"></p>
<p>首先都是 SCL 为高电平时 SDA 的数值才有意义。</p>
<p>SDA 从高到低，表示 start 位。从低到高，表示 stop 位。</p>
<p>start 位后，SDA 高电平表示1，低电平表示0.</p>
<p>发送完 1byte 数据后，总线保持拉高状态。如果接收方把总线拉低了，发送方发现总线1→0了（不是发送方自己拉的，是接收方给他拉下来的，但是发送方能察觉到），说明接收方成功接收了并且拉了拉总线以示“收到”。如果 SDA 还是保持在高电平，说明接收方没有成功收到或者成功发送 ACK。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713140822834.png" alt="image-20230713140822834"></p>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>I2C 是一种很简单的主从通信协议了，但是局限性也很多，比如7 bit 的地址线只允许 2^7 个设备；一次顶多两个设备主从通信；一个设备的快慢会影响到整条总线的通信等。</p>
<p>问题1：从设备处理速度太慢了，赶不及在下一个时钟周期接收新数据帧怎么办？</p>
<p>方法：clock stretching, 拉低一段时间 SCL 假装下一个时钟周期还没到。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713141906054.png" alt="image-20230713141906054"></p>
<p>问题2：多个设备同时发数据冲突了怎么办？</p>
<p>方法：Bus Aribitation，前面我们知道总线被一个设备拉低了，所有设备都能接收到总线拉低的信号。因此如果两个设备同时开始发信息，前面数据一致都无所谓，等到第一次数据不一致的时候，一个设备发送数据0，一个发送数据1，这时 SDA 总线被 DATA2 的0拉低了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713142029471.png" alt="image-20230713142029471"></p>
<p>发送 DATA1 数据的设备就明白了：有人同时在和我一起发数据，因此总线不是我预期的1而是被他拉低为0了。那我 quit，你发吧。然后就只有 DATA2 发送的数据了。</p>
<p>问题3：以上发送的数据每次都是 1byte 8bits 很正好。那如果要发送的地址不是 8bits 呢？</p>
<p>方法：少于 8bits 用一些固定的额外的 start 位填充，多于 8bits 的地址用两个 bytes，不够的也是用额外的 start 位填充。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143052018.png" alt="image-20230713143052018"></p>
<p>问题3：如果我 master 发完数据，想紧接着再收数据，变成 slave，可行吗？</p>
<p>方法：通过一个 sr 信号，也就是 repeat start 重发 start 位，来标识自己是 read 而不再是 write 了重新开始通信。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143601570.png" alt="image-20230713143601570"></p>
<h2 id="编址格式"><a href="#编址格式" class="headerlink" title="编址格式"></a>编址格式</h2><p>slave 地址编址有一些固定格式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143744619.png" alt="image-20230713143744619"></p>
<p>0000 000 0：广播，对所有 slave 结点讲话。如果 slave 无视（NACK），就不会参与广播。如果返回 ACK 就参与进来了。不过多个 slave 都返回 ACK 的话 master 是不知道都有谁回应了的。</p>
<p>第二个 byte 发送一些行为相关，比如：start，clear，reset software</p>
<h2 id="编程应用"><a href="#编程应用" class="headerlink" title="编程应用"></a>编程应用</h2><p>slave mode: </p>
<ul>
<li>I2C 设备默认工作在 slave mode。</li>
<li>外设时钟在 I2C_CR2 寄存器中编程。频率介于 2kHz~100kHz。</li>
<li>硬件自动等待发过来的 start 和 addr 信息。</li>
<li>如果 addr 信息和  OAR1 中存储的地址相同，说明目标是自己。如果 ACK 位为1，则发送 ack pulse。</li>
<li>设置 ADDR 位，1表示匹配。</li>
<li>如果 ITEVFEN 就是中断事件 flag 为1，则生成中断。</li>
<li>TRA 位标明 slave 是 R 还是 T 模式（收 or 发）。</li>
<li>BTF 位标识收没收完。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689255491311.png" alt="1689255491311"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713214410998.png" alt="image-20230713214410998"></p>
<p>这么说起来还是有点混乱 I2C 到底经历了哪些才顺利发送了数据？</p>
<p>首先，从主模式的概念。master 主模式驱动时钟信号，发起传输；slave 从模式响应传输。</p>
<h2 id="主模式"><a href="#主模式" class="headerlink" title="主模式"></a>主模式</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/Figure-1-4.png" alt="用于主发送数据的 I2C 传输序列图"></p>
<p>发送：</p>
<p>所有 EV 事件都会拉低 SCL，直到相应软件序列执行完成。</p>
<p>S：start 事件。比如CR2 寄存器中设置外设时钟，配置时钟寄存器，上升时钟寄存器，使能 CR1 来启用时钟，CR1 中设置 start 位，等待总线被拉低表示就绪，发送启动信号，并切换为主模式。</p>
<p>EV5：启动事件成功进行，设置 SB 寄存器&#x3D;1. SB 寄存器&#x3D;1后才可以进行地址阶段，执行完地址阶段会自动清除 SB 和 EV5 事件。</p>
<p>Address：地址阶段。传输7位地址+1位读写位，然后等待从机的 ack。收到 ack 进入 EV6.</p>
<p>EV6：设置 addr 位&#x3D;1代表地址阶段顺利执行， master 收到 ack了。清除 EV6 后自动进入 EV8.</p>
<p>EV8：设置 TxE ，准备写入主机要传入的数据。TxE 表示数据寄存器为空可以写入。每次数据写入 DR 都会清空 TxE 和 EV8 事件。写完数据数据传过去了，主机收到 ack 后继续传输。以 BTF&#x3D;1 表示数据传输的结尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_write</span><span class="params">(<span class="type">uint8_t</span> address, <span class="type">uint8_t</span> *buffer, <span class="type">int</span> buff_len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Send in sequence: Start bit, Contents of buffer 0..buff_len, Stop</span></span><br><span class="line">    <span class="keyword">while</span> (((I2C1-&gt;SR2&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>)); <span class="comment">// wait until I2C1 is not busy anymore</span></span><br><span class="line">    I2C_GenerateSTART(I2C1, ENABLE); <span class="comment">// Send I2C1 START condition</span></span><br><span class="line">    <span class="comment">// wait for I2C1 EV5 --&gt; Slave has acknowledged start condition</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));</span><br><span class="line">    <span class="comment">// Send slave Address for write then wait for EV6</span></span><br><span class="line">    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Transmitter);</span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));</span><br><span class="line">    <span class="keyword">while</span> (i &lt; buff_len)&#123;</span><br><span class="line">        I2C_SendData(I2C1, buffer[i]); <span class="comment">// send data then wait for EV8_2</span></span><br><span class="line">        <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_GenerateSTOP(I2C1, ENABLE); <span class="comment">// send stop bit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230714110003657.png" alt="image-20230714110003657"></p>
<p>接收：</p>
<p>前面和 master transmit 都一样。</p>
<p>TxE 改为 RxE 了，&#x3D;1标识接收到了数据。</p>
<p>master 自己设置 stop 事件后（发送 NACK）停止接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_read</span><span class="params">(<span class="type">uint8_t</span> address, <span class="type">uint8_t</span> *buffer, <span class="type">int</span> buff_len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Start bit, Contents of buffer from 0..buff_len, sending a NACK</span></span><br><span class="line">    <span class="comment">// for the last item and an ACK otherwise, Stop bit</span></span><br><span class="line">    I2C_GenerateSTART(I2C1, ENABLE);</span><br><span class="line">    <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); <span class="comment">//EV5</span></span><br><span class="line">    <span class="comment">// Send slave Address for write then wait for EV6</span></span><br><span class="line">    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Receiver);</span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));</span><br><span class="line">    I2C_AcknowledgeConfig(I2C1, ENABLE); <span class="comment">// going to send ACK</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; buff_len - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); <span class="comment">//EV7</span></span><br><span class="line">        buffer[i] = I2C_ReceiveData(I2C1); <span class="comment">// get data byte</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_AcknowledgeConfig(I2C1, DISABLE); <span class="comment">// going to send NACK</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); <span class="comment">//EV7</span></span><br><span class="line">    buffer[i] = I2C_ReceiveData(I2C1); <span class="comment">// get the last byte</span></span><br><span class="line">    I2C_GenerateSTOP(I2C1, ENABLE); <span class="comment">// send stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从模式"><a href="#从模式" class="headerlink" title="从模式"></a>从模式</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689259086166.png" alt="1689259086166"></p>
<p>发送：</p>
<p>start 启动事件由 master 发起。从机校验地址并决定是否发送 ack 位。</p>
<p>EV1：设置 addr 位表示地址匹配。</p>
<p>EV3-1：设置 TxE 位，开始传入数据。一直到主机返回 NACK 表示不想再要数据了，或者 AF&#x3D;1 说明 ack 失败了为止。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689259113895.png" alt="1689259113895"></p>
<p>接收：</p>
<p>前面到 EV1 和 slave transmit 都一样。</p>
<ol>
<li>数据从 DR 寄存器中读。</li>
<li>读入一个 byte 后，如果 ack 位已经设置，则返回 ack 信息。</li>
<li>RxE 位是接收数据的状态寄存器。</li>
<li>主机生成停止条件时停止。</li>
</ol>
<p>异常情况：</p>
<p>总线错误，NACK，仲裁失败，时钟异常超时。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230714110916968.png" alt="image-20230714110916968"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Miprocessor/" rel="tag">Miprocessor</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-致敬未来的攻城狮计划"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/06/24/%E8%87%B4%E6%95%AC%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%94%BB%E5%9F%8E%E7%8B%AE%E8%AE%A1%E5%88%92/"
    >致敬未来的攻城狮计划</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/06/24/%E8%87%B4%E6%95%AC%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%94%BB%E5%9F%8E%E7%8B%AE%E8%AE%A1%E5%88%92/" class="article-date">
  <time datetime="2023-06-23T23:00:00.000Z" itemprop="datePublished">2023-06-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Embeded-System/">Embeded System</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这回参加的是csdn李肯老师的攻城狮计划，简单说就是我白嫖板子，输出学习笔记。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/a3cc9258486e875c183b4fbbb1ce5fbe.jpeg" alt="552ca9fa46d8c1c7f192cdad4d207d4"></p>
<p>板子是瑞萨的CPK_RA2E1，还有触摸元件，看起来很有意思hh。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>一开始决定采取vscode搭建的方式。后期进行到最后一步——cmake build的时候一直显示语法错误，肯哥表示是环境配置不全，但是我反反复复根据官网和其他博主的文章检查了不下10遍都不知道问题何在。最终决定还是老老实实用keil。</p>
<ol>
<li><p>keil导入瑞萨包。官网下载地址：<a target="_blank" rel="noopener" href="https://www.keil.arm.com/vendors/renesas/packs/">Arm Keil | Renesas</a></p>
</li>
<li><p>下载rasc软件。对于这个东西我的理解是类似stm32cubemx，可以快速初始化项目的软件。该软件可以在瑞萨官网下载：<a target="_blank" rel="noopener" href="https://www2.renesas.cn/kr/en/software-tool/ra-smart-configurator">https://www2.renesas.cn/kr/en/software-tool/ra-smart-configurator</a></p>
</li>
<li><p>接下来我们尝试新建编译一个项目。这是我第一次没有跟着一块有完整开发流程的板子的视频课，而几乎完全是自己检索资料探索尝试的项目构建，因此碰到了很多弯路。首先rasc软件我们新建一个项目。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1d1872b93bd272401e7d2a90a943d622.png" alt="项目起名"></p>
<p>板子型号这里是根据我的学习板设置的。IDE一定记得改为keil。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/091c255e2177162e613b3635d9e8128b.png" alt="image-20230601022545320"></p>
</li>
</ol>
<p>后两页选择 no rtos 和 minimal 即可，因为我们现在的目的只是尝试编译通过一个项目。</p>
<ol start="4">
<li><p>添加完成后，点击generate code 生成相关的项目代码。然后用keil打开，尝试编译。</p>
</li>
<li><p>我第一次遇到的问题是报了19个错。我还以为是pack导入的不对，但是后来搜了一下发现不是那么回事，是编译方式选错了。参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20017379/article/details/119523286">keil出现大量未知语法错误（系统移植）_portforce_inline_IT小生lkc的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/73a1e19aee6d2d2b7837c180d17939dc.png" alt="image-20230601022913830"></p>
</li>
<li><p>于是我把编译器改为version5，编译到一半，再次报错：error: A3903U: Argument ‘Cortex-M7.fp.sp’ not permitted for option  cpu’.。这个问题原因是因为编译器版本太低，于是我又去下载了新的keil5.</p>
</li>
<li><p>再次编译的时候提示我，不能用version5，新版本已经不支持了。于是我又改为version6进行编译。这次非常顺利！</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/d34a7cfbf5f7e0bdbb55a0063df5887f.png" alt="image-20230601023151749"></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>终于考完试了，然而攻城狮的截止期限也快到了QAQ，得尽快水（划掉）写几篇文章了！</p>
<p>先争取可以成功下载一个空的程序。</p>
<p>先对上一篇文章下载 DFP 也就是 keil MDK Software Packs 做一个补充。我们要下载的是 RA_DFP，下载地址为：<a target="_blank" rel="noopener" href="https://www.keil.arm.com/packs/ra_dfp-renesas/versions/">Arm Keil | Renesas RA_DFP</a></p>
<p>至于版本我看到有前辈使用 3.5.0 的版本可以成功运行，而我下载的是4+的版本也可以。只不过在选择 device 的时候会有一点不同：<br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622160103209.png" alt="image-20230622160103209"></p>
<p>可以看到 4.1.0 的版本无法细化选择到 R7FA2E1A92DFM，只能选择大类 A9. 不过经过下面的烧录尝试，是没有问题的。</p>
<p>流程：基于上次的空项目，用keil打开，编译，下载成功。</p>
<p>一直到编译的步骤前面都做完了。下载主要需要以下几个步骤：</p>
<ol>
<li>引入项目的 src 文件夹。在 options for target - c&#x2F;c++ 里引入即可很简单。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622154546545.png" alt="image-20230622154546545"></li>
<li>debug 模式设置为 jlink 模式。设置完之后插上板子设置配置，这里因为我的jlink版本太低出现了一个报错：unkown to this version of the jlink software。解决办法就是在官网上下载了一个新版本的jlink（官网链接：<a target="_blank" rel="noopener" href="https://www.segger.com/downloads/jlink%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AF">https://www.segger.com/downloads/jlink，我选择的是</a> windows 版本），下载好后直接会提示“检测到你电脑里的 keil 环境，请问是否更新其 jlink 调试器”，更新后重新启动就没有问题了。</li>
<li>上一步参考文章: <a target="_blank" rel="noopener" href="https://blog.csdn.net/wsq_666/article/details/124367141">keil识别不到芯片，提示unkown to this version of the jlink software_keil识别不到单片机_王小琪0712的博客-CSDN博客</a> 里面也有如果没有提示自动更新 jlink 调试器的选项如何手动进行更新的步骤，建议多多支持原作者。</li>
<li>只是选择了 jlink 调试器也并不算设置完成。如果这个时候点击下载，会提示“找不到 flash”，也就是还没有配置完成，需要设置闪存。首先确保插上了板子，然后打开 jlink 的setting：<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155204869.png" alt="image-20230622155204869"></li>
<li>如果显示下图说明板子被正常识别。如果没有显示这些数据，可能是 jlink 的版本还是过低，或者线坏了，或者还未下载对应 rcsa 包。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155322848.png" alt="image-20230622155322848"></li>
<li>接下来我们配置 flash download. 打开这个页面后点击 add，添加图中所示的这款型号芯片，然后 start 和 size 应该就会自动配置成和图中一样的情形，这样就算成功了。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155451715.png" alt="image-20230622155451715"></li>
<li>点击 load，如果显示如下信息说明成功下载程序。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155546525.png" alt="image-20230622155546525"></li>
</ol>
<p>刚插上板子的时候板子上是有白色的 power 指示灯和一个红蓝交替闪烁灯。下载空程序之后，应该只有电源指示灯还在亮。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/de933bcec619535b3e8b7fe60f61238.jpg" alt="de933bcec619535b3e8b7fe60f61238"></p>
<h1 id="点亮LED"><a href="#点亮LED" class="headerlink" title="点亮LED"></a>点亮LED</h1><p>本文主要参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/oxygen23333/article/details/130306105">【致敬未来的攻城狮计划】— 连续打卡第十一天：FSP固件库开发点亮第一个灯。_嵌入式up的博客-CSDN博客</a></p>
<p>在32阶段我们已经接触过类似做法了。初始化引脚模式（可以手动库函数，或者在工具包图形化界面里配置），设置引脚输出值。</p>
<h2 id="设置-FSP-Smart-Configurator"><a href="#设置-FSP-Smart-Configurator" class="headerlink" title="设置 FSP Smart Configurator"></a>设置 FSP Smart Configurator</h2><p>像上次一样创建一个项目。</p>
<p>首先我们翻一下RA2E1的数据手册看看led在哪。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624005444720.png" alt="image-20230624005444720"></p>
<p>如图所示，一红一蓝，502 501，输出高电平亮。</p>
<p>因此 configurator 里的pin如图所示设置501 502为output initial high</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624005611958.png" alt="image-20230624005611958"></p>
<p>配置完成后点击右上角 generate project content，输出更新配置到该项目中。</p>
<h2 id="Keil代码编写"><a href="#Keil代码编写" class="headerlink" title="Keil代码编写"></a>Keil代码编写</h2><p>接下来就是编写keil里，驱动两个led灯输出高电平的部分了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624011259206.png" alt="image-20230624011259206"></p>
<p>hal_entry.c 是相当于 main.c 的入口函数。其他都是 configurator 提供的配置函数。</p>
<p>引脚设置已经设置好了。我们打开 pin_data.c 可以看到：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624011748710.png" alt="image-20230624011748710"></p>
<p>这就代表确实初始化配置加进代码里了。</p>
<p>然后在 hal_entry.c 里是通过这个 open 函数在 warm_start 里初始化了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624012345948.png" alt="image-20230624012345948"></p>
<p>接下来我们需要一个写入位函数。在 r_ioport.c 里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624012543274.png" alt="image-20230624012543274"></p>
<p>参数1：固定参数，传入 &amp;p_ctrl。</p>
<p>参数2：引脚，老方法 goto the definition</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013133790.png" alt="image-20230624013133790"></p>
<p>参数3：电平。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013206720.png" alt="image-20230624013206720"></p>
<p>然后就简单了，只需要在主函数里调用write函数写亮led。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hal_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> add your own code here */</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				 R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);</span><br><span class="line">				 R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BSP_TZ_SECURE_BUILD</span></span><br><span class="line">    <span class="comment">/* Enter non-secure code */</span></span><br><span class="line">    R_BSP_NonSecureEnter();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013456059.png" alt="image-20230624013456059"></p>
<h1 id="按键模块"><a href="#按键模块" class="headerlink" title="按键模块"></a>按键模块</h1><h2 id="后台轮询"><a href="#后台轮询" class="headerlink" title="后台轮询"></a>后台轮询</h2><p>按键也是一个比较简单的模块，主要是为了学习IO输入模式。</p>
<p>查看RA2E1电路图可见：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624133704709.png" alt="image-20230624133704709"></p>
<p>按键相关引脚是004引脚，默认上拉高电平，按下接地为低电平。</p>
<p>首先第一步还是设置对应引脚。类似上一期设置LED的方式，只不过Mode改为Input mode。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624133750237.png" alt="image-20230624133750237"></p>
<p>设置好之后仍然是记得generate。</p>
<p>然后就是程序编写。首先还是明确一下开发流程。首先我们尝试后台轮询的按键检测。在while里不断检测按键电平，如果为高点亮蓝灯，如果为低点亮红灯。</p>
<p>点亮好写，上一次已经尝试过write函数。那么我们接下来再去看类似的read函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624135423601.png" alt="image-20230624135423601"></p>
<p>第一个参数还是传入固定的&amp;g_ioport_ctrl。第二个是引脚。第三个是存放我们要存储的读取按键的值。比如传入变量state的地址 &amp;state，函数执行结束后state的值就是读取的按键电平。</p>
<p>主函数编写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hal_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bsp_io_level_t</span> state;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> add your own code here */</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			R_IOPORT_PinRead(&amp;g_ioport_ctrl, BSP_IO_PORT_00_PIN_04,&amp;state);</span><br><span class="line">			<span class="keyword">if</span>(state==BSP_IO_LEVEL_HIGH)&#123;</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_LOW);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_LOW);</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BSP_TZ_SECURE_BUILD</span></span><br><span class="line">    <span class="comment">/* Enter non-secure code */</span></span><br><span class="line">    R_BSP_NonSecureEnter();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/8d99e5ae0be2c97e2e2bb44a1ed92f6.jpg" alt="8d99e5ae0be2c97e2e2bb44a1ed92f6"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/59b0f842762bb1349190932bdcb4e74.jpg" alt="59b0f842762bb1349190932bdcb4e74"></p>
<h1 id="活动总结"><a href="#活动总结" class="headerlink" title="活动总结"></a>活动总结</h1><p>一转眼攻城狮计划就已经到了最后一天了。<br>5月我还处在一个迷茫期，那时候刚刚入坑嵌入式，只学了几款电子积木，对整个体系也不是很清楚，也不知道应该学些什么。因为刚刚转到硬件领域，也缺少相关经历和能力证明，科研实习面试都失败了。</p>
<p>一开始得到的少许鼓励来源于C站推荐的一系列交流会活动。我去参加了RTThread的学习营，第一次尝试在单片机开发中加入RTOS系统，也算是跳脱出自己当时缓慢的按部就班学习路线，如井底之蛙般弹出脑袋窥探了一眼外面的风景。</p>
<p>后来偶然收到李肯老师的攻城狮活动邀请。虽然因为选在了期末周，自己又比较懒，基本没更几篇文章hh。但是借助李肯老师的交流活动认识了很多嵌入式领域的前辈，同伴，从每天的交流话题中也能学到很多。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624180328147.png" alt="image-20230624180328147"></p>
<p>现如今，虽然学到的知识相比之前可能没有太多，但是整个系统的框架，从硬件到ISA，操作系统解释器等系统软件，汇编语言和机器语言的转化等……确实见识到了很多。</p>
<p>再聊到本次活动。虽然自己没有做过多的尝试，但是因为之前我也只尝试过51和32的库函数开发，rcsa的configurator配置本身对我来说就是一种新奇的开发模式。与32的hal库对比更能让我体会到这些driver的便捷之处，也开始适应这种开发方式。</p>
<p>非常感谢给予这次机会的李肯老大！也期望自己能保持这股热情继续学下去~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-51单片机入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/31/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8/"
    >51单片机入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/31/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2023-03-30T23:00:00.000Z" itemprop="datePublished">2023-03-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Embeded-System/">Embeded System</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h1 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h1><p>开发：Keil。如果想要没乱码的中文注释，那么设置编码方式为 UTF8 或 GB2312。</p>
<p>程序文件下载到单片机：STC&#x2F;普中（STC需要冷启动，先点击下载再开启单片机电源）</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Micro Controller Unit, MCU 单片机，其中包含了CPU RAM ROM 输入输出设备 等一系列电脑硬件常用功能。</p>
<p>功能：通过传感器采集数据，通过CPU处理数据，控制硬件。</p>
<p>可以说是一个性能低的小电脑，是了解计算机原理的很好的学习方法。</p>
<p><em>右上角的跳线帽使用数码管时跳到VCC，使用点阵时跳到GND。</em></p>
<h2 id="STC89C52RC-命名规则"><a href="#STC89C52RC-命名规则" class="headerlink" title="STC89C52RC 命名规则"></a>STC89C52RC 命名规则</h2><p>STC：芯片为 STC 公司生产的产品。 </p>
<p>8：该芯片为 8051 内核芯片。 </p>
<p>9：表示内部含有 Flash EEPROM 存储器，还有如 80C51 中 0 表内部含有 MaskROM（掩模 ROM）存储器；如 87C51 中 7 表示内部含有 EPROM（紫外线可擦除 ROM）存储器。 </p>
<p>C–表示该器件为 CMOS 产品。还有如 89LV52 和 89LE58 中的 LV 和 LE 都表示 该芯片为低电压产品（通常为 3.3V 电压供电）；而 89S52 中 S 表示该芯片含有 可串行下载功能的 Flash 存储器，即具有 ISP 可在线编程功能。 </p>
<p>5–固定不变。 </p>
<p>2：表示该芯片内部程序存储（FLASH）空间大小，1 为 4KB，2 为 8KB，3 为  12KB，即该数乘以 4KB 就是芯片内部的程序存储空间大小。程序空间大小决定了 一个芯片所能装入执行代码的多少。一般来说，程序存储空间越大，芯片价格也 越高，所以我们再选择芯片的时候要根据自己需求选择合适芯片。 RC–STC 单片机内部 RAM（随机读写存储器）为 512B。还有如 RD+表示内部 RAM 为 1280B。还有芯片会省略此部分</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540672.png" alt="image-20220828144814559"></p>
<h2 id="芯片介绍"><a href="#芯片介绍" class="headerlink" title="芯片介绍"></a>芯片介绍</h2><p>芯片在 PDIP 里。黑色的部分 PDIP 是一种封装方式，可能还有 LQFP 等（一个正方形的形状）封装方式。</p>
<p>8051 内核基本上都是中间绿色块的样子，只是外设、封装等方式不同。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540673.png" alt="image-20220828145334929"></p>
<p>管脚图：</p>
<p>Vcc 是电源，XTAL 管时钟，RST 是复位，等等。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540674.png" alt="image-20220828145345268"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252144730.png" alt="image-20230125214429628"></p>
<p>整个是一个总线结构，所有外设都挂在上面。如最下面一行左边是晶振，右边是外部引脚。</p>
<p>只有这一个单片机是不能运行的，看我们的开发板上面还外接了好多好多外设呢。能让单片机运行的最小应用系统如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252147253.png" alt="image-20230125214745143"></p>
<p>三角是正极，三线符号是负极。</p>
<p>首先需要 Vcc 接正，GND 接负。</p>
<p>然后需要接晶振。没有晶振单片机程序无法一条条往下执行，有了晶振按照固定的周期才能一条条往下执行。晶振就是板子上银色的椭圆形的一个东西，频率写在上面，一般是有12MHz和11.多MHz的两种（有的芯片自带晶振。不过很明显我们的芯片并不自带）。</p>
<p>然后还有复位电路，让程序回到第一条的位置。</p>
<h2 id="开发板介绍"><a href="#开发板介绍" class="headerlink" title="开发板介绍"></a>开发板介绍</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540671.png" alt="image-20220903113237968" style="zoom: 67%;" />

<p>中间黑色的是刚刚介绍的单片机。拉起拉杆，可以取下单片机，但放回时<strong>一定不能放反</strong>。单片机有缺口的一端左侧从01开始，逆时针逐渐增大到40。</p>
<p>右侧中间有8个 LED 灯，我是点灯大师！</p>
<p>下面是一个矩阵按键，用户可以通过按按键输入。</p>
<p>最下面一行右侧有个红外接收传感器，接收红外线的。</p>
<p>左边无线模块，8个插孔的，做无线模块（如2.4G）用的。</p>
<p>再左边四个独立按键。</p>
<p>最左下是 USB 自动下载模块，插上 USB 线后按开关就会自动下载程序，不用了解。</p>
<p>DS1302 时钟芯片，可以做一个小时钟，读取时间。</p>
<p>红色按钮是 RST 按钮。</p>
<p>AD&#x2F;DA 模数转换器，使单片机在数字与模拟领域之间转化。</p>
<p>74H595 可以扩展出更多的 IO 口。</p>
<p>步进电机可以精确控制脚步（转一圈、转半圈）。比如空调会用。</p>
<p>超声波模块可以测距。</p>
<p>蜂鸣器模块可以放歌。但我（）（）（）（）。</p>
<p>138译码器控制数码管，也可以扩展 IO 口。</p>
<p>24c02 也是一种 ROM，还是 EEP ROM（掉电不丢失）。其实单片机自带的 Flash ROM 更先进，但是只能用来存储程序。</p>
<p>温度传感器可以用来检测温度。</p>
<p>74HC245 可以驱动数码管（我的单片机是 HC138）。</p>
<p>左上角的电位器和排座用于接显示屏。电位器可以调整显示屏的亮度。</p>
<p>最大的黑色方阵是一个 LED 点阵。可以点亮8*8的方阵，甚至用来做动画。</p>
<p>之后的课程中还会详细介绍每一个模块，以及对应的电路图。</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>&amp;与，|或，!非，⊙同或（相同结果才&#x3D;1），异或⊕（不同结果才为1）</p>
<h1 id="C语言语法"><a href="#C语言语法" class="headerlink" title="C语言语法"></a>C语言语法</h1><p>int 16位，char 8位。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540675.png" alt="image-20220904115124141"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540676.png" alt="image-20220904115224027"></p>
<p>基本语法其他的都好说，再复习一下位运算。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540677.png" alt="image-20220904145323095"></p>
<p>左右移补0.</p>
<p>位运算符也可以参与成为复合赋值运算符，如^&#x3D;, &lt;&lt;&#x3D;</p>
<p>逗号运算符&#x3D;最后一个表达式的值</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540678.png" alt="image-20220904145638619"></p>
<h3 id="函数在C语言基础上做的拓展"><a href="#函数在C语言基础上做的拓展" class="headerlink" title="函数在C语言基础上做的拓展"></a>函数在C语言基础上做的拓展</h3><h4 id="重入函数"><a href="#重入函数" class="headerlink" title="重入函数"></a>重入函数</h4><p>在函数形参括号后加修饰符 reentrant，代表这个函数是重入函数，可以被递归调用，但这样就不能有bit变量，也不能进行位运算。</p>
<h4 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h4><p>在函数形参括号后加修饰符 interrupt m，系统编译时把对应函数转化为中断函数，自动加上程序头段和尾段，并按 51 系 统中断的处理方式自动把它安排在程序存储器中的相应位置。 </p>
<p>在该修饰符中，m 的取值为 0~31，对应的中断情况如下： </p>
<p>0——外部中断 0 </p>
<p>1——定时&#x2F;计数器 T0</p>
<p>2——外部中断 1 </p>
<p>3——定时&#x2F;计数器 T1 </p>
<p>4——串行口中断 </p>
<p>5——定时&#x2F;计数器 T2 </p>
<p>其它值预留。</p>
<h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>如果要调用的函数不在本文件内，在其他文件内，定义函数时函数开头要加 extern 修饰符。</p>
<h3 id="sfr-sbit"><a href="#sfr-sbit" class="headerlink" title="sfr sbit"></a>sfr sbit</h3><p>用于定义特殊功能寄存器或特殊位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sfr P0=<span class="number">0x80</span>;<span class="comment">//把地址 0x80 处的寄存器定义为 P0</span></span><br><span class="line">sbit P0_1=P0^<span class="number">1</span>;<span class="comment">//取第一位定义为 P0_1</span></span><br></pre></td></tr></table></figure>

<p>其实头文件 regx52.h 中都有。</p>
<p>能不能给位单独赋值要看是不是可位寻址。因为物理地址有限，每8个寄存器只能有一个可位寻址。</p>
<h2 id="51单片机最小系统组成"><a href="#51单片机最小系统组成" class="headerlink" title="51单片机最小系统组成"></a>51单片机最小系统组成</h2><ul>
<li>晶振电路，提供时钟，相当于心脏</li>
<li>复位电路，系统运行不正常时可以重启</li>
<li>电源电路，注意单片机的供电电压要求</li>
<li>下载电路，烧入程序</li>
</ul>
<p>另外注意，单片机的P0口是漏级开路，输出高电平会导致高阻态，因此输出高电平时要接上拉电阻，通常选择 4.7K~10K 阻值。</p>
<h1 id="程序编写前言"><a href="#程序编写前言" class="headerlink" title="程序编写前言"></a>程序编写前言</h1><p>新建项目 new μversion project</p>
<p><strong>选择 CPU 型号：Keil 中没有完全对应的 STC89C52 版本，用Atmel 中的 AT89C52 即可，不用把8051启动文件添加到工程中。</strong></p>
<blockquote>
<p>AT 和 STC 是两种型号的单片机。有的 STC 单片机上面还有 AT 接口，AT 使用那个接口烧录程序。STC 就用 USB 下载。</p>
</blockquote>
<p>新建好后有一个文件夹：source group，代码文件都在其中。</p>
<p>选中该文件夹，右键新建new item，新建c语言文件。可以选c&#x2F;cpp&#x2F;asm</p>
<p>在魔术棒 Output 选项中添加 “ create HEX file”.</p>
<h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：translate按钮</p>
<p>建立：build按钮，也有编译的作用，只编译发生变动的文件。</p>
<p>重新建立：rebuild，编译所有文件（速度慢不建议）。</p>
<p>报错如果显示：缺少root segment根段，即没有找到主函数。</p>
<h2 id="头文件作用"><a href="#头文件作用" class="headerlink" title="头文件作用"></a>头文件作用</h2><p><code>#include&lt;reg52.h&gt;</code>和&#96;#include “reg52.h”都可以。区别在于&lt;&gt;直接去软件安装处搜索头文件，而””先在该项目下查找头文件，找不到再去软件安装处，再找不到就报错。</p>
<p>查看头文件可以在左侧的结构树对应的c文件目录下打开，或者右键“reg52.h” open 打开。</p>
<p>该头文件中定义了52单片机内部所有功能寄存器，把地址值如0x80赋值给P0等端口。</p>
<h2 id="程序烧录"><a href="#程序烧录" class="headerlink" title="程序烧录"></a>程序烧录</h2><p>程序编译建立没有错误，也开启了魔术棒创建 HEX 文件选项，那么 build 后就会在对应路径中找到生成的 HEX 文件。</p>
<p>在 STC-ISP 中选定单片机型号、串口、晶振频率（可以直接看开发板上的晶振上面有写），选择对应的 HEX 文件，先断电开发板，再点击下载，再开机，就可以查看呈现在开发板上的效果。</p>
<h1 id="HELLO-WORLD——LED部分"><a href="#HELLO-WORLD——LED部分" class="headerlink" title="HELLO WORLD——LED部分"></a>HELLO WORLD——LED部分</h1><p>LED 发光二极管。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252222021.png" alt="image-20230125222255962" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252223906.png" alt="image-20230125222332854"></p>
<p>下面两个黑色的方块就是8个电阻。电阻是限流作用，防止电流过大烧毁 LED。</p>
<p>电阻上面写着小小的“102”，代表10*10^2，即1kΩ。</p>
<p>每个 LED 正极是一定通电流的，如果负极接地，那么这个 LED 被点亮。否则两头都是高电平点不亮（这里的电平是 TTL 电平，高5低0）。</p>
<p>单片机如何驱动高低电平？在 MCU 内，CPU 接到指令（如P2^0口赋1，即高电平）CPU 把数据写入寄存器，寄存器数据通过驱动器放大后变为5V&#x2F;0V 电平输出。</p>
<h2 id="点亮-LED"><a href="#点亮-LED" class="headerlink" title="点亮 LED"></a>点亮 LED</h2><p>GPIO（general purpose input output) 即通用输入输出端口，可以通过软件控制其输入和输出.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540679.png" alt="image-20220905111036720"></p>
<ul>
<li>电源引脚： Vcc， GND</li>
<li>晶振引脚：XTAL1 2</li>
<li>复位引脚：RST VPD，不做其他功能。</li>
<li>下载引脚：TXD RXD</li>
<li>GPIO引脚：Px.x的都是 GPIO 引脚，大致分为P0 P1 P2 P3，每组8个IO，P3还有附加功能，比如串口、外部中 断、计数器等。每个引脚每次只能使用一个功能。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>; <span class="comment">//将 P2.0 管脚定义为 LED1</span></span><br><span class="line"><span class="comment">//我们也可以直接给P2整个赋值。比如P2=0xFE，即1111 1110，就只会点亮最后一个 LED 灯，和 P2^0=0 效果是一样的。</span></span><br><span class="line"><span class="comment">//另，我们的这种做法只是寻找特殊寄存器P2的第几位。而头文件 REGX52.H 中是真正包含所有引脚信息的，如P2_0 就是2.0引脚，也能起到一样的效果。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LED1=<span class="number">0</span>; <span class="comment">//LED1 端口设置为低电平，就会被点亮</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//单片机默认不断执行主程序。如果没有这个死循环，单片机就会不断点亮点亮点亮点亮……不如点亮一次之后无限延时。</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译结果里面的几个数据的意义： </p>
<p>code：表示程序所占用 FLASH 的大小。 </p>
<p>data：数据储存器内部 RAM 占用大小。 </p>
<p>xdata：数据储存器外部 RAM 占用大小。 </p>
<h2 id="LED-闪烁"><a href="#LED-闪烁" class="headerlink" title="LED 闪烁"></a>LED 闪烁</h2><p>只需要点亮——延时——熄灭——延时循环即可。</p>
<p>单片机频率单位是 MHz 兆赫兹，所以只是单纯的亮灭亮灭肉眼看不出亮灭的效果。所以需要延时。</p>
<p>延时可以写一个这样的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 ten_us)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>u16 代表16位的无符号整型数据。这是一个比较常用的定义，unsigned char 定义为 u8, unsigned int 定义为 u16。当 ten_us 超出 u16 的范围后，跳出 while 循环。</p>
<p>然后就<code>LED1=0;delay(50000);LED1=1;delay(50000);</code>循环即可.</p>
<p>但是，STC-ISP 可以根据晶振频率和要延时的时间生成延时函数，真的牛！不过注意软件上标明的适用系列版本。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252241257.png" alt="image-20230125224132185"></p>
<p>其中 _nop_() 函数包括在 INTRINS.H 头文件中，是一个空语句，就只会产生延时的效果。</p>
<p>不过 STC-ISP 只能生成固定时长的延时函数。如果想要像自己写的那个 delay() 函数一样传入参数，延时对应长度的毫秒&#x2F;微秒呢？</p>
<p>很简单，我们先生成延时1毫秒&#x2F;微秒的函数，然后把函数中的内容重复执行传入参数遍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"> 	<span class="keyword">while</span>(xms--)&#123;<span class="comment">//这里是修改过的</span></span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">        j = <span class="number">190</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (--j);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Keil-软件仿真"><a href="#Keil-软件仿真" class="headerlink" title="Keil 软件仿真"></a>Keil 软件仿真</h2><p>使用仿真功能查看 LED 闪烁案例中的实际延时时间。</p>
<ol>
<li>点击魔术棒，选择 Target 选项卡，设置 Xtal 为12M或11.0592M，根据开发板晶振修改对应值。</li>
<li>点击黑色放大镜中有红色d的仿真按钮，进入仿真页面</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540680.png" alt="image-20220905153847511"></p>
<p>我们要关注的参数是sec。</p>
<ol start="3">
<li>点击RST按钮重新复位系统参数，sec 变为0。然后在要调试的行前双击，就会出现红色块的断点，点击8运行时就会直接运行到断点处。再次点击就会运行到下一处断点处。</li>
<li>点击红色标记8运行，运行到36行时显示用时：0.00039s，再次点击运行到37行，用时：0.45s</li>
<li>可见delay花费时间约为0.45s</li>
</ol>
<h2 id="LED-流水灯"><a href="#LED-流水灯" class="headerlink" title="LED 流水灯"></a>LED 流水灯</h2><p>学会了点亮和延时，流水灯的原理就很好懂了。就是给P2的所有端口赋值为：1111 1110，每次只有一个为0即点亮，这个点亮的0从最高位逐渐降到最低位。</p>
<p>取反后即为：</p>
<p>1000 0000</p>
<p>0100 0000</p>
<p>0010 0000</p>
<p>0001 0000</p>
<p>0000 1000</p>
<p>0000 0100</p>
<p>0000 0010</p>
<p>0000 0001</p>
<p>也就是一个移位运算，0x01&lt;&lt;i的循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LED P2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i--)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">			<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">				LED=~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">				delay(<span class="number">50000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移位函数"><a href="#移位函数" class="headerlink" title="移位函数"></a>移位函数</h2><p>位运算的移位操作只能补0，但是 Keil C51 软件内有对应的移位库函数，左移_crol_()，右移_cror_()，<strong>包含在 intrins.h 库中</strong>。</p>
<p>移位函数会把移出去的位补到空位，一个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LED P2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i--)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LED=~(<span class="number">0x01</span>);</span><br><span class="line">	delay(<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">			LED=_crol_(LED,<span class="number">1</span>);</span><br><span class="line">			delay(<span class="number">50000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="蜂鸣器实验"><a href="#蜂鸣器实验" class="headerlink" title="蜂鸣器实验"></a>蜂鸣器实验</h1><p>蜂鸣器简单地说，就是电磁线圈和磁铁对振动膜的作用。</p>
<p>单片机的是无源蜂鸣器，不能一直充电，需要外部控制器发送震荡信号，可以改变频率产生不同的音色、音调。</p>
<p>大多数有源蜂鸣器则没有这个效果，有源蜂鸣器外观与之相同，内部自带震荡源，接上电就能响，但不能改变频率。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302071544133.png" alt="image-20230207154444964" style="zoom: 50%;" />

<p>我们知道三极管的作用是不用单片机自己直接驱动单片机。</p>
<p>另一种方法是步进电机。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302071559700.png" alt="image-20230207155956609" style="zoom: 80%;" />

<p>ULN 2003，高电压 高电流驱动器，给信号就被驱动。IN 取反输出 OUT。</p>
<h2 id="简谱"><a href="#简谱" class="headerlink" title="简谱"></a>简谱</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302071631942.png" alt="image-20230207163112788"></p>
<p>首先整个谱大概分为几个区。大字组、小字组、小字1组、小字2组。每个组之间差8度，每相邻的两个键（如黑白）差半音，相邻的两个同色键差一个全音。</p>
<p>几个白键的表示方法就是下面的简谱，差半音的黑键用左上角的#表示升半音，b表示降半音。</p>
<p>演奏两大要素：音高和时值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20240301121053848.png" alt="image-20240301121053848"></p>
<p>谱上一个数字是1&#x2F;4 音符，二分是其两倍，数字加个横线 - 。全音符就是（2 - - -）。这个线叫增时线。</p>
<p>八分是其1&#x2F;2，数字下加一条线（<u>2</u>）.再&#x2F;2就再加一条，叫减时线。</p>
<p>试着识一个完整的谱：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302072331332.png" alt="image-20230207233115087"></p>
<p>4&#x2F;4：以四分音符为一拍，每小节有四拍。</p>
<p>第二节 $\dot{1}$ · 上面的点我们知道代表高音，后面的点代表：前一位音符延长1&#x2F;2长度，即四分音符+1&#x2F;2的四分音符。也就是3&#x2F;8哈哈哈。</p>
<p>看第一节，一般连着两个八分音符就把 underline 连起来。但是这种哪怕是一个音，中间也要先断开再重响。比如右上角的<u>3 3</u>。</p>
<p>升音和降音在本小节中有效。如第三行的 7 #4 4 7 ，两个4都是升音。</p>
<p>不过如果顶端画了延音线，就是连起来的不用断开。如中间的 $\widehat{7 7}$，拆开写是为了好读谱。</p>
<p>接下来就是如何把谱转化为单片机代码。左上角 1&#x3D;c 说明是c调的。d大调会出现黑键，c调只有白键。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080007323.png" alt="image-20230208000727170" style="zoom:67%;" />

<p>音具体是怎么定义的？首先以中音a为基准，高音a是其2倍，低音a是其1&#x2F;2。</p>
<p>中间每次升音都是等比数列递增的，即*2的1&#x2F;12次方</p>
<h2 id="使用蜂鸣器"><a href="#使用蜂鸣器" class="headerlink" title="使用蜂鸣器"></a>使用蜂鸣器</h2><p>响起来很简单：不断反转 P1^5 口（是不是这个口得看自己的板子型号）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u16 i=<span class="number">2000</span>;<span class="comment">//决定时值</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(i--)</span><br><span class="line">		&#123;</span><br><span class="line">			BEEP=!BEEP;</span><br><span class="line">			delay10Us(<span class="number">100</span>);<span class="comment">//决定音高</span></span><br><span class="line">		&#125;</span><br><span class="line">        i=<span class="number">2000</span>;</span><br><span class="line">        BEEP=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时值还好确认，音高怎么说？</p>
<p>首先我们有上图的音符与频率对照表。我们把频率转化为周期，即1&#x2F;频率。这里周期单位是us。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080935317.png" alt="image-20230208093509168"></p>
<p>然后周期时长转化为机器周期，即记一个数需要的时间。我们看看需要多少机器周期。</p>
<p>1机器周期&#x3D;12时钟周期，时钟周期&#x3D;1&#x2F;单片机晶振。比如对于我的11.0592MHZ 晶振，机器周期&#x3D;12&#x2F;11.0592MHZ （单位：us）。</p>
<p>据此把“需要切换的周期时长”转化为“需要切换的周期需要执行几次指令”。即周期&#x2F;机器周期。如果是12MHZ 晶振这一步相当于没有。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080945402.png" alt="image-20230208094537336"></p>
<p>然后电平从低到高，从高到低才是一个周期。所以实际电平反转一次的周期是周期的一半。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080951297.png" alt="image-20230208095158230"></p>
<p>我们知道定时器原理是 TH TL 加至65536触发中断。因此重装载值（定时器初值）&#x3D;65536-取整值。</p>
<table>
<thead>
<tr>
<th>音符</th>
<th>频率</th>
<th>周期</th>
<th>需要的机器周期数</th>
<th>需要的机器周期数&#x2F;2</th>
<th>取整</th>
<th>重装载值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>262</td>
<td>3816.794</td>
<td>3517.557252</td>
<td>1758.778626</td>
<td>1759</td>
<td>63777</td>
</tr>
<tr>
<td>1#</td>
<td>277</td>
<td>3610.108</td>
<td>3327.075812</td>
<td>1663.537906</td>
<td>1664</td>
<td>63872</td>
</tr>
<tr>
<td>2</td>
<td>294</td>
<td>3401.361</td>
<td>3134.693878</td>
<td>1567.346939</td>
<td>1567</td>
<td>63969</td>
</tr>
<tr>
<td>2#</td>
<td>311</td>
<td>3215.434</td>
<td>2963.344051</td>
<td>1481.672026</td>
<td>1482</td>
<td>64054</td>
</tr>
<tr>
<td>3</td>
<td>330</td>
<td>3030.303</td>
<td>2792.727273</td>
<td>1396.363636</td>
<td>1396</td>
<td>64140</td>
</tr>
<tr>
<td>4</td>
<td>349</td>
<td>2865.33</td>
<td>2640.687679</td>
<td>1320.34384</td>
<td>1320</td>
<td>64216</td>
</tr>
<tr>
<td>4#</td>
<td>370</td>
<td>2702.703</td>
<td>2490.810811</td>
<td>1245.405405</td>
<td>1245</td>
<td>64291</td>
</tr>
<tr>
<td>5</td>
<td>392</td>
<td>2551.02</td>
<td>2351.020408</td>
<td>1175.510204</td>
<td>1176</td>
<td>64360</td>
</tr>
<tr>
<td>5#</td>
<td>415</td>
<td>2409.639</td>
<td>2220.722892</td>
<td>1110.361446</td>
<td>1110</td>
<td>64426</td>
</tr>
<tr>
<td>6</td>
<td>440</td>
<td>2272.727</td>
<td>2094.545455</td>
<td>1047.272727</td>
<td>1047</td>
<td>64489</td>
</tr>
<tr>
<td>6#</td>
<td>466</td>
<td>2145.923</td>
<td>1977.682403</td>
<td>988.8412017</td>
<td>989</td>
<td>64547</td>
</tr>
<tr>
<td>7</td>
<td>494</td>
<td>2024.291</td>
<td>1865.587045</td>
<td>932.7935223</td>
<td>933</td>
<td>64603</td>
</tr>
<tr>
<td>1</td>
<td>523</td>
<td>1912.046</td>
<td>1762.141491</td>
<td>881.0707457</td>
<td>881</td>
<td>64655</td>
</tr>
<tr>
<td>1#</td>
<td>554</td>
<td>1805.054</td>
<td>1663.537906</td>
<td>831.7689531</td>
<td>832</td>
<td>64704</td>
</tr>
<tr>
<td>2</td>
<td>587</td>
<td>1703.578</td>
<td>1570.017036</td>
<td>785.0085179</td>
<td>785</td>
<td>64751</td>
</tr>
<tr>
<td>2#</td>
<td>622</td>
<td>1607.717</td>
<td>1481.672026</td>
<td>740.8360129</td>
<td>741</td>
<td>64795</td>
</tr>
<tr>
<td>3</td>
<td>659</td>
<td>1517.451</td>
<td>1398.482549</td>
<td>699.2412747</td>
<td>699</td>
<td>64837</td>
</tr>
<tr>
<td>4</td>
<td>698</td>
<td>1432.665</td>
<td>1320.34384</td>
<td>660.1719198</td>
<td>660</td>
<td>64876</td>
</tr>
<tr>
<td>4#</td>
<td>740</td>
<td>1351.351</td>
<td>1245.405405</td>
<td>622.7027027</td>
<td>623</td>
<td>64913</td>
</tr>
<tr>
<td>5</td>
<td>784</td>
<td>1275.51</td>
<td>1175.510204</td>
<td>587.755102</td>
<td>588</td>
<td>64948</td>
</tr>
<tr>
<td>5#</td>
<td>831</td>
<td>1203.369</td>
<td>1109.025271</td>
<td>554.5126354</td>
<td>555</td>
<td>64981</td>
</tr>
<tr>
<td>6</td>
<td>880</td>
<td>1136.364</td>
<td>1047.272727</td>
<td>523.6363636</td>
<td>524</td>
<td>65012</td>
</tr>
<tr>
<td>6#</td>
<td>932</td>
<td>1072.961</td>
<td>988.8412017</td>
<td>494.4206009</td>
<td>494</td>
<td>65042</td>
</tr>
<tr>
<td>7</td>
<td>988</td>
<td>1012.146</td>
<td>932.7935223</td>
<td>466.3967611</td>
<td>466</td>
<td>65070</td>
</tr>
<tr>
<td>1</td>
<td>1046</td>
<td>956.0229</td>
<td>881.0707457</td>
<td>440.5353728</td>
<td>441</td>
<td>65095</td>
</tr>
<tr>
<td>1#</td>
<td>1109</td>
<td>901.7133</td>
<td>831.018936</td>
<td>415.509468</td>
<td>416</td>
<td>65120</td>
</tr>
<tr>
<td>2</td>
<td>1175</td>
<td>851.0638</td>
<td>784.3404255</td>
<td>392.1702128</td>
<td>392</td>
<td>65144</td>
</tr>
<tr>
<td>2#</td>
<td>1245</td>
<td>803.2129</td>
<td>740.2409639</td>
<td>370.1204819</td>
<td>370</td>
<td>65166</td>
</tr>
<tr>
<td>3</td>
<td>1318</td>
<td>758.7253</td>
<td>699.2412747</td>
<td>349.6206373</td>
<td>350</td>
<td>65186</td>
</tr>
<tr>
<td>4</td>
<td>1397</td>
<td>715.8196</td>
<td>659.6993558</td>
<td>329.8496779</td>
<td>330</td>
<td>65206</td>
</tr>
<tr>
<td>4#</td>
<td>1480</td>
<td>675.6757</td>
<td>622.7027027</td>
<td>311.3513514</td>
<td>311</td>
<td>65225</td>
</tr>
<tr>
<td>5</td>
<td>1568</td>
<td>637.7551</td>
<td>587.755102</td>
<td>293.877551</td>
<td>294</td>
<td>65242</td>
</tr>
<tr>
<td>5#</td>
<td>1661</td>
<td>602.047</td>
<td>554.846478</td>
<td>277.423239</td>
<td>277</td>
<td>65259</td>
</tr>
<tr>
<td>6</td>
<td>1760</td>
<td>568.1818</td>
<td>523.6363636</td>
<td>261.8181818</td>
<td>262</td>
<td>65274</td>
</tr>
<tr>
<td>6#</td>
<td>1865</td>
<td>536.193</td>
<td>494.155496</td>
<td>247.077748</td>
<td>247</td>
<td>65289</td>
</tr>
<tr>
<td>7</td>
<td>1976</td>
<td>506.0729</td>
<td>466.3967611</td>
<td>233.1983806</td>
<td>233</td>
<td>65303</td>
</tr>
</tbody></table>
<p>使用方法：TH&#x3D;重装载值&#x2F;256，TL&#x3D;重装载值%256.</p>
<p>音高从低到高逐位响起代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer0.h&quot;</span></span></span><br><span class="line">sbit beep=P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> beep_table[]=&#123;<span class="comment">//可以加个0代表不响的0</span></span><br><span class="line">	<span class="number">63777</span>,<span class="number">63872</span>,<span class="number">63969</span>,<span class="number">64054</span>,<span class="number">64140</span>,<span class="number">64216</span>,<span class="number">64291</span>,<span class="number">64360</span>,<span class="number">64426</span>,<span class="number">64489</span>,<span class="number">64547</span>,<span class="number">64603</span>,</span><br><span class="line">	<span class="number">64655</span>,<span class="number">64704</span>,<span class="number">64751</span>,<span class="number">64795</span>,<span class="number">64837</span>,<span class="number">64876</span>,<span class="number">64913</span>,<span class="number">64948</span>,<span class="number">64981</span>,<span class="number">65012</span>,<span class="number">65042</span>,<span class="number">65070</span>,</span><br><span class="line">	<span class="number">65095</span>,<span class="number">65120</span>,<span class="number">65144</span>,<span class="number">65166</span>,<span class="number">65186</span>,<span class="number">65206</span>,<span class="number">65225</span>,<span class="number">65242</span>,<span class="number">65259</span>,<span class="number">65274</span>,<span class="number">65289</span>,<span class="number">65303</span>	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> beep_select=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;																	 </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	timer0Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		beep_select++;</span><br><span class="line">		delayMs(<span class="number">50</span>);<span class="comment">//时值		</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0Interrupt</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = beep_table[beep_select]/<span class="number">256</span>; <span class="comment">// 因为触发中断时，TH TL 归零，所以记得赋初值！</span></span><br><span class="line">    TL0 = beep_table[beep_select]%<span class="number">256</span>;</span><br><span class="line">	beep=!beep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编曲：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302081250459.png" alt="image-20230208125043337"></p>
<p>根据乐谱写一个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> little_star[]=&#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">19</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">21</span>, <span class="number">19</span>,    <span class="comment">//增时线</span></span><br><span class="line">                            <span class="number">17</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">16</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">14</span>, <span class="number">12</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">17</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">16</span>, <span class="number">14</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">17</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">16</span>, <span class="number">14</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">19</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">21</span>, <span class="number">19</span>, </span><br><span class="line">                            <span class="number">17</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">16</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">14</span>, <span class="number">12</span></span><br><span class="line">                           &#125;;</span><br></pre></td></tr></table></figure>

<p>遍历数组，得到的音高再去 beep_table 中获取重装载值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TH0 = beep_table[little_star[beep_select]]/<span class="number">256</span>; <span class="comment">// 因为触发中断时，TH TL 归零，所以记得赋初值！</span></span><br><span class="line">TL0 = beep_table[little_star[beep_select]]%<span class="number">256</span>;</span><br></pre></td></tr></table></figure>

<p>但是播放起来都是连着的，听起来效果并不好。可以每次播完一个音先关闭中断并延时一段时间，再继续播放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		beep_select++;</span><br><span class="line">		delayMs(<span class="number">50</span>);</span><br><span class="line">		TR0=<span class="number">0</span>;</span><br><span class="line">		delayUs(<span class="number">1</span>);</span><br><span class="line">		TR0=<span class="number">1</span>;		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>増时线如何处理？中间是不断开一直想的，因此需要几个特定的音符delay时间更长一些。怎么区分哪些音符加长哪些不加呢？</p>
<p>最好还是存储乐谱时搞一个二维数组（逻辑上物理上都可以），既能存储音高，也能存储时值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> little_star[]=&#123;<span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">8</span>,  <span class="comment">//增时线</span></span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">0xFF</span>,<span class="number">4</span><span class="comment">//终止标志防越界</span></span><br><span class="line">                           &#125;;</span><br></pre></td></tr></table></figure>

<p>如果数组大小超限，在魔术棒-Target-Memory Model 中选择第三个。不过这只是治标不治本，因为 RAM 只有512字节所以存不下太长。可以在定义数组时加上关键词 code 来存在 ROM 8K 的闪存中。不过这样的数组是只读的。</p>
<p>当然这样找索引比较麻烦。最好是索引全部重新宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//音符与索引对应表，P：休止符，L：低音，M：中音，H：高音，下划线：升半音符号#</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L1	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L1_	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L2	3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L2_	4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L3	5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L4	6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L4_	7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L5	8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L5_	9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L6	10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L6_	11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L7	12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M1	13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M1_	14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M2	15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M2_	16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M3	17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M4	18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M4_	19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M5	20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M5_	21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M6	22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M6_	23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M7	24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H1	25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H1_	26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H2	27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H2_	28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H3	29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H4	30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H4_	31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H5	32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H5_	33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H6	34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H6_	35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H7	36</span></span><br></pre></td></tr></table></figure>



<h1 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h1><p>动态数码管原理是什么？首先我们知道每个数码管都有 abcdefg 七个段。</p>
<p>8个数码管那我们按理来说是需要8*7个引脚，很浪费。</p>
<p>于是设计了动态数码管。首先所有数码管是共阴极的。然后我们选中哪一个数码管阴极赋0，就会启动哪一个数码管，传入的 abcdefg 就会点亮该数码管的对应段。</p>
<p>然后8个数码管像流水灯一样，以极高频率依次点亮，肉眼看到的就是8个数码管都被点亮且呈现出不同的图案。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301261308342.png" alt="image-20230126130808285"></p>
<p>开发板上的数码管是共阴极数码管，所有位共接一个阴极，给对应ABCDEF输入高电平点亮。</p>
<p>直接引脚：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301260119755.png" alt="直接引脚"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301261252056.png" alt="image-20230126125258985"></p>
<p>74译码器使用3位 bit 输入表示8种状态，调整 LED1~8 哪一个输出低电平，代表要启动8个数码管的哪一个的公共端。</p>
<p>输入的三位从最低位到最高位分别是P2^2, P2^3, P2^4，代表数码管从左到右的第几位是输入取反。</p>
<p>比如P2^4&#x3D;1, P2^3&#x3D;1, P2^2&#x3D;0, 输入就是110，取反后就是001，就是从左到右第1位数码管（从第0位开始）。</p>
<p>VCC 和 GND 是使能，接到译码器上一上电就工作。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301260059586.png" alt="image-20230126005938488"></p>
<p>P00<del>P07 代表控制当前数码管的 a</del>g 显示形式，接到 74HC245 缓冲器上而不是直接接到数码管上，使得单片机不用直接驱动数码管，Ai 连到 Bi 上。</p>
<p>OE 是使能，接地工作不接地不工作的原理。</p>
<p>DIR 是规定方向，高电平从左边读取数据传输到右边。低电平从右边读数据到左边。开发板上有个 J21 跳线帽，可以调整是 GND 与 LE 相连还是 VCC 与 LE 相连，也就是高电平输入 DIR 还是低电平输入 DIR。</p>
<p>数码管上面的 COM 是公共端，选中哪一个公共端（使得其&#x3D;0，因为是共阴极）就是调整哪一个数码管的点亮方式。</p>
<p>点亮一位数码管代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Display P0 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> display_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="comment">/*具体显示什么图案是怎么推算出来的呢？首先 abcdefg 和 dp 小数点段一共有8个要控制的段。</span></span><br><span class="line"><span class="comment">比如我们要呈现数字6，就是 acdefg 亮，b和小数点不亮。</span></span><br><span class="line"><span class="comment">因为数码管是共阴极，所以我们想让哪个段亮哪个段就输入高电平，和 LED 相反。</span></span><br><span class="line"><span class="comment">所以P00~P07 的输入应该是 1011 1110</span></span><br><span class="line"><span class="comment">然后我们直接给 P0 赋值的话，是 P0_7 在最高位，P0_0 在最低位，所以输入应该正好反过来，0111 1101，即0x7d。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Display=display_code[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//这个程序是从左到右显示12345678.当然完全也可以把确定哪一位数码管和确定要显示的数字封装成一个函数，点亮会更方便。</span></span><br><span class="line">		<span class="keyword">switch</span>(i)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;<span class="comment">//从左往右第0个数码管</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SMG_A_DP_PORT=gsmg_code[i];</span><br><span class="line">		delay_10us(<span class="number">100</span>);</span><br><span class="line">		SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消影</span></span><br><span class="line">    <span class="comment">//为什么要消影？ 不延时的话动态数码管会反复重复 位选 段选 位选 段选……位选之后不一定及时段选，可能前一位的位选就会赋给后一位。因此需要消影。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这种动态数码管扫描方式是单片机直接扫描，硬件会简单很多，但是会占据大量的 CPU 时间。有的动态数码管自带显存和扫描电路，只要告诉他要显示什么他会自动扫描显示。</p>
<h1 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h1><p>内部有一个金属片，按下后电路接通。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252340383.png" alt="image-20230125234043319" style="zoom: 50%;" />

<p>和学习 LED 时类似，所有 IO 口一开始都是高电平，我们给其接地就变成低电平了。</p>
<p>按下按键后一段时间内电平会高低抖动。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252359619.png" alt="image-20230125235945530" style="zoom:67%;" />

<p>1，先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻，所以默认 IO 为高 电平）。 </p>
<p>2，读取 IO 口电平确认是否有按键按下。 </p>
<p>3，如有 IO 电平为低电平后，延时几个毫秒。 </p>
<p>4，再读取该 IO 电平，如果仍然为低电平，说明按键按下。 </p>
<p>5，执行按键控制程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义独立按键控制脚</span></span><br><span class="line">sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//定义 LED1 控制脚</span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line">sbit LED2=P2^<span class="number">1</span>;</span><br><span class="line">sbit LED3=P2^<span class="number">2</span>;</span><br><span class="line">sbit LED4=P2^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">	<span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		delay_10us(<span class="number">1000</span>);<span class="comment">//10ms 消抖</span></span><br><span class="line">        <span class="comment">/*另一种消抖的方法：</span></span><br><span class="line"><span class="comment">        if(KEY==0)&#123;</span></span><br><span class="line"><span class="comment">        	delay_ms(20);</span></span><br><span class="line"><span class="comment">        	while(KEY==0);</span></span><br><span class="line"><span class="comment">        	delay(20ms);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        这个是针对按下按钮又抬起按钮之后的执行。*/</span></span><br><span class="line">		key=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		key=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY1_PRESS)<span class="comment">//检测按键 K1 是否按下</span></span><br><span class="line">		LED1=!LED1;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">		<span class="keyword">if</span>(key==KEY2_PRESS)<span class="comment">//检测按键 K2 是否按下</span></span><br><span class="line">		LED2=!LED2;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">		<span class="keyword">if</span>(key==KEY3_PRESS)<span class="comment">//检测按键 K3 是否按下</span></span><br><span class="line">		LED3=!LED3;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">		<span class="keyword">if</span>(key==KEY4_PRESS)<span class="comment">//检测按键 K4 是否按下</span></span><br><span class="line">		LED4=!LED4;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h1><p>为了减少 IO 口的占用，用4个 IO 口代表行，4个 IO 口代表列。</p>
<p>类似动态数码管快速扫描实现几乎同时点亮的效果，矩阵键盘也是快速扫描。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301262213298.png" alt="image-20230126221349232" style="zoom:67%;" />



<p>主要有两种扫描方法</p>
<p>行列式扫描法：每次给某一列赋值为0，然后检测这一列有无按钮按下。</p>
<p>​	按行扫描：通过设置 P17 16 15 14 中的一个为低电平来选择扫描哪一行。根据 P10 P11 P12 P13 的输入判断是哪一列。但是 	P15 口是蜂鸣器，不断反转会响。所以最好还是用按列扫描。</p>
<p>线翻转扫描方法：给所有列赋1，给所有行赋0，先判断在哪一行；然后用同样的方法判断在哪一列。</p>
<p>这里有一点问题就是：本单片机是准双向口输出，每个口既能做输入也能做输出而不用重新配置口线输出状态。其实这样相当于单片机一个引脚输出高电平，直接与另一个为低电平的引脚相连接。不会短路吗？</p>
<p>单片机的处理方法是这样的：内部 VCC 电源还附带一个下拉电阻。低电平的驱动力比高电平强，高电平直接接低电平就会被变为低电平，而不会短路。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_MATRIX_PORT P1 <span class="comment">//使用宏定义矩阵按键控制口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_matrix_ranks_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xf7</span>;<span class="comment">//1111 0111 给第一列也就是 P1_3 赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>)<span class="comment">//判断第一列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖。因为这里用了类似动态数码管的循环扫描的方法。</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第一列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x77</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;<span class="comment">//0111 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xb7</span>: key_value=<span class="number">5</span>;<span class="keyword">break</span>;<span class="comment">//1011 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xd7</span>: key_value=<span class="number">9</span>;<span class="keyword">break</span>;<span class="comment">//1101 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xe7</span>: key_value=<span class="number">13</span>;<span class="keyword">break</span>;<span class="comment">//1110 0111</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfb</span>;<span class="comment">//给第二列赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>)<span class="comment">//判断第二列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第二列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbb</span>: key_value=<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdb</span>: key_value=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xeb</span>: key_value=<span class="number">14</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfd</span>;<span class="comment">//给第三列赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>)<span class="comment">//判断第三列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第三列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbd</span>: key_value=<span class="number">7</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdd</span>: key_value=<span class="number">11</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xed</span>: key_value=<span class="number">15</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfe</span>;<span class="comment">//给第四列赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>)<span class="comment">//判断第四列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第四列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbe</span>: key_value=<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xde</span>: key_value=<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xee</span>: key_value=<span class="number">16</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    <span class="keyword">return</span> key_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_matrix_flip_scan</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//另一种扫描方式，这个函数暂时没有投入使用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0x0f</span>;<span class="comment">//给所有行赋值 0，列全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)<span class="comment">//判断按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//测试列</span></span><br><span class="line">            KEY_MATRIX_PORT=<span class="number">0x0f</span>;</span><br><span class="line">            <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存行为 0，按键按下后的列值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x07</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x0b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x0d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x0e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//测试行</span></span><br><span class="line">            KEY_MATRIX_PORT=<span class="number">0xf0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存列为 0，按键按下后的键值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x70</span>: key_value=key_value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xb0</span>: key_value=key_value+<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xd0</span>: key_value=key_value+<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xe0</span>: key_value=key_value+<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf0</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    key_value=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> key_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key=key_matrix_ranks_scan();</span><br><span class="line">        <span class="keyword">if</span>(key!=<span class="number">0</span>)</span><br><span class="line">        SMG_A_DP_PORT=gsmg_code[key<span class="number">-1</span>];<span class="comment">//得到的按键值减 1 换算成数组下标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO-扩展-串转并-74HC595"><a href="#IO-扩展-串转并-74HC595" class="headerlink" title="IO 扩展(串转并)-74HC595"></a>IO 扩展(串转并)-74HC595</h1><p>前面接的一些输入输出设备都是直接连接的单片机 IO 口，单片机仅有的 IO 口非常有限。而使用 IO 扩展可以大量增加可使用的端口。比如后面要使用的 LED 点阵，8*8个格子，使用扩展 IO 输入就更为合适。如果多级联一个，就又有了8位输出，能实现16*16的点阵。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301300101058.png"></p>
<p>由图可知，OE 低电平有效，因此 <strong>LED 点阵旁的跳线帽一定要接到 OE-GND 一端。</strong></p>
<p>74HC595 是一个位移缓存器，有8位串行输入、并行输出，并行输出是三态输出（高电平、低电平、高阻抗）。比如一次输入一个比特，输入八次，并行输出可以输出一个8位的字 1010 1010.</p>
<p>输出是由 VCC 驱动的，原理有那么一点像三极管。因为单片机内部是弱上拉，输出不足以点亮 LED 点阵，所以抛开 IO 口不够的问题，也不能直接接到 LED 点阵上，至少要有三极管。</p>
<h2 id="点亮-LED-点阵"><a href="#点亮-LED-点阵" class="headerlink" title="点亮 LED 点阵"></a>点亮 LED 点阵</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301300048214.png" alt="image-20230130004758073"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301300048730.png" alt="image-20230130004829583"></p>
<p>传入数据如列是0100 0000，行是0000 0001，则代表最后一行第二列的点会被点亮。</p>
<p>SRCLK：移位寄存器，数据先传输到移位寄存器中。移位寄存器<strong>上升沿</strong>时移位，再接收下一次数据。</p>
<p>RCLK：存储寄存器。存储寄存器<strong>上升沿</strong>时把寄存器中所有数据都通过端口输出。</p>
<p>相当于手枪，每次 SRCLK 上升时我们填入一枚子弹，RCLK 上升时把弹夹塞入。</p>
<p>QH 是级联用的。</p>
<p>列数据直接输入引脚，行数据输入 IO 拓展。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="comment">//编写程序先定义管脚和端口。管脚用sbit，端口宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MATRIX P0</span></span><br><span class="line">sbit SRCLK=P3^<span class="number">6</span>;</span><br><span class="line"><span class="comment">//因为 RCLK 是关键字不能被复用了</span></span><br><span class="line">sbit rCLK=P3^<span class="number">5</span>;</span><br><span class="line">sbit SER=P3^<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hc_led_arr[<span class="number">8</span>]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="keyword">while</span>(i--);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc_write_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span>&#123;</span><br><span class="line">	<span class="comment">//要传入8个输入，需要循环</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//注意 芯片传数据先传高位 再传低位，所以要反着写。这个问题在write函数内部解决，传入的数据和想要的形式一样就好。</span></span><br><span class="line">		<span class="comment">//通过移位获取</span></span><br><span class="line">		SER=c&gt;&gt;<span class="number">7</span>;</span><br><span class="line">		<span class="comment">//想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿</span></span><br><span class="line">		SRCLK=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//芯片一般给定一个延时时间，经过这个时间之后才能处理完毕</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		SRCLK=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//让传入数据的次高位变为下次循环的高位</span></span><br><span class="line">		c&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后通过存储寄存器的上升沿，传输全部数据</span></span><br><span class="line">	rCLK=<span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">	rCLK=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	LED_MATRIX=<span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		 <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		 	hc_write_data(<span class="number">0x00</span>);<span class="comment">//消隐</span></span><br><span class="line">		 	hc_write_data(hc_led_arr[i]);</span><br><span class="line">			delay(<span class="number">500000</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如0000 0001，传入LED阵列的数据是：每轮循环传入最高位的值，并且所有数据向左移动一位。因此前7轮 SER 传入都是0，最后一轮 SER 传入1，最下面一行全亮。</p>
<h2 id="LED-点阵实验"><a href="#LED-点阵实验" class="headerlink" title="LED 点阵实验"></a>LED 点阵实验</h2><p>上面的方法只能确定某一具体的行被点亮。可不可以具体确定哪些点点亮的方法？</p>
<p>我们让想被点亮的点列为低电平，行为高电平，就会被点亮。如果我们只想点亮第一行第一列的点，只需行脚只有第一行接高电平，列脚只有第一列接低电平即可。</p>
<p>所以只要先让第一列为低电平，其他列为高天平来只读取第一列，遍历所有行检查第一列哪些点应该被点亮；然后第二列，第三列……一次类推，每轮循环不用消除上次的结果即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="comment">//编写程序先定义管脚和端口。管脚用sbit，端口宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MATRIX P0</span></span><br><span class="line">sbit SRCLK=P3^<span class="number">6</span>;</span><br><span class="line">sbit rCLK=P3^<span class="number">5</span>;</span><br><span class="line">sbit SER=P3^<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hc_led_arr[<span class="number">8</span>]=&#123;<span class="number">0x38</span>,<span class="number">0x7C</span>,<span class="number">0x7E</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x7E</span>,<span class="number">0x7C</span>,<span class="number">0x38</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> col[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="keyword">while</span>(i--);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc_write_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span>&#123;</span><br><span class="line">	<span class="comment">//要传入8个输入，需要循环</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//注意 芯片传数据先传高位 再传低位，所以要反着写</span></span><br><span class="line">		<span class="comment">//通过移位获取</span></span><br><span class="line">		SER=c&gt;&gt;<span class="number">7</span>;</span><br><span class="line">		<span class="comment">//想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿</span></span><br><span class="line">		SRCLK=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//芯片一般给定一个延时时间，经过这个时间之后才能处理完毕</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		SRCLK=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//让传入数据的次高位变为下次循环的高位</span></span><br><span class="line">		c&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后通过存储寄存器的上升沿，传输全部数据</span></span><br><span class="line">	rCLK=<span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">	rCLK=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	LED_MATRIX=<span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		 <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		 	LED_MATRIX=col[i];</span><br><span class="line">		 	hc_write_data(hc_led_arr[i]);</span><br><span class="line">             <span class="comment">//不知道为什么，下面两部分不写图形会偏移。不知道会不会有大佬解答一下</span></span><br><span class="line">			delay(<span class="number">100</span>);</span><br><span class="line">			hc_write_data(<span class="number">0x00</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点阵的具体图案生成方法：字模提取软件。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540684.png" alt="image-20220908234813283"></p>
<h1 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h1><p>电脉冲信号转化为角位移。</p>
<p><strong>注意步进电机红色线接到5V的地方。</strong>以下程序意为：启动步进电机后，按按钮1旋转方向改变，按按钮2加速，按按钮3减速。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">sbit IN1_A=P1^<span class="number">0</span>;</span><br><span class="line">sbit IN2_B=P1^<span class="number">1</span>;</span><br><span class="line">sbit IN3_C=P1^<span class="number">2</span>;</span><br><span class="line">sbit IN4_D=P1^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义独立按键控制脚</span></span><br><span class="line">sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MINSPEED 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MAXSPEED 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">step_motor_28BYJ48_send_pulse</span><span class="params">(u8 step,u8 dir)</span>&#123;</span><br><span class="line">	u8 temp=step;</span><br><span class="line">	<span class="keyword">if</span>(dir==<span class="number">0</span>)temp=<span class="number">7</span>-step;<span class="comment">//逆时针旋转</span></span><br><span class="line">	<span class="keyword">switch</span>(temp)<span class="comment">//8 个节拍控制：A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">	<span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">	delay(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">	key=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">	key=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	u8 dir=<span class="number">0</span>;</span><br><span class="line">	u8 speed=STEPMOTOR_MAXSPEED;</span><br><span class="line">	u8 step=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		key=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">switch</span>(key)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRESS:dir=!dir;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY2_PRESS:<span class="keyword">if</span>(speed&gt;STEPMOTOR_MINSPEED)speed-=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY3_PRESS:<span class="keyword">if</span>(speed&lt;STEPMOTOR_MAXSPEED)speed+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		step_motor_28BYJ48_send_pulse(step++,dir);</span><br><span class="line">		step%=<span class="number">8</span>;</span><br><span class="line">		delay(speed*<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>使单片机能对外部或者内部随机发生的事件实时处理。</p>
<p>分时操作，实时响应，可靠性高。</p>
<p>中断相应条件：首先我们要确保相关配置都准备好了，CPU 允许中断，中断源允许中断，然后发生中断事件时才会正确触发中断。</p>
<p>中断可能还会被优先级更高的中断打断，支持这种操作的系统叫多级中断系统。</p>
<p>STC89C52 有8个中断，4外部，3定时器，1串口。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301270023159.png" alt="image-20230127002315074"></p>
<p>这是传统51单片机定时器中断结构，原理与 STC89C52 相近。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301270024434.png" alt="image-20230127002418325"></p>
<p>通过配置寄存器控制线路连接。比如上图中的开关就是由寄存器控制。</p>
<p>EA ENABLE ALL：即使能所有中断。</p>
<p>ET：中断允许位。</p>
<p>PT：中断优先级。只有一个 PT 只能决定是高或低两种优先级。更多的中断优先级寄存器可以决定更多中断优先级。</p>
<p>TCON 部分： time controller，不属于 CPU 部分，等到定时器部分展开叙述。</p>
<p>代码编写：主程序中需要包含：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EA=<span class="number">1</span>;<span class="comment">//总中断开关：打开</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//外部中断0开关：打开。</span></span><br><span class="line">IT0=<span class="number">0</span>/<span class="number">1</span>;<span class="comment">//外部中断触发方式的选择。如下降沿触发，或低电平触发。</span></span><br><span class="line"><span class="comment">//如果要配置外部中断1，则改为EX1和IT1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">()</span> interrupt 0 using 1<span class="comment">//using 1 可省略</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器中断实验"><a href="#定时器中断实验" class="headerlink" title="定时器中断实验"></a>定时器中断实验</h2><p>本章利用单片机自带的定时器来实现之前做过的操作：LED灯间歇闪烁。一直以来实现的方法都是借助while循环来拖延时间。定时器不仅更加准确，还可以节省下 CPU 的资源。</p>
<p>STC89C52 有3个定时器。</p>
<p><strong>CPU时序的相关知识</strong></p>
<p>振荡周期：为单片机提供信号的振荡源的周期（晶振周期）。12MHZ 的晶振振荡周期就是1&#x2F;12us, 求倒数。</p>
<p>状态周期：两个振荡周期&#x3D;1状态周期s（时钟周期）。</p>
<p>机器周期：6状态周期&#x3D;1机器周期。</p>
<p>指令周期：完成一条指令所用的全部时间，以机器周期为单位。</p>
<p><strong>定时器的相关知识</strong></p>
<p>定时器又可以计数，也叫计数器。不需要CPU参与自己就能完成任务，根据脉冲信号对寄存器中数据+1。来一个脉冲定时器+1，加到全为1后输出一个脉冲并归0.同时，向CPU发出计时器中断信息。</p>
<p>一般有四种工作模式：</p>
<p>13位定时器，16位定时器，8位自动重装模式，双8位计数器。</p>
<p>我们的工作模式用的是16位。</p>
<blockquote>
<p> 串口通信中为了精度考虑要使用自动重装模式。因为我们要自己设置每次溢出产生中断后 TH TL 的初值，这样吧比较容易出错且有点慢。8位自动重装模式就是舍弃了16位存储数据（到65535），只采用后八位 TL 计数（到255），初始值TH TL 赋一样的初值。TL 每次溢出，TH 把自己的值赋给 TL，这样就不用我们自己手动重新赋初值了，初值一直保存在 TH 中。</p>
<p>而且，在本例中我们使用定时器中断就是为了产生中断时给定时器赋初值并让灯切换状态。使用8位自动重装模式后，不用手动给定时器赋初值了；如果没有其他的需要定时器溢出时必须做的操作，定时器可以不用设置中断，起到一个可以看时间但是不会响的闹钟的功能，即 ET&#x3D;0。</p>
</blockquote>
<p>  <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301262352827.png" alt="image-20230126235200709"></p>
<p>左上角支路是时钟功能，左下角支路是计数功能，最终实现中断功能。</p>
<p>TH TL 寄存器最大能存储到65535.每来一次脉冲+1，加到最大值时 flag 申请中断。</p>
<p>SYSCLK 是晶振周期。另一个时钟是 T0 引脚，如果启用 T0 引脚定时器就变成计数器了，每来一个脉冲+1。</p>
<p>默认使用12T 的分频，把 12MHZ 分成12份，每一份就是1us。这个单片机上是没有对应调整的寄存器的，如果想使用 6T 的分频需要在 STC-ISP 中选择使能 6T 模式。</p>
<p>CT 是一位寄存器，赋1为C，即计数器；赋0为T，即时钟（T上面的横线就代表0时）。</p>
<p>每个定时器主要有两种寄存器：TCON TMOD。</p>
<p>TCON 包括：TF, TR, IE, IT。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301271148775.png" alt="image-20230127114845707"></p>
<p>​	TF 可见上图主路，TH TL 被允许计数后周期性+1计数，加到最大值时 TF&#x3D;1，并发起中断。处理完中断后恢复为0.</p>
<p>​	TR 可见上图支路，是开启中断的条件之一。</p>
<p>​	IE 是外部中断。</p>
<p>​	IT 是设置中断触发模式，比如设置为0是低电平触发，设置为1是下降沿触发。</p>
<p>TMOD 是不可寻址的寄存器，也就是只能整体赋值，不能像 P2 一样分开给每个变量赋值。包含：GATE, CT, M0, M1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301271149238.png" alt="image-20230127114908062"></p>
<p>​	GATE 用于开启定时器。当 GATE 打开, TR&#x3D;1（timer reset）且$\overline{INT1&#x2F;INT0}$ 为高（即打开中断引脚）时定时器开始工作。这一部分内容对应上图电路中的左下角。</p>
<p>​	M0M1 用于选定时钟的4个模式。比如16 位就是01. 两者包含一个叫做 TMOD 的不可位寻址的变量里，</p>
<p>​	CT就是打开定时器的计时还是时钟功能。</p>
<p>开启定时器计数功能及总中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">    TMOD|=<span class="number">0X01</span>;<span class="comment">//我们知道 TMOD 是不可位寻址，也就是里面虽然既包含了定时器1和0的寄存器，但是我们赋值只能一整个赋值。</span></span><br><span class="line">    <span class="comment">//如果直接给 TMOD=0x01，就会影响定时器1的值。因此我们用这两部先清空后四位，再单独给后四位赋值为0x01。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//TCON 中的 IE IT 对应就是支路图中的 INT0，因为我们开启了 GATE，或电路，因此 IE IT 不用设置也行。</span></span><br><span class="line">    <span class="comment">//我们知道 TH TL 合起来达到65535，也就是过了 65535个机器周期 后会触发中断。</span></span><br><span class="line">    <span class="comment">//比如我们现在想1ms触发一次中断，怎么处理呢？</span></span><br><span class="line">    <span class="comment">//12MHZ 下1us一个周期，1ms 1000个周期，因此我们每次设置初始值为64535，变为65535正好需要1ms。</span></span><br><span class="line">    <span class="comment">//11.0592MHz除12为921600Hz，就是1us 0.9216 个机器周期，因此初值为65535-922=64613.</span></span><br><span class="line">    <span class="comment">//我们可以给 TH TL 赋初始值，64535，这样只要过 1000us 就会触发中断。</span></span><br><span class="line">    <span class="comment">//然后因为 TH 和 TL 拼接变为一整个16位的寄存器，所以 TH 是高8位，TL 是低8位，分别用计算出的初值/256 %256得到最终结果。</span></span><br><span class="line">    TH0=<span class="number">0XFC</span>; <span class="comment">//64613/256=252=0xFC，我的单片机是 11.0592 MHZ</span></span><br><span class="line">    TL0=<span class="number">0X65</span>;<span class="comment">//64613%256=0x65</span></span><br><span class="line">    </span><br><span class="line">    TF0=<span class="number">0</span>;<span class="comment">//归零，防止刚配置好就产生中断。可有可无</span></span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器，开启中断条件之一</span></span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    PT0=<span class="number">0</span>;<span class="comment">//设置中断优先级为低。默认也是低，不写也没关系。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STC-ISP 上也有生成定时器函数。不过 AUXR 设置定时器时钟那一步是针对最新版本可以调整单片机定时器使能而添加的，我们的单片机加上会报错，需要删掉。</p>
<p>另外需要手动添加 ET EA PT。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301271643006.png" alt="image-20230127164307914"></p>
<p>LED灯间隔1s闪烁代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED=P2^<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//不再重写了~</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">time0</span><span class="params">()</span> interrupt 1&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">	TH0=<span class="number">0XFC</span>; <span class="comment">//因为触发中断时，TH TL 归零，所以记得赋初值！</span></span><br><span class="line">	TL0=<span class="number">0X65</span>;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i=<span class="number">0</span>;</span><br><span class="line">		LED=!LED;<span class="comment">//闪烁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	time0_init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外部中断实验"><a href="#外部中断实验" class="headerlink" title="外部中断实验"></a>外部中断实验</h2><p><strong>运行程序前，请摘下红外接收传感器。因为共用P3^2引脚，会干扰实验结果。</strong></p>
<p>51单片机都有2个外部中断。STC89C5X系列有INT0~INT3四个。</p>
<p>对于三个参数的初始化，一般用一个init函数执行，在main的最开头。</p>
<p>本例中，我们用按键3作为外部中断源。按下按键3就会产生中断。中断执行的指令就是点亮或熄灭LED灯。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED=P2^<span class="number">0</span>;</span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>&#123;</span><br><span class="line">	EA=<span class="number">1</span>;<span class="comment">//总中断开关：打开</span></span><br><span class="line">	EX0=<span class="number">1</span>;<span class="comment">//外部中断0开关：打开。</span></span><br><span class="line">	IT0=<span class="number">1</span>;<span class="comment">//外部中断触发方式的选择。如下降沿触发，或低电平触发。	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">()</span> interrupt 0&#123;</span><br><span class="line">	delay(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">if</span>(KEY3==<span class="number">0</span>)&#123;</span><br><span class="line">		LED=!LED;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	interrupt_init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="通信基础知识"><a href="#通信基础知识" class="headerlink" title="通信基础知识"></a>通信基础知识</h2><p>单片机还可以通过IO口实现多种通信。</p>
<p><strong>串行通信</strong>：一条数据线，一次发1bit，发很久。</p>
<p><strong>并行通信</strong>：多条数据线，同时发送，发的速度快多了但是费用高、接收困难、抗干扰性差。</p>
<p><strong>异步通信</strong>：发送和接收方时钟可以不用完全一致。</p>
<p><strong>同步通信</strong> ：发送和接收方时钟要完全一致。</p>
<p><strong>单工、半双工、全双工通信</strong>：数据的传输方式，略。</p>
<p>比特率：位&#x2F;s。</p>
<p>波特率：码元&#x2F;s。</p>
<p>溢出率：比如13us溢出一次。溢出率就是1&#x2F;13us。</p>
<p>校验位：如奇偶校验位。</p>
<p>停止位：分隔数据帧。</p>
<p>（有那么一点点感谢通原了~）</p>
<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p>串口通信，指外设和计算机之间通过数据线等传输数据的一种通信方式。比如RS-系列，大多数计算机应该都有对应的梯形接口。51单片机内自带<strong>UART</strong>（Universal Asynchronous Receiver Transmitter，通用异步收发器），可实现与计算机之间的串口通信！</p>
<p>单片机串口通信的管脚：VCC TXD（发送数据，串行输出）RXD（接收数据，串行输入）SGND（信号接地）。</p>
<p><em>电脑的串口还有很多管脚，如 RTS CTS，单片机的相对简单很多。</em></p>
<p>TXD和RXD用正负电压表示逻辑1和0，51单片机采用TTL 晶体管-晶体管逻辑集成电路，用高低电平表示逻辑状态（+5V：1；0V：0），所以需要转换型时候才能与计算机串口通信。</p>
<p><em>还有两种电平状态：RS232，3<del>15V 表示低（注意），-15</del>-3V 表示高。RS485，两线压差（差分信号）2<del>6V 表示高，-6</del>-2V 表示低。</em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301282311596.png" alt="image-20230128231105461"></p>
<p>STC89C52系列有一个通用异步收发器（UART P30 P31端口），有四种工作模式。</p>
<ul>
<li>模式0：同步移位寄存器；</li>
<li>模式1：8位UART，波特率可变（<strong>常用</strong>）；</li>
<li>模式2：9位UART，波特率固定；</li>
<li>模式3：9位UART，波特率可变.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301290130378.png" alt="image-20230129013008311"></p>
<p>TXD RXD 直接接到单片机 P30 P31 上. 另一端是单片机上自带的，我们把数据线连到电脑上就接上了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301290143413.png" alt="image-20230129014312317"></p>
<p>溢出率到波特率的计算见图。</p>
<p>串口助手和单片机要规定好发送数据的形式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301291933058.png" alt="image-20230129193307966"></p>
<p>串口数据缓存寄存器：SBUF。物理上是接收和发送两个寄存器，实际上共用相同的地址，只是使用时有不同的意义。我们只需要把数据放入其中就行，发送原理暂不用弄明白。</p>
<p>SCON：串口控制寄存器。控制电路。包含：</p>
<p>​	SM0，SM1：设置工作方式。比如我们采用8位 UART，就赋值01.</p>
<p>​	SM2：与工作方式1无关。</p>
<p>​	REN：是否允许串行接收状态。1允许接收。</p>
<p>​	TB8 RB8：接收到的第9位数据，与工作方式1无关。</p>
<p>​	TI RI：发送接收中断请求标志位。代表发送完了。硬件赋1，需要用软件复位。</p>
<p>赋值的话只有 SM0 SM1&#x3D;01，和 REN 需要注意，其他的初始值都&#x3D;0。</p>
<p>PCON：电源管理。包含：</p>
<p>​	SMOD：可见支路图，用于设置波特率是否加倍。</p>
<p>​	SMOD1：纠错或协助 SM0 设置工作方式。</p>
<p>IE：打开中断。</p>
<p>移位寄存器会触发对应中断。在中断图中的 TI RI，触发的是同一个中断。</p>
<p><strong>实施串口通信</strong></p>
<p>STC-ISP自带一个串口调试助手。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301030207020.png" alt="image-20230103020705868"></p>
<p>串口选择左侧和串口号一致的选项。</p>
<p>STC89C52串口初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">    SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1。40是 REN 关闭，50是打开，代表单片机是否可以接收数据</span></span><br><span class="line">    PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍，0就是不加倍</span></span><br><span class="line">    TH1=<span class="number">0XFA</span>; <span class="comment">//计数器初始值设置，根据波特率为9600</span></span><br><span class="line">    TL1=<span class="number">0XFA</span>;</span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//打开计数器1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化函数也可以在 STC-ISP 中生成。这里会发现 12MHZ 的晶振相较 11.0592 MHZ 的晶振误差较大，要通过波特率加倍才能减少一些。这就是 11.0592 MHZ 晶振的设计原因。</p>
<p><strong>单片机向电脑发送数据</strong>：给SBUF赋值即可。</p>
<p>在程序中发送可以直接<code>SBUF=0X11;</code>单片机就会收到11的信息，点击复位按钮后可以在串口助手的接收缓冲区中看到。</p>
<p>赋值后需要一段时间才能发送完成，发送完成后TI不再是0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    uart_init();</span><br><span class="line">    SBUF=<span class="number">0x11</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);TI=<span class="number">0</span>;<span class="comment">//=1说明发送完成，然后手动复位</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就在程序中发送了11信息。</p>
<p><strong>电脑给单片机发送数据</strong>：通过串口助手发信息可以通过串口中断<code>interrupt 4</code>实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart</span><span class="params">()</span> interrupt 4 <span class="comment">//串口通信中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    u8 rec_data;</span><br><span class="line">    P2=<span class="number">0x00</span>;<span class="comment">//这一句使得函数成功触发时LED灯全亮，便于调试</span></span><br><span class="line">    <span class="keyword">if</span>(RI==<span class="number">1</span>)&#123;P2=~SBUF;RI=<span class="number">0</span>;&#125;<span class="comment">//因为发送和接收中断共用4中断，这句用于区分具体是发送还是接收中断</span></span><br><span class="line">    <span class="comment">//如果是接收中断，RI=1，那么只简单执行这两句即可。</span></span><br><span class="line">    SBUF=rec_data; <span class="comment">//将接收到的数据放入到发送寄存器</span></span><br><span class="line">    <span class="keyword">while</span>(!TI); <span class="comment">//等待发送数据完成</span></span><br><span class="line">    TI=<span class="number">0</span>; <span class="comment">//清除发送完成标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序可以将发送缓冲区中输入的数据发给单片机，单片机再在接收缓冲区中原封不动地呈现出来。</p>
<p>文本模式和 HEX 模式就是文本和 ASCII 码的转换。</p>
<h1 id="封装头文件；绘制LED动画"><a href="#封装头文件；绘制LED动画" class="headerlink" title="封装头文件；绘制LED动画"></a>封装头文件；绘制LED动画</h1><p>类似C语言的语法，部分函数等内容可以封装到头文件里，需要的时候引入到source file 中，再在 include 中指明即可正常使用。</p>
<p>编写.h文件：如：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301031627395.png" alt="image-20230103162731330"></p>
<p>引入.h文件：右键左侧的.c文件→options for file→C51→include path→找到.h文件所在的文件夹并选中，注意<strong>一定不能有中文路径</strong>。然后就可以使用.h文件中定义的变量和函数了，注意<strong>不能重复定义</strong>。</p>
<p>什么内容封装到函数里呢？静态的方法待调用的封装进去。逻辑判断后决定使用哪个方法这类的就不用放进函数里了，因为逻辑判断很可能经常改。</p>
<p>接下来就自己试着先把delay函数和矩阵LED绘制函数写入头文件，然后制作矩阵动画，这样动起来也会更方便一些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"></span><br><span class="line">	sbit SRCLK = P3 ^ <span class="number">6</span>;</span><br><span class="line">	sbit rCLK = P3 ^ <span class="number">5</span>;</span><br><span class="line">	sbit SER = P3 ^ <span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function name: time0_init</span></span><br><span class="line"><span class="comment"> * Function paremeter: void</span></span><br><span class="line"><span class="comment"> * Function performance: 初始化定时器。只有执行此函数后才能使用单片机的定时器功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD |= <span class="number">0X01</span>; <span class="comment">// 选择为定时器 0 模式，工作方式 1</span></span><br><span class="line">	TH0 = <span class="number">0XFC</span>;	  <span class="comment">// 给定时器赋初值，定时 1ms</span></span><br><span class="line">	TL0 = <span class="number">0X18</span>;</span><br><span class="line">	ET0 = <span class="number">1</span>; <span class="comment">// 打开定时器 0 中断允许</span></span><br><span class="line">	EA = <span class="number">1</span>;	 <span class="comment">// 打开总中断</span></span><br><span class="line">	TR0 = <span class="number">1</span>; <span class="comment">// 打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function name:time0</span></span><br><span class="line"><span class="comment"> * Function paremeter: void</span></span><br><span class="line"><span class="comment"> * Function performance: 启动定时器。定时器计数器time_counter在0~10000之间循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void time0() interrupt 1&#123;</span></span><br><span class="line"><span class="comment">	TH0=0XFC; //给定时器赋初值，定时 1ms</span></span><br><span class="line"><span class="comment">	TL0=0X18;</span></span><br><span class="line"><span class="comment">	time_counter++;</span></span><br><span class="line"><span class="comment">	bit pass_1s=0;</span></span><br><span class="line"><span class="comment">	if(time_counter==1000)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		time_counter=0;</span></span><br><span class="line"><span class="comment">		pass_1s=~pass_1s;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 delay_10us)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(delay_10us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc_write_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 要传入8个输入，需要循环</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 注意 芯片传数据先传高位 再传低位，所以要反着写</span></span><br><span class="line">		<span class="comment">// 通过移位获取</span></span><br><span class="line">		SER = c &gt;&gt; <span class="number">7</span>;</span><br><span class="line">		<span class="comment">// 想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿</span></span><br><span class="line">		SRCLK = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 芯片一般给定一个延时时间，经过这个时间之后才能处理完毕</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		SRCLK = <span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 让传入数据的次高位变为下次循环的高位</span></span><br><span class="line">		c &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后通过存储寄存器的上升沿，传输全部数据</span></span><br><span class="line">	rCLK = <span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">	rCLK = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_led_animation</span><span class="params">(u8 hc_led_arr[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> col[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	P0=<span class="number">0x00</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		P0=col[i];</span><br><span class="line">		hc_write_data(hc_led_arr[i]);</span><br><span class="line">        <span class="comment">//不知道为什么，下面两部分不写图形会偏移。不知道会不会有大佬解答一下</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		hc_write_data(<span class="number">0x00</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是利用取模软件得到要绘制的图案的字模。这里我选定的图案是之前圣诞节临摹过的像素画中”Merry Christmas“的字体。参照来源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZK41167sF/?spm_id_from=333.337.search-card.all.click">圣诞节 像素画 圣诞树🎄_哔哩哔哩_bilibili</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301041233469.png" alt="image-20230104123321341"></p>
<p>绘制部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyHFile.H&gt;</span></span></span><br><span class="line">u8 anime_row[]=&#123;</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>,</span><br><span class="line"> <span class="number">0x40</span>, <span class="number">0x7C</span>, <span class="number">0x40</span>, <span class="number">0x7C</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x14</span>, <span class="number">0x18</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x1D</span>,</span><br><span class="line"> <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>, <span class="number">0x44</span>, <span class="number">0x44</span>, <span class="number">0x44</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x7C</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x5C</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>, <span class="number">0x14</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x14</span>,</span><br><span class="line"> <span class="number">0x1C</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">for</span>(cnt;cnt&lt;<span class="number">62</span>;cnt++)&#123;</span><br><span class="line">		u8 row[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		row[<span class="number">0</span>]=anime_row[cnt];</span><br><span class="line">		row[<span class="number">1</span>]=anime_row[cnt+<span class="number">1</span>];</span><br><span class="line">		row[<span class="number">2</span>]=anime_row[cnt+<span class="number">2</span>];</span><br><span class="line">		row[<span class="number">3</span>]=anime_row[cnt+<span class="number">3</span>];</span><br><span class="line">		row[<span class="number">4</span>]=anime_row[cnt+<span class="number">4</span>];</span><br><span class="line">		row[<span class="number">5</span>]=anime_row[cnt+<span class="number">5</span>];</span><br><span class="line">		row[<span class="number">6</span>]=anime_row[cnt+<span class="number">6</span>];</span><br><span class="line">		row[<span class="number">7</span>]=anime_row[cnt+<span class="number">7</span>];</span><br><span class="line">		matrix_led_animation(row);</span><br><span class="line">		delay(<span class="number">5000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然因为每次绘制完成必须擦除再重新绘制，导致看起来一闪一闪的。</p>
<p>不过最终的动画效果还是不错的~</p>
<h1 id="IIC-AT24C02"><a href="#IIC-AT24C02" class="headerlink" title="IIC, AT24C02"></a>IIC, AT24C02</h1><p>掉电不丢失的存储器。存储结构是 E2PROM，通讯方式是 I2C。</p>
<h2 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h2><p>存储器主要分为 RAM 易失性存储器和 ROM 非易失性存储器，RAM 存取快但掉电丢失，ROM 正相反。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170018818.png" alt="image-20230217001811596" style="zoom:80%;" />

<p>SRAM：锁存器，速度最快。</p>
<p>DRAM：电容，充电1放电0. 但是电容漏电比较严重，需要扫描器每隔一段时间检查一下是否漏电，漏电再充。</p>
<p>ROM 名字来源于 read-only，但是后期的非易失性存储器都可以写入，只是沿用了名字。</p>
<p>MASK ROM：不可写入。</p>
<p>PROM：只能写入一次。</p>
<p>EPROM：可擦除，但是形式比较麻烦，要用紫外线照射很久。</p>
<p>E2PROM：电擦除更加方便，我们现在的单片机所用。但是容量小。</p>
<p>FLASH：应用广泛。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170605706.png" alt="image-20230217060513510" style="zoom: 50%;" />

<p>这只是一个有助理解的简化模型~</p>
<p>选定一些结点导通，比如我们读取第一行地址1处的数据，发现第1&#x2F;2&#x2F;3个结点导通，其他节点都未导通，则从最下端读到的该处地址的数据为：1110 0000。</p>
<p>MASK ROM 中，两条线中没有二极管，则两条线都通电流就会导通。有二极管后，数据总线无法流下来，为低电平。</p>
<p>PROM 中如何实现可编程写入一次？蓝色的二极管容易被击穿。被击穿后二极管的通路变为断路，导通；否则和 MASK ROM 低电平原理一样。</p>
<p>EPROM 是二极管可以恢复。</p>
<p>选中哪条总线可以通过三位138译码器的输入决定。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170627913.png" alt="image-20230217062720840"></p>
<p>VCC 范围：1.8~5.5v</p>
<p>WE&#x2F;WR：写保护，WR 高电平保护，不能写入。可以看到 WE 标明低电平启用，而且单片机上的 EEPROM 直接 WE 接地了。</p>
<p>SCL SDA：I2C 接口。</p>
<p>E1 E2：I2C 地址。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170634937.png" alt="image-20230217063431839"></p>
<p>大概是能看懂的。SCL SDA 传入数据后，看是 R&#x2F;W 哪个地址里的数据，通过 DEC 译码器找到地址 R&#x2F;W，通过串行多路复用器 serial MUX 把并行数据转化为串行并输出。</p>
<h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><p>I2C（Inter－Integrated Circuit BUS）总线是由 PHILIPS 公司开发的两线式 串行总线，用于连接微控制器及其外围设备。因为各家自己开发的数据总线可能不通用，PHILIPS 公司开发了这款统一通信标准。这样不仅方便了芯片开发，也便于大家学习。</p>
<h3 id="I2C-结构"><a href="#I2C-结构" class="headerlink" title="I2C 结构"></a>I2C 结构</h3><p>I2C 只有两根双向信号线，一根是 SDA 数据线，一根是 SCL 时钟线。是同步、半双工的通信线，带数据应答。</p>
<p>所有设备的 SCL 和 SDA 都连在总线上。设备的 SCL SDA 是开漏输出的（高电平直接接地），SCL 和 SDA 又要添加弱上拉电阻。这两共同作用实现了“线与”的功能，避免各个设备通信相互干扰。</p>
<p>如下图所示，设备上的 SCLK SDA 是开漏输出。如果给高电平导通开关， IN 也是接地，该设备就无法读取输入数据不会被干扰。否则如果是低电平关闭开关，数据会流出 DATA IN。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170723919.png" alt="image-20230217072355835"></p>
<p>主机：启动数据传送并产生时钟信号的设备； </p>
<p>从机：被主机寻址的器件； </p>
<p>多主机：同时有多于一个主机尝试控制总线但不破坏传输； </p>
<p>主模式：用 I2CNDAT 支持自动字节计数的模式； 位 I2CRM,I2CSTT,I2CSTP 控制数据的接收和发送； </p>
<p>从模式：发送和接收操作都是由 I2C 模块自动控制的； </p>
<p>仲裁：是一个在有多个主机同时尝试控制总线但只允许其中一个控制总线并 使传输不被破坏的过程； </p>
<p>同步：两个或多个器件同步时钟信号的过程； </p>
<p>发送器：发送数据到总线的器件；</p>
<p>接收器：从总线接收数据的器件。</p>
<h3 id="I2C-协议"><a href="#I2C-协议" class="headerlink" title="I2C 协议"></a>I2C 协议</h3><p>①时钟信号周期性的高电平低电平。只有时钟信号为低电平时，数据信号才能变化。</p>
<p>②起始和停止信号：SCLK 高电平时，SDA 由高→低为开始，低→高为结束。</p>
<p>④发送数据：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171111865.png" alt="image-20230217111133747" style="zoom:67%;" />

<p>先发 start 标识，后跟一个字节，第一个字节是地址+读写位。前四位固定，比如 24C02 是1010. 后三位是地址。收到接收应答后就开始发送数据。读写位 $R&#x2F;\overline{W}$ .</p>
<p>SCLK 低电平时，SDA 先设置好要传的数据。然后 SCLK 变为高电平后 SDA 不允许再数据变化，SCLK 先读取数据。这样发送一位，SCLK 再变为低电平，如此循环。</p>
<p>发送器件传输完一个字节8位数据后，后面必须紧跟一个ACK&#x2F;NACK校验位，判断接受是否完成，数据传送是否可以继续。接收方会让主机在发完的下一个时钟信号收到接收应答。 </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301042045379.png" alt="image-20230104204527296"></p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171118952.png" alt="image-20230217111807804" style="zoom: 80%;" />

<p>复合数据帧格式：先发再收。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171135305.png" alt="image-20230217113542179" style="zoom:80%;" />

<p>字节写：规定一个字节数据地址，写入和读取都去那里。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171137046.png" alt="image-20230217113728972" style="zoom:80%;" />

<p>随机读：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171927490.png" alt="image-20230217192714230" style="zoom:80%;" />

<p>③总线寻址方式</p>
<p>从机有自己的地址，总线寻址采用7或10位的寻址位数。如7位：位定义D0表示数据传送方向位（是主机从从机读取数据？还是主机向从机写数据？代表这个从机是接收器还是发送器），D7~D1是从机地址位。</p>
<p>主机发送一个地址后，所有从机前7位地址和主机比较，如果相同再判断从机是接收还是发送器。</p>
<p>从机地址包含固定位和可编程位，可编程位决定了这个部件可以最多有多少个接入总线。如4位固定位，3位可编程位，说明2^3&#x3D;8个最多可以接入总线。</p>
<p>④数据传输</p>
<p>起始信号 S+7位从机地址+数据方向位+ACK+数据+NACK+终止信号。如果主机还想要新的数据传送，可以不终止，继续发出起始信号向另一从机寻址。</p>
<p>数据方向位&#x3D;0：主机向从机发送数据。主机一直发到从机返回 NACK 为止。</p>
<p>数据方向位&#x3D;1：从机向主机发送数据，发送到主机返回 NACK 为止。</p>
<h2 id="AT24C02"><a href="#AT24C02" class="headerlink" title="AT24C02"></a>AT24C02</h2><p>是一个2k位串行CMOS，主板上的主板上的一块可读写的并行或串行FLASH芯片。该芯片有 I2C 接口，是个从机。而且有写保护功能，其中写入的数据断电不丢失。</p>
<p>我们可以通过单片机的模拟 IIO 功能，将数据写入该芯片永久存储，下次断电时也能访问。</p>
<h2 id="创建多文件工程"><a href="#创建多文件工程" class="headerlink" title="创建多文件工程"></a>创建多文件工程</h2><p>下面编写的程序要求：</p>
<p>设计一个系统，可以写入、读取 AT24C02 中的数据，并将其中的数据用数码管显示出来。</p>
<p>这个系统涉及之前学过的按键、数码管信息，还涉及新的 AT24C02 的使用，三部分代码。由于内容太多，所以这次我们创建一个多文件系统，以后也会用这个系统模板更好的管理文件。</p>
<p>本项目主要包含：</p>
<p>App 文件夹：存储各类函数</p>
<p>Obj 文件夹：存放编译产生的 hex 文件、列表清单等。</p>
<p>Public 文件：存放公共文件，如延时、变量重定义。</p>
<p>User：存放 main.c 等主函数文件。</p>
<p><strong>创建步骤：</strong></p>
<p>①新建一个项目文件夹，在该项目文件夹中新建以上四个文件夹。</p>
<p>②在 Keil 中新建项目，选中这个项目文件夹。选择不复制 StartUp 代码。</p>
<p>③点击魔术棒右边的三色方块，创建三个分组 Group。这里创建的分组是一个逻辑上的分组，并不是指选中这三个具体的文件夹。与三个文件夹起名相同是为了方便管理.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301051154952.png" alt="image-20230105115404825"></p>
<p>④编写程序.</p>
<p>清楚了我们的需求，我们想一下要写那些代码，放在什么地方。</p>
<p>公共内容：public 中。</p>
<p>使用按钮代码：App中。</p>
<p>使用数码管代码：App中。</p>
<p>使用 AT24C02 代码：App 中。</p>
<p>调用以上几部分内容代码：main 中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301051344402.png" alt="image-20230105134459205"></p>
<p>把普中部分代码复制到单片机中，大意：按键1将当前数据写入芯片，按键2读取芯片中存储的数据，按键3将当前数据+1，按键4将当前数据清零。</p>
<p>iic：定义i2c总线的一些方法。如开始等待接收数据、结束关闭、ack、nack、wait ack、读取写入数据等方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////iic.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _iic_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _iic_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义EEPROM控制脚</span></span><br><span class="line">sbit IIC_SCL=P2^<span class="number">1</span>;<span class="comment">//SCL时钟线</span></span><br><span class="line">sbit IIC_SDA=P2^<span class="number">0</span>;<span class="comment">//SDA数据线</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC所有操作函数				 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_start</span><span class="params">(<span class="type">void</span>)</span>;			<span class="comment">//发送IIC开始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_stop</span><span class="params">(<span class="type">void</span>)</span>;	  		<span class="comment">//发送IIC停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_write_byte</span><span class="params">(u8 txd)</span>;	<span class="comment">//IIC发送一个字节</span></span><br><span class="line">u8 <span class="title function_">iic_read_byte</span><span class="params">(u8 ack)</span>;		<span class="comment">//IIC读取一个字节</span></span><br><span class="line">u8 <span class="title function_">iic_wait_ack</span><span class="params">(<span class="type">void</span>)</span>; 			<span class="comment">//IIC等待ACK信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_ack</span><span class="params">(<span class="type">void</span>)</span>;				<span class="comment">//IIC发送ACK信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_nack</span><span class="params">(<span class="type">void</span>)</span>;			<span class="comment">//IIC不发送ACK信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////iic.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>; <span class="comment">// SCL为高电平时，SDA的数据才有效</span></span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SDA = <span class="number">0</span>; <span class="comment">// SCL SDA 都由高变低，是起始标志</span></span><br><span class="line">    </span><br><span class="line">	delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_ack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_nack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">iic_wait_ack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 time_temp = <span class="number">0</span>;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (IIC_SDA)</span><br><span class="line">    &#123; <span class="comment">// 等待数据变成0</span></span><br><span class="line">        <span class="keyword">if</span> (++time_temp &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iic_stop();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">iic_read_byte</span><span class="params">(u8 ack)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>, receive = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        IIC_SCL = <span class="number">0</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL = <span class="number">1</span>;</span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (IIC_SDA)</span><br><span class="line">            receive += <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        iic_nack();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iic_ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_write_byte</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            IIC_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            IIC_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL = <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL = <span class="number">0</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>24c02：主要就是芯片调用iic来写入或取出数据的函数。看上去倒没有多少自己的东西。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////24c02.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _24c02_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _24c02_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_write_one_byte</span><span class="params">(u8 addr, u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">at24c02_read_one_byte</span><span class="params">(u8 addr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////24c02.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;24c02.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_write_one_byte</span><span class="params">(u8 addr, u8 dat)</span>&#123;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0xA0</span>);<span class="comment">//写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr);<span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(dat);</span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_stop();<span class="comment">//停止条件</span></span><br><span class="line">    delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">at24c02_read_one_byte</span><span class="params">(u8 addr)</span>&#123;</span><br><span class="line">	u8 temp;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0xA0</span>);<span class="comment">//写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr);<span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(<span class="number">0xA1</span>);<span class="comment">//进入接收模式</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    temp=iic_read_byte(<span class="number">0</span>);<span class="comment">//读取条件</span></span><br><span class="line">    iic_stop();<span class="comment">//停止条件</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>public.h和.c里面就是装了u8 u16 和 delay 函数的定义。不用多说。</p>
<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;public.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;display.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;24c02.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_ADDRESS 0<span class="comment">//数据存入EEPROM 的起始地址</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    u8 key_temp=<span class="number">0</span>;</span><br><span class="line">    u8 save_value=<span class="number">0</span>;<span class="comment">//每次刚打开单片机时，起始值都=0</span></span><br><span class="line">    u8 save_buf[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        key_temp=key_scan(<span class="number">0</span>);<span class="comment">//单词扫描按键获取当前按键</span></span><br><span class="line">        <span class="keyword">switch</span>(key_temp)&#123;<span class="comment">//按键1：写入</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">case</span> KEY1_PRESS:</span><br><span class="line">                at24c02_write_one_byte(EEPROM_ADDRESS,save_value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KEY2_PRESS:</span><br><span class="line">                save_value=at24c02_read_one_byte(EEPROM_ADDRESS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KEY3_PRESS:</span><br><span class="line">                <span class="keyword">if</span>(save_value&lt;<span class="number">255</span>)save_value++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KEY4_PRESS:</span><br><span class="line">                save_value=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        save_buf[<span class="number">0</span>]=save_value/<span class="number">100</span>;</span><br><span class="line">        save_buf[<span class="number">1</span>]=save_value/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">        save_buf[<span class="number">2</span>]=save_value%<span class="number">10</span>;</span><br><span class="line">        smg_display(save_buf,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> dat=<span class="number">0</span>,KeyNum;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	<span class="comment">//LCD_ShowString(1,1,&quot;Hello!&quot;);</span></span><br><span class="line">	<span class="comment">//AT24C02_WriteByte(1,66);//256 位字节，存入数据不 &gt;256</span></span><br><span class="line">	<span class="comment">//delayMs(50);//两次写之间需要的时间间隔</span></span><br><span class="line">	<span class="comment">//AT24C02_WriteByte(2,34);//256 位字节</span></span><br><span class="line">	<span class="comment">//delayMs(50);</span></span><br><span class="line">	<span class="comment">//dat=AT24C02_ReadByte(1);</span></span><br><span class="line">	<span class="comment">//delayMs(50);</span></span><br><span class="line">	<span class="comment">//dat1=AT24C02_ReadByte(2);</span></span><br><span class="line">	LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		KeyNum=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">switch</span>(KeyNum)&#123;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRESS:</span><br><span class="line">				<span class="keyword">if</span>(dat&lt;<span class="number">255</span>)dat+=<span class="number">1</span>;</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;++&quot;</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY2_PRESS:</span><br><span class="line">				<span class="keyword">if</span>(dat&gt;<span class="number">0</span>)dat-=<span class="number">1</span>;</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;--&quot;</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY3_PRESS:</span><br><span class="line">				AT24C02_WriteByte(<span class="number">1</span>,dat);</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Write Complete!&quot;</span>);</span><br><span class="line">				delayMs(<span class="number">50</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY4_PRESS:</span><br><span class="line">				dat=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Read Complete!&quot;</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p>一开始运行，显示当前数字000.</p>
<p>按下按钮1，数字++。</p>
<p>按下按钮2，数字–。</p>
<p>按下按钮3，当前数字会写入。</p>
<p>按下按钮4，会读取 AT24C02 中存储的数字显示出来。断电也能保存。</p>
<p>一个字节确实只能存到 255. 我们可以拿 12 两个存储地址合起来存储一个数据，一个存储高八位 &#x2F;256，一个存储低八位 %256. 取数据的时候 <code>datl|=dath&lt;&lt;8;</code></p>
<p>写入多位时，延时间隔应该&gt;5ms！因为 at24c02 的写入还是很慢的。</p>
<h1 id="温度传感器-DS18B20"><a href="#温度传感器-DS18B20" class="headerlink" title="温度传感器 DS18B20"></a>温度传感器 DS18B20</h1><p>单片机上自带的温度传感器模块：DS18B20。是一种常见的数字温度传感器。不用 ADC，自己处理好数据后放到 RAM 中，我们取出来就能用。</p>
<p>总线结构，可以把很多设备挂到总线上，省 IO 口；有温度报警装置；寄生供电（总线高电平可以供电）.</p>
<p>寄生供电需要添加强上拉电阻。</p>
<p>传感器很简单，只有三个引脚：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303222226823.png" alt="image-20230322222620666"></p>
<p>DQ 是 P37。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303222324058.png" alt="image-20230322232422937"></p>
<p>具体结构如上图。寄生供电使得 DQ 也可以供电。</p>
<p>ROM 是寻址用，可以跳过。</p>
<p>SCRATCHPAD：暂存器，读取的数据在其中。</p>
<p>EEPROM：存储一些配置信息，比如报警阈值，精度。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303222358570.png" alt="image-20230322235814438"></p>
<p>DS18B20 采用异步半双工的单总线，加上寄生供电，使得只要两根线就能驱动。不过这种结构并不常见。</p>
<p>我们将检测到的温度通过数码管显示出来。数码管的传入函数和IIC的一样，将外部dat数组传给数码管。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>主机输出低电平拉低总线 480<del>960 us，释放总线；外部上拉电阻把总线拉高，延时 15</del>60 us 进入接收模式。接着 DS18B20 拉低总线 60~240 us。</p>
<p>我们要在主机释放总线后，检测一下一定时间内总线是否被拉低了，拉低了说明有从机。然后再检测一定时间内从机是否把总线又释放了。</p>
<h2 id="发送一位数据"><a href="#发送一位数据" class="headerlink" title="发送一位数据"></a>发送一位数据</h2><p>主机拉低总线 60~120 us 后释放：0.</p>
<p>主机拉低总线 1~15 us ：1.</p>
<p>一般发送间隔 1ms。</p>
<p>从机拉低 30us 读取数据。</p>
<h2 id="读取一位数据"><a href="#读取一位数据" class="headerlink" title="读取一位数据"></a>读取一位数据</h2><p>主机拉低总线 15us，接近结束时释放，看一下总线是否释放。</p>
<p>如果释放了，说明从机在发送数据1，在 15us 内就释放了。</p>
<p>如果没释放，说明从机还在拉着总线，是打算拉 60us 以上的0.</p>
<p>至于发送读取是否会混淆，无需担心，因为总线发送给主机指令来决定其作用。</p>
<h2 id="发送-接收字节"><a href="#发送-接收字节" class="headerlink" title="发送 接收字节"></a>发送 接收字节</h2><p>连续读或发1个字节 8次。低位在前。</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>从机复位，主机检测从机是否响应；</p>
<p>ROM 指令+本指令是 R&#x2F;W；</p>
<p>功能指令+本指令是 R&#x2F;W。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303241521091.png" alt="image-20230324152054926"></p>
<p>因为只有一个从机，所以这里用 skip rom 指令 跳过地址校验。</p>
<p>功能指令：</p>
<ul>
<li>转换温度：该指令一发出，立刻转换温度后放在暂存器中。</li>
<li>写入寄存器：只写3个字节。TH TL configuration register。</li>
<li>读寄存器：读出寄存器数据。我们知道温度值只是前2个字节，所以简单处理只读2个字节即可。</li>
<li>copy：寄存器指令写入 EEPROM。RECALL 相反。</li>
<li>read power supply：检测是否寄生供电，这里我们也不需要。</li>
</ul>
<p>温度变换：init-跳过 ROM-转换温度。</p>
<p>温度读取：init-跳过 ROM-读取温度-持续读取。</p>
<p>温度&gt;0：*0.625</p>
<p>温度&lt;0：取反+1，再*0.625</p>
<p>具体代码解释在下文的注释中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line">sbit DS18B20_PORT=P3^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化序列：首先拉低总线至少480us，以产生复位脉冲。接着主机释放总线，延时至少15us，进入接收模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_reset</span><span class="params">()</span>&#123;</span><br><span class="line">	DS18B20_PORT=<span class="number">0</span>;<span class="comment">//拉低DQ</span></span><br><span class="line">	delay(<span class="number">75</span>);<span class="comment">//拉低750us</span></span><br><span class="line">	DS18B20_PORT=<span class="number">1</span>;<span class="comment">//DQ=1</span></span><br><span class="line">	delay(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds18b20_check</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 time_temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(DS18B20_PORT&amp;&amp;time_temp&lt;<span class="number">20</span>)&#123;</span><br><span class="line">		time_temp++;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//超时跳出，而不是因为DQ变低跳出</span></span><br><span class="line">	<span class="keyword">else</span> time_temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((!DS18B20_PORT)&amp;&amp;time_temp&lt;<span class="number">20</span>)&#123;</span><br><span class="line">		time_temp++;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds18b20_init</span><span class="params">()</span>&#123;</span><br><span class="line">	ds18b20_reset();</span><br><span class="line">	<span class="keyword">return</span> ds18b20_check();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写时序：写1时序：拉低后延时2us，释放后延时60us.</span></span><br><span class="line"><span class="comment">写0时序：拉低后延时60us，释放后延时2us。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_write_byte</span><span class="params">(u8 dat)</span>&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u8 temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		temp=dat&amp;<span class="number">0x01</span>;dat&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp)&#123;</span><br><span class="line">			DS18B20_PORT=<span class="number">0</span>;</span><br><span class="line">			_nop_();_nop_();</span><br><span class="line">			DS18B20_PORT=<span class="number">1</span>;	</span><br><span class="line">			delay(<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			DS18B20_PORT=<span class="number">0</span>;</span><br><span class="line">			delay(<span class="number">6</span>);</span><br><span class="line">			DS18B20_PORT=<span class="number">1</span>;</span><br><span class="line">			_nop_();_nop_();	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读时序：至少需要60us。时序起始后15us内读数据（采样总线）。</span></span><br><span class="line"><span class="comment">//典型的读时序过程为：主机输出低电平延时 2us，然后主机转入输入模式延时12us，然后读取单总线当前的电平，然后延时 50us。</span></span><br><span class="line">u8 <span class="title function_">ds18b20_read_bit</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 dat=<span class="number">0</span>;</span><br><span class="line">	DS18B20_PORT=<span class="number">0</span>;</span><br><span class="line">	_nop_();_nop_();</span><br><span class="line">	DS18B20_PORT=<span class="number">1</span>;	</span><br><span class="line">	_nop_();_nop_(); <span class="comment">//该段时间不能过长，必须在15us内读取数据</span></span><br><span class="line">	<span class="keyword">if</span>(DS18B20_PORT)dat=<span class="number">1</span>;	<span class="comment">//如果总线上为1则数据dat为1，否则为0</span></span><br><span class="line">	<span class="keyword">else</span> dat=<span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> dat;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds18b20_read_byte</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u8 dat=<span class="number">0</span>;</span><br><span class="line">	u8 temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//先低位后高位</span></span><br><span class="line">		temp=ds18b20_read_bit();</span><br><span class="line">		dat=(temp&lt;&lt;<span class="number">7</span>)|(dat&gt;&gt;<span class="number">1</span>);<span class="comment">//读取到的先放到最高位，然后逐渐向低位移动</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_start</span><span class="params">()</span>&#123;</span><br><span class="line">	ds18b20_init();</span><br><span class="line">	ds18b20_write_byte(<span class="number">0xcc</span>);<span class="comment">//跳过ROM命令，此命令通过允许总线主机不提供64位ROM编码而访问存储器操作来节省时间。</span></span><br><span class="line">	ds18b20_write_byte(<span class="number">0x44</span>);<span class="comment">//转换命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read_temperature</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 datl=<span class="number">0</span>,dath=<span class="number">0</span>;</span><br><span class="line">	u16 val=<span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> temp;</span><br><span class="line">	ds18b20_start();</span><br><span class="line">	ds18b20_init();</span><br><span class="line">	ds18b20_write_byte(<span class="number">0xcc</span>);</span><br><span class="line">	ds18b20_write_byte(<span class="number">0xbe</span>);<span class="comment">//读存储器命令，读出温度</span></span><br><span class="line">	datl=ds18b20_read_byte();<span class="comment">//低字节</span></span><br><span class="line">	dath=ds18b20_read_byte();<span class="comment">//高字节</span></span><br><span class="line">	val=(dath&lt;&lt;<span class="number">8</span>)+datl;</span><br><span class="line">	<span class="keyword">if</span>((val&amp;<span class="number">0xf800</span>)==<span class="number">0xf800</span>)<span class="comment">//负温度</span></span><br><span class="line">	&#123;</span><br><span class="line">		val=(~val)+<span class="number">1</span>;<span class="comment">//取反+1</span></span><br><span class="line">		temp=val*(<span class="number">-0.0625</span>);<span class="comment">//计算方法如此。*0.0625，如果是负数要先取反+1。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> temp=(<span class="number">0.0625</span>*val);</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//每50次循环读取一次温度</span></span><br><span class="line">	<span class="type">int</span> temp_value;</span><br><span class="line">	u8 temp_buf[<span class="number">5</span>];</span><br><span class="line">	ds18b20_init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span>(cnt%<span class="number">50</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			cnt%=<span class="number">50</span>;</span><br><span class="line">			temp_value=ds18b20_read_temperature()*<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(temp_value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				temp_value=-temp_value;</span><br><span class="line">				temp_buf[<span class="number">0</span>]=<span class="number">0x40</span>;<span class="comment">//负号</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> temp_buf[<span class="number">0</span>]=<span class="number">0x00</span>;<span class="comment">//不显示负号</span></span><br><span class="line">			temp_buf[<span class="number">1</span>]=gsmg_code[temp_value/<span class="number">1000</span>];</span><br><span class="line">			temp_buf[<span class="number">2</span>]=gsmg_code[temp_value%<span class="number">1000</span>/<span class="number">100</span>];</span><br><span class="line">			temp_buf[<span class="number">3</span>]=gsmg_code[temp_value%<span class="number">100</span>/<span class="number">10</span>]|<span class="number">0x80</span>; <span class="comment">//加小数点</span></span><br><span class="line">			temp_buf[<span class="number">4</span>]=gsmg_code[temp_value%<span class="number">10</span>];</span><br><span class="line">			smg_display(temp_buf,<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h1><p>DS1302 时钟芯片。开发板上已经集成的芯片，本次实验目的是用数码管显示出当前时间，以hh-mm-ss的格式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301301306004.png" alt="image-20230130130648915"></p>
<p>VCC2：电源</p>
<p>VCC1：备用电源，即单片机断电后维持时钟继续运行的。STC89C52 是没有的，即断电就停止运行。</p>
<p>X1X2：晶振。</p>
<p>CE：使能。</p>
<p>IO：输入输出。</p>
<p>SCLK：时钟。</p>
<p>操作流程就是将数据写入 DS1302 的寄存器来设置当前时间格式，然后 DS1302 时钟运作后我们再将寄存器中数据读出。</p>
<p>DS1302 中存储顺序是秒分时日月周年，存储格式是 BCD 码。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301101426338.png" alt="image-20230110142624173"></p>
<p>首先，CE&#x2F;RST在整个读写过程中要保持是高电平，一次字节读写完毕后要返回低电平。</p>
<p>然后，控制指令字输入后的下一个 SCLK 上升沿数据写入，下降沿数据读出，在图中可以看得出来，都是从低位0先读，最后出高位7. 第一位代表读或写，后四位代表地址（年、月、日、时、分、秒有着不同的地址），R&#x2F;C 代表存取 RAM 数据还是读取时钟数据。最高位只有&#x3D;1才能启用时钟。后面八位是读或写的数据。</p>
<p>读时序注意：<strong>因此写命令的第八个上升沿结束后，紧接着第八个下降沿就开始读数据了。</strong></p>
<p>写时序注意：先关闭写保护 WP，1是只读，0才可以写。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302062342494.png" alt="image-20230206234252279"></p>
<p>我们先试着写入一个秒初值，然后读取时钟里的秒数值，应该是1s一加。</p>
<p>记得 BCD 码和十进制的转换。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302060152783.png" alt="image-20230206015234658"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;REG52.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line">sbit DS1302_CLK=P3^<span class="number">6</span>;<span class="comment">//时钟管脚</span></span><br><span class="line">sbit DS1302_CE=P3^<span class="number">5</span>;<span class="comment">//复位管脚</span></span><br><span class="line">sbit DS1302_IO=P3^<span class="number">4</span>;<span class="comment">//数据管脚</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302Init</span><span class="params">()</span>&#123;</span><br><span class="line">    DS1302_CE=<span class="number">0</span>;</span><br><span class="line">    DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302WriteByte</span><span class="params">(u8 command,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i;</span><br><span class="line">    DS1302_CE=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO=command&amp;(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO=dat&amp;(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CE=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds1302ReadByte</span><span class="params">(u8 command)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	u8 dat=<span class="number">0x00</span>;<span class="comment">//全局变量会有初值0，局部变量不会。data 是要写入的数据</span></span><br><span class="line">    DS1302_CE=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO=command&amp;(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;<span class="comment">//这里为什么和 write 是相反的？因为我们注意到 read 是先上升沿读入8位，再切换为下降沿读入8位。、</span></span><br><span class="line">        <span class="comment">//如果还是先1后0，读入第8位时不仅会把上升沿读掉，下降沿也会读掉，导致错过第九位。</span></span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">		<span class="keyword">if</span>(DS1302_IO)dat|=(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CE=<span class="number">0</span>;</span><br><span class="line">	DS1302_IO=<span class="number">0</span>;<span class="comment">//读取前要归0，因为内部是以 BCD 码格式存储。</span></span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    u8 second;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	ds1302Init();</span><br><span class="line">	<span class="comment">//ds1302WriteByte(0x8E,0x00);//如果读出数据&gt;59，可能是处于 wp 写保护，需要通过这句关闭</span></span><br><span class="line">	ds1302WriteByte(<span class="number">0x80</span>,<span class="number">0x01</span>);<span class="comment">//写入55s，就是0x55，与内部BCD码对应</span></span><br><span class="line">	LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;DS1302&quot;</span>);</span><br><span class="line">	second=ds1302ReadByte(<span class="number">0x81</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,second/<span class="number">16</span>*<span class="number">10</span>+second%<span class="number">16</span>,<span class="number">3</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入其他变量时分秒都一样。就是更换不同的地址。</p>
<p>不过全部定义变量明显太麻烦。可以先 define 定义了所有地址，再定义一个数组存所有值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">u8 ds1302_address[<span class="number">7</span>]=&#123;<span class="number">0x80</span>, <span class="number">0x82</span>, <span class="number">0x84</span>, <span class="number">0x86</span>, <span class="number">0x88</span>, <span class="number">0x8c</span>&#125;;<span class="comment">// second, minute, hour, date, month, year</span></span><br><span class="line">u8 ds1302_time[<span class="number">7</span>]=&#123;<span class="number">0x55</span>, <span class="number">0x59</span>, <span class="number">0x11</span>, <span class="number">0x07</span>, <span class="number">0x02</span>, <span class="number">0x23</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 i;</span><br><span class="line">    u8 time_temp[<span class="number">6</span>];</span><br><span class="line">	u8 temp;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	ds1302Init();</span><br><span class="line">	<span class="comment">//ds1302WriteByte(0x8E,0x00);//如果读出数据&gt;59，可能是处于 wp 写保护，需要通过这句关闭</span></span><br><span class="line">	ds1302WriteByte(<span class="number">0x80</span>,<span class="number">0x01</span>);</span><br><span class="line">	ds1302WriteByte(<span class="number">0x82</span>,<span class="number">0x37</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">		ds1302WriteByte(ds1302_address[i], ds1302_time[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;  -  -  &quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;  :  :  &quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			temp=ds1302ReadByte(ds1302_address[i]+<span class="number">1</span>);</span><br><span class="line">			time_temp[i]=temp/<span class="number">16</span>*<span class="number">10</span>+temp%<span class="number">16</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			LCD_ShowNum(<span class="number">1</span>+i/<span class="number">3</span>,<span class="number">1</span>+<span class="number">3</span>*(i%<span class="number">3</span>), time_temp[<span class="number">5</span>-i],<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//LCD_ShowNum(2,1,minute/16*10+minute%16,2);</span></span><br><span class="line">		<span class="comment">//LCD_ShowNum(2,3,second/16*10+second%16,2);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们让按键可以修改时钟值，这样用户可以手动更改时钟。</p>
<p>按键1切换切换要调整的位，按键2切换回第0位，按键3+1，按键4-1.</p>
<p>难点主要在于+ -的溢出情况。这里我们不考虑秒+1进位对分钟或小时等影响，大多数闹钟也是这样设计的。59+1就归零，0-1就变59.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key)&#123;</span><br><span class="line">			<span class="keyword">switch</span>(key)&#123;</span><br><span class="line">				<span class="keyword">case</span> KEY1_PRESS: time_set_select=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY2_PRESS: time_set_select=(time_set_select+<span class="number">1</span>)%<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY3_PRESS:</span><br><span class="line">					<span class="keyword">if</span>(time_set_select&lt;=<span class="number">1</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">59</span>)&#123;<span class="comment">//second, minute 59-00</span></span><br><span class="line">						ds1302_time[time_set_select]=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">2</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">23</span>)ds1302_time[time_set_select]=<span class="number">0</span>;<span class="comment">//hour 23-00</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">3</span>&amp;&amp;ds1302_time[time_set_select]==maxDate(ds1302_time[<span class="number">3</span>],ds1302_time[<span class="number">4</span>],ds1302_time[<span class="number">5</span>]))ds1302_time[time_set_select]=<span class="number">1</span>;<span class="comment">//date 超过最大日期 -01</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">4</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">12</span>)ds1302_time[time_set_select]=<span class="number">1</span>;<span class="comment">//month 12-00</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">5</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">99</span>)ds1302_time[time_set_select]=<span class="number">0</span>;<span class="comment">//year 99-00</span></span><br><span class="line">					<span class="keyword">else</span> ds1302_time[time_set_select]++;<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY4_PRESS: </span><br><span class="line">					<span class="keyword">if</span>((ds1302_time[time_set_select]&amp;&amp;time_set_select!=<span class="number">3</span>&amp;&amp;time_set_select!=<span class="number">4</span>)</span><br><span class="line">					||ds1302_time[time_set_select]&gt;<span class="number">1</span>)ds1302_time[time_set_select]--;<span class="comment">//date month!=0</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select&lt;=<span class="number">1</span>)ds1302_time[time_set_select]=<span class="number">59</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">2</span>)ds1302_time[time_set_select]=<span class="number">23</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">3</span>)ds1302_time[time_set_select]=maxDate(ds1302_time[<span class="number">3</span>],ds1302_time[<span class="number">4</span>],ds1302_time[<span class="number">5</span>]);</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">4</span>)ds1302_time[time_set_select]=<span class="number">12</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">5</span>)ds1302_time[time_set_select]=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(key&gt;=<span class="number">3</span>)timeSet();</span><br></pre></td></tr></table></figure>

<p>计算日期最大值函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">maxDate</span><span class="params">(u8 date, u8 month,u8 year)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(month==<span class="number">1</span>||month==<span class="number">3</span>||month==<span class="number">5</span>||month==<span class="number">7</span>||month==<span class="number">8</span>||month==<span class="number">10</span>||month==<span class="number">12</span>)<span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((month==<span class="number">4</span>||month==<span class="number">6</span>||month==<span class="number">9</span>||month==<span class="number">11</span>)&amp;&amp;date==<span class="number">31</span>)<span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(year%<span class="number">4</span>)<span class="keyword">return</span> <span class="number">28</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>)<span class="keyword">return</span> <span class="number">28</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">29</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个弊端就是不知道现在在操作哪一位（只能自己记住）。可以利用定时器的定时闪烁，让在被操作的位不停闪烁。（重复写入空格或数值。）</p>
<p>还有就是按下按键，时钟会停走，不松开就一直停着。可以改按键触发条件为按下或弹起的上升沿或下降沿，避免按键处理函数死循环。</p>
<h1 id="红外传感器"><a href="#红外传感器" class="headerlink" title="红外传感器"></a>红外传感器</h1><p>遥控器通过红外 LED 发送调制后的信号，开发板上的红外接收模块接收遥控器的红外线。</p>
<p>单工异步，940nm 波长（还有一种 250nm 的N，可见光），EC 通信标准。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280003691.png" alt="image-20230328000312504"></p>
<p>38KHz：红外线频率。</p>
<p>IN：发送的方波。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280019264.png" alt="image-20230328001955152" style="zoom:50%;" />

<p>红外接收模块中会自动帮我们滤出 In 部分。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280027670.png" alt="image-20230328002724563"></p>
<p>空闲状态：OUT 输出高电平。</p>
<p>发送高电平：OUT 输出高电平。</p>
<p>发送低电平：OUT输出低电平，代表有数据。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280049094.png" alt="image-20230328004940943"></p>
<p>38kHz 属于是底层信息，所以协议层不给予展示，类似类的封装。</p>
<p>9ms 低+4.5ms 高：start。</p>
<p>后面跟四个字节数据。反码用于数据验证。</p>
<p>560us 低+560us 高表示0，560us 低+1690us 高表示1. 结束的最后一个高电平后面要跟一个下降沿表示终止。</p>
<p>一直扫描是效率很低的做法，所以 out 是接在外部中断上的。</p>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303281153651.png" alt="image-20230328115258479"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LCD_Init();</span><br><span class="line">    LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    IT0=<span class="number">1</span>;</span><br><span class="line">    IE0=<span class="number">0</span>;</span><br><span class="line">    EX0=<span class="number">1</span>;</span><br><span class="line">    EA=<span class="number">1</span>;</span><br><span class="line">    PX0=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,num,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Int0_Routine</span><span class="params">()</span> interrupt 0 &#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断和第三个按键 P3^2 接在一起，因此按下按键3时就会下降沿触发中断。</p>
<p>如果改为低电平触发，即 IT0&#x3D;0，按下按键就一直触发。</p>
<p>接收到的数据会以2位的二进制位展现在数码管上，这里遥控器上的按钮并不是按几数码管就会显示几的注意一下。重点只是在于看遥控器不同的信号单片机能否区分和识别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303281457220.png" alt="image-20230328145734093"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ired.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ired_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ired_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管脚定义</span></span><br><span class="line">sbit IRED=P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">extern</span> u8 gired_data[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ired.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ired.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 gired_data[<span class="number">4</span>];<span class="comment">//存储4个字节接收码（地址码+地址反码+控制码+控制反码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名         : ired_init</span></span><br><span class="line"><span class="comment">* 函数功能		   : 红外端口初始化函数，外部中断0配置 </span></span><br><span class="line"><span class="comment">* 输    入         : 无</span></span><br><span class="line"><span class="comment">* 输    出         : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	IT0=<span class="number">1</span>;	<span class="comment">//下降沿触发</span></span><br><span class="line">	EX0=<span class="number">1</span>;	<span class="comment">//打开中断0允许</span></span><br><span class="line">	EA=<span class="number">1</span>;	<span class="comment">//打开总中断</span></span><br><span class="line">	IRED=<span class="number">1</span>;	<span class="comment">//初始化端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired</span><span class="params">()</span> interrupt 0	<span class="comment">//外部中断0服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 ired_high_time=<span class="number">0</span>;</span><br><span class="line">	u16 time_cnt=<span class="number">0</span>;</span><br><span class="line">	u8 i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//引导信号有9ms的低电平和4.5ms的高电平，先把这两部分读掉，并且如果太长时间引导信号没有发生相应的变化就先跳出，省的系统死机。我们给引导信号10ms和5ms的机会。</span></span><br><span class="line">	<span class="keyword">if</span>(IRED==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		time_cnt=<span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">while</span>((!IRED)&amp;&amp;(time_cnt))<span class="comment">//等待引导信号9ms低电平结束，若超过10ms强制退出</span></span><br><span class="line">		&#123;</span><br><span class="line">			delay_10us(<span class="number">1</span>);<span class="comment">//延时约10us</span></span><br><span class="line">			time_cnt--;</span><br><span class="line">			<span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(IRED)<span class="comment">//引导信号9ms低电平已过，进入4.5ms高电平</span></span><br><span class="line">		&#123;</span><br><span class="line">			time_cnt=<span class="number">500</span>;</span><br><span class="line">			<span class="keyword">while</span>(IRED&amp;&amp;time_cnt)<span class="comment">//等待引导信号4.5ms高电平结束，若超过5ms强制退出</span></span><br><span class="line">			&#123;</span><br><span class="line">				delay_10us(<span class="number">1</span>);</span><br><span class="line">				time_cnt--;</span><br><span class="line">				<span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//接下来是读取地址、地址反码、控制、控制反码。</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//循环4次，读取4个字节数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)<span class="comment">//循环8次读取每位数据即一个字节</span></span><br><span class="line">				&#123;</span><br><span class="line">					time_cnt=<span class="number">600</span>;</span><br><span class="line">					<span class="keyword">while</span>((IRED==<span class="number">0</span>)&amp;&amp;time_cnt)<span class="comment">//等待数据1或0前面的0.56ms结束，若超过6ms强制退出</span></span><br><span class="line">					&#123;</span><br><span class="line">						delay_10us(<span class="number">1</span>);</span><br><span class="line">						time_cnt--;</span><br><span class="line">						<span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;	</span><br><span class="line">					&#125;</span><br><span class="line">					time_cnt=<span class="number">20</span>;</span><br><span class="line">					<span class="keyword">while</span>(IRED)<span class="comment">//等待数据1或0后面的高电平结束，若超过2ms强制退出</span></span><br><span class="line">					&#123;</span><br><span class="line">						delay_10us(<span class="number">10</span>);<span class="comment">//约0.1ms</span></span><br><span class="line">						ired_high_time++;</span><br><span class="line">						<span class="keyword">if</span>(ired_high_time&gt;<span class="number">20</span>)<span class="keyword">return</span>;	</span><br><span class="line">					&#125;</span><br><span class="line">					gired_data[i]&gt;&gt;=<span class="number">1</span>;<span class="comment">//先读取的为低位，然后是高位</span></span><br><span class="line">					<span class="keyword">if</span>(ired_high_time&gt;=<span class="number">8</span>)<span class="comment">//如果高电平时间大于0.8ms，数据则为1，否则为0</span></span><br><span class="line">						gired_data[i]|=<span class="number">0x80</span>;<span class="comment">//最高位赋1</span></span><br><span class="line">					ired_high_time=<span class="number">0</span>;<span class="comment">//重新清零，等待下一次计算时间</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(gired_data[<span class="number">2</span>]!=~gired_data[<span class="number">3</span>])<span class="comment">//校验控制码与反码，错误则清空后返回</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">				gired_data[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	u8 ired_buf[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	ired_init();<span class="comment">//红外初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;				</span><br><span class="line">		ired_buf[<span class="number">0</span>]=gsmg_code[gired_data[<span class="number">2</span>]/<span class="number">16</span>];<span class="comment">//将控制码高4位转换为数码管段码</span></span><br><span class="line">		ired_buf[<span class="number">1</span>]=gsmg_code[gired_data[<span class="number">2</span>]%<span class="number">16</span>];<span class="comment">//将控制码低4位转换为数码管段码</span></span><br><span class="line">		ired_buf[<span class="number">2</span>]=<span class="number">0X76</span>;<span class="comment">//显示H的段码</span></span><br><span class="line">		smg_display(ired_buf,<span class="number">6</span>);	</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h1><p>liquid crystal display 液晶显示屏，一种字符型液晶显示模块，可以显示 16*2 个字符，每个字符是 5*7 点阵。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302030040324.png" alt="image-20230203004049189"></p>
<p>P0 P2 会和数码管、LED 一定程度上冲突。</p>
<ol>
<li><p>地。</p>
</li>
<li><p>Vcc。</p>
</li>
<li><p>调对比度的。</p>
</li>
<li><p>RS：数据指令端。1代表 DB 是数据，0代表是指令。</p>
</li>
<li><p>RW：1读0写。</p>
</li>
<li><p>E：类似时钟的使能。高电平有效，下降沿执行。</p>
</li>
<li><p>DB：并行输入。一个字节长。</p>
</li>
<li><p>BG：背光灯电源。</p>
</li>
</ol>
<h2 id="内部结构图"><a href="#内部结构图" class="headerlink" title="内部结构图"></a>内部结构图</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302210241581.png" alt="image-20230221024102411"></p>
<p>类似 SMG，想显示1并不是直接输入1，而是操纵数码管右侧一竖被点亮。字模库起的就是这个作用，里面有固定的 ROM 和用户课自定义的 RAM。</p>
<p>DDRAM 长于屏幕，可以通过移平实现滚动效果。 </p>
<p>AC address controller，可以自动移位写入数据。</p>
<p>字模库中的数据大多数和 ASCII 码是一样的。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302211954113.png" alt="image-20230221195404983"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302211954631.png" alt="image-20230221195434495"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302211954194.png" alt="image-20230221195450094"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212006550.png" alt="image-20230221200656434"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212008132.png" alt="image-20230221200839017"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212010707.png" alt="image-20230221201026593"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212012009.png" alt="image-20230221201247867"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212013859.png" alt="image-20230221201355749"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302221623821.png" alt="image-20230222162315672"></p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212056483.png" alt="image-20230221205604331" style="zoom:67%;" />

<h2 id="初始化指令"><a href="#初始化指令" class="headerlink" title="初始化指令"></a>初始化指令</h2><p>初始化要做哪些操作？</p>
<p>规定显示区域（如8位数据接口，2行显示，5*7点阵，即为0011 10xx，如果取0即为 0x38.）。</p>
<p>显示的模式设置（如开启显示，关闭光标，关闭光标闪烁：0000 1101，即 0x0D）。</p>
<p>进入模式设置（如读写后光标++，屏幕不动：0000 0110,0x06。如果是滚动屏幕则为）。</p>
<p>清屏（0x01）。</p>
<h2 id="显示指令"><a href="#显示指令" class="headerlink" title="显示指令"></a>显示指令</h2><p>先设置 DDRAM 初始地址，0x80|AC（开头的8是 DDRAM 固定指令信息不能改。后面的全是0，与 AC 光标位置做与，AC 不同位置的值见 DDRAM 地址表）.</p>
<p>然后发送数据。</p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212100898.png" alt="image-20230221210035721" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212101594.png" alt="image-20230221210102393" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212106325.png" alt="image-20230221210614193" style="zoom: 80%;" />

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>第一阶段我们先编写 LCD1602 模块化编程代码，这一部分主要显示静态内容，用于程序编写过程中显示变量进行调试。</p>
<p>目标模块化函数：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302030044040.png" alt="image-20230203004415880" style="zoom: 80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LCD1602.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LCD1602_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LCD1602_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line">sbit LCD_RS=P2^<span class="number">6</span>;</span><br><span class="line">sbit LCD_RW=P2^<span class="number">5</span>;</span><br><span class="line">sbit LCD_E=P2^<span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DATAPORT P0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Delay1ms</span><span class="params">()</span>;		<span class="comment">//@11.0592MHz</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">LCD_Pow</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> str[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LCD1602.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Delay1ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	_nop_();</span><br><span class="line">	_nop_();</span><br><span class="line">	_nop_();</span><br><span class="line">	i = <span class="number">11</span>;</span><br><span class="line">	j = <span class="number">190</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span>&#123;</span><br><span class="line">	LCD_RS=<span class="number">0</span>;</span><br><span class="line">	LCD_RW=<span class="number">0</span>;</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">	LCD_DATAPORT=Command;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">1</span>;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span>&#123;</span><br><span class="line">	LCD_RS=<span class="number">1</span>;</span><br><span class="line">	LCD_RW=<span class="number">0</span>;</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">	LCD_DATAPORT=Data;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">1</span>;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x38</span>);</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x0C</span>);</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x06</span>);</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(line==<span class="number">1</span>)&#123;</span><br><span class="line">		LCD_WriteCommand(<span class="number">0x80</span>|(column<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		LCD_WriteCommand(<span class="number">0x80</span>|(column<span class="number">-1</span>)+<span class="number">0x40</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">LCD_Pow</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i=y;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)res*=x;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> c)</span>&#123;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	LCD_WriteData(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		LCD_WriteData(str[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> base;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">10</span>, i<span class="number">-1</span>);</span><br><span class="line">		LCD_WriteData(num/base%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> base;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> single_num;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">2</span>, i<span class="number">-1</span>);</span><br><span class="line">		single_num=num/base%<span class="number">2</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		LCD_WriteData(single_num);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> base;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> single_num;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">16</span>, i<span class="number">-1</span>);</span><br><span class="line">		single_num=num/base%<span class="number">16</span>;</span><br><span class="line">		<span class="keyword">if</span>(single_num&lt;=<span class="number">9</span>)single_num+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> single_num+=<span class="string">&#x27;A&#x27;</span><span class="number">-10</span>;</span><br><span class="line">		LCD_WriteData(single_num);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> base;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">if</span>(num&gt;<span class="number">0</span>)LCD_WriteData(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;LCD_WriteData(<span class="string">&#x27;-&#x27;</span>);num=-num;&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">10</span>, i<span class="number">-1</span>);</span><br><span class="line">		LCD_WriteData(num/base%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望屏幕滚动，一定时间执行一次<code>LCD_WriteCommand(0x18);</code> 屏幕左移指令。</p>
<h1 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h1><p>电能转机械能。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303270017098.png" alt="image-20230327001703813"></p>
<p>第二种驱动方式可以双向，电机可以双向驱动，转向不同。</p>
<p>直接驱动电机还起到电感的作用，断开电源后电机产生电压，可以形成一个回路慢慢消耗掉。</p>
<p>PWM：脉冲信号调制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303270035159.png" alt="image-20230327003516983"></p>
<p>比如调 LED 灯，我们可以加一个有电位器的电阻（滑动变阻器）。</p>
<p>电机可能这种方式有局限性，比如电阻太大直接不转，驱动不起来，太小烧毁。</p>
<p>脉冲调制比如：“转2s”“停1s”“转2s”“停1s”……因为电机有惯性，所以可行。</p>
<p>示例：LED 流水灯：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sbit LED=P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">char</span> period=<span class="number">100</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ti;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ti=<span class="number">0</span>;ti&lt;<span class="number">100</span>;ti++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">				LED=<span class="number">0</span>;</span><br><span class="line">				delay(ti);</span><br><span class="line">				LED=<span class="number">1</span>;</span><br><span class="line">				delay(period-ti);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ti=<span class="number">100</span>;ti&gt;<span class="number">0</span>;ti--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">				LED=<span class="number">0</span>;</span><br><span class="line">				delay(ti);</span><br><span class="line">				LED=<span class="number">1</span>;</span><br><span class="line">				delay(period-ti);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用 timer 来计数，我们知道 timer 是一直增加的，我们可以设置一个比较值，当 timer 大于比较值时输出1，小于时输出0类似这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;regx52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nixie.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED=P1^<span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> compare;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> T0Count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> level=<span class="number">1</span>;</span><br><span class="line">	time0Init();</span><br><span class="line">	compare=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		key=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY1_PRESS)level++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(key==KEY2_PRESS)<span class="keyword">if</span>(level&gt;<span class="number">1</span>)level--;</span><br><span class="line">		level%=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span>(level==<span class="number">0</span>)level++;</span><br><span class="line">		<span class="keyword">if</span>(level==<span class="number">1</span>)compare=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">2</span>)compare=<span class="number">50</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">3</span>)compare=<span class="number">75</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">4</span>)compare=<span class="number">100</span>;</span><br><span class="line">		Nixie_Scan(<span class="number">1</span>,level);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">  TL0 = <span class="number">0xAE</span>;</span><br><span class="line">  TH0 = <span class="number">0xFB</span>;</span><br><span class="line">  T0Count++;</span><br><span class="line">  <span class="keyword">if</span>(T0Count&gt;=<span class="number">100</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    T0Count=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(T0Count&lt;compare)&#123;</span><br><span class="line">  	 LED=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(T0Count&gt;compare)LED=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><p>使得调节开发板上的电位器时，数码管上能够显示 AD 模块 采集电位器的电压值且随之变化。</p>
<p>开发板上有三个应用：光敏电阻，热敏电阻，电位器。</p>
<p>一般 AD 转换有多个输入，提高使用效率。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271700414.png" alt="image-20230327170005984"></p>
<p>ADC 通过地址锁存与译码判断采用哪个输入。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271722801.png" alt="image-20230327172256586"></p>
<p>运算放大器，可以作为电压比较器、同相反相放大器、电压跟随器</p>
<p>T 型电阻网络 DA 转换器：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271951179.png" alt="image-20230327195138979"></p>
<p>低通滤波器：输入是有直交流两个分量的，可以通过低通滤波器提取出直流。电压跟随器让驱动能力增加。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271951641.png" alt="image-20230327195154405"></p>
<p>da 简单些，因为d值是固定的，根据d调整a即可。</p>
<p>ad 怎么判断电压大小？我们用一个电压值和给定电压作比较，看大于还是小于，逐渐逼近来找近似值。</p>
<p>分辨率：精细程度。比如8位的 ad 可以把 5v 转换到 0~255 范围。</p>
<p>转换速度：最大采样&#x2F;建立频率。</p>
<p>XPT2046 采用 SPI，的时序在上升沿输入，下降沿输出，可实现输入再输出。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303272139709.png" alt="image-20230327213950578"></p>
<p>采用单端模式（触摸屏查分会更好一些）。</p>
<p>PD1&#x3D;1 采用内部参考电压，内部电压为 2.5v，我们知道adc 映射范围是 0~5v，所以1采用内部电压不如0采用5v的外部电压。</p>
<p>A 地址配置：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303272207617.png" alt="image-20230327220710512"></p>
<p>VBAT：电池电压。</p>
<p>AUX：辅助电压。</p>
<p>XP YP：XY 正极。</p>
<p>读取指令并 ad 转化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_XP_8 0x9C    <span class="comment">// 1001 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_YP_8 0xDC    <span class="comment">// 1101 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_VBAT_8 0xAC  <span class="comment">// 1010 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_AUX_8 0xEC   <span class="comment">// 1110 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_XP_12 0x94   <span class="comment">// 1001 0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_YP_12 0xD4   <span class="comment">// 1101 0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_VBAT_12 0xA4 <span class="comment">// 1010 0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_AUX_12 0xE4  <span class="comment">// 1110 0100</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">XPT2046_ReadAD</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> command)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp=command;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ADValue = <span class="number">0</span>;</span><br><span class="line">    XPT2046_DCLK = <span class="number">0</span>;</span><br><span class="line">    XPT2046_CS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        XPT2046_DIN = temp &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        XPT2046_DCLK = <span class="number">1</span>;</span><br><span class="line">        XPT2046_DCLK = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        XPT2046_DCLK = <span class="number">1</span>;</span><br><span class="line">        XPT2046_DCLK = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (XPT2046_DOUT)</span><br><span class="line">            ADValue |= (<span class="number">0x0800</span> &gt;&gt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    XPT2046_CS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//for 12 bit:</span></span><br><span class="line">    <span class="keyword">if</span>(command&amp;<span class="number">0x08</span>)<span class="keyword">return</span> ADValue&gt;&gt;<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ADValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ADValue = <span class="number">0</span>;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	LCD_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;ADC NTC RG&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ADValue = XPT2046_ReadAD(XPT2046_XP_8);<span class="comment">//电位器</span></span><br><span class="line">		LCD_ShowNum(<span class="number">2</span>, <span class="number">1</span>, ADValue, <span class="number">3</span>);</span><br><span class="line">		ADValue = XPT2046_ReadAD(XPT2046_YP_8);<span class="comment">//热敏电阻</span></span><br><span class="line">		LCD_ShowNum(<span class="number">2</span>, <span class="number">5</span>, ADValue, <span class="number">3</span>);</span><br><span class="line">		ADValue = XPT2046_ReadAD(XPT2046_VBAT_8);<span class="comment">//光敏电阻</span></span><br><span class="line">		LCD_ShowNum(<span class="number">2</span>, <span class="number">9</span>, ADValue, <span class="number">3</span>);</span><br><span class="line">		delayMs(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dac 也是采用 pwm 的原理，改变01 叫错频率来模拟灯的亮度（输出口：P2^1）。所以 dac 用处不广泛，因为可以被代替。</p>
<h1 id="完结：库函数封装说明"><a href="#完结：库函数封装说明" class="headerlink" title="完结：库函数封装说明"></a>完结：库函数封装说明</h1><p>从12月开始决定入嵌入式开始，经历了5个月的学习，终于把入门模块基本弄懂并且跟着代码敲了一遍。</p>
<p>在这期间跟随普中课程老师学习到的封装习惯让我主键开始留意每做完一个模块后就进行调试并把该模块封装起来，供下次使用该模块时可以快捷导入。</p>
<p>后来浅了解了一些 git 的项目管理后，我又把封装好的函数发布到 github repository 上。</p>
<p>单片机版本：STC89C52RC</p>
<p>github 仓库地址：<a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/MySTC89C52RCFunction">Jingqing3948&#x2F;MySTC89C52RCFunction: 学习 STC89C52RC 单片机时的一些封装好的库函数。 (github.com)</a></p>
<p>函数包含：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303281845268.png" alt="image-20230328184524152"></p>
<p>AT24C02：掉电不丢失存储器。</p>
<p>DS18B20：温度传感器。</p>
<p>delay：stc-isp 生成的基于 11.0592MHz 晶振的延时函数。</p>
<p>IIC：IIC 总线的使用，配合 AT24C02 模块使用。</p>
<p>IR：红外遥控模块，包括外部中断、定时器等内容。</p>
<p>Key：四个独立按键。</p>
<p>LCD1602：LCD1602 显示屏。</p>
<p>NiXie：数码管。</p>
<p>Timer：定时器中断函数。</p>
<p>public.h：无用，定义了 u8 u16 两个变量。</p>
<p>有问题欢迎随时与博主沟通。如侵犯他人权益会尽快删除！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-王道操作系统网课笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/27/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"
    >王道操作系统网课笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/11/27/%E7%8E%8B%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2022-11-27T00:00:00.000Z" itemprop="datePublished">2022-11-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/OS/">OS</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>[TOC]</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h2><p>计算机结构大概分为四层：</p>
<ul>
<li>用户</li>
<li>应用程序</li>
<li>操作系统</li>
<li>硬件</li>
</ul>
<p>操作系统是一类系统软件，调度硬件资源，合理分配管理软件（因此操作系统又被称作资源管理器（resource manager））。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202211121137338.png" alt="image-20221026211255236" style="zoom:67%;" />

<p>程序要运行首先要被放到内存中，然后才能被 CPU 处理；运行中的程序叫进程。</p>
<p>双击打开 QQ.exe，对应进程就会被放到内存中；</p>
<p>QQ 正常运行过程中，对应进程被 CPU 处理。</p>
<p>QQ 若想调用摄像头等，操作系统会把相应硬件分配给他。</p>
<p>计算机还会提供用户和硬件之间的接口。主要分为三种：GUI 接口，命令接口，程序接口。</p>
<p>联机&#x2F;交互式命令接口：用户说一句，系统做一句。（cmd）</p>
<p>脱机&#x2F;批处理命令接口：用户说一堆，系统做一堆。（.bat）</p>
<p>程序接口：通过程序才能调用。（.dll）</p>
<p>只有硬件的计算机叫裸机；操作系统将硬件资源转换为通用的、强大的虚拟形式，有时操作系统也被称为虚拟机。操作系统提供几百个系统调用（system call）供其他应用程序使用，实现运行程序、访问内存和设备等操作，也可以说操作系统为其他应用程序提供了一个标准库（standard library）。</p>
<h2 id="操作系统几大特征"><a href="#操作系统几大特征" class="headerlink" title="操作系统几大特征"></a>操作系统几大特征</h2><p>操作系统围绕以下几大主题展开：</p>
<ul>
<li>虚拟化（virtualize）：尽管一般只有一个 CPU，但是能同时进行多个进程，造成多个 CPU 的假象。多个程序实例同时用到一片内存地址时，却能各运行各的，值互不干扰。实际上每个进程是在访问自己的私有虚拟内存空间（virtual address space)，虚拟内存通过一定的规则映射到物理内存上，运行中的程序的物理内存是完全独立的。</li>
<li>并发（concurrency）<strong>不是并行！并行是同时发生，并发是交替发生。</strong>单核计算机就会采用并发的程序运行方式。现在尽管都有四核计算机，可以进行4个程序的并行操作，但是并发仍然很重要。</li>
<li>共享：系统中的某些资源供多个进程使用。</li>
</ul>
<p>​		互斥型共享就是一次只能一个程序用，如摄像头；</p>
<p>​		同时型共享就是两个进程交替使用，如 QQ 微信 同时发送文件。</p>
<ul>
<li>异步性：并发执行的程序有时候会卡住。比如 AB 程序都要用同一个地址，A先用了，B用的时候就要等A用完释放才能用。</li>
</ul>
<h2 id="操作系统历史"><a href="#操作系统历史" class="headerlink" title="操作系统历史"></a>操作系统历史</h2><p>手工操作阶段：用户手工打点，给机器。人机协调不均衡，资源分配不均匀。</p>
<p>批处理阶段——单道批处理系统：用户打好的点交给磁带，磁带读入计算机速度快得多（监督程序，早期的操作系统）。但是利用率仍然很低。</p>
<p>批处理阶段——多道批处理系统：每次内存中同时读入多个程序。多个程序并发执行，有了”中断“的概念。但是用户在程序执行的时候没法干涉，人机交互很差。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212021804594.png" alt="image-20221202180444486"></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位轮流给所有用户提供服务。用户的请求可以被及时响应，解决了人机交互问题；各个用户之间也感受不到其他用户的存在。但是众生平等，没有优先级。</p>
<p>实时操作系统：优先度高的任务可以先被处理，并且必须在给定的时限内完成任务。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212021811216.png" alt="image-20221202181100161"></p>
<h1 id="OS-运行机制和体系结构"><a href="#OS-运行机制和体系结构" class="headerlink" title="OS 运行机制和体系结构"></a>OS 运行机制和体系结构</h1><p>计算机中的指令有的安全（加减乘除运算），有的危险一点（清空内存）。因此需要通过权限控制限制用户能执行的指令。</p>
<p>具体实现方法为：CPU 处于核心态（管态）时可以执行所有指令；处于用户态（目态）时只能执行非特权指令。</p>
<p>内核程序是系统的管理者，可以执行所有指令，运行在核心态；</p>
<p>应用程序只能执行非特权指令，运行在用户态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212022149616.png" alt="image-20221202214904545"></p>
<p>操作系统的内核包含橙黄两部分：大内核。</p>
<p>只包含黄色部分：微内核。</p>
<p>各自的缺点：大内核组织结构混乱，难以维护；微内核频发切换，性能低。</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>一开始的计算机只是简单的串行执行程序。</p>
<p>现在的操作系统不仅可以并发执行程序，而且收到中断指令时，CPU 会切换到内核模式，中断当前程序的执行，按中断指令调整程序执行顺序，然后恢复到用户态继续执行。</p>
<p>中断分内中断、外中断。区别在于中断指令来自于 CPU 内部还是外部。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212022249948.png" alt="image-20221202224925813"></p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>我们知道计算机硬件为了供用户使用，向上层提供了一些接口。用户直接使用的接口叫命令接口；用户通过应用程序间接使用的接口叫程序接口。系统调用是操作系统提供给应用程序的接口。</p>
<p>系统调用可以增加安全性，不让用户可以直接随意访问所有功能。如两个人去打印店用打印机，第一个人打到一半第二个人发送了他的打印任务请求，可打印机最终还是有序地把两个人的任务分别打印好了。如果用户能直接让打印机打印自己的任务，不加协调，无法实现这样的结果。</p>
<p>哪些操作要通过系统调用的方式进行？凡是和资源相关的。这样可以保证系统的安全性和稳定性。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212030058354.png" alt="image-20221203005839292"></p>
<p>编程语言提供的一些库函数也是从下往上提供的一些封装的功能。但库函数不一定是系统调用。如求绝对值的库函数，这个库函数就不是系统调用，用户直接就能访问。</p>
<p>现在大多数系统调用都是高级语言中封装的部分库函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212030122447.png" alt="image-20221203012249371"></p>
<p>陷入指令核心态不能执行，可以理解为：核心态只能执行系统调用，不能发起系统调用给自己。</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程（process）是操作系统中最基本的抽象。</p>
<p>进程就是运行中的程序，程序本身只是存放在磁盘上的一些静态指令，是操作系统让其运行起来。</p>
<p>现在我们的计算机可以同时运行上百个进程，是通过虚拟化 CPU 而实现。每个进程只运行一个时间片段，然后跳转到其他进程，造成多个进程同时运行的假象。</p>
<p>内存中存放每个进程的程序段和数据段，但内存怎么知道哪个是哪个进程的？通过一种数据结构叫进程控制块（PCB）找到对应进程的额程序段和数据段。程序段、数据段、PCB 组成了进程实体。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031509614.png" alt="image-20221203150903451"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031512628.png" alt="image-20221203151228535"></p>
<p>操作系统需要一些低级机制（mechanism）切换程序运行，如上下文切换（context switch，停止当前程序，并运行另一个程序）；还需要一些智能决定要切换到哪个程序，如策略（poliicy，根据一些算法判断要运行哪个程序，如“哪个程序在上一分钟运行的时间更长？”）</p>
<h2 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031514568.png" alt="image-20221203151433504"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031605299.png" alt="image-20221203160553246"></p>
<p>就绪态就是除了处理机其他资源都准备就绪了。阻塞态还需要准备资源才能进入就绪态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031608044.png" alt="image-20221203160853843"></p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>就是这几种进程状态之间的切换。</p>
<p>通过两个指针实现：就绪队列指针和阻塞队列指针，用于存放就绪和阻塞的进程（阻塞队列可能还有好几个，按阻塞原因分组）。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031747844.png" alt="image-20221203174739750"></p>
<p>状态切换使用原语，因为原语执行过程中不会受到中断的干扰。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212031748654.png" alt="image-20221203174850603"></p>
<p>原语做的操作无非是：1. 修改 PCB；2. 把 PCB 放到对应队列中；3. 分配&#x2F;释放资源。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212032207002.png" alt="image-20221203220754958"></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程之间互相通信，安全起见不能直接进行。</p>
<ol>
<li><p>共享存储，共用一块存储空间。有基于数据结构的分享（给定数据结构存储方式）和基于存储区的分享（内存中划定一块存储区，进程自己决定怎么存储）。</p>
<p>共享的缓冲区叫做管道，如果只采用一个管道只能使用半双工型，全双工型需要两根管道。两个进程访问该管道要互斥的访问。</p>
<p>管道写满才能读，读空了才能写。</p>
<p>读出来的数据就直接被丢弃了。所以安全起见只能有一个读的进程。</p>
</li>
<li><p>消息传递。类似计网的数据报，消息封装好之后发给另一个进程的消息队列。</p>
</li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>让一个进程可以并发执行多个任务。比如 qq 聊天的同时可以发文件收消息发消息。</p>
<p>一个进程包含多个线程。线程是调度， CPU 的程序执行单元，进程是资源分配的单元，比如把显示器资源分配给 QQ。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041613632.png" alt="image-20221204161307495"></p>
<p>线程有两种实现方式：</p>
<ol>
<li>用户级线程 （ULT），进程的切换由应用程序实现，而不需要操作系统管理，因此用户态下就能实现线程的切换，且线程的存在对用户透明，对操作系统不透明。</li>
<li>内核级线程（KLT），线程管理靠操作系统在核心态下实现、</li>
<li>两者组合的形式，n 个用户级线程映射到 m 个内核级线程上。</li>
</ol>
<p>操作系统分配 CPU 处理机只能分配给内核级线程（因为用户级线程对操作系统来说不透明）。所以如果有三个用户级线程，但这个应用程序只有两个内核级线程，最多也只能被分配到两个处理机，最多也只能有两个用户线程并发执行（哪怕这个操作系统是三核的，四核的，有很多核空闲出来）。</p>
<p>几个用户级进程映射到几个内核级进程上？这就是多线程模型问题。</p>
<ol>
<li><p>多个用户级进程映射到一个内核级进程上。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041620426.png" alt="image-20221204162042367"></p>
<p>线程切换不用在核心态下进行，切换效率高，但是并发度不高。</p>
</li>
<li><p>一对一。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041621304.png" alt="image-20221204162149252"></p>
<p>优缺点正好和1相反。</p>
</li>
<li><p>n 对 m，用户级线程多于内核级线程，较为折中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041622150.png" alt="image-20221204162233095"></p>
</li>
</ol>
<h1 id="进程调度和切换"><a href="#进程调度和切换" class="headerlink" title="进程调度和切换"></a>进程调度和切换</h1><p>线程数往往多于处理机数，因此要考虑按怎样的算法分配处理机。</p>
<p>进程调度和切换的区别是什么？</p>
<p>进程调度先选再切换。</p>
<p>进程切换包括：</p>
<ol>
<li>保存原来运行的数据</li>
<li>恢复新进程的数据。</li>
</ol>
<p>切换会影响效率。</p>
<p><strong>调度层次1：高级调度（→就绪态）</strong></p>
<p>首先先不说处理机够不够处理内存中的线程，有时候线程多到内存中放不下。高级调度需要按一定的原则从外存中挑选一些作业放到内存中并建立进程（PCB），让他们有进一步竞争处理机的机会。主要解决的是调入问题。</p>
<p><strong>调度层次2：中级调度（挂起态→就绪态）</strong></p>
<p>引入虚拟存储技术之后，暂时不能运行的进程可以先调至外存等待（挂起）。等可以运行再拿回来，这样能提高内存利用率和系统吞吐量。</p>
<p>其对应的 PCB 并不会一起移出内存，而是存储了被挂起的进程的信息，被放到内存中的挂起队列里。</p>
<p>中级调度就是挑选挂起的进程调入内存。</p>
<p>引入挂起的进程实际上可以说是有七种状态。不能运行的进程都会先放到就绪挂起态或阻塞挂起态，能运行再回到内存（有的操作系统阻塞挂起态直接回到就绪挂起态）。注意挂起和阻塞的区别！</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212041640940.png" alt="image-20221204164038790"></p>
<p><strong>调度层次3：初级调度（就绪态→运行态）</strong></p>
<p>就是从就绪队列中按一定算法挑一个进程来执行。</p>
<h2 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h2><p>当前运行的进程主动（运行完了，或者异常终止）或被动放弃处理机，就会发生调度。</p>
<p>有以下几种情况不能调度：</p>
<ol>
<li>进程在处理中断时。</li>
<li>进程在操作系统内核程序临界区中。（<a target="_blank" rel="noopener" href="https://blog.csdn.net/gary101818/article/details/124198452?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-124198452-blog-111413758.pc_relevant_vip_default&spm=1001.2101.3001.4242.1&utm_relevant_index=4">临界资源及临界区（内核&#x2F;普通）以及三种进程不能切换的情况_Unstoppable~~~的博客-CSDN博客_内核临界区</a> 在此感谢这位博主！调度区和调度资源是两回事，调度区又分普通调度区和内核调度区。）</li>
<li>原语执行时.</li>
</ol>
<h2 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a>调度方式</h2><p>非剥夺&#x2F;非抢占调度方式：只允许进程主动放弃处理机。哪怕有更紧急的进程到达，也不会把当前正在使用处理机的进程挤开。开销小，但没法处理紧急情况。</p>
<p>剥夺&#x2F;抢占调度方式：允许进程主动或被动放弃处理机。</p>
<h2 id="调度算法评价指标"><a href="#调度算法评价指标" class="headerlink" title="调度算法评价指标"></a>调度算法评价指标</h2><p>CPU 利用率：CPU 有活干的时间&#x2F;总时间。</p>
<p>系统吞吐量：完成了的作业道数&#x2F;总用时。</p>
<p>周转时间：提交作业到作业完成用时。包括在外存等待高级调度→在内存就绪队列等待低级调度→在 CPU 上执行→等待 I&#x2F;O 操作完成的时间。</p>
<p><em>注意概念问题，进程是运行中的程序，所以作业在外存的时候不可以被称为进程。进入内存才创建了进程。</em></p>
<p>带权周转时间：周转时间&#x2F;实际运行时间。越小越好（排队用时少吧）。</p>
<p>等待时间：作业等待处理机状态的时间之和。（不包括 IO）</p>
<p>响应时间：用户提交请求到首次产生响应的时间。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>早期批处理调度算法：只根据等待时间和预估处理时间调度，不考虑是否紧急。</p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>思想</th>
<th>规则</th>
<th>用于何种调度</th>
<th>是否可抢占</th>
<th>优缺点</th>
<th>是否会导致饥饿（某个作业长期得不到服务）</th>
</tr>
</thead>
<tbody><tr>
<td>先来先服务 FCFS</td>
<td>公平</td>
<td>先来后到</td>
<td>都用</td>
<td>非抢占式</td>
<td>公平；但排在后面的短作业体验差</td>
<td>不会</td>
</tr>
<tr>
<td>短作业优先 SJF</td>
<td>让平均等待、周转、带权周转时间最短</td>
<td>最短的作业优先服务</td>
<td>都用</td>
<td>非抢占式（最短剩余优先算法是抢占式的，当有进程入队的时候立刻调度。平均时间抢占式的更少）</td>
<td>平均时间少，但对长作业不公平，可能“饥饿</td>
<td>会</td>
</tr>
<tr>
<td>高响应比优先 HRRN</td>
<td>综合考虑等待时间和处理时间</td>
<td>$\frac{等待时间+服务时间}{服务时间}$，优先执行响应比大的</td>
<td>都用</td>
<td>非抢占式（当前进程主动结束时才进行调度）</td>
<td>综合考虑了等待时间和服务时间，长作业等久了也会执行</td>
<td>不会</td>
</tr>
</tbody></table>
<p>后期交互式系统算法：</p>
<table>
<thead>
<tr>
<th>算法名</th>
<th>思想</th>
<th>规则</th>
<th>用于何种调度</th>
<th>是否可抢占</th>
<th>优缺点</th>
<th>是否会导致饥饿</th>
</tr>
</thead>
<tbody><tr>
<td>时间片轮转 RR</td>
<td>公平轮流地为所有进程服务</td>
<td>按先来后到，轮流给各个进程一个时间片执行。如果没执行完就交给下一个进程，然后重新到队尾排队（时间片大小要合适。太大就是 FCFS 算法了，太小效率低）</td>
<td>进程调度</td>
<td>是</td>
<td>公平；响应快；但是频繁切换效率低，不区分紧急程度</td>
<td>不会</td>
</tr>
<tr>
<td>优先级调度</td>
<td>按紧急程度处理</td>
<td>优先度高的先执行</td>
<td>都用</td>
<td>是</td>
<td>可以优先处理紧急任务；但总是高优先级任务到来可能饥饿</td>
<td>会</td>
</tr>
<tr>
<td>多级反馈队列调度算法</td>
<td>根据时间片计算优先级</td>
<td>进程刚到达放入1队列，一个时间片内没完成放入2队列，还没完成一直往后放，如果已经在最后一个队列了就重新放到该队列结尾。1队列优先级最高</td>
<td>进程调度</td>
<td>是</td>
<td>综合了各个调度算法优点</td>
<td>会</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071304330.png" alt="image-20221207130426052"></p>
<h1 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h1><p>虽然之前提过进程是异步的，各个进程相互独立，但是有的工作是有顺序的，比如先读入再写。</p>
<p>同步，即相互制约，指部分工作的次序需要协调。</p>
<p>互斥：一些共享资源不允许多个进程同时访问。比如一次只允许一个进程访问的资源叫临界资源。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071354552.png" alt="image-20221207135453437"></p>
<p><strong>进程互斥遵循以下原则</strong>：</p>
<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待，防止饥饿，不让进程等太久</li>
<li>让权等待，如果该进程进不去，那就不给他了，赶紧给别人。</li>
</ol>
<h2 id="进程互斥软件实现方法"><a href="#进程互斥软件实现方法" class="headerlink" title="进程互斥软件实现方法"></a>进程互斥软件实现方法</h2><ol>
<li><strong>单标志法</strong>	<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071403844.png" alt="image-20221207140305743"></li>
</ol>
<p>​	一开始只允许 P1 访问。一直到P1把 turn 变为0，然后切时间片的时候才能交给 P0. 两者交替访问。</p>
<p>​	但是违背了空闲让进。如果只有 P0 想访问临界区，就一直进不去。</p>
<ol start="2">
<li><p><strong>双标志先检查法</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071408231.png" alt="image-20221207140814172"></p>
<p>判断对方有没有在访问。</p>
<p>但是如果按照①⑤③②⑥⑦的顺序，两者会同时访问临界资源，违反了忙则等待。</p>
</li>
<li><p><strong>双标志后检查法</strong></p>
<p>先上锁再检查。但是两个进程要是都先锁住了，就都执行不了了，可能出现死锁问题。</p>
</li>
<li><p><strong>Peterson 算法</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071417229.png" alt="image-20221207141722082"></p>
<p>可惜没有遵守让权等待。</p>
</li>
</ol>
<h2 id="进程互斥硬件实现方法"><a href="#进程互斥硬件实现方法" class="headerlink" title="进程互斥硬件实现方法"></a>进程互斥硬件实现方法</h2><ol>
<li><p><strong>中断屏蔽方法</strong></p>
<p>访问临界资源的时候把中断关上；访问完了打开，再允许调度。但是用户态不适用（用户态不应该搞中断的问题），而且对多处理机不适用。</p>
</li>
<li><p><strong>TestAndSet 指令</strong></p>
<p>是硬件实现方法，下图为软件实现方式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071812977.png" alt="TS 软件实现方式"></p>
<p>如果 lock 原来是 true，那么其他进程访问的时候一直卡在 while 处。知道访问临界区的进程退出并解锁，其他进程访问的时候 lock 才是 false，才能跳出循环。</p>
<p>但是无法解决让权等待问题，如果有一个进程把 lock 变成 true 之后又进不去临界区，其他进程就永远无法访问，一直忙等。</p>
</li>
<li><p><strong>Swap 指令</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071819188.png" alt="image-20221207181932099"></p>
<p>逻辑上等同于 TS，也无法解决让权等待问题。</p>
</li>
<li><p><strong>信号量</strong></p>
<p>信号量用于表示系统中某种资源的数量。我们用一对原语（等待 P，信号 V）对信号量做操作.信号量涉及到的三个操作就是初始化、P、V。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071834097.png" alt="image-20221207183421978" style="zoom:67%;" />

<p>然而这样的信号量也没能解决让权等待问题。不过一个记录型信号量可以解决。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212071941190.png" alt="image-20221207194128022"></p>
<p>释放完资源，S.value≤0 说明还有进程在阻塞队列中，直接把当前刚释放的处理机给阻塞队列的进程执行。</p>
<p>这样如果该进程进不去自己的处理机，就会把自己调整到堵塞态，把处理机让出来给别人，解决了让权等待问题。</p>
</li>
</ol>
<h2 id="信号量实现进程同步和互斥"><a href="#信号量实现进程同步和互斥" class="headerlink" title="信号量实现进程同步和互斥"></a>信号量实现进程同步和互斥</h2><p><strong>互斥</strong>：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072021901.png" alt="image-20221207202126671"></p>
<p><strong>同步</strong>：如怎样保证2一定在4之前执行</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072032942.png" alt="image-20221207203235758"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072035570.png" alt="image-20221207203533381"></p>
<h1 id="进程种类"><a href="#进程种类" class="headerlink" title="进程种类"></a>进程种类</h1><p><strong>生产者和消费者</strong></p>
<p>生产者把产品放入未满的缓冲区，消费者从未空的缓冲区取出。两者要互斥地对缓冲区访问；同时如果生产者要放入满缓冲区要先等消费者取出，消费者要从空缓冲区取要先等生产者放，这两件事是同步关系。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212072051458.png" alt="image-20221207205103231"></p>
<p>注意 决定互斥的 mutex 顺序不能和决定同步的 empty full 颠倒！！！</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080032409.png" alt="image-20221208003209311"></p>
<p>如上图，如果先进行①②，则互斥锁打开，生产者因为仓库已满无法放入，阻塞。消费者又因为互斥锁打开无法取东西，阻塞，就死锁了。</p>
<p><strong>多生产者 多消费者</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080034113.png" alt="image-20221208003430037"></p>
<p>缓冲区大小（盘子）如果为1，那么不用互斥变量也能解决。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080038949.png" alt="image-20221208003840866"></p>
<p>因为苹果、橘子、盘子变量同时只能有一个&#x3D;1，每次最多也只能有一个变量访问。如果缓冲区变为2就需要 mutex 了，父母同时放入水果可能覆盖对方的值。</p>
<p><strong>吸烟者问题</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080042576.png" alt="image-20221208004256422"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212080207995.png" alt="image-20221208020707796"></p>
<p>因为只有一个缓冲区，所以不需要 mutex 就能实现互斥。</p>
<p>吸烟者问题其实是实现了一个生产者生产多种产品的问题。此例中生产者生产的产品顺序固定，还可以修改生产顺序逻辑。</p>
<p><strong>读者-写者问题</strong></p>
<p>允许多人同时读，但是有人在写的时候其他人不能读写。</p>
<p>读进程有限的解决办法：mutex 用于所有读进程互斥访问 count 变量，当 count 变量&#x3D;0时才可写入。但是写进程有饿死的风险。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212081327613.png" alt="image-20221208132742538"></p>
<p>如果再加一个写的互斥信号量，就能让写操作优先于读操作了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212081327794.png" alt="image-20221208132713723"></p>
<p><strong>哲学家进餐问题</strong></p>
<p>一个进程同时持有多个临界资源的情况。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212081937374.png" alt="image-20221208193715205"></p>
<p>如果只是简单地用两个信号量判断左右两根筷子是否空闲，可能所有进程并发拿起了左手的筷子，并发地卡住了右手的筷子，造成死锁。</p>
<p>有几种解决方案：①拿两只筷子的行为添加一个互斥信号量。这样一个哲学家拿不起来被阻塞的时候，其他哲学家也不会尝试拿。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212090131892.png" alt="image-20221209013159819"></p>
<p>②奇数先拿左手，偶数先拿右手，这样相邻的人拿筷子就会互斥。</p>
<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>信号量挺琐碎的，而且容易出错，顺序错了都会影响结果。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212091244806.png" alt="管程是什么" style="zoom:67%;" />

<p>管程内的数据只有在管程内的过程（函数）才能访问；一次只允许一个进程进入管程。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212091302459.png" alt="image-20221209130200400"></p>
<p>monitor 是 java 语法的管程，每次只允许一个进程访问（互斥），进程只能通过管程提供的特定入口进入。我们可以自己定义逻辑判断，让进程等待或释放（同步）。</p>
<p>关键字 synchronized 修饰的函数同一时间段内只能被一个进程访问。</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>A等B，B等C，C等A，都在等对方手里的资源。</p>
<p>和饥饿不一样，饥饿是如果一直来新进程自己可能一直无法继续。</p>
<p>死锁的四个条件：</p>
<ol>
<li>互斥，对某一资源互斥使用。</li>
<li>不剥夺，不能抢资源。</li>
<li>请求和保持，在新资源还在请求时可以保持自己手里已有的资源。</li>
<li>循环等待，存在资源的循环等待链。比如有12两个资源，进程一申请顺序：12，进程二申请顺序：21，两者正好互相锁住。</li>
</ol>
<p>可能发生死锁的情况：</p>
<ul>
<li>竞争不能共用的系统资源时；</li>
<li>进程推进顺序不当；（哲学家拿筷子，都先拿左手的）</li>
<li>信号量使用不当（如生产者消费者一例，先互斥锁再信号量锁。生产者先进入满仓库，因为当前只有自己进程进入仓库所以互斥锁不干扰；但是仓库已满，无法放入导致阻塞；消费者又因为生产者正在访问，互斥锁限制导致阻塞）。</li>
</ul>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>破坏四个条件之一。</p>
<ol>
<li><p>把资源改为可以共享使用的；不过不是所有设备都能强行改的。</p>
</li>
<li><p>剥夺：要么如果当前进程资源不足时立刻全部释放资源，等一会再重新运行；要么根据优先级，高优先级抢低优先级的资源使用。但是比较复杂而且会影响前一个进程，常用于易于保存和恢复状态的进程（如 CPU）；效率低；方案一还可能导致饥饿。</p>
</li>
<li><p>请求保持：采用静态分配方法，进程开始运行时就把所有需要的资源都给他，全程让他运行。但是可能有的资源这个进程就用一两下，一直占着会比较浪费；可能导致饥饿。</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212092228135.png" alt="image-20221209222856008"></p>
<p>比如上例，两个进程申请资源顺序都从小到大，先1后2，就不会死锁了。但是实际资源使用顺序可能并不是从小到大，效率低；而且增添设备要修改编号，不方便；而且用户编程要注意顺序，比较费事。</p>
</li>
</ol>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212092245236.png" alt="image-20221209224517132"></p>
<p>安全序列就是按某种顺序分配资源，所有进程都能顺利得到，不会死锁。存在一种安全序列的情况，那么当前系统就是处于安全状态。</p>
<p>银行家算法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212092328566.png" alt="image-20221209232829502"></p>
<p>如图，剩余资源 (3, 3, 2)，视作一个一维数组。P0 全分配也不够，不行；P1可以，全分配给P1后P1归还资源，剩余资源数变成 (5, 3, 2)；然后P2不够，P3可以，变成 (7, 4, 3)；p4 变成 (7, 4, 5); P1 变成 (7, 5, 5)，最后 P2 P4，五轮循环全部分配。</p>
<p>最大需求：Max</p>
<p>已分配：Allocation</p>
<p>最多还需要：Need</p>
<p>当次发起申请的请求量：Request</p>
<p>Request≥Need：出错了</p>
<p>Request≤Available：说明有多余空闲。系统先尝试分配一下，成功后证明安全，正式分配。</p>
<h2 id="检测、消除死锁"><a href="#检测、消除死锁" class="headerlink" title="检测、消除死锁"></a>检测、消除死锁</h2><p>点表示进程，方框表示资源，箭头表示分配。如果所有箭头都能被顺利消除，证明不会发生死锁。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212100101090.png" alt="image-20221210010155006"></p>
<p>P1向R2要一个。R2给了P2一个自己还剩下一个，所以可以要到。（P1释放后，就能把P1的所有边去掉了）</p>
<p>P2向R1要一个。但是R1三个都给出去了，所以P2要不到，阻塞了。</p>
<p>P1运行完释放，R1里就有两个空闲的了，P2就能要到了。</p>
<p>下例就没法全部消除，死锁了。只有P3能正常运行并释放。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212100117430.png" alt="image-20221210011729366" style="zoom:67%;" />

<p>解决办法：可以挂起或终止死锁的部分节点，或者回退到没有发生死锁的断点。</p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>存放数据的硬件，程序要先被放到内存中才能被处理.</p>
<p>代码被编译成指令，通常还会涉及到几个地址。比如一个加法指令涉及的三部分（A，B，C）A代表：这是一个加法指令；B C代表：把B中的数据加到C中。</p>
<p>指令中采取的是相对的逻辑地址，因为还不能确定物理存到了哪里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212101408696.png" alt="image-20221210140802510"></p>
<p>装入有三种：</p>
<ol>
<li>绝对装入，编译时就知道要放到哪个物理地址里，编译时直接采用物理地址；适用于单道程序环境。</li>
<li>静态重定位装入，编译时采用相对地址，装入时根据相对地址存入到物理地址。但是如果内存中容量不够，就不能装入。用于早期操作系统。</li>
<li>动态重定位装入，刚进内存不会装入，等到程序运行时再装入。允许程序运行中在内存里移动。现代操作系统。</li>
</ol>
<p>链接也有三种，装入前链接成一块，边装入边链接，运行时再链接。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存中存了多少？空闲多少？进程分配到哪里？怎么释放？内存扩充（游戏60G，内存4G，采用虚拟内存的方式扩充）、地址转换（就是装入。逻辑地址和物理地址之间的链接 是操作系统解决，程序员不用管）、内存保护。</p>
<p><strong>覆盖与交换技术</strong></p>
<p>覆盖技术：解决内存太小的问题。内存中分固定区和覆盖区。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212101818476.png" alt="image-20221210181822311"></p>
<p>缺点在于固定区覆盖区要程序员自己规定，不透明。</p>
<p>交换技术：把内存中某些进程拿出来，再把某些进程换进去。磁盘中专门有一块交换区，追求交换的速度，采用连续存储方式，IO 比文件区要快得多。缺页率高时换出得多。优先换出阻塞和优先级低的进程。</p>
<p><em>覆盖是同一个进程中的</em>，交换是多个进程中的。</p>
<p><strong>内存保护</strong>限制每个进程只能访问自己范围内的数据。可以设置上下限寄存器；或者重定向寄存器决定上限，界地址寄存器代表最大长度。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a><strong>内存分配</strong></h2><p><strong>连续分配</strong>：内存分为系统区和用户区。系统区存放操作系统相关数据；用户区存进程，只能存一个。实现简单，没有外部碎片（内存空闲区域太小，没法分配给进程的情况），可以通过覆盖技术扩大内存，不一定要保护；但是利用率低，而且有内部碎片（分配给某个进程的内存区域，有些部分没有用到）。</p>
<p><strong>固定分区分配</strong>：内存分成很多个分区，每个分区只装一道作业。</p>
<p>（分区大小相等，缺乏灵活性，但是适用于一台计算机控制多个相同对象的场合；</p>
<p>也可以设置不同大小的分区，适用于各种作业）</p>
<p>操作系统需要叫分区说明表的数据结构，让内核程序知道哪些分区可用不可用，起始位置，大小等。没有外部碎片，但是有内部碎片；而且可能有过大的用户程序，所有分区都满足不了，就只能覆盖，降低效率。</p>
<p><strong>动态分区分配</strong>：根据进程大小动态建立分区。系统区大小都是不固定的。可以采取空闲表或空闲链的数据结构存储信息。</p>
<p>动态分配的算法：</p>
<ol>
<li>要插入的进程比空闲区小：更新空闲区起始位置和大小。</li>
<li>要插入的进程和空闲区一样大：直接在空闲分区表中删掉这一条空闲区的记录。</li>
</ol>
<p><strong>动态分区回收算法</strong></p>
<ol>
<li>要回收的分区前面或后面有一块空闲：更新那块空闲的起始位置和大小。</li>
<li>前后没有空闲：新增一条空闲记录。</li>
<li>前后都有空闲：空闲表中两条记录 更新成一整条。</li>
</ol>
<p>动态分配算法 没有内部碎片，但有外部碎片。可以通过“拼凑”来解决。</p>
<p>具体怎么选择空闲分区分配？</p>
<p><strong>动态分区分配算法</strong></p>
<p>首次适应算法：从小地址到大逐渐找。空闲区按地址从小到大存储在空闲链中。</p>
<p>最佳适应算法：优先找能容得下的最小的空闲区，大的留着给大的进程预备着。空闲分区从小到大存储在空闲链中。小碎片会越来越多，导致外部碎片。</p>
<p>最坏适应算法：优先使用最大的空闲分区，避免外部碎片。但是大进程到来的时候可能插入不进来了。</p>
<p>临近适应算法：因为首次适应算法每次都从头找，头部可能有很多小碎片，每次又要遍历。临近适应算法每次从上次结束的地方开始查找。也是优先使用最大分区，类似最坏适应算法。</p>
<p><strong>基本分页存储算法</strong></p>
<p>是一种非连续分配。</p>
<p>每个分区10MB，A进程23MB，可以拆成10+10+3MB存储。</p>
<p>但是这样导致第三个分区内部碎片达到7MB。如果分区大小为2MB，那么只有最后一个分区有1MB内部碎片。</p>
<p>每个分区是一个页框，有页框号，从0开始。把进程分配成页框的大小，叫做一个个页，有页号。</p>
<p>分的页并不是连续存储在分区中的，可以不连续存储，根据逻辑地址找页与页之间的关系。</p>
<p>页号：逻辑地址&#x2F;页面长度。</p>
<p>偏移量：逻辑地址%页面长度。</p>
<p>如第80个内存单元，页面长度50，那么页号&#x3D;1，偏移量&#x3D;30.</p>
<p>如果页面大小是2的整数次幂，那么页面范围就是00000……0001000……0000到00000……00010111……11111，末尾的部分就是页面偏移量。</p>
<p>页表存储页面信息，页表项包含页号和块号信息，每个页表项应该能表示出所有块数的信息。比如有2^20个块，则每个页表项要有20种状态，20位即至少三个字节。(但是通常采用4个字节 这样让总内存数可以等于证书个页表项)</p>
<p><strong>基本地址变换机构</strong></p>
<p>用于实现分页管理逻辑地址转变为物理地址的操作。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212111322421.png" alt="image-20221211132202245"></p>
<p>基本地址变换结构 每次要访问两次内存。</p>
<p>查页表，知道要访问的数据的位置：一次；</p>
<p>去访问数据：二次。</p>
<p><strong>具有快表的地址变换机构</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212111948810.png" alt="image-20221211191228059"></p>
<p>让最近访问过的页表项存到快表中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212111948830.png" alt="image-20221211194853670"></p>
<p>如果快表中有该页表项，直接取出该项计算出物理地址，就不用到慢表中查表了。</p>
<p>访问快表命中了，就只需要一次访存。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212112026971.png" alt="image-20221211202653892"></p>
<p><strong>两级页表</strong></p>
<ol>
<li>单极页表必须连续存储；</li>
<li>并不是整张页表都会被频繁访问到。</li>
</ol>
<p>可以把长长的页表再分成离散的几块，即第二级页表。又叫顶级页表。这样就解决了问题1.</p>
<p>然后对于没有进内存的目标页，访问的时候产生缺页中断，然后调入页。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121211186.png" alt="image-20221212121134020"></p>
<p>但是没有快表的话，两级页表要访存3次。</p>
<p><strong>基本分段存储管理方式</strong></p>
<p>按逻辑把程序分为一个个段（如 主函数，sum 函数……）分段离散的存储到内存中。可读性更高。</p>
<p>段号规定了可以有多少个段，段内地址规定了段的大小。</p>
<p>当然啦，为了查找到哪个段放在哪里，也需要段表。段表每一条包含段号、基址（起始位置）、段长。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121532859.png" alt="image-20221212153212634"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121541529.png" alt="image-20221212154131290"></p>
<p>段表寄存器存储在系统区的 PCB 中，即段表的位置。</p>
<p>相比分页，分段是有意义的，是二维的，用户既要给出段名（如 main 函数的段），又要给出地址。</p>
<p>分段也更容易实现信息共享和保护。首先什么代码可以共享？不能修改的代码可以共享，如常量，防止多个进程并发访问会出问题。</p>
<p>然后分段是按逻辑分的。比如每个函数分一个段。分页是按大小直接截断的。所以分段可能提取出可以共享的代码片段，分页会更难一些。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121545141.png" alt="image-20221212154510085"></p>
<p>分段也是两次访存，也可以尝试快表。</p>
<p><strong>段页式管理方式</strong></p>
<p>分段和分页的缺点是什么？</p>
<p>分页划分固定分区，但不便于信息共享和保护。</p>
<p>分段根据程序分配大小不确定的分区，可能有外部碎片（紧凑还是付出代价很大的）。而且进程太大的话也难以找到一大块连续区域。</p>
<p>那，把大的段分页就好了。</p>
<p>分页的页表包含：页号 页内偏移量信息。分段的段表包含：段号 段长 基址信息（段号可以隐含）。</p>
<p>段页式系统的逻辑地址结构 段包含：段号 页表长 页存放块号（起始地址）。页包含：页号 页面存放的内存块号。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121726546.png" alt="image-20221212172648263"></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>归根结底，以上的内存分配方法需要把整个程序都装入内存运行。而且由于内存的<strong>驻留性</strong>，程序运行完之前整个都一直留在内存中。</p>
<p>第一，没必要，程序的某些部分不常使用，不用一直占在内存里，内存利用率低。第二，太大的程序装不进来。第三，很多程序排队时，这样一次只能运行很少的几个，并发性差。</p>
<p>根据之前快存学到的局部性原理，可以把常用的部分留到内存中，不常用的拿出去。要用到的不在内存里，就拿进来；内存太满，就把不常用的再拿出去。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121801081.png" alt="image-20221212180126990" style="zoom:50%;" />

<p>虚拟内存有多次性（分多次装入）、对换性（可以换出来）、虚拟性。</p>
<p>存储方式：采用连续型并不合适，因为要分多次装入。改用请求式管理。</p>
<p><strong>请求分页管理</strong></p>
<p>和基本分页管理的区别在于：1. 要访问的信息可能在内存中，也可能不在。不在的话要调入进来。要存储该页是否在内存中的信息。</p>
<ol start="2">
<li>暂时不用的可以换出去。如果在内存中做过修改，那么不用拿回到外存；如果做过修改了就要了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121843299.png" alt="image-20221212184343182"></p>
<p>先根据状态位<strong>判断要访问的页在不在内存中</strong>，不在里面，就先产生缺页中断，<strong>调入内存</strong>。如果有空闲块就插到空闲块里，没有就根据<strong>页面置换</strong>算法换出来一个不常用的。调出内存的页面如果发生改变就要写入外存，没有就直接丢掉。最后还要<strong>修改请求页表中的状态信息</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121916450.png" alt="image-20221212191632934"></p>
<p>缺页中断是自行产生的内中断。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121858690.png" alt="image-20221212185821630"></p>
<p>几个值得注意的点：</p>
<ol>
<li>我们知道，如果内存中的内容被修改（发生了”写“操作），状态位中的修改位变为1，移出内存时要再写入外存。实际上修改位的改变不一定用在内存中修改，可能只修改快表中的修改位即可，这样少访存。</li>
<li>换入换出页面太频繁，开销会很大。</li>
<li>页面调入内存后，直接就放到快表里，之后访问就访问快表就行。</li>
</ol>
<p><strong>页面置换算法</strong></p>
<p>追求更小的缺页率，这样换入换出更少。</p>
<p>最佳置换算法 OPT：选择不再使用，或者最长时间内不再被访问的页面淘汰。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121943217.png" alt="image-20221212194302144"></p>
<p>插入701之后满了，再想插入2就要顶掉一个。看看后面要访问的页面，7是最不着急的，先把7顶掉。后面以此类推。</p>
<p><em>注意缺页不一定就会发生页面置换。如果还有块空闲就不用。</em></p>
<p>但最大问题就是操作系统无法提前预判后面的页面访问序列。</p>
<p>先进先出置换算法 FIFO：最早进来的页面最早被淘汰。就是队列的数据结构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121946779.png" alt="image-20221212194655703"></p>
<p>但是这就是再猜啊。怎么能因为用的早就觉得下一秒他不会用了呢？买彩票呢。可能会引发 Belady 异常（为进程分配的物理块变大时，缺页次数反而变多）。</p>
<p>最近最久未使用置换算法 LRU：</p>
<p>哪个最久没用过，就先替换掉哪个。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212121953012.png" alt="image-20221212195347896"></p>
<p>性能确实好，但是开销大，实现困难。</p>
<p>时钟置换算法 CLOCK：每个页面添加一个访问位，初值都是0，访问过了改为1.每次优先替换掉0的页面。如果全为1，则全置0后再次扫描。</p>
<p>改进的时钟置换算法：同时考虑访问位和修改位。</p>
<p>替换：第一轮扫描找0，0的替换。这种不仅最近没用过，而且不用写入外存。</p>
<p>第二轮找0，1的替换。这种最近没用过，但是之前修改过，要写入外存。</p>
<p>如果这两轮都没找到，说明所有的第一位都是1.全部置0，再进行扫描。</p>
<p>第三轮找0，0，类似第一轮。</p>
<p>第四轮找0，1，类似第二轮。</p>
<p><strong>页面分配策略</strong></p>
<p>驻留集：请求分页存储管理中分给内存的物理块的集合。虚拟存储中，驻留集大小一般小于进程总大小。太小，频繁缺页出入内存效率低；太大，并发性降低。</p>
<p>固定分配：一开始给定每个进程固定大小的驻留集。</p>
<p>动态分配：根据运行过程中的情况动态分配大小。</p>
<p>局部置换：缺页时只能当前进程自己的物理块置换需要的页进来。</p>
<p>全局置换：可以用空闲的物理块，或其他进程的物理块置换。全局置换大小肯定不固定，肯定是动态分配。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212130102033.png" alt="image-20221213010232817"></p>
<p>调入哪些页？</p>
<p>首次调入时，根据局部性原理，某个页相邻的页也会容易用到。因此一调调一小片。</p>
<p>运行中缺页调入时，只调缺少的页。</p>
<p>从何处调入页面？</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212130114188.png" alt="image-20221213011456020"></p>
<p>抖动&#x2F;颠簸现象：刚换出去的页面又换进来。主要原因是驻留集太少了，少于要频繁使用的块。</p>
<p>工作集：运行时进程实际访问的页面集合。驻留集不应小于工作集。</p>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>有信息的数据集合。</p>
<p>文件包含的信息：文件名、标识符（操作系统要看）、类型、大小、创建修改时间、所有者、安全信息。</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>文件分为无结构的流式文件和有结构的记录式文件。记录式文件由一条条记录组成。</p>
<p>文件存放在根目录里的目录里。</p>
<p>操作系统应该向上提供给用户的功能：CRUD，打开和关闭文件。</p>
<p>文件存放在外存类似进程在内存中，是分块存放的（救命啊，我刚把那块学过去）。</p>
<p>初次子海外，操作系统还应该提供文件共享和保护功能。</p>
<h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><p>无结构文件（如txt）很简单。</p>
<p>有结构文件一般有关键字区分各个记录；记录存储长度不同又分为定长和可变长。</p>
<p>有结构文件逻辑结构：</p>
<ol>
<li><p>顺序&#x2F;链式存储。顺序定长存储可以实现随机存取，想找第i位直接起始位置+i*单位长度即可。顺序可变长无法计算，链式存储不连续也无法实现随机存取。<em>顺序定长存储如果物理上也采用顺序存储，则可实现快速检索。</em></p>
</li>
<li><p>索引文件。对于可变长记录文件，可以建立一个定长的索引表，包含索引号、长度、起始位置指针的信息。检索速度很高。但是索引表和记录数一样，占的空间不小。</p>
</li>
<li><p>索引顺序文件，一条索引代表一组记录。可能查找速度还是很慢，那就建立多级索引。</p>
<p>类似数据结构中学到的中间表，如果索引中只存储必要的少部分信息（文件名，指针），索引占的小，能放更多的索引，用更少的磁盘块存储，就平均需要访问更少的磁盘块就能找到文件。</p>
</li>
</ol>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20221213034225243.png" alt="image-20221213034225243" style="zoom:50%;" />

<p>​	外存中的索引节点叫磁盘索引节点，内存中的叫索引节点，可能包含更多信息，如文件是否被修改、同时有几个进程在访问等。</p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>文件控制块 FCB 中存储文件名、类型（是否是目录）、权限、地址等信息。</p>
<p>目录支持的功能有：搜索、创建、删除、显示、修改文件。</p>
<p>早期操作系统只支持<strong>单文件目录</strong>，那就不能重名了。</p>
<p>早期多用户操作系统支持<strong>双文件目录</strong>，一个主文件目录，其中包含多个用户目录。不同用户目录各自文件可以重名。但是用户自己没办法创建多级目录。</p>
<p>后来的多级目录结构支持<strong>多级目录</strong>了。</p>
<p>引入当前目录概念：如果没有此概念，我们要找根目录下 &#x2F;目录1&#x2F;目录2&#x2F;照片.jpg，需要三次访存。根目录找目录1，目录1找目录2，目录2找jpg。要是有当前目录的相对路径就会方便得多。</p>
<p>树形目录结构缺点在于不能共享文件。</p>
<p><strong>无环图目录结构</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212130400399.png" alt="image-20221213040035339"></p>
<p>不同用户不同目录下可以访问到相同的共享文件。</p>
<p>共享文件要设置共享计数器。当有用户取消共享后，要删除共享信息，共享计数器–。减为0时删除共享节点。</p>
<h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p>很多操作系统中，磁盘块和内存块、页大小相同，成块成块拿进来。</p>
<p>类似内存，文件存储的逻辑地址分为逻辑块号和块内地址两部分。</p>
<p><strong>连续分配</strong></p>
<p>自不必多说<del>物理块号&#x3D;起始块号+逻辑块号。支持顺序访问和随机访问。但是不方便拓展，比如1</del>3块的A文件想扩展，但是4~6是B文件，不是空闲文件，A文件想拓展只能整体挪到空闲区域；而且还可能产生大量磁盘碎片。</p>
<p><strong>链接分配</strong></p>
<p>隐式链接：FCB存储起始块号和结束块号。像链表一样从第一个找到结尾（每个磁盘块中包含指向下一个盘块的指针，但是这对用户来说是透明的），没法随机存取，但是拓展方便。</p>
<p>显示链接：FCB 中包含起始块号，此外还有一张文件分配表 FAT，其中包含所有块号的下一块指针。隐式链接想找一个块，要先在 FCB 中找到起始位置，再读磁盘，找磁盘里的下一块。显示连接可以先不用读磁盘，根据分配表推测出要找的逻辑块的物理地址再去读磁盘，访问速度更快。</p>
<p>链接分配都不会有外部碎片。</p>
<p><strong>索引分配</strong></p>
<p>每个文件建立一个索引表。索引表存放的磁盘块叫索引块，文件数据存放的磁盘块叫数据块。FAT是一个磁盘对应一张，索引表是一个文件对应一张。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131026788.png" alt="image-20221213102643626"></p>
<p>也支持随机存取，也方便拓展，但是索引表占空间。</p>
<p>要是文件太大，索引表一个索引块存不下，需要多个。</p>
<p>可以让索引块之间链接起来。但是不支持顺序存储，要找最后一块就要从头便历。</p>
<p>可以建立多级索引。每级大小不超过一个数据块。k级表访问数据，要访问k+1次磁盘块（k次查找位置，1次查找数据）。</p>
<p>混合索引：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131040897.png" alt="image-20221213104019760"></p>
<p>小文件层级小一点。因小文件访问可能频繁一些，就少访问几次。</p>
<h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>操作系统的盘有什么用？又叫文件卷，每个文件卷都包含目录区和文件区。</p>
<p><strong>空闲表法</strong></p>
<p>分配磁盘块给用户：类似动态分区分配，可采用首次适应、最佳适应、最坏适应等。</p>
<p>回收磁盘块：也类似动态分区分配，考虑前后有无空闲块。</p>
<p><strong>空闲链表法</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131057529.png" alt="image-20221213105751349"></p>
<p>空闲盘块链分配：空闲链从链头摘下来k个空闲块，并修改链头位置。</p>
<p>空闲盘块链回收：回收的空闲块挂到空闲链结尾，并修改链尾位置。</p>
<p>空闲盘区链分配：先按算法找到合适的空闲盘区。如果没有合适的，也可以把不同盘区的盘块同时给一个文件。</p>
<p>空闲盘区链回收：如果和空闲盘区挨着，直接合并。否则变成一个单独的空闲盘区挂到队尾。</p>
<p><strong>位示图法</strong></p>
<p>一定注意从0还是1开始！</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131113265.png" alt="image-20221213111306083"></p>
<p>分配：扫描位图，找到连续的k个0，修改为1.</p>
<p>回收：算出回收盘块的位图字号、位号，置为0.</p>
<p><strong>成组链接法</strong></p>
<p>大文件不适用空闲块法。</p>
<p>超级块存放在内存中，其中包含下一组空闲块块数和块号。</p>
<p>如果没有下一级了，下一组空闲盘块数可以用特殊标识符如-1表示。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131251971.png" alt="image-20221213125105862"></p>
<p>空闲分配：如果&lt;100个，从超级块分配就够。</p>
<p>如果&#x3D;100个，不能直接分配超级块因为这样超级块对后面的链接就消失了。要先把300的内容提到超级块作为新的超级块，再分配。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131309663.png" alt="image-20221213130944587"></p>
<p>回收：直接加到超级块上。如果超级块最大大小为100，已经满了，还要回收，就要让新回收的块作为新的超级块，并指向原来的超级块。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131313202.png" alt="image-20221213131331129"></p>
<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><p><strong>文件创建</strong></p>
<p>需要关注：文件名；文件路径；需要的外存空间。</p>
<ol>
<li>在外存中找到合适大小的内存空间；</li>
<li>在目录表中更新新文件的信息。</li>
</ol>
<p><strong>文件删除</strong></p>
<ol>
<li>根据目录表找到该目录项；</li>
<li>外存中回收内存；</li>
<li>目录表中删除该文件信息。</li>
</ol>
<p><strong>打开文件</strong></p>
<p>需要用户提供的信息：文件名；文件目录；打开方式（读；写；……）</p>
<p>操作系统先去目录表找到对应的文件，复制到内存中。并且把目录项复制到内存系统的“打开文件表”中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131338588.png" alt="image-20221213133814373"></p>
<p><strong>关闭文件</strong></p>
<p>删除用户打开文件表的对应项；回收空间；系统打开文件表的打开计数器-1，减到0则删除打开文件表的对应项。</p>
<p><strong>读文件</strong></p>
<p>指明要读的文件，要读入多少数据，读入的数据在内存中的位置。读入指定大小放入内存中。</p>
<p><strong>写文件</strong></p>
<p>和read很像。最后再通过write系统调用写回外存。</p>
<h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>基于索引节点的共享方式（硬链接）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131621187.png" alt="image-20221213162136121"></p>
<p>count说明还有几个进程在共享该文件。</p>
<p>要删除时，count–，若&gt;0则不能删除，&#x3D;0才能删除。</p>
<p>基于符号链的共享方式（软链接）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131626995.png" alt="image-20221213162634924"></p>
<p>删掉文件1，软链接仍然存在，只是无法通过软链接去访问文件1了。</p>
<p>因为访问共享文件要查询多级目录，进行多次 IO，因此采用软链接。</p>
<h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p>口令保护：规定一个口令，用户要说对应口令才能访问。但是口令保存在系统内部，不安全。</p>
<p>加密保护：用密码对文件加密。如异或加密。有点费时。</p>
<p>访问控制：文件的 FCB 中增加一个访问控制列表 ACL，记录用户可以有哪些权限（读写运行ls）。以组为单位，如：管理员，文件主，文件主的伙伴，陌生人。</p>
<h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131650838.png" alt="image-20221213165015538"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131653423.png" alt="image-20221213165347348"></p>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131724309.png" alt="image-20221213172411000"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131726317.png" alt="image-20221213172609205"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131726041.png" alt="image-20221213172629925"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131726557.png" alt="image-20221213172637487"></p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131813172.png" alt="image-20221213181331914"></p>
<p>先来先服务算法 FCFS：就是单纯的先处理先来的进程。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131821625.png" alt="image-20221213182105548"></p>
<p>最短寻找时间优先 SSTF：先找离当前磁道近的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131824597.png" alt="image-20221213182454524"></p>
<p>扫描算法 SCAN：只有磁道移到最外侧之后才允许往回移动，避免 SSTF 的左右横跳。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131830038.png" alt="image-20221213183053980"></p>
<p>LOOK 调度算法：改进 SCAN 算法，观察到当前磁道已经是访问请求最右边的磁道后，就可以立即改变磁道移动方向往回。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131833520.png" alt="image-20221213183329408"></p>
<p>循环扫描算法 C-SCAN：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131844015.png" alt="image-20221213184440873"></p>
<p>C-LOOK 算法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131845424.png" alt="image-20221213184532367"></p>
<h2 id="减少延迟时间"><a href="#减少延迟时间" class="headerlink" title="减少延迟时间"></a>减少延迟时间</h2><p>磁盘一直旋转的。如果要读几个相邻的扇区，读了第一个处理的过程中磁盘还在转，处理好了的时候可能又转到不知道哪里去了。可能就会产生很长的延迟时间。</p>
<p>解决办法：交替编号。逻辑上相邻的扇区物理上分开。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212131921182.png" alt="image-20221213192126906"></p>
<p>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）？因为更改柱面号需要移动磁头臂，更改盘面号不用移动臂，只需要激活相邻盘面的磁头即可。可以减少磁头移动消耗的时间。</p>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p>初始化：</p>
<p>​	物理格式化：把磁盘划分为扇区。扇区包含头、尾、中间数据部分。头尾会存放一些扇区校验码之类的信息。</p>
<p>​	磁盘分区：分为几个文件卷。</p>
<p>​	逻辑格式化：创建文件系统（根目录、管理空间的数据结构如位示图、空闲分区表等）。</p>
<p>​	磁盘的初始化程序：放在哪里？</p>
<p>​	ROM 只读存储器中的数据出厂时就写好了且不能更改，集成在主板上。但是磁盘的初始化程序说不定以后会更新换代，ROM 中的内容又不能更新，因此初始化程序不放在 ROM 中，而是放在磁盘（C）里。初始化程序的装入程序写在 ROM 中。</p>
<p>坏块的管理：坏掉的扇区。简单的磁盘直接在 FAT 中标记出来防止被使用到（对操作系统不透明）。复杂的磁盘交给磁盘控制器维护坏块链表，而且保留一些备用分区（对操作系统透明）。</p>
<h1 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h1><h2 id="I-O-设备分类"><a href="#I-O-设备分类" class="headerlink" title="I&#x2F;O 设备分类"></a>I&#x2F;O 设备分类</h2><p><strong>按使用特性分类</strong></p>
<p>人机交互类外设：如鼠标打印机键盘等。数据传输慢。</p>
<p>存储设备：移动硬盘、光盘等，数据传输速率快。</p>
<p>网络通信设备：调制解调器等用于网络通信，速度中等。</p>
<p><strong>按速率分类</strong></p>
<p>低速设备：鼠标键盘。</p>
<p>中速：激光打印机。</p>
<p>高速：移动硬盘等。</p>
<p><strong>按信息交换的单位分类</strong></p>
<p>块为单位：磁盘。</p>
<p>字符为单位：鼠标键盘等。</p>
<h2 id="I-O-控制器"><a href="#I-O-控制器" class="headerlink" title="I&#x2F;O 控制器"></a>I&#x2F;O 控制器</h2><p>IO设备包括：</p>
<ul>
<li><p>机械部件：用于执行具体 IO 操作的，如鼠标按钮、显示器屏、磁盘盘面。</p>
</li>
<li><p>电子部件：插入主板扩充槽的印刷电路板。</p>
</li>
</ul>
<p>CPU 要通过 IO 控制器作为中介才能控制机械部件。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132007717.png" alt="image-20221213200720497"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132008149.png" alt="image-20221213200846891"></p>
<p>一个 IO 控制器可能控制多个设备；而且可能有多个寄存器。有的操作系统让这些寄存器存到内存里，叫做内存映像 IO；有的采用专门的地址，即寄存器独立编址。独立编址不在内存里，因此还要设置专门的指令来实现对其的操作，还要指明具体对哪个控制器操作。</p>
<h2 id="IO-控制方式"><a href="#IO-控制方式" class="headerlink" title="IO 控制方式"></a>IO 控制方式</h2><p>关注：一次读写操作的流程；CPU 干预的频率；数据传送单位；数据流向；优缺点。</p>
<p><strong>程序直接控制</strong></p>
<p>读：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132014482.png" alt="image-20221213201440173"></p>
<p>重点在轮询。CPU要不断轮询。</p>
<p>数据传送单位：每次一个字。</p>
<p>数据流向：内存和 IO 设备经由 CPU 读写。每个字读写都需要 CPU 帮助。</p>
<p>简单，但是 CPU 和 IO 只能串行工作，CPU 一直轮询检查效率也很低。</p>
<p><strong>中断驱动方式</strong></p>
<p>CPU 发出读写命令后，等待 IO 的进程暂时阻塞，先运行其他程序。IO 完成后控制器会向 CPU 发一个中断信号，CPU 收到后继续执行。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132032231.png" alt="image-20221213203221153"></p>
<p>CPU 执行完每个指令的周期末尾检查中断。中断处理过程需要保存、恢复进程的运行环境，也需要一定时间开销。</p>
<p>CPU 只有 IO 开始时干预一下，等待 IO 过程中就运行其他进程了。</p>
<p>数据传送单位：每次一个字。</p>
<p>数据流向：内存和 IO 设备经由 CPU 读写。每个字读写都需要 CPU 帮助。</p>
<p>相比程序直接控制，CPU 利用率高一点了。但是一个字一个字的传，速度还是慢。</p>
<p><strong>DMA 方式</strong></p>
<p>数据传输单位是块；设备和内存之间数据传输不用每次都经过 CPU ，只有开始传输或结束时才需要干预。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132141644.png" alt="image-20221213214114491"></p>
<p>缺点：CPU 每发一条 IO 指令，只能读写几次连续的数据块。离散的数据块就要多次中断。</p>
<p><strong>通道控制方式</strong></p>
<p>通道相当于简化版的 CPU。CPU向通道发出指令，指明通道程序在内存中的位置，并指明要操作的是哪个 IO 设备，然后 CPU 就去运行其他程序了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132150157.png" alt="image-20221213215048076"></p>
<p>通道能执行的指令很单一，而且放在内存中。</p>
<p>CPU 干预次数极少，效率也高，就是需要专门的通道程序支持。</p>
<h2 id="I-O-软件层次"><a href="#I-O-软件层次" class="headerlink" title="I&#x2F;O 软件层次"></a>I&#x2F;O 软件层次</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132153000.png" alt="image-20221213215341827"></p>
<p>设备独立性软件：向上提供接口（入库函数）。校验用户是否有权限使用当前设备。差错处理。分配和回收设备。管理数据缓冲区。建立逻辑设备名到物理设备名的映射，并根据实际的物理设备选择合适的驱动程序。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132205495.png" alt="image-20221213220547401"></p>
<p>可以只设立一个系统 LUT，但是所有用户的逻辑设备名不能重复；也可以给每个用户设计一个。</p>
<p>为什么不同设备驱动程序也不同？因为不同设备内部结构也不一样。比如不同打印机内部寄存器数量可能不一样。驱动程序一般作为单独的进程。</p>
<p>设备驱动程序：主要负责具体控制硬件设备。</p>
<p>中断处理程序：IO 顺利完成后，进行中断处理。并从设备读入一个字长的数据。</p>
<h2 id="I-O-核心子系统"><a href="#I-O-核心子系统" class="headerlink" title="I&#x2F;O 核心子系统"></a>I&#x2F;O 核心子系统</h2><p><strong>假脱机技术</strong></p>
<p>脱机技术是什么？我们记得最早期的计算机是人手动打孔纸带放入计算机中的，因为人打孔太慢，CPU 运行再快也得等着。</p>
<p>批处理几段引入了脱机输入，先通过外围控制机把数据输入到更快速的磁带上再让主机读入。脱机指的是脱离主机控制的 IO 操作。</p>
<p>不仅 IO 快了，而且 CPU 忙的时候用户也可以先处理数据到磁带上。</p>
<p>假脱机技术 SPOOLing 用软件模拟脱机技术。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132359303.png" alt="image-20221213222958979"></p>
<p>输入输出进程模拟外围控制机。</p>
<p>借助 SPOOLing 技术，可以让打印机实现共享。收到用户的打印请求时，在输出井里申请空闲缓冲区（在磁盘上），并放入要打印的数据；且给用户进程申请一张空白的打印请求表，里面存储打印的相关信息，并把该表挂到假脱机文件队列上。打印机空闲时从队列中取出打印请求表，根据表取出打印的数据到输出缓冲区，再到打印机打印。</p>
<h2 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h2><p>分配设备要考虑：<strong>设备属性</strong>（独占？共享？虚拟？虚拟就是假脱机技术等独占改成共享）。<strong>设备分配算法</strong>（FCFS 优先级高的优先 短任务优先）。<strong>安全性</strong>。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132238185.png"></p>
<p>分配分为静态分配和动态分配。</p>
<p><strong>设备分配管理中的数据结构</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132240499.png" alt="image-20221213224041439"></p>
<p><strong>设备控制表 DCT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132242703.png" alt="image-20221213224208534"></p>
<p><strong>控制器控制表 COCT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132243321.png" alt="image-20221213224340187"></p>
<p><strong>通道控制表 CHCT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132244138.png"></p>
<p><strong>系统设备表 SDT</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132245062.png" alt="image-20221213224501959"></p>
<p><strong>设备分配步骤</strong></p>
<ol>
<li>根据进程的物理设备名，去 SDT 找设备。</li>
<li>根据 SDT 找 DCT，空闲就直接把设备分给这个进程，忙碌就把这个进程的 PCB 挂到设备等待队列中。</li>
<li>根据 DCT 找到 COCT，空闲就分配，不空闲就等待。</li>
<li>根据 COCT 找到 CHCT，空闲就分配，不空闲就等待。</li>
</ol>
<p>以上方法缺点在于用户要知道物理设备名，不透明；而且只指定这一个设备，如果该设备坏了或者堵塞哪怕其他设备能用也无法切换。</p>
<p>可以建立逻辑设备，用逻辑设备找物理设备。</p>
<p>SDT 中设备类型就是逻辑设备名。</p>
<p>通过逻辑设备表 LUT 建立逻辑设备名和物理设备名之间的映射关系。</p>
<h1 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h1><p>缓冲区是一个存储区域，可以用专门的硬件寄存器，也可以用内存做。速度快，成本高，容量小，比如快表。本节中介绍的主要是内存缓冲区。</p>
<p>可以缓冲 CPU 和 IO 之间速度不匹配的矛盾，进而 CPU 中断次数也会减少；解决数据颗粒度不匹配的问题；提高 CPU 与 IO 的并行性。</p>
<p><strong>单缓冲区</strong></p>
<p>某用户进程请求设备读入若干个块的数据。。如果采用单缓冲策略，主存中会被分配一个缓冲区（一般是一个块大小）。缓冲区中只有空的时候才能冲入数据，只有非空的时候才能传出数据。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132311260.png" alt="image-20221213231116133"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132315136.png" alt="image-20221213231551012"></p>
<p><strong>双缓冲区</strong></p>
<p>一满一空，可以空的边读，满的边往工作区写。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132321677.png" alt="image-20221213232144595"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132321658.png" alt="image-20221213232106544"></p>
<p>用时&#x3D;Max(C+M, T)</p>
<p>如果两台机器各配置2个缓冲区，就能同时收发了。</p>
<p><strong>循环缓冲区</strong></p>
<p>多个大小相同的缓冲区链接成一个循环队列。 </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132329586.png" alt="image-20221213232951510"></p>
<p><strong>缓冲池</strong></p>
<p>放满了各种各样缓冲区的池子。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212132331181.png" alt="image-20221213233107985"></p>
<p>输入：取出一个空缓冲区挂到收容输入队列中，输入放到收容输入队列中，装好了挂到输入队列中。</p>
<p>提取输入：从输入队列取下来，放到提取输入队列中提取到用户进程，再挂回空缓冲区。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/" rel="tag">OS</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-大作业：Java 程序设计-Java-语言-Wordle"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/20/%E5%A4%A7%E4%BD%9C%E4%B8%9A%EF%BC%9AJava%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java-%E8%AF%AD%E8%A8%80-Wordle/"
    >大作业：Java 程序设计-Java-语言-Wordle</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/20/%E5%A4%A7%E4%BD%9C%E4%B8%9A%EF%BC%9AJava%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Java-%E8%AF%AD%E8%A8%80-Wordle/" class="article-date">
  <time datetime="2022-07-19T23:00:00.000Z" itemprop="datePublished">2022-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Wordle-游戏介绍"><a href="#Wordle-游戏介绍" class="headerlink" title="Wordle 游戏介绍"></a>Wordle 游戏介绍</h1><blockquote>
<p>Wordle的游戏规则很简单，玩家需要猜出程序每天指定的一个5位英语单词谜底。</p>
<p>玩家可以随意提交一个英语单词，但必须是字典里有的，不能胡乱拼写。</p>
<p>如果字母在谜底中出现且位置对了就显示绿色，字母出现了但位置不对就显示黄色，字母在答案的单词中没出现就显示灰色。</p>
<p>根据反馈信息再进行下一轮猜测，在6次尝试之内猜出就算赢。<br>来源：<a target="_blank" rel="noopener" href="https://news.mydrivers.com/1/813/813695.htm#:~:text=Wordle%E7%9A%84%E6%B8%B8,%E4%BD%8D%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%B0%9C%E5%BA%95%E3%80%82">https://news.mydrivers.com/1/813/813695.htm#:~:text=Wordle%E7%9A%84%E6%B8%B8,%E4%BD%8D%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E8%B0%9C%E5%BA%95%E3%80%82</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/494e131e4b2641d48becd4aef3f90c7d.png" alt="在这里插入图片描述"></p>
<h1 id="成果图示"><a href="#成果图示" class="headerlink" title="成果图示"></a>成果图示</h1><p>博主大二期间学习的java课程大作业，就是写一款 wordle 游戏，主要考察 GUI 界面的开发。<br>最终成果图示：<br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/008abdff020b4e05bc56265450bc7442.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1840388526344189a27121987da22d47.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/74f2dd38063349298b84d23cafb28db2.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e9aacefcb2984adf913ea8c80fee24ff.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/07e7dd5c4a4348afb35cfc7cc009ca88.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/f163f8a63ff14878b74691ba432fd882.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/de75c6c50c9b45a3bbd2c58f95104217.png" alt="在这里插入图片描述"></p>
<h1 id="玩法介绍"><a href="#玩法介绍" class="headerlink" title="玩法介绍"></a>玩法介绍</h1><p>点击HELP 查看帮助，点击 START 开始游戏。<br>本游戏中没有虚拟键盘，输入框也不能获取鼠标焦点，只能通过键盘键入字母，回车检查答案。<br>敲下回车后，字母就会呈现灰色、黄色、绿色三种状态，并换到下一行开始下一次猜单词机会。当猜中答案或六轮游戏结束时，弹出小窗，提示用户游戏胜利&#x2F;失败。<br>注意：</p>
<ol>
<li>检查用户输入。本游戏中用户只能输入字母，当用户试图键入数字或符号时会提示只能输入字母。当用户输入不足5位就尝试检查，或尝试输入超出5位时会提示输入必须为5位字母。当用户输入非单词尝试检查会提示输入必须为词库中存在的单词（词库：words.txt，可以自己更新）</li>
<li>一些小的注意点。当用户输入中有两个e，都不在正确的位置上，那这两个e只有一个会显示黄色就够了，另一个显示灰色，否则会影响用户的判断。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/Java_Wordle_Game">Java_Wordle_Game github下载地址</a><br>README：帮助信息<br>javadoc：生成的 javadoc<br>Test：测试图片及说明<br>words.txt：词库</p>
<p>运行方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br><span class="line">java Main</span><br></pre></td></tr></table></figure>
<p>在此感谢老师同学对此项目的帮助指导！<br>欢迎大家star支持[Doge]有问题也可以与博主交流~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=1357960253&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>