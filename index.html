<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title> 灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
  <div class="cover-frame">
    <div class="bg-box">
      <img id="random-cover" src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">灰海宽松的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['没有一条路无风无浪', '常应常静，常清净矣', 'Love the Life You Live'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>

  <script>
  (function () {
    const coverCount = 5; // 修改为你有几张封面图
    const index = Math.floor(Math.random() * coverCount) + 1;
    const imgPath = `/images/cover${index}.jpg`;
    const imgEl = document.getElementById('random-cover');
    if (imgEl) {
      imgEl.src = imgPath;
    }
  })();
</script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-题目练习：代码随想录解题思路分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/05/29/%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/"
    >题目练习：代码随想录解题思路分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/29/%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2025-05-28T23:00:00.000Z" itemprop="datePublished">2025-05-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实博主从大二开始闲着没事陆续刷 leetcode 也刷了不少了，但是感觉都是没什么思想地刷，可能大多数题能记住解法，但是很多题再看到第一眼还是想不到什么双指针，滑窗之类的优解，没有这个意识，要扫一眼题解的方法才会恍然大悟“哦对哦可以这么做的”然后才能写出来。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505300004032.png" alt="博主的 Leetcode 数据" style="zoom: 67%;" />

<p>所以这回（第 N 次为了面试做准备而重刷，从代码随想录开始，我还没试过这个）我决定重点在于“看到题目如何构思解法”的分析上。比如双指针一般应用于什么题型？为什么这道题看到后第一眼知道用双指针？</p>
<p>希望对你也有所帮助。</p>
<p><em>注：博主使用语言为 java。</em></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二分查找（Leetcode-704-）"><a href="#二分查找（Leetcode-704-）" class="headerlink" title="二分查找（Leetcode 704.）"></a>二分查找（Leetcode 704.）</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505300005472.png" alt="Leetcode 二分查找" style="zoom: 67%;" />

<p>xxxxxxxxxx int zong(int i)&#x2F;&#x2F;纵坐标y1{    double x&#x3D;(i-51);    double y&#x3D;12.0*sin(x&#x2F;7);    int y1&#x3D;(int)(15-y);    return y1;}​int heng(int i)&#x2F;&#x2F;横坐标j{    int j&#x3D;i;    if(i&gt;101&amp;&amp;i&lt;&#x3D;202)j&#x3D;203-i;    else if(i&gt;202&amp;&amp;i&lt;&#x3D;303)j&#x3D;i-202;    else if(i&gt;303&amp;&amp;i&lt;&#x3D;404)j&#x3D;405-i;    return j;}​void dayin(char ch,int j,int y1)&#x2F;&#x2F;在(y1,j)处输出给定字符{        gotoxy(y1,j);        if(ch&#x3D;&#x3D;’ ‘)        {            if(y1&#x3D;&#x3D;15)printf(“-“);            else if(j&#x3D;&#x3D;51)printf(“|”);            else printf(“ “);        }        else printf(“#”);        gotoxy(29-y1,102-j);        if(ch&#x3D;&#x3D;’ ‘)&#x2F;&#x2F;防止坐标点和坐标轴被空格覆盖        {            if(29-y1&#x3D;&#x3D;15)printf(“-“);            else if(102-j&#x3D;&#x3D;51)printf(“|”);            else if(29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;49)printf(“-“);            else if((29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;50)||(29-y1&#x3D;&#x3D;3&amp;&amp;102-j&#x3D;&#x3D;50))printf(“1”);            else if(29-y1&#x3D;&#x3D;16&amp;&amp;102-j&#x3D;&#x3D;100)printf(“X”);            else printf(“ “);        }        else printf(“#”);        gotoxy(1,1);}​​​​int main(){    float x,y;    int tim&#x3D;20;    system(“color F0”);    system(“mode con cols&#x3D;101 lines&#x3D;30”);    clear();        for(int i&#x3D;0;i&lt;&#x3D;100;i++)&#x2F;&#x2F;打印x轴     {        gotoxy(15,i+1);        if(i!&#x3D;50)printf(“-“);        else printf(“+”);        gotoxy(1,1);        rest(1);    }        for(int i&#x3D;29;i&gt;&#x3D;0;i–)&#x2F;&#x2F;打印y轴     {        gotoxy(i+1,51);        if(i!&#x3D;14)printf(“|”);        gotoxy(1,1);         rest(1);    }    &#x2F;&#x2F;打印轴上的点    gotoxy(16,52); printf(“O”);        gotoxy(16,100);printf(“X”);        gotoxy(1,49);printf(“Y”);        gotoxy(3,50);printf(“1”);        gotoxy(26,49);printf(“-1”);                    int i&#x3D;0,j,y1;​    for(i&#x3D;52;i&lt;&#x3D;404;i++)&#x2F;&#x2F;打印函数     {        j&#x3D;heng(i),y1&#x3D;zong(i);        dayin(‘#’,j,y1);        rest(4);                if(i-51-tim&gt;0)        {            y1&#x3D;zong(i-tim);            j&#x3D;heng(i-tim);            dayin(‘ ‘,j,y1);        }    }       for(int r&#x3D;i-tim;r&lt;&#x3D;i;r++)    {        j&#x3D;heng(r);        y1&#x3D;zong(r);        dayin(‘ ‘,j,y1);        rest(4);    }     gotoxy(1,1);    rest(1000);    return 0;}c</p>
<p>时间复杂度是 log2(n)，空间复杂度 O(1)。</p>
<p>二分法使用的时候注意自己规定好左右边界，不要漏掉一些边界情况等。我的常用玩法是循环跳出条件为 <code>left&gt;right</code>，每次校验完 mid 之后让 <code>left=mid+1</code> 或 <code>right=mid-1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length&lt;=<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; nums[mid]!=target )&#123;</span><br><span class="line">            <span class="comment">// nums[mid]&gt;target?right=mid-1:left=mid+1;</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)right=mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移除数组指定值元素（Leetcode-27-）"><a href="#移除数组指定值元素（Leetcode-27-）" class="headerlink" title="移除数组指定值元素（Leetcode 27.）"></a>移除数组指定值元素（Leetcode 27.）</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505300011662.png" alt="Leetcode 移除元素" style="zoom:80%;" />

<p>如果没有<strong>原地</strong>的要求，我们新开辟一个数组空间，有选择性地把原数组值复制过去就行，记得记一下数看有多少个非 <code>val</code> 值。</p>
<p>GPT 总结双指针使用场景总览：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>常见题型举例</th>
</tr>
</thead>
<tbody><tr>
<td>1. 对撞指针</td>
<td>从两端向中间逼近</td>
<td>排序数组的和、回文串判断、三数之和等</td>
</tr>
<tr>
<td>2. 快慢指针</td>
<td>一快一慢遍历链表或数组</td>
<td>环形链表、删除重复元素、寻找中点等</td>
</tr>
<tr>
<td>3. 滑动窗口</td>
<td>左右指针控制一个动态区间</td>
<td>最小覆盖子串、最长无重复子串等</td>
</tr>
<tr>
<td>4. 区间遍历&#x2F;合并区间</td>
<td>对多个数组或区间双向扫描</td>
<td>区间交集、归并两个有序数组等</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slowIndex</span> <span class="operator">=</span> <span class="number">0</span>, fastIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex]!=val)nums[slowIndex++]=nums[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有序数组的平方（Leetcode-977-）"><a href="#有序数组的平方（Leetcode-977-）" class="headerlink" title="有序数组的平方（Leetcode 977.）"></a>有序数组的平方（Leetcode 977.）</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505300855824.png" alt="Leetcode 有序手势的平方" style="zoom:67%;" />

<p>这个题的关键点在于负数，也就是原数组按原顺序平方后得到的数组可能是先减后增的。</p>
<p>那么问题就变成怎么把负数那一部分按从小到大顺序插入到正数那一部分（我的理解），这和“合并两个数组”差不多。所以就是两个指针分别指向数组左右两端（负数绝对值的最大值和正数绝对值的最大值），每次拿出相对更大的一个放入到新数组中并移动该指针。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">0</span>, rightIndex = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resIndex</span> <span class="operator">=</span> rightIndex;</span><br><span class="line">        <span class="type">int</span>[] resultNums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; resIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> nums[leftIndex] * nums[leftIndex], right = nums[rightIndex] * nums[rightIndex];</span><br><span class="line">            <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                resultNums[resIndex--] = left;</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resultNums[resIndex--] = right;</span><br><span class="line">                rightIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="长度最小的子数组（Leetcode-209-）"><a href="#长度最小的子数组（Leetcode-209-）" class="headerlink" title="长度最小的子数组（Leetcode 209.）"></a>长度最小的子数组（Leetcode 209.）</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505300900649.png" alt="Leetcode 长度最小的子数组" style="zoom:67%;" />

<p>从一个序列中找到符合标准的一个连续子序列，很明显的滑动窗口问题。</p>
<p>依然是双指针，确定左右边界。</p>
<p>每次循环先移动右指针，窗口 sum 值加上右指针指向的新值，如果超过 target 先试一试移动左指针后是否仍然满足（sum-当前左指针值，尽可能让满足条件的序列更短一些），如果不满足就不移动左指针了，然后比较记录当前子序列长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="keyword">while</span> (sum - nums[left] &gt;= target) &#123;</span><br><span class="line">                    sum -= nums[left++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLength)</span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minLength == nums.length + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="螺旋矩阵II（Leetcode-59-）"><a href="#螺旋矩阵II（Leetcode-59-）" class="headerlink" title="螺旋矩阵II（Leetcode 59.）"></a>螺旋矩阵II（Leetcode 59.）</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505300904926.png" alt="Leetcode 螺旋矩阵 II" style="zoom:67%;" />

<p>这个其实没啥难度，主要就是自己遍历的时候边界判定条件要统一，别自己写乱了。</p>
<p>做这种题我一般习惯于设置成下面这种 direction 矩阵，这样比较方便一些（学嵌入式时候的习惯）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] resMatrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span>[] direction = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentDirection</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">currentX</span> <span class="operator">=</span> <span class="number">0</span>, currentY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n * n; i++) &#123;</span><br><span class="line">            resMatrix[currentX][currentY] = i;</span><br><span class="line">            <span class="keyword">if</span> (currentX + direction[currentDirection] &lt; <span class="number">0</span> ||</span><br><span class="line">                    currentX + direction[currentDirection] &gt;= n ||</span><br><span class="line">                    currentY + direction[currentDirection + <span class="number">1</span>] &lt; <span class="number">0</span> ||</span><br><span class="line">                    currentY + direction[currentDirection + <span class="number">1</span>] &gt;=n ||</span><br><span class="line">                    resMatrix[currentX + direction[currentDirection]][currentY</span><br><span class="line">                            + direction[currentDirection + <span class="number">1</span>]] != <span class="number">0</span>) &#123;</span><br><span class="line">                currentDirection = (currentDirection + <span class="number">2</span>) % <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            currentX = currentX + direction[currentDirection];</span><br><span class="line">            currentY = currentY + direction[currentDirection + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resMatrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间和（代码随想录-58-）"><a href="#区间和（代码随想录-58-）" class="headerlink" title="区间和（代码随想录 58.）"></a>区间和（代码随想录 58.）</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505300908469.png" alt="代码随想录 区间和" style="zoom:67%;" />

<p>主要练习一下 ACM 算法模式，整个程序都要自己写。</p>
<p>代码上，像这种需要区间求和的题目，如果每次都遍历求和就容易超时。取而代之的方法是搞一个 sum 数组，每个位置记录“从0位置到当前位置的所有元素和”（前缀和）。这个数组初始化的时候计算很方便，<code>sum[i-1]+nums[i]</code> 就可以了。求区间和的话就作差就行，<code>sum[j]-sum[i-1]</code>，注意 i&#x3D;0 的时候单独处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] vector = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            vector[i]=sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)vector[i]+=vector[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNextInt())&#123;</span><br><span class="line">            <span class="type">int</span> left=sc.nextInt();</span><br><span class="line">            <span class="type">int</span> right=sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(left ==<span class="number">0</span>)System.out.println(vector[right]);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(vector[right]-vector[left-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="开发商购买土地（代码随想录-44"><a href="#开发商购买土地（代码随想录-44" class="headerlink" title="开发商购买土地（代码随想录 44.)"></a>开发商购买土地（代码随想录 44.)</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505301226634.png" alt="代码随想录 开发商购买土地"></p>
<p>这个是二维上的区间和，所以要点也是在于创造一个 sum 数组每个点存储当前位置的值+之前位置值之和（前缀和），通过 sum 数组值相减快速获取区间值，只不过变成两个维度了。</p>
<p>如果暴力求解的话，时间复杂度是 O(n^3)，每次选取一个维度进行遍历求该行或者列的求和值，再遍历组合所有分割可能的求和值的组合方式找到差值最小的情况。简化后变成 O(n^2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(), m = sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] column = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minDiff</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                matrix[i][j] = sc.nextInt();</span><br><span class="line">                row[i] += matrix[i][j];</span><br><span class="line">                column[j] += matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            row[i] += row[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minDiff == -<span class="number">1</span> || minDiff &gt; Math.abs(row[n - <span class="number">1</span>] - <span class="number">2</span> * row[i]))</span><br><span class="line">                minDiff = Math.abs(row[n - <span class="number">1</span>] - <span class="number">2</span> * row[i]);</span><br><span class="line">            <span class="keyword">if</span> (minDiff == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            column[i] += column[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minDiff == -<span class="number">1</span> || minDiff &gt; Math.abs(column[m - <span class="number">1</span>] - <span class="number">2</span> * column[i]))</span><br><span class="line">                minDiff = Math.abs(column[m - <span class="number">1</span>] - <span class="number">2</span> * column[i]);</span><br><span class="line">            <span class="keyword">if</span> (minDiff == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(minDiff);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组可以说是必考的基础类型题目。主要考察算法就是二分法，双指针法，滑动窗口，前缀和。</p>
<p>数组在内存中是连续的存储空间，二维数组是多条连续的存储空间（两行之间地址不一定连续）。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Data-Structure/" rel="tag">Data Structure</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：黑马程序员 Redis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/05/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Redis/"
    >技术学习：黑马程序员 Redis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Redis/" class="article-date">
  <time datetime="2025-05-20T23:00:00.000Z" itemprop="datePublished">2025-05-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习自：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t/?p=2&share_source=copy_web&vd_source=dcdc734e318da0cd82bcccb180b12b40">【黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目】 </a></p>
<h2 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs. NoSQL"></a>SQL vs. NoSQL</h2><ul>
<li>S：结构化，比如在 MySQL 我们需要定义一个表，第一个属性是 id 第二个是 name 第三个是 age…… 定义好表之后所有新插入的数据都必须遵循这个结构，各个表还可能有外键等关联，所以总的来说不能随意修改表的属性。而 NoSQL 结构要求没那么严格，比如下面这种 Redis 定义方式也可以，就是没啥章法：</li>
</ul>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505211052874.png" alt="image-20250521105232832" style="zoom:67%;" />

<p>​	除了键值类型，还有文档类型，列类型，图类型等 NoSQL。</p>
<ul>
<li><p>R：关联的，SQL 数据库的各个属性之间有关联而 NoSQL 未必。</p>
</li>
<li><p>SQL 语句查询：关系型数据库都支持，而非关系型不支持。</p>
</li>
<li><p>ACID 事务：NoSQL 不支持。</p>
</li>
<li><p>存储位置：SQL 在硬盘，NoSQL 在内存。</p>
</li>
<li><p>SQL 对安全一致性要求较高，NoSQL 对性能要求较高。</p>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis Remote Dictionary Server 是一种基于内存的<strong>键值对</strong>数据库，被创造的原因就是 MySQL 性能太差。里面没有表什么的结构，就是存储一对一对的键值，所以是 NoSQL 数据库。值可以是复杂的数据形式，比如键是 1001，值是 {name: “xxx”, age:”19”}…… 这样的 json 格式。</p>
<p>Redis 是<strong>单线程</strong>的，但是效率仍然比 MySQL 高很多，因为内存存取速度远大于硬盘，C 语言编写，IO 多路复用等特点。</p>
<p>支持<strong>数据持久化</strong>，定期将数据从内存持久化到磁盘存储。</p>
<p>支持主从集群，分片集群。</p>
<p>支持多语言客户端。</p>
<h1 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h1><p>安装部分就跳过不做过多赘述了。</p>
<p>Redis 默认启动方式是前台启动，会阻塞整个会话窗口。可以通过修改配置文件的方式改为后台启动。或者在 system 文件夹内新建一个系统服务 .service 文件，实现开机自启动。</p>
<p>配置完成后，终端客户端连接：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">start</span> redis # 启动 redis 后台服务</span><br><span class="line">$ redis-cli -h <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> [-p port] [-a password] # 客户端终端方式连接 redis-cli</span><br><span class="line">&gt; AUTH password # 输入用户名和密码进行登录，也可以在上面 -a 那一步登录 不过这样不安全</span><br><span class="line">&gt; <span class="built_in">ping</span> # 如果成功登录了就会收到：PONG 否则会受到权限不够的提示</span><br><span class="line"></span><br><span class="line">&gt; SELECT <span class="number">1</span> # 选择一个库，<span class="number">0</span>-<span class="number">15</span></span><br><span class="line">&gt; get key # 获取某个键对应的值</span><br><span class="line">&gt; <span class="built_in">set</span> key value # 添加一个键值对</span><br></pre></td></tr></table></figure>

<p>图形化客户端连接：其实不是官方开发的是 Github 上有人发布的开源图形化客户端。</p>
<h2 id="Redis-通用命令"><a href="#Redis-通用命令" class="headerlink" title="Redis 通用命令"></a>Redis 通用命令</h2><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p><code>Keys pattern</code> 查询符合某种模式的键，比如 <code>keys a*</code> 是查询 a 打头的所有键值。</p>
<p>这个查询并不高效，而且会阻塞其他请求，所以在生产环境中尽量不要使用，特别是不要在主节点上使用。</p>
<h3 id="Del"><a href="#Del" class="headerlink" title="Del"></a>Del</h3><p><code>Del key1 key2 ...</code> 删除键值对。返回值是成功删除的键数量。</p>
<h3 id="MSet"><a href="#MSet" class="headerlink" title="MSet"></a>MSet</h3><p><code>msel k1 v1 k2 v2 ...</code> 批量添加键值对。</p>
<h3 id="Exists"><a href="#Exists" class="headerlink" title="Exists"></a>Exists</h3><p><code>exists key</code> 查询指定键是否存在。</p>
<h3 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h3><p>给键值对设定一个有效期，到期自动删除。</p>
<p><code>expire key seconds</code></p>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p><code>ttl key</code> 查询这个键还有多久过期。-1表示永久有效，-2表示已过期。</p>
<h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><p>key 一般是 string 类型，而 value 类型多种多样。</p>
<ul>
<li>String：字符串。</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>sortedset</li>
</ul>
<p>以上为基本数据类型。</p>
<ul>
<li>geo</li>
<li>bitmap</li>
<li>hyperlog</li>
</ul>
<p>以上为特殊数据类型。</p>
<p>在 redis 里面输入 <code>help @想要查询的 command 名称</code> 就可以进行查询。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>最简单的存储方式，字符串类型。具体可以分为三类：String，int，float。</p>
<p>是的 int 和 float 在 redis 里被视作属于 string。</p>
<p>这些底层存储方式都是字节数组，只不过数字会被直接转化为对应的二进制，这样能存储的范围更大。</p>
<table>
<thead>
<tr>
<th>字符串常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set key value</code></td>
<td>添加键值对，如果存在则覆盖</td>
</tr>
<tr>
<td><code>Get key</code></td>
<td>获取这个键的值</td>
</tr>
<tr>
<td><code>MSet k1 v1 k2 v2</code></td>
<td>批量添加</td>
</tr>
<tr>
<td><code>MGet k1 k2 k3</code></td>
<td>批量获取</td>
</tr>
<tr>
<td><code>INCR key</code></td>
<td>让一个整形 Key 对应的值自增1</td>
</tr>
<tr>
<td><code>INCRBY key step</code></td>
<td>指定步长的自增，如步长是2。可以指定为负数来取代 DECR 的功能。</td>
</tr>
<tr>
<td><code>INCRBYFLOAT key step</code></td>
<td>浮点数据的指定长度的自增</td>
</tr>
<tr>
<td><code>SETNX k v</code></td>
<td>添加一个 String 类型的键值对，如果存在则不执行返回0. 其实 <code>set key value nx</code> 也能实现同样的效果</td>
</tr>
<tr>
<td><code>SETEX k v seconds</code></td>
<td>添加一个 String 类型的键值对并指定有效期。<code>set key value ex</code> 也能实现同样的效果</td>
</tr>
</tbody></table>
<h4 id="Key-的层级格式"><a href="#Key-的层级格式" class="headerlink" title="Key 的层级格式"></a>Key 的层级格式</h4><p>Redis 没有 MySQL 的 Table，如何区分不同的 key 意义呢，比如一个商品 id 是1，一个顾客 id 也是1.</p>
<p>Redis 允许键值进行拼接，如：<code>项目名:业务名:类型:id</code> 这样。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:user:<span class="number">1</span> &#x27;&#123;&quot;id&quot;:<span class="number">1</span>, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;: <span class="number">21</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:user:<span class="number">2</span> &#x27;&#123;&quot;id&quot;:<span class="number">2</span>, &quot;name&quot;:&quot;Rose&quot;, &quot;age&quot;: <span class="number">18</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:product:<span class="number">1</span> &#x27;&#123;&quot;id&quot;:<span class="number">1</span>, &quot;name&quot;:&quot;小米<span class="number">11</span>&quot;, &quot;price&quot;: <span class="number">4999</span>&#125;&#x27;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:product:<span class="number">2</span> &#x27;&#123;&quot;id&quot;:<span class="number">2</span>, &quot;name&quot;:&quot;荣耀<span class="number">6</span>&quot;, &quot;price&quot;: <span class="number">2999</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看图形化客户端可以发现：Key 已经形成层级结构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212230806.png" alt="image-20250521223051719"></p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>无序字典，类似 java HashMap.</p>
<p>之前我们学过，String 处理对象的方式是变成 json 字符串，但是这样缺点是修改比较难操作。而 Hash 数据结构是可以真正将所有字段都分开存储方便操作。</p>
<table>
<thead>
<tr>
<th>Hash 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>HSET key field value</code></td>
<td>添加或者修改 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HGET key field</code></td>
<td>获取一个 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HMSET key f1 v1 ...</code></td>
<td>批量添加多个 hash 类型 key 的 field 的值（Redis 4.0+ 推荐用 HSET）</td>
</tr>
<tr>
<td><code>HMGET key f1 f2 ...</code></td>
<td>批量获取多个 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HGETALL key</code></td>
<td>获取一个 hash 类型的 key 中的所有的 field 和 value</td>
</tr>
<tr>
<td><code>HKEYS key</code></td>
<td>获取一个 hash 类型的 key 中的所有 field</td>
</tr>
<tr>
<td><code>HVALS key</code></td>
<td>获取一个 hash 类型的 key 中的所有 value</td>
</tr>
<tr>
<td><code>HINCRBY key field step</code></td>
<td>让一个 hash 类型 key 的字段值自增，并指定步长</td>
</tr>
<tr>
<td><code>HSETNX key field value</code></td>
<td>添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</td>
</tr>
</tbody></table>
<p>添加完字段之后，图形化界面中可视化结构：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212241594.png" alt="image-20250521224155538"></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>大致可以看做 java 的双向链表结构。有序，插入删除速度快，查询速度一般。</p>
<p>常常用于存储有顺序的数据，比如排队，朋友圈点赞列表等。</p>
<table>
<thead>
<tr>
<th>List 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>LPUSH key element ...</code></td>
<td>向列表左侧插入一个或多个元素</td>
</tr>
<tr>
<td><code>LPOP key</code></td>
<td>移除并返回列表左侧的第一个元素，没有则返回 nil</td>
</tr>
<tr>
<td><code>RPUSH key element ...</code></td>
<td>向列表右侧插入一个或多个元素</td>
</tr>
<tr>
<td><code>RPOP key</code></td>
<td>移除并返回列表右侧的第一个元素</td>
</tr>
<tr>
<td><code>LRANGE key start end</code></td>
<td>返回一段脚标范围内的所有元素（脚标从左0开始向右逐渐增加）</td>
</tr>
<tr>
<td><code>BLPOP key [key ...] timeout</code></td>
<td>与 LPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil</td>
</tr>
<tr>
<td><code>BRPOP key [key ...] timeout</code></td>
<td>与 RPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil</td>
</tr>
</tbody></table>
<p>用 List 模拟栈：只用 LPUSH 和 LPOP 或者 RPUSH RPOP 同向。</p>
<p>用 List 模拟队列：LPUSH+RPOP 或 RPUSH+LPOP 不同向。</p>
<p>用 List 模拟阻塞队列：首先需要入口和出口在不同边；其次出队使用 BLPOP 或者 BRPOP。</p>
<p><em>阻塞队列：当队列为空的时候，取元素的线程会等待一段时间直到队列非空。应用：线程池，待处理的任务先到等待队列，等待有空闲的线程时再开始被执行。这样不用一直创建新的线程，只利用现有的最大线程数，节约资源和响应速度。</em></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>类似 Java 中的 HashSet，无序，不重复，查找快，支持并集差集交集等运算。</p>
<table>
<thead>
<tr>
<th>Set 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD key member ...</code></td>
<td>向 set 中添加一个或多个元素</td>
</tr>
<tr>
<td><code>SREM key member ...</code></td>
<td>移除 set 中的指定元素</td>
</tr>
<tr>
<td><code>SCARD key</code></td>
<td>返回 set 中元素的个数</td>
</tr>
<tr>
<td><code>SISMEMBER key member</code></td>
<td>判断一个元素是否存在于 set 中</td>
</tr>
<tr>
<td><code>SMEMBERS key</code></td>
<td>获取 set 中的所有元素</td>
</tr>
<tr>
<td><code>SINTER key1 key2 ...</code></td>
<td>求 key1 与 key2 的交集</td>
</tr>
<tr>
<td><code>SDIFF key1 key2 ...</code></td>
<td>求 key1 与 key2 的差集</td>
</tr>
<tr>
<td><code>SUNION key1 key2 ...</code></td>
<td>求 key1 和 key2 的并集</td>
</tr>
</tbody></table>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>有点类似 java 的 treeset 但是底层逻辑差得很远。</p>
<p><em>java 的 treeset：一种有序集合，底层逻辑是红黑树。红黑树类似 AVL 树，这两种树在排序的同时也会保证树的左右子节点深度，数量差别不大以免树结构的复杂度变得和线性结构差不多，AVL 是规定左右子节点深度差不能超过1，而红黑树要求松一些，规定从根到叶子的最长路径不可能达到最短路径的2倍长，所以旋转操作相对 AVL 少一些，AVL 更适用于查找操作远多于插入删除操作数量的情况。</em></p>
<p>SortedSet 每个元素都带有一个 score 属性可以排序，通过跳表+hash表排序。</p>
<p><em>跳表结构大概如下，来加速单链表的查找效率。可以再多建几级索引。图源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Appleeatingboy/article/details/119948340">跳表的原理与实现 [图解]_跳表实现-CSDN博客</a></em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212313909.png" alt="img"></p>
<p>SortedSet 由于其排序效率高，常常被用于实现如排行榜这样的功能。</p>
<table>
<thead>
<tr>
<th>Sorted Set 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member</code></td>
<td>添加一个或多个元素到 sorted set，如果已经存在则更新其 score 值</td>
</tr>
<tr>
<td><code>ZREM key member</code></td>
<td>删除 sorted set 中的一个指定元素</td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>获取 sorted set 中指定元素的 score 值</td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>获取 sorted set 中指定元素的排名（从 0 开始）</td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取 sorted set 中的元素个数</td>
</tr>
<tr>
<td><code>ZCOUNT key min max</code></td>
<td>统计 score 值在指定范围内的元素个数</td>
</tr>
<tr>
<td><code>ZINCRBY key increment member</code></td>
<td>让 sorted set 中指定元素自增，步长为指定的 increment 值</td>
</tr>
<tr>
<td><code>ZRANGE key start stop</code></td>
<td>按 score 排序，获取指定排名范围内的元素 <em>如前十名</em></td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max</code></td>
<td>按 score 排序，获取指定 score 范围内的元素 <em>如60分~70分</em></td>
</tr>
<tr>
<td><code>ZDIFF / ZINTER / ZUNION</code></td>
<td>分别用于求差集、交集、并集</td>
</tr>
</tbody></table>
<p>以上都是升序，降序就在 Z 后面加 REV。</p>
<h2 id="Redis-的-Java-客户端"><a href="#Redis-的-Java-客户端" class="headerlink" title="Redis 的 Java 客户端"></a>Redis 的 Java 客户端</h2><p>主要有一下三种：</p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>简介</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Jedis</td>
<td>以 Redis 命令作为方法名称，学习成本低，简单实用。</td>
<td>实例非线程安全，多线程环境下需基于连接池使用。</td>
</tr>
<tr>
<td>Lettuce</td>
<td>基于 Netty 实现，支持同步、异步和响应式编程方式，线程安全。</td>
<td>支持 Redis 的哨兵模式、集群模式和管道模式。</td>
</tr>
<tr>
<td>Redisson</td>
<td>基于 Redis 实现的分布式、可伸缩 Java 数据结构集合。</td>
<td>提供如 <code>Map</code>、<code>Queue</code>、<code>Lock</code>、<code>Semaphore</code>、<code>AtomicLong</code> 等强大功能，适合分布式场景。</td>
</tr>
</tbody></table>
<p>spring data redis 整合了前两种。</p>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>使用方式很简单：引入依赖，建立连接，使用，释放资源。</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在 pom.xml 文件中粘贴：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505221740557.png" alt="image-20250522173946616"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一部分依赖是必须引入的，第二部分是测试用的。</p>
<p>执行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">SetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.73.129&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;369789&quot;</span>);</span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 插入hash数据</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line">        Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>Jedis 线程不安全，而且频繁创建销毁 Jedis 线程性能损耗比较大。</p>
<p><em>线程不安全的大概原因：每次 set 的时候都要调用 connect 方法。在 connect 方法里，一个实例的多个线程都共用一个 socket, inputstream, outputstream。所以如果线程1正在读写，线程2把 socket重新初始化了，那么1的连接就断了。或者两个线程同时读写，inputstream outputstream 共用可能就会导致输入或读取数据错误。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1678172">使用jedis面临的非线程安全问题-腾讯云开发者社区-腾讯云</a></em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505222302284.png" alt="img"></p>
<blockquote>
<p>图源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84481313">java客户端：Jedis和Jedis连接池的基本使用和配置 - 知乎</a></p>
</blockquote>
<p>创建连接池代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);<span class="comment">// 最大连接数</span></span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);<span class="comment">// 最大空闲连接数</span></span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);<span class="comment">// 最小空闲连接数，防止空闲连接被释放</span></span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.150.101&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建 Jedis 的时候改成使用连接池的获取代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis = JedisConnectionFactory.getJedis();</span><br></pre></td></tr></table></figure>

<p><code>jedis.close()</code> 函数底层如果判断有连接池的时候，就不会 close 关闭 Jedis 资源了，而是归还资源，所以不需要改。</p>
<h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h3><p>SpringData 是 Spring 的数据操作模块，其中的 Redis 集成模块叫做 SpringDataRedis。整合了多个 Redis 客户端，并提供了统一的访问 API。</p>
<p>支持 JDK json 字符串 对象等的序列化和反序列化，因为现在我们直接操作 Jedis 传入的都是 byte[] 数组，如果想传入 json 或者对象需要自己手动调整序列化。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>redisTemplate.opsForValue()</code></td>
<td><code>ValueOperations</code></td>
<td>操作 <code>String</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForHash()</code></td>
<td><code>HashOperations</code></td>
<td>操作 <code>Hash</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForList()</code></td>
<td><code>ListOperations</code></td>
<td>操作 <code>List</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForSet()</code></td>
<td><code>SetOperations</code></td>
<td>操作 <code>Set</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForZSet()</code></td>
<td><code>ZSetOperations</code></td>
<td>操作 <code>SortedSet</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate</code></td>
<td>-</td>
<td>通用的命令接口</td>
</tr>
</tbody></table>
<p>使用起来也非常简单。首先在 IDEA 里面创建项目的时候就可以创建 spring initilize 的项目，然后导入相关依赖（redis，连接池等），配置连接，直接使用。</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yaml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SpringDataRedis 默认引入了 Lettuce 的依赖，如果想在上面的配置文件中使用 jedis 也可以只不过就是需要在 pom.xml 里面也引入 jedis 的依赖。</p>
<p>代码测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;springtest&quot;</span>,<span class="string">&quot;springtest&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;springtest&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;value &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Redis 数据库中可见真正存入的数据形式其实是：\xAC\xED\x00\x05t\x00\x0Aspringtest，前面这一串可能就是 Spring Redis 的自动序列化用于记录对象格式的，反正 System.out.print 输出的是没有乱码的。</p>
<p><em>老师的案例里面，老师是写入的 name xxx 键值对，然后再去终端执行 redis 命令 <code>get name</code> 发现获取到的值并没有更新，也是一样的道理，因为老师实际存入的键也是类似 <code>\乱码 \乱码 name</code> 这样的形式，和 <code>get name</code> 访问的键不一样.</em></p>
<p>这种方式的主要两个问题：可读性差；内存占用大。Java 的 String 也会被视作是一种对象，而非单纯的 String。</p>
<h4 id="RedisTemplate-自定义和序列化"><a href="#RedisTemplate-自定义和序列化" class="headerlink" title="RedisTemplate 自定义和序列化"></a>RedisTemplate 自定义和序列化</h4><p>想要“写入什么值就存入什么值”，就必须去改写 RedisTemplate 的序列化方法（其实底层调用的是 <code>JDKSerializationRedisSerializer</code> 的序列化方法）。</p>
<p>对于字符串，或者键，可以将底层序列化方法改成：<code>StringRedisSerializer</code>，这个是专门处理字符串的序列化方法。</p>
<p>对于对象，可以用 <code>GenericJackson2JsonRedisSerializer</code> 转 JSON 字符串的序列化方法。</p>
<p>具体修改：新建一个 <code>RedisConfig</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123; <span class="comment">// 这里可见我们直接让 key 默认就是 String 类型了</span></span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具，用于对象处理</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是所有 key 都用字符串序列化方法，而所有的 value 都用 json 对象处理方法。</p>
<p>使用的时候，唯一区别就是声明要使用的 RedisTemplate 类是 &lt;String, Object&gt; 的，也就是我们刚刚生成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></pre></td></tr></table></figure>

<p>重新运行后发现数据库里面的键值都没有乱码了（值的话，可能 String Object 转换成 JSON 也是 String 的形式）。</p>
<p>尝试传入对象也非常顺利，假设新建了一个 User 对象，数据库中成功传入后的 json value 如下（第一句话就是帮助反序列化还原用的）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505231149205.png" alt="image-20250523114928080"></p>
<p>并且 java 输出里面自动反序列化成对象的输出形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value User(name=jingqing, age=22)</span><br></pre></td></tr></table></figure>

<p>但是可以看出，上面 class 那一行占用存储空间还是挺大的，比这个对象的其余部分内容都长。</p>
<p>不要这部分，就不能实现自动的反序列化了。要吧，又要占用内存空间。</p>
<h4 id="StringRedisTemplate-手动序列化"><a href="#StringRedisTemplate-手动序列化" class="headerlink" title="StringRedisTemplate 手动序列化"></a>StringRedisTemplate 手动序列化</h4><p>另一种实现方式是 <code>StringRedisTemplate</code> ，就是统一使用 String 序列化器。对于对象的存储，需要手动序列化或者反序列化。</p>
<p>实现起来也不是特别难，就是通过一个 <code>ObjectMapper</code> 将 String 映射成一个 json String 后传入数据库，传出的时候再通过映射类映射回来。也不需要自定义 RedisTemplate 的序列化方案了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 写入一条String数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;verify:phone:13600527634&quot;</span>, <span class="string">&quot;124143&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取string数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:200&quot;</span>, json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:200&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还可以进一步将序列化后写入和读出后反序列化封装成工具类，用工具类直接写入和读出，这样代码复杂度上也降低了。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-项目学习：黑马点评"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/05/21/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/"
    >项目学习：黑马点评</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/21/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/" class="article-date">
  <time datetime="2025-05-20T23:00:00.000Z" itemprop="datePublished">2025-05-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Project/">Project</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="黑马点评项目介绍"><a href="#黑马点评项目介绍" class="headerlink" title="黑马点评项目介绍"></a>黑马点评项目介绍</h1><p>类似大众点评。</p>
<p>要实现的功能：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232128675.png" alt="image-20250523124316562"></p>
<h1 id="项目导入"><a href="#项目导入" class="headerlink" title="项目导入"></a>项目导入</h1><p>基础代码，数据库等，不过多赘述。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232128575.png" alt="image-20250523124618786" style="zoom:50%;" />

<h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p>不是微服务是单体架构模式，因为重点还是在 Redis 学习上。Springboot 那个课涉及微服务实战，我后面应该也会学习一下。</p>
<p>架构图如下，前后端分离，开发完成后前后端分别部署在 Nginx 和 Tomcat 上。</p>
<pre class="mermaid">graph LR
    K1[客户端]
    K2[客户端]
    K3[客户端]
    K1-->N[前端<br>Nginx]
    K2-->N
    K3-->N
    N-->T[后端<br>Tomcat]
    subgraph Redis 集群
        R1[Redis]
        R2[Redis]
        R3[Redis]
        end
    T-->R1
    T-->R2
    T-->R3
    subgraph MySQL 集群
        M1[MySQL]
        M2[MySQL]
        M3[MySQL]
    end
    T-->M1
    T-->M2
    T-->M3</pre>

<p>后期这个项目可能还会做一些水平横向扩展，比如多 Tomcat 集群数据共享等，后面再扩展。</p>
<p>导入 nginx 前端，mysql 数据库及 java 后端服务器运行后就可以看到如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232128062.png" alt="image-20250523212804999"></p>
<h1 id="短信登录"><a href="#短信登录" class="headerlink" title="短信登录"></a>短信登录</h1><h2 id="Session-实现"><a href="#Session-实现" class="headerlink" title="Session 实现"></a>Session 实现</h2><p>首先用 Session 尝试实现一下。</p>
<pre class="mermaid">graph TD

%% 校验登录状态
subgraph 校验登录状态
    C1[开始] --> C2[请求并携带 cookie]
    C2 --> C3[从 session 获取用户]
    C3 --> C4{判断用户是否存在}
    C4 -- 有 --> C5[保存用户到 ThreadLocal]
    C5 --> C6[放行]
    C6 --> C7[结束]
    C4 -- 没有 --> C8[拦截]
    C8 --> C7
end

%% 短信验证码登录/注册
subgraph 短信验证码登录/注册
    B1[开始] --> B2[提交手机号和验证码]
    B2 --> B3{校验验证码}
    B3 -- 不一致 --> B2
    B3 -- 一致 --> B4[根据手机号查询用户]
    B4 --> B5{用户是否存在}
    B5 -- 不存在 --> B6[创建新用户]
    B6 --> B7[保存用户到数据库]
    B7 --> B8[保存用户到 session]
    B5 -- 存在 --> B8
    B8 --> B9[结束]
end

%% 发送短信验证码
subgraph 发送短信验证码
    A1[开始] --> A2[提交手机号]
    A2 --> A3{校验手机号}
    A3 -- 不符合 --> A2
    A3 -- 符合 --> A4[生成验证码]
    A4 --> A5[保存验证码到 session]
    A5 --> A6[发送验证码]
    A6 --> A7[结束]
end</pre>

<p>其他地方都比较好理解。保存用户到 ThreadLocal 是因为每次访问用户信息都要访问 session。</p>
<h2 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h2><p>点击用户登录界面，输入手机号尝试发送短信，根据发送链接 <code>xxx/user/code?phone=xxx</code> 可以看出请求路径是 <code>/user/code</code>，请求参数是电话号码，无返回值。</p>
<p>在 <code>UserController</code> 类文件中可以看到这个待完成的函数 <code>public Result SendCode</code>，具体的发送短信请求还是交给 <code>userService</code> 去实现的，所以我们这里补全这个函数将任务交给 <code>userService</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/UserController.java</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> IUserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> IUserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送手机验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源代码中，有一个 <code>IUserService</code> 接口里面声明了所有需要实现的 <code>UserService</code> 方法（目前是空的），然后 <code>UserServiceImpl</code> 类继承自 <code>ServiceImpl</code> 类实现了 <code>IUserService</code>。所以通过 IDEA 快速补全，我们先在 <code>IUserService</code> 里面添加一个待实现的 <code>sendCode </code>方法，然后再在 <code>UserServiceImpl</code> 里面实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/IUserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/UserServiceImpl.java</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">// 用于 log.debug 传递多个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据流程图分析步骤</span></span><br><span class="line">        <span class="comment">// 1. 校验手机号</span></span><br><span class="line">        <span class="comment">// 2. 如果不符合，返回错误信息</span></span><br><span class="line">        <span class="comment">// 在老师提供的 utils 工具类里面有校验手机号的正则表达式</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3， 如果符合，生成验证码</span></span><br><span class="line">        <span class="comment">// 随机生成6位数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 保存验证码到 session</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;code&quot;</span>, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发送验证码</span></span><br><span class="line">        <span class="comment">// 这里就和具体的运营商服务平台等等有关了，其实不算什么重点，就随便写一下代替一下</span></span><br><span class="line">        log.debug(<span class="string">&quot;发送验证码成功，验证码：&#123;&#125;&quot;</span>, code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 返回 ok</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505232245964.png" alt="image-20250523224519872" style="zoom:67%;" />

<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>现在可以发送验证码了，用户收到验证码之后怎么校验登录呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/UserController.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;</span><br><span class="line">    <span class="comment">// TODO 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> userService.login(loginForm, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/IUserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span>;</span><br><span class="line"></span><br><span class="line">    Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/UserServiceImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 校验手机号。虽然之前发送验证码的时候已经校验过了，</span></span><br><span class="line">    <span class="comment">// 但是现在用户填写完成验证码又改了一个错误的手机号再提交也是有可能的。所以有必要二次验证</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line">    <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 校验验证码</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheCode</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;code&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !code.equals(cacheCode.toString()))&#123;</span><br><span class="line">        <span class="comment">// 3. 不一致，报错</span></span><br><span class="line">        <span class="comment">// 反向嵌套，避免越嵌套越深</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 一致，根据手机号查询用户 select * from user where phone = xxx</span></span><br><span class="line">    <span class="comment">// 这个类继承自 ServiceImpl，由 mybatisplus 提供，可以实现方便的单表增删改查。</span></span><br><span class="line">    <span class="comment">// 我们已经在 User 里面注解了对应的 MySQL 表是 tb_user，传给 ServiceImpl 就可以实现方便的 MySQL 操作</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 判断用户是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 6. 不存在，创建新用户，保存用户到数据库</span></span><br><span class="line">        <span class="comment">// 其实创建用户大多数字段都不需要知道，先手机号，然后随机生成一个昵称就行了</span></span><br><span class="line">        user = createUserwithPhone(phone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 保存用户到 session</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="comment">// return 就不需要给用户 token 了，因为 session id 已经自动存在 cookie 里面了，用户带着 cookie 就能校验</span></span><br><span class="line">    <span class="keyword">return</span>  Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">createUserwithPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setPhone(phone);</span><br><span class="line">    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mybatis 修改数据库命令：</span></span><br><span class="line">    save(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以实现登录校验功能了，不过我们会发现用户登录信息没有被成功保存，登陆之后再点击用户，还是需要输入手机号发验证码登录验证。</p>
<h2 id="登录校验拦截器"><a href="#登录校验拦截器" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h2><p><code>xxx/user/me</code> 是登录校验的请求，查询是否已经登录。</p>
<p>按理来说我们应该在每个 Controller 里面补全代码，根据获取到的 cookie 里携带的 session id 去找到对应的 session，进而获取到对应的用户数据。但是有很多 Controller 可能都需要这样获取用户信息，所以这种写法就不太好。</p>
<p>我们可以用拦截器处理：</p>
<pre class="mermaid">graph LR
    A[拦截器<br>（统一入口）] --> B[OrderController]
    A --> C[UserController]
    A --> D[XxxController]</pre>

<p>然后拦截器校验完，按我们之前说的，把用户信息缓存到 ThreadLocal 里面供这些控制类取用。</p>
<p>拦截器可以写在 utils 里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/LoginInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// preHandle 实现：到达 Controller 之前执行，进行登录校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取 session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 session 中的用户信息</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4. 不存在，拦截。最好加一些标识.401 状态码表示未授权</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 存在，保存用户信息到 ThreadLocal。老师已经写好了：</span></span><br><span class="line">        UserHolder.saveUser((User) user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 放行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 实现：Controller 执行完成之后执行，销毁用户数据避免内存泄露</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拦截器做好了，接下来需要配置一个 MVC 使其生效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/MvcConfig.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 添加拦截器，并且除外一些不需要拦截的路径</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">// 其实有挺多用不到用户信息的，随便写一些做个示范。</span></span><br><span class="line">                        <span class="comment">// 比如店铺信息，热门博客，用户发送验证码，用户登录这些其实都用不到用户的信息</span></span><br><span class="line">                        <span class="string">&quot;shop/xx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;shop-type/xx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，再回到对应的控制类里面完善代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/UserController.java</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">me</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前登录的用户并返回</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行，现在登录完就可以看到用户信息了：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241406383.png" alt="image-20250524140619277" style="zoom:67%;" />

<p>但是目前这样实现有一个非常严重的问题：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241413447.png" alt="image-20250524141312310"></p>
<p>是的密码也会返回。</p>
<h2 id="隐藏用户敏感信息"><a href="#隐藏用户敏感信息" class="headerlink" title="隐藏用户敏感信息"></a>隐藏用户敏感信息</h2><p>我们再捋一下用户信息泄露的整个过程：</p>
<ol>
<li>用户信息在数据库里。</li>
<li>登录校验后，从数据库中取得用户信息，存到 session 也就是 Tomcat 的内存空间里面，方便后续使用。</li>
<li>校验登录状态：根据 cookie 传来的 session id，在 session 中找到对应存在的用户后，存到 ThreadLocal 里面方便后续使用。</li>
</ol>
<p>要不直接就不把密码什么的无用或者敏感信息存到 session 里面，也能节约内存空间，也安全？</p>
<p>这里老师直接定义了一个类：UserDTO，里面只有用户 id 昵称 头像三个属性。所以我们存数据到 session 里面之前需要将 User 转成 UserDTO 类型。这里也可以直接用工具类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/UserServiceImpl.java</span></span><br><span class="line"><span class="comment">// public Result login(LoginFormDTO loginForm, HttpSession session)</span></span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));</span><br></pre></td></tr></table></figure>

<p>相应的，取用户信息的时候也应该用 UserDTO 类型接着。包括 ThreadLocal 里面也应该改成存入 UserDTO 信息。</p>
<p>这部分我就不一一阐述了，记不太清都有哪些要改了，反正就顺着改类型就行，UserDTO 也有 getId() 等方法。</p>
<p>现在在开发者模式看获取到的 UserDTO 信息格式如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241445854.png" alt="image-20250524144557746"></p>
<h2 id="Session-共享问题"><a href="#Session-共享问题" class="headerlink" title="Session 共享问题"></a>Session 共享问题</h2><p>Session 是存在服务器自身的内存空间的，所以多台 Tomcat 不共享 Session。</p>
<p>所以可能上一秒用户请求被负载均衡到服务器1，成功登陆，下一秒被负载均衡到服务器2又要重新登陆，非常影响使用体验。</p>
<p>解决方法：其实也不难嘛，多服务器 session 拷贝就行吗？并不是，会有很多内存和时间上的损失，拷贝过程中如果用户发送请求可能也会出错。</p>
<p>那么就需要找到 session 的替代方案，这个替代品需要满足：</p>
<ol>
<li>数据共享，因为我们就想解决这个问题。</li>
<li>内存存储，因为要和 session 有差不多的性能。</li>
<li>键值对形式，因为这种实现方法比较简单。</li>
</ol>
<p>答案就是 Redis 了。</p>
<h2 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h2><p>我们先盘点一下 Redis 实现相较 Session 实现的，不一样的问题：</p>
<ol>
<li>键值对设计。比如验证码，session 里面是让键&#x3D;code 值&#x3D;对应验证码数字，redis 我们可以让 String 表示验证码数字字符串，但是 key 不可以&#x3D;”code”，因为 session 对于每个不同的客户端都不一样，所以不同客户端的 session 验证码属性都叫 code 也不冲突，但是 redis 是一个键唯一的数据库，所以不能不同客户端的 key 都叫 “code”。可以用手机号代替，手机号也是唯一标识：”phone:xxx” 这样。</li>
<li>之前将用户数据保存到 session，我们的实现非常简单，直接存到 session，浏览器自动就把 session id 写到 cookie 里面，下次发过来的时候我们用 session id 去查找对应的 session 非常方便，但是换成 redis 这些部分就没有自动实现了，需要我们再根据用户提交的手机号作为 key 去 redis 数据库里查询。这个过程其实也顺带校验了手机号是否存在，因为把手机号作为 key，直接去 redis 里面查询 value，如果找不到对应的键值对，也说明了手机号错误。</li>
<li>存储用户数据用什么数据类型？存储对象常见两种方式，一种是 String JSON 形式，另一种是 Hash 存储每个字段。推荐 Hash 方法，因为可以对每个字段进行 CRUD，并且内存占用更少。</li>
<li>存储用户数据，键用什么？也可以用手机号，不过更推荐用 token （生成一个随机字符串）。当然，相比 session （浏览器自动将 session id 存入 cookie）的实现，我们还需要加一步，手动将 token 传回给前端保存，这样用户下次校验登录状态时该客户端才能拿着一样的 token 来取数据。而且相较于手机号更安全，前端可见。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505241519713.png" alt="image-20250524151949549"></p>
<p>修改代码部分，首先我们要将 <code>UserServiceImpl.java</code> 里面的 session 实现转化为 Redis 实现，主要还是之前说的问题，Redis 里面的键值怎么存，怎么保存到浏览器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/UserServiceImpl.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 保存验证码到 redis  // set key value ex 120</span></span><br><span class="line">    <span class="comment">// stringRedisTemplate.opsForValue().set(&quot;login:code:&quot; + phone, code, 2, TimeUnit.MINUTES);</span></span><br><span class="line">    <span class="comment">// 不过这里我们在 RedisConstant 里定义一下常量，这样方便一些</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 校验验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> loginForm.getCode();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cacheCode == <span class="literal">null</span> || !code.equals(cacheCode))&#123;</span><br><span class="line">        <span class="comment">// 3. 不一致，报错</span></span><br><span class="line">        <span class="comment">// 反向嵌套，避免越嵌套越深</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 保存用户到 redis</span></span><br><span class="line">    <span class="comment">// 7.1 随机生成 token，作为登录令牌</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 7.2 将 User 对象转为 Hash 存储</span></span><br><span class="line">    <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span>  BeanUtil.copyProperties(loginForm, UserDTO.class);</span><br><span class="line">    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);</span><br><span class="line">    <span class="comment">// 7.3 存储</span></span><br><span class="line">    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY+token, userMap);</span><br><span class="line">    <span class="comment">// 7.4 设置有效期</span></span><br><span class="line">    stringRedisTemplate.expire(LOGIN_USER_KEY+token, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line">    <span class="comment">// return 返回 token</span></span><br><span class="line">    <span class="keyword">return</span>  Result.ok(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有一个额外的问题，就是 token 有效期这里我们设定的是登录过后30分钟过期，实际上一般 session 的默认配置是“30分钟无活动后过期”，比如我登陆之后访问一下“我的”用户界面，这就算有一次活动，重新计时30分钟后再过期，只不过之前这部分是 session 自动完成，我们需要手动修改。</p>
<p>也就是每次访问用户状态，都要重新更新 token 有效期，很明显这部分代码在拦截器中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/LoginInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preHandle 实现：到达 Controller 之前执行，进行登录校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 基于 token 获取 redis 中的用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY+token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(userMap.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 4. 不存在，拦截。最好加一些标识.401 状态码表示未授权</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将查询到的 Hash 数据转化为 UesrDTO 对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 存在，保存用户信息到 ThreadLocal。老师已经写好了：</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 刷新 token 有效期</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 放行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 实现未修改，仍然就是一个简单的 UserHolder remove</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下 Redis 实现需要注意的几个点，1 在于数据类型选择（key String, value Hash 因为可以单独对字段修改，占用内存空间小）；2  在于选择合适的 key 标识（<code>user:login:token:xxx</code>），自己可以方便找到；3 在于合适的存储粒度，<code>UserDTO</code> 并不是存储全部 User 信息的，节省内存空间的同时也更安全。</p>
<h2 id="状态登录刷新问题"><a href="#状态登录刷新问题" class="headerlink" title="状态登录刷新问题"></a>状态登录刷新问题</h2><p>不过目前还有一个问题。我们这个拦截器是只有“和用户信息有关的请求”才会工作，比如我访问商户信息，这个用户信息拦截器不工作，没问题吧。</p>
<p>但是我们的 token 刷新机制是写在拦截器里面的，也就是说：</p>
<ol>
<li>用户不断访问用户信息页面，则 token 不断刷新，一直登录，没问题。</li>
<li>用户一直没有访问用户信息界面，比如用户一直在看商家信息，则 token 一直没刷新直到过期退出登录了，这样其实也挺影响用户体验的，用户说我一直在用 app 怎么还给我退出登录了。</li>
</ol>
<p>解决方式：我们可以加两个拦截器。一级拦截器实际上不拦截任何东西，他只是会处理一些所有请求都会触发的工作，像 token 刷新这种所有请求都会触发的方法就放在一级拦截器中。还有查询 Redis 用户，不存在则创建，然后放到 ThreadLocal 缓存里这种操作也可以放到一级拦截器里面。二级拦截器才处理和用户信息有关的请求，在 ThreadLocal 里面查询对应用户，不存在则拦截。</p>
<pre class="mermaid">flowchart TB
    subgraph 拦截器A[拦截器：一切路径]
        A1[获取 token]
        A2[查询 Redis 的用户]
        A3[保存到 ThreadLocal]
        A4[刷新 token 有效期]
        A5[放行]
        A1 --> A2 --> A3 --> A4 --> A5
    end

    subgraph 拦截器B[拦截器：需要登录的路径]
        B1[查询 ThreadLocal 的用户]
        B2{用户是否存在？}
        B2 -- 不存在，拦截 --> B3[拦截]
        B2 -- 存在，继续 --> B4[放行]
        B1 --> B2
    end

    A5 --> B1

    %% 控制器调用链
    B4 --> C1[OrderController]
    B4 --> C2[UserController]
    B4 --> C3[XxxController]

    %% 样式设置（可选）
    style A1 fill:#fff,stroke:#d43f3a,color:#000
    style A2 fill:#fff,stroke:#d43f3a,color:#000
    style A3 fill:#fff,stroke:#d43f3a,color:#000
    style A4 fill:#fff,stroke:#d43f3a,color:#000
    style A5 fill:#fff,stroke:#d43f3a,color:#000
    style B1 fill:#fff,stroke:#d43f3a,color:#000
    style B2 fill:#fff,stroke:#d43f3a,color:#000
    style B3 fill:#fdd,stroke:#d43f3a,color:#000
    style B4 fill:#dfd,stroke:#5cb85c,color:#000</pre>



<p>新建一个拦截器 <code>RefreshTokenInterceptor</code>，把查询用户，缓存，Token 刷新，Controller 执行完成后删除缓存的功能全放进去（并且不需要拦截了，比如如果用户为空，直接放行，给 <code>LoginInterceptor</code> 让它判断是否拦截）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/RefreshTokenInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preHandle 实现：到达 Controller 之前执行，进行登录校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求头中的 token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 基于 token 获取 redis 中的用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY+token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 判断用户是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(userMap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将查询到的 Hash 数据转化为 UesrDTO 对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6. 存在，保存用户信息到 ThreadLocal。老师已经写好了：</span></span><br><span class="line">        UserHolder.saveUser(userDTO);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 刷新 token 有效期</span></span><br><span class="line">        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 实现：Controller 执行完成之后执行，销毁用户数据避免内存泄露</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>LoginInterceptor</code> 就简单多了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/LoginInterceptor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// preHandle 实现：到达 Controller 之前执行，进行登录校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求头中的 token</span></span><br><span class="line">        <span class="keyword">if</span>(UserHolder.getUser()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 4. 不存在，拦截。最好加一些标识.401 状态码表示未授权</span></span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 8. 放行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MVC Config：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/MvcConfig.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加拦截器，并且除外一些不需要拦截的路径</span></span><br><span class="line">    <span class="comment">// 这里我们期望 RefreshTokenInterceptor 是一级拦截器，LoginInterceptor 是二级拦截器</span></span><br><span class="line">    <span class="comment">// RefreshTokenInterceptor 优先级 &gt; LoginInterceptor</span></span><br><span class="line">    <span class="comment">// 如何实现？其实默认添加拦截器的时候，优先级都是0，默认按照添加顺序优先添加的优先级更大</span></span><br><span class="line">    <span class="comment">// 这里为了保险，老师还是单独给每个拦截器赋值优先级了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="comment">// 其实有挺多用不到用户信息的，随便写一些做个示范。</span></span><br><span class="line">                        <span class="comment">// 比如店铺信息，热门博客，用户发送验证码，用户登录这些其实都用不到用户的信息</span></span><br><span class="line">                        <span class="string">&quot;shop/xx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;shop-type/xx&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;blog/hot&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span></span><br><span class="line">                        ).order(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// token 刷新拦截器</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).addPathPatterns(<span class="string">&quot;/**&quot;</span>).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，即便是在商户页面刷新，也可以看到 Redis 里面 Token TTL 时长也是恢复到30分钟后才过期了。</p>
<h1 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h1><h2 id="缓存介绍"><a href="#缓存介绍" class="headerlink" title="缓存介绍"></a>缓存介绍</h2><p>缓存就是数据交换的临时缓冲区，数据读写效率较高。比如 CPU 中的缓存区域读写速度远大于内存，硬盘；前端概念上，浏览器也可以缓存一些图片等内容，大大降低加载时间，缓存未命中的内容才会去 Tomcat 找。</p>
<p>Tomcat 应用层上也可以添加一些缓存，比如典型的 Redis 数据库。没命中的数据才会去 MySQL 里面查询。</p>
<p>MySQL 里面也可以建立缓存，也就是索引。建立索引后查找速度大大提高。</p>
<p>然后最终数据查找还是落到 CPU 和磁盘，CPU 也有多级缓存，磁盘也有读写缓存……</p>
<p>缓存的好处非常明显，如降低后端负载，提高读写效率等。但随之而来的成本也会提高。如数据一致性成本，数据库数据更新了缓存中数据也要实时更新确保一致性；代码维护成本，缓存击穿等问题；运维成本，集群服务器维护，硬件等……</p>
<p>所以对于中小型企业可能缓存并不必要。</p>
<h2 id="商户查询流程分析"><a href="#商户查询流程分析" class="headerlink" title="商户查询流程分析"></a>商户查询流程分析</h2><h2 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h2><p>我们打开一个商户页面，可以看到：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505242253429.png" alt="image-20250524225340232"></p>
<p><code>shop/商户id</code> 就是对应的接口，里面 data 数据还是挺多的，我们需要给这个接口添加缓存。</p>
<p>那么我们去对应的 <code>ShopController.java</code> 文件里面查看对应代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">public</span> IShopService shopService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询商铺信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 商铺id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 商铺详情数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shopService.getById(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也是基于 mybatis 的 MySQL 查询。</p>
<p>我们的缓存逻辑就是：</p>
<p>缓存作用模型：</p>
<pre class="mermaid">flowchart LR

A1[客户端] --> A2[请求]
A2 --> A3[Redis]
A3 -->|命中| A4[返回数据]
A3 -->|未命中| A5[数据库]
A5 --> A6[写缓存]
A6 -.-> A3
A5 --> A4</pre>

<p>查询流程: 根据 ID 查询商铺缓存</p>
<pre class="mermaid">flowchart LR
B1[开始] --> B2[提交商铺 ID]
B2 --> B3[从 Redis 查询商铺缓存]
B3 --> B4{缓存是否命中？}
B4 -- 命中 --> B5[返回商铺信息]
B4 -- 未命中 --> B6[根据 ID 查询数据库]
B6 --> B7{商铺是否存在？}
B7 -- 不存在 --> B8[返回 404]
B7 -- 存在 --> B9[将商铺数据写入 Redis]
B9 --> B5
B5 --> B10[结束]
B8 --> B10</pre>

<p>实现起来也并不难：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/ShopController.java</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询商铺信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 商铺id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 商铺详情数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 还是给对应的服务类处理</span></span><br><span class="line">        <span class="keyword">return</span> shopService.queryById(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopMapper, Shop&gt; <span class="keyword">implements</span> <span class="title class_">IShopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShopServiceImpl</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 从 Redis 查询商铺缓存</span></span><br><span class="line">        <span class="comment">// 这里为什么改用 String，完全是老师为了每种方法都让我们看一遍，hash 还是优于 string 的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">            <span class="comment">// 3. 存在，直接返回</span></span><br><span class="line">            <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 不存在，查数据库判断是否存在</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 不存在，返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;商户不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 存在，添加到 Redis 商铺缓存中，并返回</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话加载速度优化没看出来（毕竟其实还有一个同时查询优惠券的操作，那个是一定会去 MySQL 里面查询的），反正 Redis 里是缓存了数据了，证明正确运行了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505242346276.png" alt="image-20250524234630919"></p>
<p>然后老师布置的作业是自己把首页的 shop-list 设置缓存机制，就是这10个图标：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505242359952.png" alt="image-20250524235946740" style="zoom:50%;" />

<p>因为这些是静态不变的所以特别适合被做成缓存。</p>
<p>没啥难点，非要说的话其实就是它们的数据类型是 Collection 集合类型，需要琢磨一下类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopTypeServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShopTypeServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;ShopTypeMapper, ShopType&gt; <span class="keyword">implements</span> <span class="title class_">IShopTypeService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShopTypeServiceImpl</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryTypeList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopTypeJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;cache:shop-type-list&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(shopTypeJson)) &#123;</span><br><span class="line">            List&lt;ShopType&gt; typeList = JSONUtil.toList(shopTypeJson, ShopType.class);</span><br><span class="line">            <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ShopType&gt; typeList = <span class="built_in">this</span>.query().orderByAsc(<span class="string">&quot;sort&quot;</span>).list();</span><br><span class="line">        <span class="keyword">if</span>(typeList == <span class="literal">null</span> || typeList.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;未查询到商店类型列表！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;cache:shop-type-list&quot;</span>, JSONUtil.toJsonStr(typeList));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(typeList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>数据库中数据更新，缓存数据也要及时更新不然查出来可能是错的。</p>
<p>缓存更新策略对比：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>内存淘汰</th>
<th>超时删除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody><tr>
<td>说明</td>
<td>不用自己维护，利用 Redis 的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td>
<td>给缓存数据添加 TTL 时间，到期后自动删除缓存。下次查询时更新缓存。</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存。</td>
</tr>
<tr>
<td>一致性</td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td>维护成本</td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p>推荐业务场景：</p>
<ul>
<li>低一致性需求：使用内存淘汰机制。例如：店铺列表类型的查询缓存，几乎不改。</li>
<li>高一致性需求：主动更新，并以超时删除作为兜底方案。例如：店铺详情查询的缓存，店家更新完希望用户那边实时更新。</li>
</ul>
<p>主动更新的几种实现方法：</p>
<h3 id="主动更新策略对比"><a href="#主动更新策略对比" class="headerlink" title="主动更新策略对比"></a>主动更新策略对比</h3><table>
<thead>
<tr>
<th>编号</th>
<th>策略名称</th>
<th>简要说明</th>
</tr>
</thead>
<tbody><tr>
<td>01</td>
<td>Cache Aside Pattern</td>
<td>由缓存的<strong>调用者</strong>在更新数据库的同时更新缓存。</td>
</tr>
<tr>
<td>02</td>
<td>Read&#x2F;Write Through Pattern</td>
<td>缓存与数据库整合为一个服务，由服务<strong>自动维护一致性</strong>，调用者无需关心缓存。</td>
</tr>
<tr>
<td>03</td>
<td>Write Behind Caching Pattern</td>
<td>调用者<strong>只操作缓存</strong>，由其他线程<strong>异步</strong>将数据持久化到数据库，保证最终一致。</td>
</tr>
</tbody></table>
<p>方法1就是我们自己写代码实现。</p>
<p>方法2找这种服务很难，实现也比较难，维护成本高，但是实现完了很方便。</p>
<p>方法3好处在于：比如多个数据修改，最后一次写入；包括一个数据修改多次，最终也只将最后的结果写入，效率比较高。但是一致性比较差（比如一个缓存修改了几次还没写入，这时候数据库中的数据就不是最新的，或者万一缓存宕机那更新就没了；而且这个异步任务要实时监控缓存中的变化也比较难）。</p>
<p>所以总而言之，方法1比较可控，企业里常用。</p>
<h3 id="更新缓存机制"><a href="#更新缓存机制" class="headerlink" title="更新缓存机制"></a>更新缓存机制</h3><p>选用第一种策略（即我们自己手动编写代码实现主动更新缓存）后还有一些需要确定的细节。</p>
<ol>
<li>数据库数据更新后，缓存中的数据是随之更新呢，还是删除，等待下次查找时添加进缓存呢？删除处理方式比较好，因为如果数据多次更新第一种方式无效写操作较多。</li>
<li>如何确保缓存和数据库同时更新？单体数据库用事务实现，分布式系统用 TCC 等分布式事务方案。</li>
<li>先操作数据库还是先删除缓存？两种方案都有安全问题。先删除缓存，还没更新数据库的时候这时候有其他线程来访问，访问到的就是旧的数据；先更新数据库，还没来得及删除缓存然后另一个线程来访问，访问到缓存里面旧的数据了。但是总体而言第二种方法发生可能性更低因为缓存操作速度远快于数据库操作。</li>
</ol>
<p>具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// controller/ShopController.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新商铺信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shop 商铺数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PutMapping</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShop</span><span class="params">(<span class="meta">@RequestBody</span> Shop shop)</span> &#123;</span><br><span class="line">    <span class="comment">// 写入数据库</span></span><br><span class="line">    <span class="keyword">return</span> shopService.update(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺 id 不能为空！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    updateById(shop);</span><br><span class="line">    <span class="comment">// 2. 删除缓存</span></span><br><span class="line">    stringRedisTemplate.delete(CACHE_SHOP_KEY+ id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后因为客户端其实没写商店端，所以这里我们用 Postman 来实现发送请求。首先在 Header 里面加一个 Authorization 请求头（具体值是我们的 token 值），然后发送 put 数据：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251146316.png" alt="image-20250525114613159"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251146129.png" alt="image-20250525114625026"></p>
<p>发送完之后区 RESP 里面看数据发现缓存消失了，然后刷新页面缓存被更新成最新的内容了。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>比如用户一直在查询一个不存在的商户信息，这个查询每次都会穿透缓存去数据库里面查询，但是每次因为数据库里面不存在这个数据所以每次都不会缓存到 Redis 里面。</p>
<ul>
<li>解决方法1：缓存一个空对象。缺点在于占用内存空间，并且可能会造成短期不一致（刚查询完缓存得知商户不存在的瞬间，刚好插入了商户数据，不过问题应该不是特别大）。</li>
<li>解决方法2：在 Redis 之前建立一个布隆过滤器，利用哈希算法只简单判断哪些数据存在（因为并不存储实际商户数据，只是用01记录这个商户是否存在并用一定的哈希算法映射，所以占用存储不大）。但是哈希可能有冲突，所以布隆过滤器说不存在的一定不存在，但是布隆过滤器说存在的可能不存在。优点在于相比缓存大量空数据，内存占用较小，没有多余的 key；缺点在于实现相对复杂，而且存在误判可能。</li>
</ul>
<pre class="mermaid">flowchart TD

A[客户端] --> B[布隆过滤器]

B -->|不存在，拒绝| C[拒绝] --> Z1[返回客户端]
B -->|存在，放行| D[Redis]

D -->|缓存命中| E1[返回数据] --> Z1
D -->|缓存未命中| F[数据库查询]

F --> G[返回数据] --> H[写入缓存] --> D

G --> Z1</pre>

<p>黑马点评这个项目里，我们尝试使用缓存空对象方法（实际企业应用可能使用大部分布隆过滤器+小部分的缓存空对象的结合方法）。</p>
<p>在原有缓存逻辑上，修改两点：</p>
<ol>
<li>数据库没查到的话不是直接返回 404 了，而是需要先将空对象存到 Redis 里面。</li>
<li>Redis 缓存命中之后，我们还要进一步判断是不是空对象。如果不是返回数据，如果是返回404.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断是否存在</span></span><br><span class="line">    <span class="comment">// isNotBlank 指的是判断不为 Null，不为空值。</span></span><br><span class="line">    <span class="comment">// Null 表示我们的缓存里没有这个数据，未命中，需要进一步去数据库里查找之后再缓存。</span></span><br><span class="line">    <span class="comment">// 空值表示缓存里面有这个数据，并且记录了这是一个不存在的商户。</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">// 3. 存在，直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 缓存里有记录这是一个不存在商户</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 缓存未命中，查数据库判断是否存在</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 商户在数据库中不存在，将空值写入 Redis 再返回错误</span></span><br><span class="line">    <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES); <span class="comment">// 空值2分钟，短一些</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;商户不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 存在，添加到 Redis 商铺缓存中，并返回</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们发送请求查询 1000 号商户的信息：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251327257.png" alt="image-20250525132748119"></p>
<p>缓存里面也存入了这个空值：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251328757.png" alt="image-20250525132810630"></p>
<p>除了这两种方法，也可以增加 id 的复杂度，避免被别人猜到 id 规律，错误的 id 请求就直接不查。现在我们的商户信息就是简单的 <code>shop/xx</code> 数字形式。</p>
<p>还可以加一些校验，比如 <code>shop/0</code> 这种肯定不存在，或者可以设定 id&gt;10000 这样的直接不查，软件逻辑上拦截一下。</p>
<p>以及用户权限管理，不能让任何用户都能访问到一些特殊业务。</p>
<p>以及热点参数的限流（见老师的 springCloud 微服务课）。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>在同一时间段内大量缓存 key 同时失效或者 Redis 宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p><em>正常是大部分缓存命中，少部分请求到达数据库。</em></p>
<p>解决方案：</p>
<ol>
<li>TTL 添加随机值。比如30~35分钟，波动大小可以调整。</li>
<li>利用 Redis 集群提高服务的可用性。主从 Redis 实现，不仅可以实现数据备份，也可以在主 Redis 宕机的时候从 Redis 顶上，在 Redis 高级部分知识会涉及。</li>
<li>给缓存业务添加降级限流策略。比如 Redis 整个服务器挂了，不要把所有查询压力都放到数据库，可以适当的服务降级让一些请求失败。<em>详见老师的 springCloud 微服务课，笑死啦</em></li>
<li>多级缓存。Nginx 缓存，JVM 缓存，数据库缓存……<em>详见 springCloud 课程。</em></li>
</ol>
<p>这部分就不实现了，234都比较进阶，1太简单了一个随机数就完事了。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存雪崩是大量缓存失效，而缓存击穿是少部分高并发以及缓存重建业务较复杂（比如多表查询联合运算得到，可能需要上百毫秒）的关键 key 失效，也会给数据库带来较大的冲击。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251338321.png" alt="image-20250525133819142"></p>
<p>解决方法1：互斥锁，排队。缺点在于等待时间比较长，比如1k个线程同时访问。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251339186.png" alt="image-20250525133921070"></p>
<p>解决方法2：逻辑过期，首先我们并没有给缓存键值对直接设置 expire 过期时间，而是在键值里面标注了过期时间：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251343701.png" alt="image-20250525134337596"></p>
<p>也就是说相当于这个键值对是永不过期的。如果我们取出数据校验后发现，value 里面存的过期时间提示已经过期了，我们再用代码去修改并且重写入 Reids 进行更新或者删除。</p>
<p>重写的过程中，访问数据的线程获取到的将会是没有更新的过期的旧数据（下图中的1,3。1线程发现过期后，不自己更新数据，而是新开一个线程2更新数据，自己返回过期数据，保证速度性能）。虽然一致性有所降低，但是这样的访问方式比数据库崩掉要好吧。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505251345702.png" alt="image-20250525134528501"></p>
<p>逻辑过期一般用于某些商品活动实现。</p>
<p>互斥锁实现简单，一致性好，但是线程等待可能时间长，性能受影响，且可能有死锁风险。</p>
<p>逻辑过期线程无需等待，性能较好，实现复杂，有额外内存消耗，一致性低。</p>
<p>CAP 理论，Consistency 一致性和 Availablity 可用性的抉择。</p>
<h3 id="互斥锁实现"><a href="#互斥锁实现" class="headerlink" title="互斥锁实现"></a>互斥锁实现</h3><p>互斥锁我们可以利用 Redis 的 <code>setnx</code> 命令实现。这个命令是如果不存在这个键才插入键值对并返回1证明插入成功，如果存在则不插入并返回0表示插入失败。那么我们直接执行 <code>setnx lock x</code> 命令就直接设置好锁了。</p>
<p>此外，如果获取互斥锁的线程出问题导致没有及时 del 互斥锁那么也会出现问题。为了避免这个问题可以给互斥锁设置一个 expire 有效期。有效期一般几十倍，比如设置成10s就可以。</p>
<pre class="mermaid">flowchart TD
    A[开始] --> B[提交商铺 id]
    B --> C[从 Redis 查询商铺缓存]
    C --> D{判断缓存是否命中}
    D -- 命中 --> E[返回数据] --> F[结束]
    D -- 未命中 --> G[尝试获取互斥锁]
    G --> H{判断是否获取锁}
    H -- 否 --> I[休眠一段时间] --> C
    H -- 是 --> J[根据 id 查询数据库]
    J --> K[将商铺数据写入 Redis]
    K --> L[释放互斥锁]
    L --> E</pre>

<p>代码实现：首先我们写 Redis 加锁和解锁的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> Boolean.TRUE.equals(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(LOCK_SHOP_KEY + key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改原来的查询方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存击穿，先把原来的查询代码全复制过去然后修改未命中实现</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> queryWithMutex(id);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(shop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithMutex</span><span class="params">(Long id)</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从 Redis 查询商铺缓存</span></span><br><span class="line">    <span class="comment">// 这里为什么改用 String，完全是老师为了每种方法都让我们看一遍</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(CACHE_SHOP_KEY + id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断是否存在</span></span><br><span class="line">    <span class="comment">// isNotBlank 指的是判断不为 Null，不为空值。</span></span><br><span class="line">    <span class="comment">// Null 表示我们的缓存里没有这个数据，未命中，需要进一步去数据库里查找之后再缓存。</span></span><br><span class="line">    <span class="comment">// 空值表示缓存里面有这个数据，并且记录了这是一个不存在的商户。</span></span><br><span class="line">    <span class="keyword">if</span>(StrUtil.isNotBlank(shopJson))&#123;</span><br><span class="line">        <span class="comment">// 3. 存在，直接返回</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存里有记录这是一个不存在商户</span></span><br><span class="line">    <span class="keyword">if</span>(shopJson!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 缓存未命中，实现缓存重建</span></span><br><span class="line">    <span class="comment">// 4.1 获取互斥锁</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="comment">// 4.2 判断是否获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 4.3 失败，则休眠并重试</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">return</span> queryWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.4 成功，根据 id 查询数据库</span></span><br><span class="line">        <span class="comment">// 这里其实应该再访问一下缓存的 DoubleCheck，如果访问到了说明就在上锁的时候有线程更新了。我们就不需要重建缓存了</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        <span class="comment">// 这里其实我们的获取操作过于简单可能不一定会引发缓存击穿，所以我们这里特地让数据库访问线程延时200ms这样其他并发线程就很容易被互斥锁阻塞了，方便我们实现。</span></span><br><span class="line">        <span class="comment">// 比如我们压测同时启动1k个线程查询商店信息，第一个线程会拿到互斥锁然后去数据库查询数据，但是可能很快就查完了。现在我们让这第一个线程拿数据的时间增加200毫秒这样其他很多线程都因为缓存未命中且拿不到互斥锁而进入等待状态，以此判断我们的代码是否生效。</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 商户在数据库中不存在，将空值写入 Redis 再返回错误</span></span><br><span class="line">        <span class="keyword">if</span>(shop == <span class="literal">null</span>)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES); <span class="comment">// 空值2分钟，短一些</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 存在，添加到 Redis 商铺缓存中，并返回</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 7. 释放互斥锁</span></span><br><span class="line">        unlock(LOCK_SHOP_KEY + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 JMeter 压测，我这边的报告如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505252103009.png" alt="image-20250525210334877"></p>
<p>不过所有线程都拿到数据了，而且 IDEA 里面调试信息输出显示确实是只查询了一次数据库。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505252104222.png" alt="image-20250525210422045"></p>
<h3 id="逻辑过期实现"><a href="#逻辑过期实现" class="headerlink" title="逻辑过期实现"></a>逻辑过期实现</h3><p>首先想办法添加一个 expire 字段到要存储的缓存键值对中。注意尽量不要修改原来的业务，比如直接在 Shop 商店类里面加一个字段这种行为并不可取。</p>
<p>在 utils 里面添加 RedisData.java，老师已经实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/RedisData.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LocalDateTime expireTime;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般有两种实现方式，一种是 RedisData 里面只有 expireTime，然后让 shop 继承它，不过这样也比较有侵入性；另一种方式就是上面这种写法，在其中加入一个 data 对象，和 Shop 绑定。</p>
<p>首先我们尝试拼接一下 expireTime </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShop2Redis</span><span class="params">(Long id, Long expireSeconds)</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 查询店铺数据</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 睡眠来引发异常</span></span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 2. 封装逻辑过期时间</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(shop);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line">        <span class="comment">// 3. 导入 Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后尝试写一个测试用例并运行，插入一条热点数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/HmDianPingApplicationTests.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HmDianPingApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ShopServiceImpl shopService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveShop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        shopService.saveShop2Redis(<span class="number">1L</span>, <span class="number">10L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写缓存穿透代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// service/impl/ShopServiceImpl.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">public</span> Shop <span class="title function_">queryWithLogicalExpire</span><span class="params">( Long id )</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">    <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="comment">// 2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">        <span class="comment">// 3. 不存在，直接返回，因为热点数据只存在 redis 里数据库中没有</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">    <span class="comment">// 5.判断是否过期</span></span><br><span class="line">    <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">    <span class="comment">// 6.缓存重建</span></span><br><span class="line">    <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">    <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//重建缓存</span></span><br><span class="line">                <span class="built_in">this</span>.saveShop2Redis(id,<span class="number">20L</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 里面现在存储的是 101 茶餐厅，我们在数据库里改成 105 茶餐厅，然后运行代码并查询餐厅名称（我们设置的热点过期时间很短，10s）。</p>
<p>使用 JMeter 压测会发现一定线程后数据才更新为新数据，IDEA 里面 mybatis 执行的数据库查询语句只有一条。</p>
<h2 id="缓存工具类封装"><a href="#缓存工具类封装" class="headerlink" title="缓存工具类封装"></a>缓存工具类封装</h2><p>主要要封装的四个常用方法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505262028285.png" alt="image-20250526202849126"></p>
<p>在 utils 文件夹里新建方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/CacheClient.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.hmdp.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.hmdp.entity.Shop;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.hmdp.utils.RedisConstants.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存添加正常值并且带一个 TTL 过期时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), expireTime, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加逻辑过期值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLogicalExpire</span><span class="params">(String key, Object value, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(expireTime)));</span><br><span class="line"></span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long expireTime, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存命中且有值</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(json))&#123;</span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(json, type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存命中且为空值</span></span><br><span class="line">        <span class="keyword">if</span>(json != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存未命中，数据库查询</span></span><br><span class="line">        <span class="comment">// 不过这里并不确定要查询的是什么类型</span></span><br><span class="line">        <span class="comment">// 所以需要传入查询函数</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">null</span>)&#123;</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.set(key, r, expireTime, unit);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(LOCK_SHOP_KEY + key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R, ID&gt; R <span class="title function_">queryWithLogicalExpire</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbFallback, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line">        <span class="comment">// 1.从redis查询商铺缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">// 2.判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="comment">// 3. 不存在，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.命中，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">// 5.判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span>(expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 5.1.未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.2.已过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 6.缓存重建</span></span><br><span class="line">        <span class="comment">// 6.1.获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="comment">// 6.2.判断是否获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock)&#123;</span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit( ()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">r1</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 写入 redis</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLogicalExpire(key, r1, time, unit);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.4.返回过期的商铺信息</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h1><h2 id="全局唯一-ID"><a href="#全局唯一-ID" class="headerlink" title="全局唯一 ID"></a>全局唯一 ID</h2><p>商店发布优惠券，用户抢购的时候就会使用订单并保存到 <code>tb_voucher_order</code> 表中。但是表的 id 不建议使用自增 id，因为：</p>
<ol>
<li>会泄露信息给用户，比如用户今天下单的订单id1，明天id100，用户可以知道我们昨天一天有100单优惠券订单。</li>
<li>数据量太大，单表存储有限制。所以订单数据往往采用多表存储，但是多表存储自增 id 很难保证不出现重复。</li>
</ol>
<p>而订单业务有需要 id 唯一。</p>
<p>我们需要有一个全局 ID 生成器：用于分布式系统生成全局唯一 id，生成的 id 一定是当前业务内唯一的。</p>
<p>这个 ID 生成器需要满足：</p>
<ol>
<li>唯一性，不用多说。</li>
<li>高可用，访问的时候快速获取。</li>
<li>高性能，创建也要快一些。</li>
<li>递增性，便于数据库建立索引。</li>
<li>安全性，不能被轻易找到规律从而获取公司信息。</li>
</ol>
<p>我们可以借助 Redis 的自增命令实现，同时为了确保安全性再拼接一些其他数据：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505262225246.png" alt="image-20250526222516102"></p>
<p><em>当然也可以用一些其他策略，如 UUID 但是是十六进制的字符串，而且并非单调递增的；还有 snowflake 雪花算法。但是需要维护机器内部的自增 id。还有就是数据库自增，但性能也不如 Redis 自增。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/RedisIdWorker</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span>  &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳，这个是老师通过当前时间获取的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond + BEGIN_TIMESTAMP;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 生成序列号</span></span><br><span class="line">        <span class="comment">// Redis 自增是基于键自增的，长度2^32的话，一个业务的总订单数可能会超过这个数值</span></span><br><span class="line">        <span class="comment">// 所以结尾加上一个当前日期拼接，效果就变成：每天自增序列号上限为2^32</span></span><br><span class="line">        <span class="comment">// 此外分层级的 key 也方便查找</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h2><p>主要分为两种：普通券（折扣较低）和特价秒杀券（折扣较高，但限量）。</p>
<p>分别对应数据库表的 <code>tb_voucher</code> 和 <code>tb_seckill_voucher</code> 。</p>
<p>表详情如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_voucher` (</span><br><span class="line">  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">  `shop_id` bigint unsigned DEFAULT NULL COMMENT &#x27;商铺id&#x27;,</span><br><span class="line">  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT &#x27;代金券标题&#x27;,</span><br><span class="line">  `sub_title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;副标题&#x27;,</span><br><span class="line">  `rules` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT &#x27;使用规则&#x27;,</span><br><span class="line">  `pay_value` bigint unsigned NOT NULL COMMENT &#x27;支付金额，单位是分。例如200代表2元&#x27;,</span><br><span class="line">  `actual_value` bigint NOT NULL COMMENT &#x27;抵扣金额，单位是分。例如200代表2元&#x27;,</span><br><span class="line">  `type` tinyint unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;0,普通券；1,秒杀券&#x27;,</span><br><span class="line">  `status` tinyint unsigned NOT NULL DEFAULT &#x27;1&#x27; COMMENT &#x27;1,上架; 2,下架; 3,过期&#x27;,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=COMPACT</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tb_seckill_voucher` (</span><br><span class="line">  `voucher_id` bigint unsigned NOT NULL COMMENT &#x27;关联的优惠券的id&#x27;,</span><br><span class="line">  `stock` int NOT NULL COMMENT &#x27;库存&#x27;,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `begin_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;生效时间&#x27;,</span><br><span class="line">  `end_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;失效时间&#x27;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`voucher_id`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci ROW_FORMAT=COMPACT COMMENT=&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;</span><br></pre></td></tr></table></figure>

<p>目前茶餐厅里面只有一个普通优惠券没有秒杀券。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505272157869.png" alt="image-20250527215752692" style="zoom:50%;" />

<p>我们首先需要添加一些秒杀优惠券。老师已经写好方法了，<code>/voucher/seckill</code> 路径（注意要给登录拦截器里写上这个放行一下）。我们直接 postman 发送请求就能添加：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505272214076.png" alt="image-20250527221418833"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505272214461.png" alt="image-20250527221430256"></p>
<p>（这里其实要改一下，把 endTime 改成在你当前时间之后。这样才能在前端看到优惠券）</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505272216808.png" alt="image-20250527221609663" style="zoom:50%;" />

<p>不过现在没法点击抢购，会显示功能未完成。请求 URL 为：<code>http://localhost:8080/api/voucher-order/seckill/10</code></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-伦敦国王学院EEM笔记：Machine Learning 机器学习"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/01/01/%E4%BC%A6%E6%95%A6%E5%9B%BD%E7%8E%8B%E5%AD%A6%E9%99%A2EEM%E7%AC%94%E8%AE%B0%EF%BC%9AMachine%20Learning%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"
    >伦敦国王学院EEM笔记：Machine Learning 机器学习</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/01/01/%E4%BC%A6%E6%95%A6%E5%9B%BD%E7%8E%8B%E5%AD%A6%E9%99%A2EEM%E7%AC%94%E8%AE%B0%EF%BC%9AMachine%20Learning%20%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2025-01-01T00:00:00.000Z" itemprop="datePublished">2025-01-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%8E%8B%E9%81%93%EF%BC%88KCL%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">王道（KCL电子工程专业课内学习）</a> / <a class="article-category-link" href="/categories/%E7%8E%8B%E9%81%93%EF%BC%88KCL%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E4%B8%93%E4%B8%9A%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概率论基础"><a href="#概率论基础" class="headerlink" title="概率论基础"></a>概率论基础</h1><p>在正式开始机器学习方法之前，我们先学习一些概率论（Probability）的知识以便后面进入算法正题。</p>
<h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><h3 id="离散随机变量"><a href="#离散随机变量" class="headerlink" title="离散随机变量"></a>离散随机变量</h3><p>离散随机变量（Discrete Random Variables）x 可能在集合 X 的范围内取值，比如投掷硬币的概率随机变量 x，取值集合 X &#x3D;{正面，反面}。随机变量实质是函数。</p>
<p>投硬币是一个离散的例子，X 还可能是连续的集合。</p>
<p>注意区分随机变量 x 和它的取值 realization <em>x</em> 的区别，x &#x3D; <em>x</em> 意思是随机向量 x 取值为 <em>x</em>（类似于投硬币事件 x 投出了 “正面” 结果吧。第二个 x 是斜体）</p>
<blockquote>
<p>[!TIP]</p>
<p>英文教材表达：random varible x takes value <em>x</em>.</p>
</blockquote>
<p>对于每个不同的 <em>x</em> 值，都有它在这个随机变量 x 里的概率，用函数表示就是：</p>
<p><strong>x~p(<em>x</em>)&#x3D; Pr [x &#x3D; <em>x</em>]</strong></p>
<p>p(x)的范围肯定是 0 到 1 的，概率不可能大于 1.rv x 中的所有概率求和 &#x3D; 1.</p>
<ul>
<li><p>伯努利二元随机变量（Binary&#x2F;Bernoulli variable）：x 中只有两个值，类似投硬币的正反。这两个值概率互补，比如投硬币正反概率各 50%。</p>
</li>
<li><p>分类随机变量（Categorical&#x2F;Multinoulli variable）：有多个结果。</p>
</li>
</ul>
<p>$$<br>\begin{aligned}<br>X&amp;&#x3D;{0, 1, … , C-1}\<br>p(k)&amp;&#x3D; q_k\<br>Random; Variable; q&amp;&#x3D; [q_0, q_1, … , q_{C-1}]<br>\end{aligned}<br>$$</p>
<p>且随机向量内所有元素求和 &#x3D; 1.</p>
<p>机器学习中常用一种叫做独热编码（one-hot vector）的方式表示随机变量，就是对于多分类问题的结果预测里面只有一个值 &#x3D; 1，其他的都是 0（<em>也就是预测结果一定是某一个结果，比如：这张图片有100%的概率是猫，0%的概率是狗或者老鼠。也类似嵌入式的位掩码，只有一个元素生效</em>）。 比如：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202409301229711.png"></p>
<h3 id="连续随机变量"><a href="#连续随机变量" class="headerlink" title="连续随机变量"></a>连续随机变量</h3><p>连续随机变量（Continuous）通常用概率密度函数表示，$$x\sim p(\textit x)$$，同样 p(x)在域上求积分 &#x3D; 1.</p>
<p>比如经典的高斯变量，$$x \sim N(\mu, \sigma ^2)$$，表示公式：<br>$$<br>p(x)&#x3D; N(x|\mu,\sigma ^2) &#x3D; \frac{1}{\sqrt{2\pi \sigma ^2}}exp(-\frac{(x-\mu)^2}{2\sigma ^2})<br>$$<br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202409301232062.png" alt=" "  /></p>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>期望（Expection）也叫平均值，最有可能的结果。离散随机变量的期望：<br>$$<br>E_{\mathbb{x}\sim p(x)}[\mathbb{x}] &#x3D;\sum_{x\in\mathcal{X}}p(x)\cdot x<br>$$<br>离散变量的 <strong>函数</strong> 的期望：给定 x 和其概率分布，求 f(x) 的期望值是多少。可以理解为首先 x 有多大的概率等于这个值，然后再用 x 的这个值代入 f(x)得到的结果，我们要计算这个结果的期望值。<br>$$<br>xE_{\mathbb{x}\sim p(x)}[f(\mathbb{x})] &#x3D;\sum_{x\in \mathcal{X}}p(x)\cdot f(x)<br>$$<br>比如下题，cat 是分类分布，表示 x 有 0.1 的概率 &#x3D; 0,0.2 的概率 &#x3D; 1,0.7 的概率 &#x3D; 2，求 f(x)的期望值：<br>$$<br>\begin{aligned}<br>x\sim Cat([0.1,0.2,0.7]), and, f(x)&#x3D; x^2\\<br>E_{x\sim Cat(q)}[x^2] &#x3D; 0.1 \cdot 0^2+0.2\cdot 1^2+0.7\cdot 2^2 &#x3D; 3<br>\end{aligned}<br>$$<br>连续函数求期望的方式类似，求积分而已。<br>$$<br>xE_{\mathbb{x}\sim p(x)}[f(\mathbb{x})] &#x3D;\int_{-\infty }^{+\infty }p(x)f(x)dx<br>$$<br>高斯随机变量 $$N(µ, σ^2)$$ 的期望，对于 f(x)&#x3D; x 函数来说 $&#x3D; µ$，对于 $f(x)&#x3D; x^2$ 函数来说 $&#x3D; µ^2+σ^2$.</p>
<ul>
<li>高斯随机变量的期望是线性的. 也就是说满足 $$E(af(x)+bg(x))&#x3D;aE(f(x))+bE(g(x))$$ 。</li>
</ul>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>基础向量（Vector）操作矩阵乘法等不再赘述。这里指的向量的表示形式是列向量（L×1 长度）。</p>
<p><strong>inner product 内积</strong>：两个长度相同的列向量每个元素相乘，$$x^Ty$$。内积一般用来衡量两个向量的相似度（similarity）.</p>
<p>比如下面这两对 xy，内积都 &#x3D; 6，说明其相似度差不多。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202409301313822.png" alt=" "  />

<p><strong>范数（norm）</strong>：就是向量的标量长度，可以通过 $$x^Tx$$ 计算。</p>
<p>L1 范数：$$x^Tx$$</p>
<p>L2 范数：L1 范数再开根，代表向量长度。</p>
<p>比如上面的笑脸图，除了右上角的 y 的 L2 范数 &#x3D; 6，其他向量 L2 范数 &#x3D; 8.</p>
<p>$\widetilde{x}$：x 的归一化，相当于一个和 x 方向相同但是长度 &#x3D; 1 的向量，用 x&#x2F;L2 范数（‖x‖）就可以得到。</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p><strong>对角矩阵（Diagonal matrix）</strong>：只有对角线上的值（$$a_{ii}$$）非零<br>$$<br>Diag(a)&#x3D;<br>\begin{bmatrix}<br>   a_1 &amp; 0 &amp; {…} &amp; 0 \<br>   0 &amp; a_2 &amp; \  &amp; 0\<br>   {…} &amp; \  &amp; {…} &amp; {…}\<br>   0 &amp; 0 &amp; {…} &amp; a_L<br>\end{bmatrix}<br>$$<br>L×1 列向量的对角矩阵相当于把列向量中的元素均匀分到 L×L 矩阵的对角线上。两个列向量的乘积 &#x3D; 一方的对角矩阵与另一方列向量的乘积。</p>
<p><strong>Symmetric matrix 对称矩阵</strong>：矩阵转置仍然等于其本身。对角矩阵很明显就是对称的。</p>
<h2 id="随机向量"><a href="#随机向量" class="headerlink" title="随机向量"></a>随机向量</h2><p>随机向量（Random Vector）是随机变量中所有元素按列向量排列。其中某个元素的概率：$$Pr[x&#x3D;x_i]$$</p>
<p><strong>联合随机向量（Joint pmf p(x)）</strong>：多个维度的事件同时发生的概率。类似于：第一次硬币投出正面，第二次投出反面的概率。 $$p(x)&#x3D;Pr[x_1 &#x3D; x_1\ and\ x_2&#x3D;x_2\ …\ and\ x_L &#x3D; x_L]$$</p>
<p>伯努利随机向量（Bernoulli random vector）：只有两种情况，类似投硬币，一正一反。</p>
<p>联合伯努利随机向量（Jointly Bernoulli random vector）：2 个维度的伯努利向量。</p>
<table>
<thead>
<tr>
<th>x1\x2</th>
<th>0</th>
<th align="center">1</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>p(0,0)&#x3D; 0.45</td>
<td align="center">p(0,1)&#x3D; 0.05</td>
</tr>
<tr>
<td>1</td>
<td>p(1,0)&#x3D; 0.1</td>
<td align="center">p(1,1)&#x3D; 0.4</td>
</tr>
</tbody></table>
<p>连续随机变量的联合表示从二维的平面变为三维的空间了，两个自变量 x 是两个维度，得到的最终概率值是一个维度。比如下图是高斯随机变量的联合表示图，x y 坐标决定 z 坐标值：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202409301345912.png" alt=" "></p>
<p><strong>边际分布（Marginal Distributions）</strong>：只考虑多个变量中的部分变量的概率。比如上面的表格，x1~Bern(0.5)，x2~Bern(0.45)（伯努利的写法是 Bern(&#x3D; 1 部分的概率)）</p>
<p><strong>条件概率（Conditional Distributions）</strong>：给定其他变量为 xx 的条件下，这个变量为 xxx 的概率是多少。比如上表格，x2 &#x3D; 0 的话 x1 的概率分布：P(x1 &#x3D; 0 | x2 &#x3D; 0)&#x3D; 0.45&#x2F;0.55, P(x1 &#x3D; 1 | x2 &#x3D; 0)&#x3D; 0.1&#x2F;0.55, (x1|x2 &#x3D; 0)~Bern(0.18)</p>
<p>应用：比如生成式语言模型，已经生成了之前 1k 个词后下一个词为“xxx”的概率为多少。</p>
<p><strong>独立性（Independence）</strong>：两个变量没有什么关系。两者同时发生的概率就是两者分别发生的概率的乘积，p(x1, x2)&#x3D; p(x1)p(x2).</p>
<p>p(x1, x2) &#x3D; p(x1)p(x2|x1).</p>
<h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p>贝叶斯定理（Bayes）被称为：改变信念 brief 的定理，大概是从概率角度上让人更改自己的偏好。所以也常用在机器学习中。<br>$$<br>p(x_2|x_1) &#x3D; p(x_2) \frac{p(x_1|x_2)}{p(x_1)}<br>$$</p>
<blockquote>
<p>[!NOTE]</p>
<p>以吴军老师在中文分词领域举的一个例子来说，对于一个句子：南京市长江大桥，可以有两种划分：</p>
<ul>
<li>南京市 &#x2F; 长江大桥</li>
<li>南京市长 &#x2F; 江大桥</li>
</ul>
<p>到底哪一种更合理？我们可以计算条件概率：</p>
<ul>
<li>P(长江大桥|南京市) &#x3D; 出现“南京市”时，出现“长江大桥”的概率；</li>
<li>P(江大桥|南京市长) &#x3D; 出现“南京市长”时，出现“江大桥”的概率。</li>
</ul>
<p>提前准备好大量的中文语料，计算出两种分词的条件概率，我们就可以得出哪种分词更合理。</p>
<p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/blogs/all/2023-08-29-bayes-use/index.html">一文搞懂贝叶斯定理（应用篇） - Blogs - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
</blockquote>
<p>生成式大模型，搜索引擎等常见其应用。</p>
<h1 id="推理"><a href="#推理" class="headerlink" title="推理"></a>推理</h1><p>现在我们已经有一定概率论基础了。我们开始学习“推理（Inference）”，即：已知概率的情况下，根据输入 x 猜测输出 t。</p>
<p>推理的中间过程是一个概率模型 probabilistic model （x 和 t 的联合分布 p(x, t) ）来预测最可能的 t。</p>
<p>模型的具体实现被称作预测器 predictor。</p>
<p>推理问题主要分为两类，离散的 <strong>detection</strong> （比如晴天或者雨天）和连续的 <strong>estimation</strong>（比如温度）。</p>
<p>而推理结果又分为两种：<strong>hard predictor</strong> 和 <strong>soft predictor</strong>，hard 就是只挑选某一个具体结果（比如预测 x &#x3D; 0 时 t &#x3D; 1，只确定一个固定结果）；soft 就是不确定的（当 x &#x3D; 某个值时，t 为 0 的概率有 10%，为 1 的概率有 90%）。</p>
<p>下面的公式示例中，第一行是 hard 的写法，代表：x &#x3D; 0 时 t 的预测结果 &#x3D; 1。</p>
<p>第二行是条件概率的 soft 的写法，代表：x &#x3D; 0 时 t &#x3D; 1 的概率是 0.2。<br>$$<br>\begin{aligned}<br>\hat t(0)&#x3D; 1\<br>q(1|0)&#x3D; 0.2<br>\end{aligned}<br>$$</p>
<h2 id="贝叶斯推理"><a href="#贝叶斯推理" class="headerlink" title="贝叶斯推理"></a>贝叶斯推理</h2><p>贝叶斯定理（Optimal Soft Prediction &#x2F; Bayesian Inference）比如我们求出，q(t|1)&#x3D; Bern(t|0.8)，那么可以说：$$\hat t(1) &#x3D; 1$$ with associated probability of error of 0.2（误差 &#x3D; 0.2 的硬推理）。当 x &#x3D; 1 时 t &#x3D; 1 的硬预测器是最优的。</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>代价函数（Loss Function）用于计算预测器和正确值之间的偏差，进而后续决定如何修改预测器让代价更小。</p>
<p>对于硬推理，我们用代价函数记录预测的硬推理值与真实值之间的偏差来评估硬推理。<br>$$<br>\mathcal{l} (t,\hat t)&#x3D;|t-\hat t|^k<br>$$<br>k 一般 &#x3D; 2，也就是平方损失（quadratic error loss）。</p>
<p>一种损失函数：detection-error loss，也叫 0-1 loss。指实际值和预测值要么相等，要么差 1. 比如只有 0 和 1 两种结果的伯努利随机向量情况（猜猜明天是晴天还是雨天。猜对了损失 &#x3D; 0，猜错了 &#x3D; 1）。</p>
<p>$\mathbb{1}$ 是指示符函数，预测结果正确时 &#x3D; 1，否则 &#x3D; 0.<br>$$<br>\begin{aligned}<br> \mathcal{l} (t, \hat t) &#x3D; \mathbb{1}(t &#x3D; \hat t)\<br> \mathbb{1}(a) &#x3D;<br> \begin{cases}<br>      1 &amp; \text{if a &#x3D; true}\</p>
<pre><code>  0 &amp; \text&#123;if a = false&#125;
\end&#123;cases&#125;     
</code></pre>
<p>\end{aligned}<br>$$</p>
<p>用什么损失评估硬推理的整体性能？一般用损失函数的平均值（population loss）计算。<br>$$<br>L_p(\hat t(\cdot))&#x3D; E_{(x, t)\sim p(x, t)}[l(t,\hat t(x))]<br>$$<br>比如下题，预测器是令 t 永远 &#x3D; 1，求 population loss。只需要计算算错部分的概率即可。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410070004028.png" alt=" " style="zoom: 33%;" />

<div>

<h2 id="最优硬预测"><a href="#最优硬预测" class="headerlink" title="最优硬预测"></a>最优硬预测</h2><p>最优硬预测（Optimal Hard Prediction）器的预测思路就是让 population loss 最小的预测函数。比如上图，很明显^t(1)&#x3D; 0, ^t(0)&#x3D; 1 的代价最小，&#x3D; 0.15。</p>
<p>对于硬预测，我们只需要挑出概率最大的条件概率点作为预测值即可。</p>
<h2 id="最优软预测"><a href="#最优软预测" class="headerlink" title="最优软预测"></a>最优软预测</h2><p>最优软预测（Cross-Entropy Loss and Optimal Soft Prediction）的损失函数突然就上强度了，要算 log。cross-entropy loss：−log q(t|x)</p>
<p>这是因为，对数损失的惩罚更高，迫使预测器做出更高概率更准确额预测：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410070142271.png" alt=" " style="zoom:67%;" />

<p>伯努利分布的 population 对数损失的计算公式如下（按 x 求期望)：<br>$$<br>Log\  Loss &#x3D;-\frac{1}{N}\sum^N_{i &#x3D; 1}[y_i log(q(y_i|x))+(1-y_i)log(1-q(y_i|x))]<br>$$</p>
<p>即：每个预测结果 log 后与标准概率相乘，求平均值。</p>
<p>最优软预测就是让 log loss 最小化的预测取值。</p>
<h1 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h1><h2 id="监督学习简介"><a href="#监督学习简介" class="headerlink" title="监督学习简介"></a>监督学习简介</h2><p>推理和学习的主要区别在于 p(x, t) 是否已知。比如天气预测问题，没有人知道根据当前条件明天到底会是什么天气，只能通过以往样本学习统计出估计值作为训练参考。</p>
<p>模型不可靠或者太复杂的时候，如果知道输入数据和期望输出我们可以用监督学习。</p>
<p>监督学习（Supervised Learning）的步骤简单来说分为五步：</p>
<ol>
<li>Inductive bias selection 归纳偏置。首先我们假设一下 <strong>目标模型</strong> 是什么样的，比如：一次函数？二次函数？做了这个假设之后再代入训练（比如 t &#x3D; ax，代入训练数据后求出 a）。当然，我们的假设可能会有偏差，毕竟不一定所有问题都能找到完全合适的问题解决，这个偏差就叫 bias。以及还要定义 <strong>损失函数</strong>，损失函数用于计算预测值与训练数据之间的偏差以此调整模型；<strong>正交函数</strong>；<strong>训练方法</strong>（比如：让 loss 最小化）。</li>
<li>Training 训练。下面会讲到，我们把已知的数据分为训练集和测试集，训练集用于训练我们的模型，测试集用于检验模型效果不用于训练。</li>
<li>Validation 验证，利用训练集数据计算 loss 损失判断模型的合理性，比如二次函数用一次函数的模型，偏差就会很大。</li>
<li>Revise inductive bias 可能考虑是否修改归纳偏置模型。</li>
<li>test 测试集测试。</li>
</ol>
<p>监督学习解决的问题主要分为：</p>
<ul>
<li>回归问题（regression problem），连续</li>
<li>分类问题（classification problem），离散</li>
</ul>
<p><em>memoralizing 是记忆，记住训练数据中的 x, t 的键值对。learning 是学习，找规律。</em></p>
<p>没有免费的午餐定理（no free lunch theorem）: <strong>没有一种通用的学习算法可以在各种任务中都有很好的表现</strong>。我们需要对数据进行先验假设 inductive bias ，在归纳过程中再做修改。最终得到一个预测器 predictor，连续问题是软预测器 soft，离散问题是硬预测器 hard。</p>
<p>比如下面这张图，我们觉得两条横线不同长度，就是因为我们大脑根据经验觉得在参考线的辅助下两条线不一样长。这个过程有点类似于计算机的归纳偏置。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410111628240.png" style="zoom: 25%;" />



<h3 id="常见符号解释"><a href="#常见符号解释" class="headerlink" title="常见符号解释"></a>常见符号解释</h3><p>训练集：D，内含 N 个数据。training set D with N training data points<br>$$<br>D &#x3D;{(x_n, t_n)^N_{n &#x3D; 1}}<br>$$<br>硬预测器：^t<br>$$<br>\hat t_D(x)<br>$$<br>软预测器：q<br>$$<br>q_D(t|x)<br>$$<br>硬预测模型类 model class：意为我们对预测器做一个大概的假设，这个预测器属于某一个模型类（比如一次函数的预测器类，二次函数的预测器类等）。θ 是模型的参数，属于一个特定范围，在训练过程中调整 θ 值。注意 θ 是一个向量代表一系列系数。<br>$$<br>H &#x3D;{\hat t(\cdot|\theta):\theta\in\Theta}<br>$$<br>如果选择的模型类是多项式函数，一般用 degree M 表示其项数。<br>$$<br>\hat t(x|\theta)&#x3D;\theta_0+\theta_1x+\theta_2x^2+…+\theta_Mx^M &#x3D;\theta^Tu(x)<br>$$<br>其中的 u(x) 可不是阶跃函数，而是 feature vector 表示 $$[1, x, x^2, x^3…x^M]^T$$ 这个列向量。</p>
<p>这个模型类被称为线性预测器（不是因为 t 和 x 呈线性关系，很明显不是。而是因为 t 和 θ 呈线性关系）。</p>
<p>总体损失 population loss：特指推理中的损失，因为我们知道概率 p(x, t) 的具体值：<br>$$<br>L_p(\theta)&#x3D; E_{(x, t)\sim p(x, t)}[l(t,\hat t(x|\theta))]<br>$$<br>但是学习和推理不同，我们不知道具体概率值因此这个损失无法得到。我们可以评估训练损失：<br>$$<br>L_D(\theta)&#x3D;\frac{1}{N}\sum^{N}<em>{n &#x3D; 1}l(t_n,\hat t(x_n|\theta))&#x3D;\sum</em>{x, t}p_D(x, t)l(t,\hat t(x|\theta))<br>$$</p>
<h2 id="归纳偏差选择"><a href="#归纳偏差选择" class="headerlink" title="归纳偏差选择"></a>归纳偏差选择</h2><p>选择模型类 &#x2F; 预测器的过程也是确定归纳偏差（Inductive Bias Selection）的过程。</p>
<h3 id="三种预测器"><a href="#三种预测器" class="headerlink" title="三种预测器"></a>三种预测器</h3><p>总体最优无约束预测器（Population-optimal unconstrainded predictor）：最小化总体损失且无视模型，所以叫做无约束预测器，因为不受模型类的限制。但是我们不知道标准概率分布所以很难实现。<br>$$<br>t^*(\cdot)&#x3D; arg,\mathop{min}\limits_{t(\cdot)}L_p(t(\cdot))<br>$$<br>总体最优类内预测器（Population-optimal within-class predictor）：首先确定模型类，在这种模型类的前提下选择 θ 最小化损失。<br>$$<br>\theta ^*<em>M &#x3D; arg \mathop{min}\limits</em>{\theta \in R^{M+1}}L_p(\theta)<br>$$<br>经验风险最小化训练预测器（Trained ERM predictor）：确定模型类，且使用有限的训练数据集来计算损失。<br>$$<br>\theta_M^{ERM}&#x3D;&#x3D; arg \mathop{min}\limits_{\theta \in R^{M+1}}L_D(\theta)<br>$$</p>
<h3 id="ERM-经验风险最小化预测"><a href="#ERM-经验风险最小化预测" class="headerlink" title="ERM 经验风险最小化预测"></a>ERM 经验风险最小化预测</h3><p>针对这个损失函数，一种训练原则是 Empirical Risk Minimization 经验风险最小化（ERM），即找到使得 LD(θ) 最小的 θ 作为预测器参数。<br>$$<br>\theta_D^{ERM}&#x3D; arg,\mathop{min}\limits_{\theta \in \Theta}L_D(\theta)<br>$$</p>
<p>$$<br>L_D(\theta)&#x3D;\frac{1}{N}||t_D-X_D\theta||^2<br>$$</p>
<p><em>和之前提到的一样，连续问题（如 Regression）的损失函数是求次方偏差，离散问题（如 Classification）的损失函数是求 0-1 偏差。</em></p>
<p>t_D：一个列向量，依次存储了所有目标值.</p>
<p>X_D：一个矩阵，每行存储了一个 u(x)，和 θ 向量相乘后就组成了每行一个预测器（第一行：输入 x1 得到的 t1 值；第二行：输入 x2 得到的 t2 值……）。</p>
<p>意思就是所有预测值和训练值之间的代价损失的平均值。</p>
<p>让这个代价函数最小的 θ 的解是：<br>$$<br>\theta^{ERM}_D &#x3D;(X_D^TX_D)^{-1}X_D^Tt_D<br>$$<br>如果第一部分的矩阵乘积是不可逆的，舍去这一部分即可。</p>
<h3 id="ERM-相关的两个定理"><a href="#ERM-相关的两个定理" class="headerlink" title="ERM 相关的两个定理"></a>ERM 相关的两个定理</h3><p>对于学习，有两个定理：</p>
<ul>
<li>魏尔斯特拉斯近似定理（Weierstrass approximation theorem）：任何连续函数，随着 M 的增加（M 是多项式模型的最高项数），精准度都会逐渐增大。（当然预测器复杂度也增加了，所以并不能只一味增加了事，计算难度也会大幅增加的）</li>
<li>由于学习不知道准确概率只是根据训练数据估算的概率，所以这只能算是一种 <strong>估计</strong> 的损失。根据大数定理  law of large numbers，测试案例越多，估计损失越接近真正的 population loss.</li>
</ul>
<p>例题：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410121816117.png" alt=" " style="zoom: 50%;" />

<p>给出的预测器形式很简单，就是 x &#x3D; 0 时预测结果为 θ_0，x &#x3D; 1 时预测结果为 θ_1。我们计算 2 个维度四种情况分别的 loss 选取损失最小的预测器。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410121817373.png" alt=" " style="zoom:50%;" />

<h3 id="最优预测器和经验风险最小化预测器的对比"><a href="#最优预测器和经验风险最小化预测器的对比" class="headerlink" title="最优预测器和经验风险最小化预测器的对比"></a>最优预测器和经验风险最小化预测器的对比</h3><p>例：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141312358.png" alt=" "></p>
<p>当采用多项式函数模型，M &#x3D; 1 时，两种预测器拟合出的预测结果分别如图：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141314110.png" alt=" "></p>
<p>这种情况下，ERM <strong>underfits</strong> the data 欠拟合数据：</p>
<ul>
<li>模型不够复杂，the model is not rich enough</li>
<li>estimation error 很小，ERM 和 population-optimal 的预测结果很像</li>
<li>但是 bias 很大，因为用错公式了，一次方的函数怎么样也不可能和原函数很接近。</li>
<li>training loss 和 population loss 都很大。</li>
</ul>
<p>如果 M &#x3D; 9：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141318744.png" alt=" "></p>
<p>这种情况下，ERM <strong>overfits</strong> the data 过拟合数据：</p>
<ul>
<li>模型太复杂了，为了匹配所有训练数据，训练数据外的数据不够精确。</li>
<li>这是因为训练模型重点在于记住训练的数据集，而不是总结出没见过的数据的规律。</li>
<li>estimation error 很大，ERM 和 population -optimal 差距很大；</li>
<li>bias 很小，population -optimal 预测器和真正的数据规律很像。如果 bias 很大那两个模型的损失应该都很大，但是既然人家行你不行说明问题出在  ERM 本身上而不是归纳偏置上。</li>
<li>当训练数据够多时，training 和 population -optimal 之间的差距会越来越小，training 会越来越准确。</li>
</ul>
<p>M &#x3D; 3 时，模型预测如图，可以看出 ERM 在欠拟合和过拟合中间的 M 值会比较贴近正确预测结果：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141325430.png" alt=" "></p>
<p>但是我们如何判断模型是否过拟合？我们不一定知道正确的模型公式。因为我们到目前为止只是用训练数据在测试，就算训练出了完全拟合训练数据的预测器（如上面第二个图，M &#x3D; 9 的例子）我怎么知道这是适用于所有数据的预测器呢？</p>
<h3 id="软预测器的概率模型"><a href="#软预测器的概率模型" class="headerlink" title="软预测器的概率模型"></a>软预测器的概率模型</h3><p>软预测器的概率模型（Probabilistic Models）用已知 t 和 θ 的条件概率表示。第三章的时候用 q 符号表示，这章用 p 符号，反正意思到位了。<br>$$<br>\mathcal H &#x3D;\left{p(t|x,\theta):\theta \in \Theta \right}<br>$$</p>
<p>概率模型的训练采用软预测，因为其中的概率不确定性。</p>
<p>事实上很多确定性模型也可以用概率模型的特例来看待，也同样可以应用其公式。</p>
<p>总体损失：<br>$$<br>L_p(\theta)&#x3D; E_{(x, t)~p(x, t)}[-log, p(t|x,\theta)]<br>$$<br>训练损失（ERM）：<br>$$<br>L_D(\theta)&#x3D;\frac{1}{N}\sum^{N}_{n &#x3D; 1}(-log, p(t_n|x_n,\theta))<br>$$<br>也叫 Maximum Likehood Learning (ML Learning) 最大似然学习。最小化 log 损失，最大化概率。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>可以先拿出一部分已知数据作为验证集（validation set）不参与训练。预测器用训练集训练，验证集再计算损失。计算损失的方法仍然是整体损失：<br>$$<br>\hat L_p(\theta)&#x3D; L_{D^v}(\theta)&#x3D;\frac{1}{N^v}\sum^{N^v}_{n &#x3D; 1}l(t^v_n,\hat t(x^v_n|\theta))<br>$$</p>
<ul>
<li><p>损失函数应该会小于真实值，因为 ERM 是基于整个训练集训练的。</p>
</li>
<li><p>偏差问题：大数定理不再有效，因为大数定理是“训练集数量越多，整个训练集的损失越小”，而验证集的损失和训练集是分开的。所以验证集的损失是整体损失的有偏估计 biased estimate。</p>
</li>
</ul>
<p>比如我们可以利用验证选择更合适的模型：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141350628.png" alt=" "></p>
<p>如何选择验证集？</p>
<h3 id="K-Fold-Cross-Validation"><a href="#K-Fold-Cross-Validation" class="headerlink" title="K-Fold Cross-Validation"></a>K-Fold Cross-Validation</h3><p>首先将模型划分为 K 个类。每次迭代从每个类中选取一个值作为验证集，比如第 3 次就把 3 类作为验证集，把剩下的类作为训练集。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141707768.png" alt=" " style="zoom: 67%;" />

</div>

<p>最后求所有迭代的损失平均值：<br>$$<br>\hat L_p &#x3D; \frac{1}{K}\sum^{K}<em>{k &#x3D; 1}L</em>{D_k}(\theta^{ERM}<em>{\mathop{D}\limits^{\sim}</em>{-k}})<br>$$</p>
<p>例题：如下，尝试计算只选取两个元素作为验证集（不用 K-Fold 验证方式）的损失。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141713672.png" alt=" " style="zoom: 67%;" />

<p>如果是总体最优预测模型：很简单，把所有数据都作为训练数据，并且如果只涉及到这四个数据，损失 &#x3D; 0.</p>
<div align="center">
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410141717057.png" alt="" style="zoom: 67%;" />

<div>

<p>学习（ERM）：现在假设我们先选择两个数据作为训练数据。假设我们选择了 x &#x3D; 2 x &#x3D; 3. 那就完蛋了，用这两个数据我们训练得到的预测器是 t(x)&#x3D; 2，t 的值不受 x 的影响。<br>$$<br>\hat t(x|\theta) &#x3D; \theta _0 + \theta _1x. \theta _0 &#x3D; 2, \theta _1 &#x3D; 0.<br>$$<br>总体损失就是(2^2^+1^2^+0+0)&#x2F;4 &#x3D; 5&#x2F;4，过拟合。</p>
<h3 id="Bias-vs-Estimation-Error"><a href="#Bias-vs-Estimation-Error" class="headerlink" title="Bias vs Estimation Error"></a>Bias vs Estimation Error</h3><p>如何权衡偏差和估计错误？<br>$$<br>L_p(\theta _D) &#x3D; L_p(\hat t^*(\cdot))^{\text{minimum unconstrained population loss}} + \left(L_p(\theta^*_H) - L_p(\hat t^*(\cdot))\right)^{\text{bias}} + \left(L_p(\theta_D) - L_p(\theta^*_H)\right)^{\text{estimation error}}<br>$$<br>第一部分：最优预测的损失。当然最优预测很难找到因为不知道概率。</p>
<p>第二部分：bias。跟模型选择有关。</p>
<p>第三部分：估计错误。跟训练数据集大小有关。</p>
<p>在之前的例子中，我们知道：</p>
<p>M 增加，也就是模型 class 复杂度增加，bias 会下降，但 estimation error 可能会增加，过度拟合。</p>
<p>N 增加，也就是训练数据集增加，bias 不变，estimation error 会减少。</p>
<div align="center">

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410142027925.png" alt="" style="zoom:67%;" />

<p>再细化一点，对于每个输入 x，损失函数的表达方式是：<br>$$<br>L_p(\theta _D |x)&#x3D;\underbrace{L_p(\hat t^*(x) |x)}_\text{aleatoric, uncertainty}+\underbrace{(L_p(\theta^*_H|x)-L_p(\hat t^*(x)|x))}_\text{bias}+\underbrace{(L_p(\theta_D|x)-L_p(\theta^*_H|x))}_\text{epistemic, uncertainty}\<br>$$</p>
<p><em>其实这里对模型容量，数据量的介绍有些过于简化其作用了，训练效果和要解决的问题，模型选择，训练算法等等都有影响。比如深度神经网络一般是大容量模型，并不一定适用“模型容量越大，越容易过拟合”的定理。当模型容量增加的时候，测试误差会首先增加（过拟合）然后下降，直到一个插值点 interpolation point。这个特性被称为“双降 double descent”，意思是 training loss 随着模型容量增加而下降的同时，population loss 也没有如过拟合预期的那样增加。</em></p>
<h3 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h3><p>正交化（Regularization）一种让 ERM 模型变得更加泛化的方法。</p>
<p>θ 的参数过多会导致 overfitting，而正交化期望：降低 θ 的权重使得过拟合问题不那么明显。<br>$$<br>\theta^{R-ERM}<em>D &#x3D; arg,\mathop{min}\limits</em>{\theta \in \Theta}\left{L_D(\theta)+\frac{\lambda}{N}R(\theta) \right}<br>$$</p>
<p>括号内的部分是正交训练损失，Regularized training loss.</p>
<p>λ：一个可以设定的参数，尽可能的在减小训练损失和准确度之间权衡。</p>
<p>R：正交化 θ。比如一维范式就是所有 θ 的值求和 ||θ||，二维范式是其平方求和 $$||θ||^2$$。<em>一维范式被称作 LASSO Least Absolute Shrinkage and Selection Operator 最小绝对收缩和选择算子回归。</em></p>
<p>θ 数量越多，第二项也会使得整体的值增加，作用相当于 loss 增加。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>验证集多次迭代的过程是有偏估计，所以损失一般小于总体损失。</p>
<p>建议提前拿出一组数据作为测试集（Test Set），不参与训练和验证，用测试集评估总体损失且训练者不应该知道测试集的内容。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>我们之前已经得出损失公式，以及训练的目标就是让损失最小化：<br>$$<br>min_{\theta}{g(\theta)&#x3D;\frac{1}{N}\sum^N_{n &#x3D; 1}f(x_n, t_n|\theta)+\frac{\lambda}{N}R(\theta)}<br>$$<br>但是并不能一定取到最小值，比如类似 e^n 的函数，最小值无限接近 0 永远取不到。</p>
<p>最小值点（global optimal point g(θ*)），对于所有 g(θ) 都有 g(θ)&gt;&#x3D; g(θ*)，但大多数时候找不到。</p>
<p>极小值点（local optimal point），对于 θ* 附近的 θ 值有 g(θ)&gt;&#x3D; g(θ*)</p>
<p>找极小值点的方法当然是求导，如果 d(g(θ)&#x2F;θ)&#x3D; 0 那就说明 0 处是一个极值点（stationary point）（但可能是极大值点或者暂时停止上升）。</p>
<p>二阶导 &#x3D; 0：在该点处局部线性。&gt; 0：说明是“U”形状。&lt; 0：说明是“倒 U”形状。</p>
<p>如果二阶导一直 &gt;&#x3D; 0，那么 g(θ) 的增长率（一阶导）就是一直增加或不变的（比如二次函数），那么我们可以称原函数 g 为凸函数 convex，并且 stationary point 一定是最小值点。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410230631921.png" alt=" " style="zoom: 80%;" />

<p>θ 向量是从 1 到 D 维的所有 θ 系数，而 ∇g(θ) 是所有 θ 的导数的向量。</p>
<p>首先如果一个点是极值点 ，这个点的一阶导一定 &#x3D; 0，这是充分条件：一阶优化条件（first-order optimality condition）。</p>
<p>多元函数的曲率由下公式定义 Hessian：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410231828240.png" alt=" " style="zoom:67%;" />

<p>这个矩阵是对称的，比如：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410231831727.png" alt=" " style="zoom: 50%;" />

<p>其中的值全部 &#x3D; 0 说明是凸函数。</p>
<h3 id="梯度下降优化"><a href="#梯度下降优化" class="headerlink" title="梯度下降优化"></a>梯度下降优化</h3><p>梯度下降优化（Gradient Descent）是一种局部优化方法 Local optimization。</p>
<p>简单来说，每次迭代的时候沿损失梯度下降最快的方向走一定的步长，让下次迭代的 θ 序列损失更小。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410270009617.png" alt="[神经网络基础理论与简单实践 | korilin's blog](https://korilin.com/posts/basic-theory-and-simple-practice-of-neural-network/image_21.png)" style="zoom: 80%;" />

</div>

<p>公式如下，注意这里的 θ 不是指多项式中的每一个参数 θ，而是每次迭代产生的一组 θ。初始化第一组 θ 后，后面的每组 θ 都迭代计算。γ 是学习率，步长，决定每次迭代要迈多大的步子。<br>$$<br>\theta^{(i+1)}&#x3D;\theta^{(i)}-\gamma\nabla g(\theta^{(i)})<br>$$</p>
<p>如果 γ 设置的太大了，就容易迈过，再回头往反方向走。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410270016642.webp" alt=" " style="zoom:80%;" />
</div>

<blockquote>
<p>[!NOTE]</p>
<p>图源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45365719">深度学习优化算法入门：一、梯度下降 - 知乎</a></p>
</blockquote>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><ul>
<li>如果 g(θ) 的二阶导全部 &lt;&#x3D; L，可以说 g(θ) 是 L-smooth 的函数。</li>
</ul>
<p>$$<br>\frac{d^2g(\theta)}{d\theta^2}\le L<br>$$</p>
<p>就是 g(θ) 一阶导的增长率不会过快，一定在 L 的范围内。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410270022541.png" alt=" " style="zoom: 67%;" />

<ul>
<li>当学习率 γ &lt;&#x3D; 1&#x2F;L 时，有如下性质：<ul>
<li>guaranteed reduction of the loss function:</li>
</ul>
</li>
</ul>
<p>$$<br>g(\theta^{(i+1)})\le g(\theta^{(i)})-\frac{\gamma}{2}|\nabla g(\theta^{(i)})|^2<br>$$</p>
<p>​		也就是说下一次迭代的 θ 一定能让损失下降这么多。</p>
<ul>
<li><ul>
<li>convergence to a stationary point：g(θ) 收敛，$$\nabla g(\theta^{(i)})\rightarrow0$$</li>
</ul>
</li>
</ul>
<p>不过问题在于 L 不一定知道。我们可以通过验证，以及其他方法获取（后续章节介绍）。</p>
<h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>计算整个数据集的梯度，对于大模型来说计算成本还是太高了。</p>
<p>每次迭代我们不挑出所有的训练集样本点计算 g(θ) ，只随机选取部分：随机梯度下降（Stochastic Gradient Descent）。<br>$$<br>\theta^{(i+1)}\leftarrow \theta^{(i)}-\frac{\gamma^{(i)}}{S^{(i)}}\sum_{n \in S^{(i)}}\nabla g_n(\theta^{(i)})<br>$$<br>SGD 相比 GD 可能需要多走几步因为一开始的每一步不一定精准朝着 g(θ) 下降方向。但是计算成本还是下降了，因为 GD 每一步迈之前都要先考虑清楚所有可能的方向，再决定出让损失最小化的下一次迈步；如果数据量太大，这个功夫都够 SGD 走好多步了。</p>
<p>所以选择合适的学习率也可以适当减少迭代次数。根据 Munro-Robbins conditions，SGD 的学习率设置：<br>$$<br>\sum^{\infty}<em>{i &#x3D; 1}\gamma^{(i)}&#x3D;\infty; and;\sum^{\infty}</em>{i &#x3D; 1}(\gamma^{(i)})^2\lt\infty<br>$$<br>第一部分保证了学习率不会太小以至于原地踏步，永远无法到达 stationary point；第二部分确保学习率不会太大，SGD 的方差是逐渐减小直到消失的，保证逐渐逼近 stationary point 而不会在极点附近来回徘徊。</p>
<p>比如 $$\gamma^{(i)}&#x3D;1&#x2F;i^{\alpha},\alpha \in (0.5, 1]$$ 这个学习率满足这一条件。</p>
<p>多项式学习率常常用 $$ \gamma ^{(i)} &#x3D; \gamma ^{(0)}&#x2F;(1 + \beta i)^\alpha, \beta&gt;0,\gamma^{(0)}&gt;0,\alpha \in (0.5,1]$$</p>
<p>除了对学习率范围设限，另一种避免到达不了极点的方法是 S 样本量每次迭代都会增加。这两种方式可以结合使用。</p>
<h3 id="计算梯度的方式"><a href="#计算梯度的方式" class="headerlink" title="计算梯度的方式"></a>计算梯度的方式</h3><p>Symbolic Differentiation：直接求导。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271538688.png" alt=" "></p>
<p>Numerical Differentiation：利用导数定义近似求解。把 g(θ) 看作一个黑盒，不关心其内部结构，只考虑输入输出。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271540283.png" alt="" style="zoom: 67%;" />




<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271542004.png" alt=" " style="zoom:50%;" />

<p>Automatic Differentiation：使用求导方法，但是只求出某个点的梯度值而不是先求出整体公式。</p>
<p>三种方式的对比：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271611213.png" alt=" "></p>
<h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>计算图（Computational Graph）便于计算梯度的图。</p>
<p>比如：<br>$$<br>g(\theta)&#x3D;\theta^2_1+\theta^2_2+\theta^2_3<br>$$<br>计算图表示为：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271626631.png" alt=" " style="zoom: 50%;" />

<p>当然也可能出现 θ1θ2 这样的形式：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271626706.png" alt=" " style="zoom:50%;" />

<p>已知 θ 序列求 g(θ) 非常简单，把参数带进去就可以。forward pass</p>
<p>反向传播（backward pass），假设 g(θ)&#x3D; 1，反推回来。所有 f() 的部分要对相应的 θ 求导。</p>
<blockquote>
<p>例题： $$g(\theta)&#x3D;\theta^2_1+2\theta^2_2-\theta^2_3$$ ，求 [1,-1,1] 点处的梯度。</p>
<p>首先进行 forward pass，代入三点数值到计算图中求 g(θ) 在 [1,-1,1] 处的数值，这一步的主要作用是确定计算图：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271649432.png" alt=" " style="zoom: 50%;" />

<p>接着假设 g(θ)&#x3D; 1，倒推回来：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271652421.png" alt=" " style="zoom:50%;" />

<p>[2, -2, 2] 部分是对 forward pass 中三个函数求导再代入 [1,-1,1] 的值得到的。</p>
<p>最终得到的 $$\nabla g(\theta)&#x3D;[2,-4,-2]^T$$</p>
<p>例题 2：如下图，f1-f3 都是 $$(x_1+2x_2)^2$$，f4 &#x3D; logx。</p>
<p>求 [1, -2, 1] 点处的梯度下降值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271835911.png" alt=" "></p>
<p>首先 forward pass 求出 g(θ)，并且在此过程中把每个函数对于 x1 x2 的求导也算出来（并带入输入 x1 x2 值）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271838872.png" alt=" "></p>
<p>然后假设 g(θ)&#x3D; 1，反推回去得到 θ 的值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202410271842537.png" alt=" "></p>
<p>$$\nabla \theta&#x3D;[-4&#x2F;3, -8&#x2F;3,0]^T$$</p>
</blockquote>
<h1 id="上述方法在二元分类中的应用"><a href="#上述方法在二元分类中的应用" class="headerlink" title="上述方法在二元分类中的应用"></a>上述方法在二元分类中的应用</h1><p>如下图，给了一个新点判断这个点可能是圈还是叉。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411120216352.png" alt=" "></p>
<p>目标 t 值：0 或者 1.<br>$$<br>t^{\pm}&#x3D; 2t-1 &#x3D;\left{<br>\begin{aligned}<br>1,, if; t &#x3D; 1\<br>-1,, if; t &#x3D; 0<br>\end{aligned}<br>\right.<br>$$</p>
<p>整体流程还是和之前讲的差不多：</p>
<ul>
<li>inductive bias selection</li>
<li>training</li>
<li>validation</li>
<li>revise inductive bias</li>
<li>test</li>
</ul>
<p>模型主要分为线性模型和神经网络模型。</p>
<h2 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h2><h3 id="预测器"><a href="#预测器" class="headerlink" title="预测器"></a>预测器</h3><p>还是经典公式：<br>$$<br>\theta^T u(x)&#x3D; \sum^{D’}_{d &#x3D; 1}\theta_du_d(x)<br>$$<br>特征向量 u(x) 也不一定只是 x 的多次幂列向量，比如可能是“一个句子中不同词的出现次数”。</p>
<p>硬预测器的计算结果：如果公式值 &gt; 0 则 t 预测 &#x3D; 1，如果 &lt; 0 则预测 &#x3D; 0. 公式值 &#x3D; 0 的情况不考虑也很难发生。<br>$$<br>\hat t(x|\theta)&#x3D; step(\theta^Tu(x))<br>$$</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411120228255.png" style="zoom:67%;" />


<p>软预测用指数函数处理：<br>$$<br>\begin{aligned}<br>p(t &#x3D; 1|x,\theta)&amp;&#x3D;\sigma (\theta^T u(x))\<br>p(t &#x3D; 0|x,\theta)&#x3D; 1&amp;-p(t &#x3D; 1|x,\theta)\<br>\sigma (x)&#x3D;(&amp;1+e^{(-x)})^{-1}<br>\end{aligned}<br>$$<br>$$\sigma&#x3D;\frac{1}{1+e^{-x}}$$ 或者 $$&#x3D;\frac{e^2}{1+e^2}$$ ，<strong>注意两种形式！</strong></p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411120232281.png" style="zoom: 67%;" />


<p>多项式计算结果区间位于 0 到 5 时，概率 &gt; 0.5，说明更有可能发生。所以软预测器选择 &gt; 0.5 的那一项结果作为预测值。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411120233740.png" style="zoom:67%;" />


<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>考虑下面这个式子，就是 classification margin：<br>$$<br>y &#x3D; t^\pm \cdot \theta^T u(x)<br>$$<br>这个式子为正值时预测结果为正确，为负值时预测结果为错误。</p>
<p>所以硬预测的 Detection-Error Loss Function 损失函数（还是指示符函数，预测正确 &#x3D; 0，预测错误 &#x3D; 1）可以写作：<br>$$<br>\begin{aligned}<br>l(t,\hat t(x|\theta))&amp;&#x3D;\mathbb{1} (t\neq \hat t(x|\theta))\<br>&amp;&#x3D; step(-y)<br>\end{aligned}<br>$$<br>但是这个函数没法应用 GD 降维（损失函数图像类似矩阵函数，只有 0 和 1，没法降维）。所以我们可以应用其他的损失函数：</p>
<div align="center">

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411120632479.png" style="zoom:67%;" />

</div>

<ul>
<li><p>Exponential loss 指数损失：$$l(y)&#x3D;e^{-y}$$</p>
</li>
<li><p>Hinge loss 铰链损失：$$l(y)&#x3D;max(0,1-y)$$</p>
</li>
<li><p>Hinge-at-zero loss 零损失铰链函数：$$l(y)&#x3D;max(0,-y)$$</p>
</li>
<li><p>Logistic loss 对数损失：$$l(y)&#x3D;log(1+e^{-y})$$</p>
</li>
</ul>
<p>这些函数都可以用，相比 detection-error loss 都可以应用 GD 降维。</p>
<ul>
<li>软预测损失：$$l(t,\hat t(x|\theta))&#x3D;log(1+e^{-y})$$</li>
</ul>
<h3 id="感知器算法"><a href="#感知器算法" class="headerlink" title="感知器算法"></a>感知器算法</h3><p>应用了 ERM，hinge-at-zero loss，SGD 的算法（Perceptron Algorithm）。</p>
<p>损失函数：$$l(y)&#x3D;max(0,-y)$$</p>
<p>梯度函数：<br>$$<br>\nabla l(t^\pm \cdot (\theta^T u(x)))&#x3D;\left{<br>\begin{aligned}<br>0;;; if; prediction; is; correct\<br>-t^\pm \cdot u(x);; if; prediction; is; wrong<br>\end{aligned}<br>\right .<br>$$</p>
<p>每次梯度下降迭代后的新 θ 参数计算公式：<br>$$<br>\theta^{(i+1)}&#x3D;\theta^{(i)}+\gamma^{(i)}\cdot\left{<br>\begin{aligned}<br>0;;; if; prediction; is; correct\<br>t^\pm \cdot u(x);; if; prediction; is; wrong<br>\end{aligned}<br>\right .<br>$$</p>
<p>例题：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411120744954.png" alt=" "></p>
<p>首先假设选取 (2.1, 1) 点计算梯度下降。<br>$$<br>\begin{aligned}<br>prediction; is; wrong,\ &amp;\theta_1\cdot 2.1 &#x3D;-2.1, hard\ prediction &#x3D; 0\neq 1\\<br>\theta_2&amp;&#x3D;\theta_1-\gamma x_1\\</p>
<p>\theta_2&amp;&#x3D;-1+0.1\cdot 2.1 &#x3D;-0.79<br>\end{aligned}<br>$$<br>然后选取 (-1.5, 0) 点计算梯度下降。<br>$$<br>\begin{aligned}<br>prediction; is; wrong,\ &amp;\theta_2\cdot -1.5 &#x3D; 1.185,\ hard\ prediction &#x3D; 1\neq 0\\<br>\theta_3&amp;&#x3D;\theta_2-\gamma x_2\\<br>\theta_3&amp;&#x3D;-0.79-0.1\cdot (-1.5)&#x3D;-0.64<br>\end{aligned}<br>$$<br>计算每个步骤中的 classification margin 会发现值是逐渐接近于 0 的。</p>
<p>对于 log loss 软预测器的梯度下降函数：<br>$$<br>\nabla l(t^\pm \cdot (\theta^T(u(x)))&#x3D;(\sigma(\theta^T u(x))-t)\cdot u(x)<br>$$<br>$$\sigma(\theta^T u(x))-t$$ 部分又用 $$\delta(x,t) $$ 表示，表示 mean error，&#x3D; 0 的时候说明预测完全准确。</p>
<p>当 mean error &#x3D; 0 时，如果 t &#x3D; 1，则 $$\theta^T(u(x))\rightarrow \infty$$ ；如果 t &#x3D; 0，则 $$\theta^T(u(x))\rightarrow -\infty$$ </p>
<p>软预测器梯度下降公式：<br>$$<br>\theta^{i+1}\leftarrow \theta^{(i)}-\gamma^{(i)}\frac{1}{S^{(i)}}\sum_{n\in S^{(i)}}(\sigma((\theta^{(i)})^Tu(x_n))-t^n)\cdot u(x_n)<br>$$<br>例题：还是上一道题的数据，初始预测器 $$\theta_1&#x3D;-1, \lambda&#x3D;0, \gamma&#x3D;0.1$$, minimum batch size S &#x3D; 1</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411122221190.png" alt=" "></p>
<h2 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h2><p>神经网络模型（Neural Network Model）主要用于处理非线性情况。</p>
<p>u(x) 并不像线性模型一样一开始是确定的，可能在模型训练过程中还有改动。对于难以建立先验的情况来说比较适用。</p>
<p>之前线性模型中我们常用 u(x) 来描述特征向量(feature vector)，而神经网络模型中用 x 表示输入的特征向量，u(x) 是其一种表示形式。</p>
<p>另外，神经网络模型专注于概率计算问题。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411122230604.png"></p>
<p>中间的每一层都叫做特征提取层（feature extraction layers）。</p>
<p>第一层输入 x 输出 D^1^ 维度的 h^1^ 向量。后面的每一层都用前一层的向量输入，输出一个 D^l-1^ 维度的 h^l-1^ 向量。最后一层叫做 classification layer 分类层，把 h 作为 u(x) 输入到预测器里计算概率。</p>
<p>每一层的处理公式如下：<br>$$<br>\begin{aligned}<br>a^l &#x3D; W^lh^{l-1}\</p>
<p>\end{aligned}<br>$$<br>W：权重向量，分配不同项之间的权重。</p>
<p>a：本层的 pre-activations 预激活向量。</p>
<p>h：列向量，用本层的 a 向量通过一个激活函数激活后得到。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411122312272.png" style="zoom:67%;" />

<p>典型的几种激活函数：</p>
<ul>
<li>sigmoid：$$\sigma (a)$$</li>
<li>hyperbolic tangent: $$tanh(a)$$</li>
<li>Rectified Linear Unit: $$max(0,a)$$</li>
<li>Leaky ReLU: $$max(\alpha a,a),,\alpha\in[0,1]$$</li>
</ul>
<p>下面是这四者的图像：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411131823276.png"></p>
<p>梯度消失问题：见 Sigmoid 函数，其的导数特征在于：在 ±5 范围之外，导数全部 &#x3D; 0；在中间导数先增长为 1 再下降。这就导致 a 必须落在 [-5,5] 的区间内，梯度值才会有效；在某些层传播中，梯度值很容易消失变为 0.</p>
<p>梯度爆炸：tanh 中间的梯度值都快到 ∞ 了，梯度范围浮动非常大，不稳定。</p>
<p>所以 ReLU 在这两点上优于 tanh 和 Sigmoid 函数，有效避免梯度下降和梯度消失问题。</p>
<p>最后一层获取 u(x|θ) 的公式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260337845.png"></p>
<p>每一层的作用都是提取一些信息化表示的特征，为最终通过 x 分类 t 做准备。</p>
<p>其中，W 是权重矩阵向量。W^l^ 是一个 D^l^ * D^l-1^ 形状的向量，作用是和前一层传入的 D^l-1^ 长度的行向量相乘后输出 D^l^ * 1 长度的符合下一层形状的向量。<strong>注意矩阵乘法的时候，W 在前，h 在后。</strong></p>
<p>一个比较通俗易懂的图解如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260348069.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260348830.png" alt="img"></p>
<blockquote>
<p>来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/illikang/article/details/82019945">神经网络——最易懂最清晰的一篇文章-CSDN 博客</a></p>
</blockquote>
<p>而 θ 也就是每一层的参数（权重）则这样表示：<br>$$<br>\theta &#x3D;{W^1, W^2, …, W^{L-1}, w^L}.<br>$$<br><em>如果 h 是线性函数，那么整个预测器就是一个线性预测器。</em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260351906.png"></p>
<p>例题：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260354580.png"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260357979.png"></p>
<p>给定题目后，我们大概可知神经网络图像如下，两层（注意神经网络算出来的默认结果是预测值 &#x3D; 1 的概率）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260358132.png"></p>
<p>用输入向量逐层与权重相乘后激活计算得到：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260405256.png"></p>
<p>p(0|x, θ) 就 1-0.12 &#x3D; 0.88 即可。</p>
<h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>又到了最喜欢的梯度下降优化环节。</p>
<p>首先还是要找一个计算损失的方法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260408835.png"></p>
<p>最后一层：<br>$$<br>l(\theta)&#x3D;-log,\sigma (t^{\pm}a^L)<br>$$<br>后向传播最后一层（第 L 层）所需梯度：只说结论的话：<br>$$<br>\delta^l &#x3D;\sigma(a^L)-t<br>$$</p>
<p>最后一层后向传播的梯度 &#x3D; 该层梯度的输入值代入 σ 函数再-目标值 t。比如最后一层输入-2，最终要计算 t &#x3D; 0 时的梯度，计算结果就是 $$\frac{e^{-2}}{1+e^{-2}}-0\approx0.12$$</p>
<p>推导也很简单，其实就是最后一层的损失函数求导罢了，$$t^\pm$$ 视作一个常数。大家可以对 l(θ) 求导试试，对于 t &#x3D; 1 和 0 的情况得到的分别是 $$\frac{1}{e^x+1}$$ 和 $$\frac{e^x}{e^x+1}$$ ，和下面的结论项是相等的。</p>
<p>对于前面的 1 到 L-1 层，其导数还是对对应自变量求导代入求值，和之前的 GD 算法类似。</p>
<p>比如：还是之前那道题，计算 t &#x3D; 0 时的梯度。首先是前向传播：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260431343.png" alt=" "></p>
<p>t &#x3D; 0 时，t^±^&#x3D;-1（$$t^\pm&#x3D;2t-1$$），a^2^ 是该层（第二层所以有个 2 的上标，不是平方）的输出 &#x3D;-2，两者相乘 &#x3D; 2，代入公式计算得到 0.13 为损失值。</p>
<p>然后假设结尾 &#x3D; 1，开始后向传播：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260439190.png" alt=" "></p>
<p>首先根据 t 和 a^2^ 计算出 δ &#x3D; 0.12，用 1*0.12 再*第二层权重回推。</p>
<p>第一层的梯度公式是 h 对 a^1^求导，h 是一个 ReLU 函数，所以当 a &gt; 0 时求导结果 &#x3D; 1，a &lt; 0 时求导结果 &#x3D; 0. （参考 ReLU 公式）所以得到这一层的向量是 [1,0]，回推出反向传播误差。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260446136.png" alt=" "></p>
<p>最终，我们给输入值*反向传播误差计算权重梯度，用原权重-权重梯度*学习率更新权重。这里貌似学习率视作 1 了吧？</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260449094.png" alt=" "></p>
<p>下图是不同层数，随着迭代次数增加训练损失下降情况图。可以看出 3 层反而是最有效进行二元分类的训练方法。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260451091.png" alt=" "></p>
<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p>一种常常用于自然语言处理的深度学习架构。</p>
<p>输入可以被划分为 subset 子集或者 token：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260459045.png" alt=" "></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260459330.png" alt=" "></p>
<p>对于输入数据，创建 N 个 Tokens，每一个都有 D*1 的维度：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260501909.png" alt=" "></p>
<h2 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h2><p>transformer 的一个重要机制在于自注意力（self-attention）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260515316.png" alt=" "></p>
<p>softmax 是形如下图的公式，这只是一种计算方法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260524551.png" alt=" "></p>
<p>在自注意力公式中，我们发现初始词嵌入出现了 3 次。前两次是作为句中词向量与其他词（包括它自己）点积得到权重；第三次再与权重相乘得到最终带上下文的词嵌入。这三个地方出现的词嵌入我们给他们三个术语：查询(Query), 键(Key), 值(Value)。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411260529285.png" alt=" "></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jarodyv/article/details/130867562">【万字长文】深度解析 Transformer 和注意力机制（含完整代码实现）_transformer 架构注意力机制-CSDN 博客</a></p>
</blockquote>
<p>Query 和 Key 不是对称的，一方对另一方的词注意力可能与反过来不同。比如“伦敦国王学院”和“大学”关联度很高，但”大学“和”伦敦国王学院“关联度不高，大学有那么多所呢。</p>
<h2 id="多头注意力"><a href="#多头注意力" class="headerlink" title="多头注意力"></a>多头注意力</h2><p>多头注意力（MultiHead Attention）除了一个句子中不同词之间的关联，可能还有其他因素（如一词多义，语序问题等）。</p>
<h1 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h1><p>无监督学习（Unsupervised Learning）相比监督学习没有一个“标准答案”，比如对于输入 x 我们没有期望 t 输出值。有很多问题是没有期望答案的，比如分类问题，或者异常检测（某个 x 的 p 值过小，很可能是异常）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292224162.png" alt=" "></p>
<p>一种常用的方法是自监督学习，把问题转化为监督学习。比如将预测所有 token 的问题转换为条件概率。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292239366.png" alt=" "></p>
<h2 id="密度估计"><a href="#密度估计" class="headerlink" title="密度估计"></a>密度估计</h2><p>压缩（Compression）：对于 x 向量中所有可能元素的表示，概率大的用简洁形式表示，概率小的用复杂形式表示更节省存储空间。比如摩斯电码。</p>
<div align="center">
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292244100.png" style="zoom:67%;" />

</div>

<h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>很简单的无参密度估计方法，就是统计 x 出现次数除以总数据数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292321324.png" alt=" "></p>
<p>首先我们定义区间 quantizer，一定区间范围内 x 一起统计。</p>
<p>公式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292324839.png" alt=" "></p>
<p>也就是说概率高度是 x 在这个区间内出现次数除以(区间长度*总区间数)。</p>
<p>例题：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292325573.png"></p>
<p>区间范围是 -2.5 到-2 有一个，-1.5 到-1 有一个，1 到 1.5 有一个，1.5 到 2 有一个，2 到 2.5 有一个。</p>
<p>区间密度单位 &#x3D; 1&#x2F;(5*0.5)&#x3D; 0.4.</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292326794.png" style="zoom:67%;" />

<p>可以看出区间的选取对直方图无监督学习影响很大。选太大了，bias 就很大，因为比较贴近正常值的异常值也可能被划进正常区间范围内；选太小了，估计误差可能又大了，因为每个区间的点数少了，就像上图，每个有样本的区间内都是一个样本数，怎么判断哪个是异常。</p>
<h3 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a>核密度估计</h3><p>核密度估计（Kernel Density Estimation）：如果分布假设是平滑的而不是类似直方图的离散状，误差应该会小一些。比如假设每个样本点（相当于一个阶跃函数的图像）都变成一个高斯函数 k_h(x)&#x3D; N(x|0, h)，概率密度函数如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292332293.png"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292332272.png"></p>
<p>h 越小，高斯函数越窄，但是就像直方图中暴露出来的问题一样，bias 下降，estimation error 上升。</p>
<p>例题：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292335529.png"></p>
<p>首先先用阶跃函数的形式画出样本点，然后延伸宽度为 0.1：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292336576.png"></p>
<p>如果设置 kernel width &#x3D; 0.5，也就是每个点都变成 0.5 宽度的矩形函数:</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411292336721.png"></p>
<h3 id="维度诅咒"><a href="#维度诅咒" class="headerlink" title="维度诅咒"></a>维度诅咒</h3><p>前两种方法缺陷在于 h 和 △ 选择必须合适，而且对于多维度数据误差可能很大（除非数据量够大）。这就是维度诅咒。</p>
<p>由此引入了参数密度估计方法，相较于非参数密度方法不会受到维度诅咒（Curse of Dimensionality）。但是对概率模型有限制，必须是可以通过参数模型得到的概率模型。</p>
<h3 id="对比监督学习"><a href="#对比监督学习" class="headerlink" title="对比监督学习"></a>对比监督学习</h3><p>对比监督学习（Contrastive Density Learning）：目标是将相似样本拉近，不相似样本离远。</p>
<p>生成噪声点：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411300016154.png"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411300051547.png"></p>
<h3 id="潜在变量模型"><a href="#潜在变量模型" class="headerlink" title="潜在变量模型"></a>潜在变量模型</h3><p>潜在变量模型（Latent Variable Models）找到一些隐变量进行分类。</p>
<p>主要有四种应用方式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411300120934.png"></p>
<p>a：z 产生 x。</p>
<p>b：x 产生 z。比如 x 是不同书籍，z 是其分类（历史，科幻……）</p>
<p>c：从 x 中提取 z，比如混频信号分离。</p>
<p>d：x 转换为 z 后再重建，比如图片 AI 高清化。</p>
<p>z 需要通过无监督学习找寻。</p>
<h3 id="自动编码器"><a href="#自动编码器" class="headerlink" title="自动编码器"></a>自动编码器</h3><p>自动编码器（Autoencoders）：一种 x-&gt; z-&gt; x 潜在变量模型。依赖于模型参数 θ：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202411302253564.png"></p>
<p>比如 z 是图片 x 的压缩形式，解压得到 x（可能会有损失）。</p>
<h4 id="自动编码器训练"><a href="#自动编码器训练" class="headerlink" title="自动编码器训练"></a>自动编码器训练</h4><p>将无监督问题转化为监督问题的一种案例。选定期望输出 x 值或者原始 x 值作为预期结果，这样就可以计算损失了。</p>
<p>比如：期望加密解密后的输出 x 值和原值相等：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010132334.png"></p>
<p>下面介绍一些自动编码器的案例：</p>
<p><strong>主成分分析（Principal Component Analysis (PCA)）</strong>：</p>
<p>在 AI 课里学过：</p>
<p><a target="_blank" rel="noopener" href="https://stellaris.graysea.cn/kcl/artificial-intelligence-and-decision-making-6ccs3ain-lv6/note#principle-component-analysis-zhu-cheng-fen-fen-xi">https://stellaris.graysea.cn/kcl/artificial-intelligence-and-decision-making-6ccs3ain-lv6/note#principle-component-analysis-zhu-cheng-fen-fen-xi</a></p>
<p>对于 D 维度数据可以很好地提取出 M 个特征向量，M &lt; D.</p>
<p>解码器：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010158780.png"></p>
<p>这里的 W 就是 θ。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010210022.png"></p>
<p>编码器：<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010211177.png"></p>
<p>要去除 inductive bias，就需要从原数据中去掉平均值。</p>
<p>计算损失的方法：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010213093.png"></p>
<p>例：USPS Data Set 手写识别数据集，一张图片的维度是 256 维（每个像素点的颜色可能性）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010233576.png"></p>
<p>现在我们考虑这样两个 w 作为主成分，具体是什么主成分我不太理解，下图的灰度值只是便于理解的呈现（在 16*16 的矩阵方向上对应每个点的灰度值）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010234994.png"></p>
<p>我们用这两个主成分和原 16*16 像素的图片相乘，得到对应两个主成分维度上的所有点的灰度值求和，作图后得到：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010238271.png"></p>
<p>可以比较明显的看出这两个主成分的选择还是蛮正确的，可以有效将数字 01 分开。</p>
<p>这样这个例子就有效的把原来的 256 维度转换为 2 维度（当然这个例子 pick 的太简单了，手写识别里的只考虑 01 情况所以才会降维得这么厉害）。</p>
<p><strong>Neural Autoencoders 神经自动编码器</strong>：</p>
<p>加密解密都是神经网络模型，使用前后向传播方法。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010241248.png"></p>
<h3 id="直接生成模型"><a href="#直接生成模型" class="headerlink" title="直接生成模型"></a>直接生成模型</h3><p>Directed Generative Models 一种 z-&gt; x 模型。</p>
<h4 id="K-聚类算法"><a href="#K-聚类算法" class="headerlink" title="K 聚类算法"></a>K 聚类算法</h4><p>把 n 个 x 数据分配给 k 个聚类（K-means）。z 是分配结果，$$z_{k,n}&#x3D;1$$ 代表第 n 个数据分配给了第 k 簇，$$z_{k,n}&#x3D;0$$  代表不在这个簇里。所有的 z_{k, n} 组成列向量 z。 </p>
<p>分法本质上是每个簇的中心点离该簇内所有 x 数据点的欧几里得距离和最小。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010252586.png" alt=" "></p>
<p>但是我们并不知道怎么选质心点。</p>
<p>所以最开始可以先选择几个 x 点作为质心点，先进行簇分类，然后计算每个簇中所有点的质心。</p>
<p>再根据新质心，重新分类，直到质心不变为止。</p>
<p>损失：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010335392.png" alt=" " style="zoom:50%;" />

<p>例题：注意给定了初始 k 质心了。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010403368.png" style="zoom:50%;" />

<p>首先给这几个点就近分类：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010403073.png" alt=" " style="zoom:50%;" />

<p>然后求平均找质心：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202412010404051.png" alt=" " style="zoom:50%;" />
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Machine-Learning/" rel="tag">Machine Learning</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：Software Engineering 软件工程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ASoftware%20Engineering%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"
    >北邮国院笔记：Software Engineering 软件工程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ASoftware%20Engineering%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="article-date">
  <time datetime="2024-12-01T00:00:00.000Z" itemprop="datePublished">2024-12-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="software-types"><a href="#software-types" class="headerlink" title="software types"></a>software types</h2><p>general: developed for a general market. (ps, office)</p>
<p>custom: developed for a particular aim. (embeded system)</p>
<h2 id="good-software-features"><a href="#good-software-features" class="headerlink" title="good software features"></a>good software features</h2><p>delivers required functionality</p>
<p>usable</p>
<p>efficient</p>
<p>dependable</p>
<p>maintainable</p>
<p>understandable</p>
<p>cost-effective</p>
<p>security</p>
<h2 id="what-is-software-engineering"><a href="#what-is-software-engineering" class="headerlink" title="what is software engineering?"></a>what is software engineering?</h2><p>using proper theories, tools, methods(organized and systematic), constraints to develop high quantity software.</p>
<h2 id="4-layers"><a href="#4-layers" class="headerlink" title="4 layers"></a>4 layers</h2><p>Tools, method, process, quality focus.</p>
<h2 id="Why-important"><a href="#Why-important" class="headerlink" title="Why important?"></a>Why important?</h2><p>large scale projects are hard to finish in time properly because of time, budget, disaster, etc. guiding scientific principles and universally applicable methods can reduce practice and frequent failures.</p>
<h2 id="General-issues-that-affect-software"><a href="#General-issues-that-affect-software" class="headerlink" title="General issues that affect software"></a>General issues that affect software</h2><p>Heterogeneity (distributed systems, different type of devices), business and social change, security and trust, scale.</p>
<h1 id="Software-process"><a href="#Software-process" class="headerlink" title="Software process"></a>Software process</h1><p>a set of structured activities to produce software.</p>
<p>includes: required specification, development(analysis, design, implementation), validation (test), evolution.</p>
<ul>
<li>required specification: what should this system do? a complete desc of the problem and environment constraints. contains: system function, future extension, documentation amount, time and preformance response</li>
<li>analysis: create a conceptual model.</li>
<li>design: implementable model (architecture, components of this system).</li>
<li>implementation: implementation of interfaces.</li>
<li>testing: unit, functional, integration, system, acceptance. test and implementation should run in parallel.</li>
<li>deployment: install, run and test on real environment.</li>
<li>evolution: corrective, adaptive, perfective, preventive.</li>
</ul>
<h2 id="process-models"><a href="#process-models" class="headerlink" title="process models"></a>process models</h2><p>a abstraction of process. activities must be modelled to be managed.</p>
<h3 id="waterfall"><a href="#waterfall" class="headerlink" title="waterfall"></a>waterfall</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332918.png" alt="1685629715429"></p>
<p>易于管理 monitor，结构化很好。前面的模块必须完成才能跳到下一个，也就要求我们在最初设计的时候对需求很清楚，但是很难不遇到一些问题，很难按照正常流程正常走。</p>
<h3 id="evolutionary-development"><a href="#evolutionary-development" class="headerlink" title="evolutionary development"></a>evolutionary development</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685629943510.png" alt="1685629943510"></p>
<p>交互性的活动，及时的反馈。核心需求能很好的满足，但是扩展性很差，结构性很差，缺少过程中的可见性。适合小型项目。</p>
<h3 id="rational-unified-process"><a href="#rational-unified-process" class="headerlink" title="rational unified process"></a>rational unified process</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685630556923.png" alt="1685630556923"></p>
<p>inception: 分析项目可行性。</p>
<p>elaboration: 分析风险，架构。</p>
<p>construction: iterative 迭代开发到 beta 版本为止。</p>
<p>transition: 交付到客户手中。</p>
<p>通用的完整流程，动态。但是开销大了。</p>
<h3 id="Agile-Software-Development"><a href="#Agile-Software-Development" class="headerlink" title="Agile Software Development"></a>Agile Software Development</h3><p>现代软件开发流程：敏捷开发。</p>
<p>Rapid software development 快速开发：争取每一版都交一个可以交付的东西给客户。</p>
<p>敏捷开发：系统在一次一次迭代小增量过程中建立而成。specification, design, implementation, testing 并行。专注于代码，轻量级代码频繁发布，维护简单。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/8a04dc9794b9fae3b772c1efab38b648.png" alt="image-20230507002834816"></p>
<p>Individuals and interactions over processes and tools </p>
<p>Working software over comprehensive documentation </p>
<p>Customer collaboration over contract negotiation </p>
<p>Responding to change over following a plan</p>
<p>敏捷开发需要程序员之外的项目经理，运营，测试……</p>
<p>敏捷开发重视价值，不要设计没价值的东西。实践一定要解决文分体，文档一定要有对应受众，不要过度设计系统。</p>
<p>敏捷开发注重 steer而不是percise prediction。由customer priorities 和 programmer estimates of  feature difficulty 共同制定不断迭代的计划。</p>
<p>开发原则：</p>
<p>• Emphasis on simple design and refactoring.</p>
<p>• Removing duplication.</p>
<p>• Increasing cohesion. </p>
<p>• Reducing coupling</p>
<p>常见的敏捷开发方法：如极限开发 Extreme Programming.</p>
<ul>
<li>每天构建几次新版本</li>
<li>每两周给用户提交一版增量</li>
<li>需求由用户描述</li>
<li>程序员Pair programming（两个人坐一起一起开发，效率差不多，而且对彼此代码更加了解）</li>
<li>先开发测试单元，再写代码</li>
<li>测试过了才算构建完成</li>
</ul>
<p>Test Driven Development (TDD): </p>
<ul>
<li>Define both an interface and a specification. </li>
<li>先写test后写code。</li>
<li>基于增量设计测试 Incremental。</li>
<li>每次构建后自动化测试 Automated。</li>
<li>客户参与测试 User involvement，测试包括程序员单元测试（unit test），客户确认测试（acceptance test，看是否符合需求）。</li>
</ul>
<p>敏捷开发的问题：</p>
<ul>
<li><p>客户易失去积极性 customers interests.</p>
</li>
<li><p>团队成员未必喜欢团队开发。</p>
</li>
<li><p>多方利益相关，prioritising change is difficult.</p>
</li>
<li><p>难维持简洁性，maintaining simplicity.</p>
</li>
<li><p>频繁变化，合同设计困难 contract。</p>
</li>
</ul>
<p>适用于多变的，客户要求明确的中小型系统。</p>
<h2 id="requirements"><a href="#requirements" class="headerlink" title="requirements"></a>requirements</h2><p>确定需求是软工设计中最重要的部分。</p>
<ul>
<li><p>feature to satisfy customer.</p>
</li>
<li><p>indicates what should this sys do.</p>
</li>
<li><p>可能是高层抽象的需求 high-level abstract 或者底层具体的 low-level specific.</p>
</li>
</ul>
<p>Stakeholder 利益相关者：受系统影响的组织或个人（当然有的软件可能是针对市场需求开发，而不存在具体的用户）。这些人站在不同角度上有不同见解。</p>
<p>客户不一定清晰描述其需求，也不一定清楚产品特性和功能，且其需求可能不断变化。</p>
<p>在确定需求环节投入的额外时间长远角度来看会节省更多的时间和金钱。</p>
<p>需求分为：functional 和 non functional.</p>
<h3 id="functional-requirements"><a href="#functional-requirements" class="headerlink" title="functional requirements"></a>functional requirements</h3><p>定义系统的需求，要干什么。比如教务系统对于老师和学生端提供的不同的服务。</p>
<p>这一部分要完整 completeness 清晰一致 consistency 的描述大需求，避免不必要的误解。</p>
<h3 id="non-functional-requirements"><a href="#non-functional-requirements" class="headerlink" title="non-functional requirements"></a>non-functional requirements</h3><p>这一部分比功能性更重要，相当于不满足这一部分系统错误，不满足功能需求系统有一些小bug。</p>
<p>Define system properties and constraints，比如时空复杂度，设备 capability。</p>
<p>Process requirements：比如质量标准，编程语言等。</p>
<p>Organisational requirements: 如系统要符合IT政策规定。</p>
<p>external requirements: 比如“用户密码不能泄露”。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332607.png" alt="1685634113657"></p>
<p>非功能性需求需要定量描述指标。不然比如“希望程序跑的快一点”这就很模糊。要有measure的方法区测量quantitative定量指标。</p>
<h3 id="Requirement-conflicts"><a href="#Requirement-conflicts" class="headerlink" title="Requirement conflicts"></a>Requirement conflicts</h3><p>要trade-off权衡需求，让所有人都同意一个最优需求。</p>
<h3 id="Requirement-document"><a href="#Requirement-document" class="headerlink" title="Requirement document"></a>Requirement document</h3><p>Software Requirements Specification (SRS) 软件需求规范，确认测试的参考规范，指明了应该实现的需求，但是不指明如何实现。</p>
<h3 id="Requirements-Capture"><a href="#Requirements-Capture" class="headerlink" title="Requirements Capture"></a>Requirements Capture</h3><p>Background Reading</p>
<p>Interviewing</p>
<p>Observation（观察用户使用系统的情况）</p>
<p>Document or Record Sampling（专业的observation）</p>
<p>Questionnaires</p>
<h2 id="敏捷开发中的需求"><a href="#敏捷开发中的需求" class="headerlink" title="敏捷开发中的需求"></a>敏捷开发中的需求</h2><h3 id="usr-stories"><a href="#usr-stories" class="headerlink" title="usr stories"></a>usr stories</h3><p>用户需求被称作用户故事，一两句话写在卡片上。</p>
<p>customer 给他们排序需求，development team分解实现任务。</p>
<p><em>As a user,  I want to backup my entire hard drive  so that I won’t lose any work.</em></p>
<p>写在 stories cards 上，按顺序贴在墙上大家讨论，注意重点不是记录而是大家的讨论。</p>
<h3 id="Project-glossary"><a href="#Project-glossary" class="headerlink" title="Project glossary"></a>Project glossary</h3><p>一些项目相关的专业术语，建议总结出来方便大家理解讨论。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230601235612956.png" alt="image-20230601235612956"></p>
<h3 id="Epics"><a href="#Epics" class="headerlink" title="Epics"></a>Epics</h3><p>大的 usr story。通常开始讨论前被拆分为小的块。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230601235720919.png" alt="image-20230601235720919"></p>
<h3 id="Acceptance-Criteria"><a href="#Acceptance-Criteria" class="headerlink" title="Acceptance Criteria"></a>Acceptance Criteria</h3><p>验收标准，通常写在故事卡背面，有助于理解需求和 invite negotiation with the team about the business  value that we are trying to create.</p>
<h3 id="Non-functional-Requirements-as-User-Stories"><a href="#Non-functional-Requirements-as-User-Stories" class="headerlink" title="Non-functional Requirements as User Stories"></a>Non-functional Requirements as User Stories</h3><p>比如用户表示：我希望电脑打cf fps高于100.</p>
<h3 id="usr-stories注意事项"><a href="#usr-stories注意事项" class="headerlink" title="usr stories注意事项"></a>usr stories注意事项</h3><ol>
<li>谁都能写，最好让更多的成员写。</li>
<li>整个 agile development 过程中都可以写。一开始开故事讨论会确定基本，后续随时可以添加。</li>
</ol>
<h3 id="Product-backlog"><a href="#Product-backlog" class="headerlink" title="Product backlog"></a>Product backlog</h3><p>需求按优先级排列的需求表。综合考虑多方因素。</p>
<p>MoSCoW：一种 dsdm 动态系统开发方法。</p>
<ul>
<li>must have：最重要的。</li>
<li>should have：如果时间资源超限可以被取代。</li>
<li>could have：用户期望的需求，完成后用户满意度会高。但是不必要。</li>
<li>want to have: 当前阶段不重要的。</li>
</ul>
<h3 id="Estimating"><a href="#Estimating" class="headerlink" title="Estimating"></a>Estimating</h3><p>估计项目用时。</p>
<blockquote>
<p> story point：故事点，用于表示完成一个产品待办项或者其他任何某项工作所需的所有工作量的估算结果。</p>
<p> 当采用故事点估算时，我们为每个待办项分配一个点数。待办项估算结果的原生数据并不重要，我们只关注最后得到的相对估算结果。一个估算值为2的用户故事应该是估算值为1的用户故事的2倍。而它也应该是另一个估算值为3的用户故事的三分之二。</p>
<p> 团队不要采用100、200、300，或者1百万、2百万、3百万，而要使用1、2、3。估算结果是比值，而不是绝对值。</p>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351172855">敏捷开发中到底什么是故事点（Story Point）？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="评判-good-usr-story"><a href="#评判-good-usr-story" class="headerlink" title="评判 good usr story"></a>评判 good usr story</h3><p>INVEST原则。</p>
<p>– Independent – Negotiable – Valuable – Estimatable – Small – Testable</p>
<h3 id="Prototyping"><a href="#Prototyping" class="headerlink" title="Prototyping"></a>Prototyping</h3><p>physical：比如画gui。</p>
<p>logical：元素，元素之间的关联……</p>
<p>Low-fidelity 低保真：最简单，比如手绘图，纸板做的，快速验证产品概念的可行性。</p>
<p>Medium-fidelity 中保真：数字模型。</p>
<p>high-fidelity：如3d打印，最接近产品但是制作麻烦。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685636483862.png" alt="1685636483862"></p>
<h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>仅仅从用户的需求来看得到的消息不全面，还需要分析。用户可能认为你明白了，或者他考虑不全面，觉得一些地方是不需要的。</p>
<p>因此我们需要分析来 Refining requirements。</p>
<p>gather requirements-analyse in real world context-develop the architecture</p>
<p>分析包括：Textual analysis (针对文档分析)，Entities and concepts（应用层面分析），Experience（过往经验分析）</p>
<h3 id="conceptual-model"><a href="#conceptual-model" class="headerlink" title="conceptual model"></a>conceptual model</h3><p>面向对象的UML图。</p>
<blockquote>
<p>边界类用于系统外部环境与内部交互进行建模的类。我的理解是不同系统之间的胶合层。能够减少系统之间的耦合。</p>
<p>控制类用于对一个或几个用例所特有的控制行为进行建模。控制类源于对用例场景中行为的定义。</p>
<p>实体类是对必须存储的信息和相关行为建模的类。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iron_sky/article/details/45478455">UML-分析类_Iron_Sky的博客-CSDN博客</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602013913446.png" alt="image-20230602013913446"></p>
<p>attributes: 属性和相应数据类型。比如姓名，字符串。</p>
<p>Operations：行为方法。一个operation一般只做一件事。</p>
<p>relationships: – Association – Inheritance.</p>
<ul>
<li>associations 指两个类之间存在双向联系。比如一个老师教多个学生。有1对1,1对多等关系。</li>
<li>Inheritance 继承，父类泛化子类特化。</li>
</ul>
<p>Activities:  </p>
<ol>
<li>Identify Entity, Boundary and Control classes </li>
<li>Identify class relationships </li>
<li>A conceptual class diagram </li>
<li>Identify attributes for each entity class </li>
<li>Add constraints</li>
</ol>
<h2 id="design"><a href="#design" class="headerlink" title="design"></a>design</h2><p>design 是把分析模型转换成设计模型，不是代码实现！implementation才是实现。</p>
<p>design must have a purpose: how things works.</p>
<p>A software design: enough information for a  development team to implement the solution.</p>
<h3 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h3><ul>
<li>finish non-functional requirements</li>
<li>break down the overall task.</li>
<li>Create a ‘skeleton’ of the system 创建易于实现的骨架结构。</li>
</ul>
<h3 id="Fundamental-Concepts"><a href="#Fundamental-Concepts" class="headerlink" title="Fundamental Concepts"></a>Fundamental Concepts</h3><ul>
<li>Abstraction：抽象类和行为的功能。</li>
<li>Encapsulation：information hiding。限制某些对象对内容的直接访问。</li>
<li>Modularity：封装成模块，提供接口给其他模块。</li>
<li>Coupling：耦合，模块间关系紧密程度。最好是loose 松耦合，这样不容易牵一发而动全身。</li>
<li>Cohesion：内聚，模块内部自己元素的相关度。最好是high的。</li>
<li>Refactoring：在代码正常完成要求的前提下修正代码减少重复。主要改进非功能属性。</li>
</ul>
<p>面向对象设计的好处：对象就是实体；对象可以重用，继承；有的系统对象是现实世界的明显映射。</p>
<h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><p>conceptual class diagram</p>
<p>Class Relationships</p>
<p>operations</p>
<p>Describing methods</p>
<p>Captures implementation requirements</p>
<p>Produce detailed design class diagram</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>分析和设计阶段基本上把创意都列出来了。实现就是比较机械地按照前面的设计去敲代码。</p>
<p>利用一些组件去实现。组件主要包括：excutable 可执行文件，file 源码和数据，document，table 数据库表。</p>
<p>implementing subsystem 实现部分功能，利用打包功能导出一个有接口的模块.</p>
<p>Integration Build Plan 迭代构建项目,每次构建指出构建实现的功能和构建需要的子系统、组件。</p>
<p>OOP：有类，对象，方法。但是关联不是双向的，而是只能单向的，比如：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332479.png" alt="1685692184183"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685692194908.png" alt="1685692194908"></p>
<p>一对多可以在一个类里包含另一个类的一个对象集合。</p>
<p>类的实现要从最小耦合到最大耦合 least  coupled to most coupled。</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>在交付给用户前尽可能发现错误，验证每个阶段的结果。测试占据了40%。</p>
<p>组件层面：开发者测试。</p>
<p>集成测试：测试工程师，专注于质量。</p>
<ul>
<li>Validation testing：验证测试，测试系统正常需求已经满足。</li>
<li>Defect testing：检测系统的缺陷。</li>
</ul>
<h3 id="Testing-policies"><a href="#Testing-policies" class="headerlink" title="Testing policies"></a>Testing policies</h3><p>我们不可能把所有可能情况都找到并且测试出来。因此只能选取有代表性的子集。</p>
<p>好的测试：测试人员能预料到可能哪里出错；没有多余的测试用例；应选取“最可能出错”的用例；合适的复杂程度。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685693050733.png" alt="1685693050733"></p>
<p>test case：输入的规范和预期的输出。</p>
<p>test data：输入。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685693215844.png" alt="1685693215844"></p>
<h3 id="testing-strategy"><a href="#testing-strategy" class="headerlink" title="testing strategy"></a>testing strategy</h3><p>what 测试用例？when 测试？how to 测试？如何比对输出是否正确？</p>
<p>test cases 示例（正确的输入。错误的输入比如学号输入英文）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602160905111.png" alt="image-20230602160905111"></p>
<p>Test Procedures 测试程序，通常设置为可通用的，便于之后修改重用。这个程序不一定是代码，可能以流程指导的形式（比如按下login按钮，输入账号99001122登录……）</p>
<p>test matrix: </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602161119974.png" alt="image-20230602161119974"></p>
<p>发现缺陷：比如上例，错误的密码也能登录，于是测试工程师把错误信息返回给开发者：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602161157432.png" alt="image-20230602161157432"></p>
<h3 id="Testing-Techniques"><a href="#Testing-Techniques" class="headerlink" title="Testing: Techniques"></a>Testing: Techniques</h3><p>黑盒测试，black box&#x2F;behavior test，即我们要测试的模块，对我们来说像一个内部结构不可见的黑盒子，我们重点关注他行为对不对，与外界的接口是否正确，访问外界数据库正不正确。</p>
<ul>
<li>Partition testing：典型的黑盒测试，把数据分成等效的几个区域，比如正数负数0.</li>
<li>Scenario-based testing：从用户角度触发，分析用户可能的正确和错误操作。</li>
<li>Regression Testing：集成测试，随着添加增量也不断添加新测试，每次运行所有测试用例，确保系统更新的时候以前的功能没有受干扰。</li>
</ul>
<p>白盒测试，white&#x2F;glass&#x2F;clear box test，主要关注程序内部结构按规范运行，所有内部组件都正确。</p>
<p>确保盒内的所有路径都被正确执行过；考虑正确和错误用例；在边界内外测试；尽量使用内部数据结构。</p>
<ul>
<li>Basis Path Testing：执行所有路径的最少用例数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685696256126.png" alt="1685696256126"></p>
<p>总体测试流程：白盒测试，建立 test harness 测试装置，测试正确性，测试健壮性；然后黑盒测试。</p>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="number">20</span>, student.getAge());<span class="comment">//判断返回值是不是20岁</span></span><br></pre></td></tr></table></figure>

<p>在开发代码前编写测试。 simple, short-cycled mechanism。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332492.png" alt="1685710646767"></p>
<p>small cycle：编写测试，编写代码，测试失败，修改代码，测试通过。</p>
<h1 id="Software-architecture"><a href="#Software-architecture" class="headerlink" title="Software architecture"></a>Software architecture</h1><p>功能需求和软件架构关系紧密，非功能需求是软件架构的选择结果（好的架构运行效率高之类的）。可以以表格或图的形式，比如UML图。</p>
<p>设计难以更改。敏捷开发的早期阶段就是设计系统架构。</p>
<p>好处：</p>
<ul>
<li>system analysis：利于分析系统是否满足非功能需求。</li>
<li>large-scale reuse：架构可重用，更安全、更快。</li>
<li>Stakeholder communication：可以 成为一个讨论点。</li>
</ul>
<h1 id="Project-management"><a href="#Project-management" class="headerlink" title="Project management"></a>Project management</h1><p>让项目能在有限的时间和预算范围内按预期保质落地。</p>
<p>软件工程比较灵活，没有标准的完全正确的方案，需要随机应变，敏锐的洞察力。</p>
<h2 id="Project-planning"><a href="#Project-planning" class="headerlink" title="Project planning"></a>Project planning</h2><p>最耗时的环节。</p>
<p>计划只有在项目完成时才算完成，因为计划在项目开发阶段也不断变化。</p>
<p>计划可能包括多种，如质量计划，员工开发计划……</p>
<h2 id="Activity-organisation"><a href="#Activity-organisation" class="headerlink" title="Activity organisation"></a>Activity organisation</h2><p>活动应该组织成切实的输出以及可以判断的进度。</p>
<p>milestone：标志阶段的结束，不一定是能输出给用户的成果。比如文档，或者逻辑阶段的结束。</p>
<p>Deliverables：可以交付给用户的设计，规格等成果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332283.png" alt="image-20230602221047262"></p>
<h2 id="Project-scheduling"><a href="#Project-scheduling" class="headerlink" title="Project scheduling"></a>Project scheduling</h2><p>估计项目时间预算的花费，并按顺序排布。</p>
<p>比较难估计。通常根据过往项目经验估计。</p>
<p>先把大项目分解为几个小项目，然后并发的组织任务——尽可能充分利用劳动力 workforce，以及 Minimise task dependencies 尽量减少因为前面的任务没完成对后面任务的延误。</p>
<p>要对错误有预期，没错误是不可能的。约30%预料到的问题+20%未预料到的问题。</p>
<p>通常用图表表示：</p>
<p>任务表：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724379869.png" alt="1685724379869"></p>
<p>活动网：最长的是关键路径，因为这条路径任务要是延期了，整个工期都要延期。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724395138.png" alt="1685724395138"></p>
<p>甘特图：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724424966.png" alt="1685724424966"></p>
<p>Monitoring&#x2F;Reporting：定期周会周报监督进度。</p>
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>代码行数，代码中的缺陷，测试用例通过情况。</p>
<h3 id="People-in-the-process"><a href="#People-in-the-process" class="headerlink" title="People in the process"></a>People in the process</h3><p>选择成员，管理，激励他们，解决大家遇到的技术和非技术问题。</p>
<ul>
<li>Consistency：对大家态度一致。</li>
<li>Respect：大家拥有技能不同，互相尊重。</li>
<li>Inclusion：让大家都参与进项目，聆听所有人的意见。</li>
<li>Honesty：进度保持诚实。</li>
</ul>
<h3 id="Group-working"><a href="#Group-working" class="headerlink" title="Group working"></a>Group working</h3><p>不仅仅是个人的集合。团队能力的组成，凝聚力，沟通，大型团队的层次结构。</p>
<p>敏捷开发的团队合作方法：Scrum approcah，有一个Scrum master，日会，跟随进度，记录决策，和客户等沟通。</p>
<p>项目被分解为易于管理和理解的小部分。不稳定的需求不影响项目进度。团队成员对项目把控更到位 visibility，客户能常常看到项目进度，双方交流更相信彼此。</p>
<h2 id="Risk-management"><a href="#Risk-management" class="headerlink" title="Risk management"></a>Risk management</h2><p>失败是常有的事。我们要做好备选方案，推迟时间或者放弃目标。</p>
<p>风险管理是预测可能的失败，决定该在什么地方制定备选方案 alternative plans 。</p>
<p>Project risks：项目开发或者资源的问题。比如项目员工走了；原材料没法及时收到了；项目要求时间提前了。</p>
<p>Product risks：产品质量和性能的问题。比如开发软件出bug了，开发出的软件质量不行，用户对gui不满意，有没考虑到的错误。</p>
<p>Business risks：开发，采购组织的问题。比如上市了发现其他公司的技术，竞品比我们的好；负责该系统的组织因财务原因倒闭了。</p>
<p>Project+Product：需求一直变；分析阶段太慢了；开发团队技能能力不行；项目比预想的要大。</p>
<h3 id="Risk-Identification"><a href="#Risk-Identification" class="headerlink" title="Risk Identification"></a>Risk Identification</h3><p>识别风险。</p>
<h3 id="Risk-Analysis"><a href="#Risk-Analysis" class="headerlink" title="Risk Analysis"></a>Risk Analysis</h3><p>评估风险的影响。</p>
<h3 id="Risk-Planning"><a href="#Risk-Planning" class="headerlink" title="Risk Planning"></a>Risk Planning</h3><p>制定应对风险的计划。</p>
<h3 id="Risk-Monitoring"><a href="#Risk-Monitoring" class="headerlink" title="Risk Monitoring"></a>Risk Monitoring</h3><p>在项目开发过程中监控风险。</p>
<h3 id="Avoidance-Strategies"><a href="#Avoidance-Strategies" class="headerlink" title="Avoidance Strategies"></a>Avoidance Strategies</h3><p>尽量使用熟悉的模式，但是也接受新技术，时刻关注市场动向；</p>
<p>对员工合理培训，确保技术没被掌握在一个人手中；创造良好的工作环境；</p>
<p>员工不要欺瞒进度，高管要时刻了解进度以及其对项目的重要性。</p>
<h3 id="Contingencies-突发事件"><a href="#Contingencies-突发事件" class="headerlink" title="Contingencies 突发事件"></a>Contingencies 突发事件</h3><p>换人，换工具，换资源。</p>
<p>改变，舍弃一部分目标。</p>
<p>争取做的改动最小，但是损失也降到最小。</p>
<p>我们知道敏捷开发持续提交小版本，因此经常进行测试修改当阶段错误。但是缺陷在于敏捷开发不注重长远眼光 long term planning，因此可能带来一些问题。</p>
<h2 id="Quality-Management"><a href="#Quality-Management" class="headerlink" title="Quality Management"></a>Quality Management</h2><p>对质量的评估，最好从软件开发过程中抽离出来。因为开发的过程会错误影响开发者自己对质量的评估（我都这么努力了，做出来的东西肯定很好吧）。</p>
<p>瀑布模型中在系统实现后单独测试软件质量。敏捷开发在每次发布新版本的时候测试。因为主要是在实际使用场合的测试，因此会比“为了达成测试而开发”的系统想的更多一些。</p>
<p>好的软件符合目的 Fitness for purpose，标准好，易于使用，高效，代码写的好（当然从用户角度来说他看不到这一层。但是代码写得好是前提，比如时间复杂度运行得快）。开发者需要考虑用户的需求前提下，自己用专业知识思维去想：这个需求实现合理吗。然后多喝用户沟通表达看法。</p>
<p>区分bug和特性：正常运行的是特性。有的时候哪怕系统除了意想不到的bug，但是功能意外的很合适，这也可以是特性。</p>
<p>特性很难移除，当用户开始依赖特性功能的时候，移除用户可能不乐意不习惯；而且向后（版本）兼容变得很难。</p>
<p>软件标准有很多好处，新员工快速入手，大家更熟悉项目等，但是标准可能对一些过去常常发生而现在不怎么出现的问题采取忽略的态度，从而兼容性上出现问题；而且可能浪费很多时间填文书。注重标准好的部分。</p>
<h2 id="Design-principle"><a href="#Design-principle" class="headerlink" title="Design principle"></a>Design principle</h2><p>设计的软件不仅要正确，高效运行，还要在限定时间，人力，软件，经济条件下。差代码后期可能要花很多时间弥补隐患；而且不同模块的代码经常交互，差代码还会有安全隐患。</p>
<p>我们仅仅想着怎么“正确”地编写代码是不够的，还要更省事省力地去开发。</p>
<p>Software lifespan：软件生命周期，软件是一直在持续开发的，比如新技术，客户新需求。</p>
<p>Software scale：项目大多数规格很大，很多人开发，代码多，多次修订。</p>
<p>Decomposition：项目分解为小模块开发。有Locality（实现一个模块可以不用检查其他模块的实现）和Modifiability（修改一个模块也不用考虑用使用这个模块的模块）的特点。</p>
<p>Specification and implementation：规范连接了设计和实现，规定了模块应该提供哪些服务以及如何使用服务。模块之间的交互应该仅仅限于规范，以此实现分解后模块的locality和modifiability。</p>
<p>Classes and Methods：面向对象思想中的模块为类。</p>
<p>Separation：分开考虑一个模块要实现的功能what和如何实现how。一个应用程序级别，一个实现级别。</p>
<p>Splitting Methods and Classes：设计方法和类的时候好好考虑如何拆分方法和类。类太大了考虑一下要不要拆，几个变量模式比较常用考虑一下要不要抽象成类。</p>
<p>Helper Methods and Classes：有一些方法和类只是为了抽象出来辅助拆分代码用的，这种一般是私有的helper method和嵌套的nested class，只在特定类里起作用，对其他类是private的。</p>
<p>Reuse：用以前的代码重复实现功能，节约代码，而且一改全改。重用代码可能厂商提供，编程语言提供，早期开发者开发。</p>
<p>Abstraction and generalisation：抽象是提取一些概念，比如接口，类；泛化是提取一些重复元素，以便代码重用，比如父类。</p>
<p>UML class diagrams：比代码更高的层次，是面向对象编程很重要的内容。</p>
<p>Static v. Dynamic：匹配静态内容和代码运行时产生的内容。对应UML中的类图 class diagram 和顺序图 sequence diagram。</p>
<p>图源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lingchen336/article/details/111400141#:~:text=UML%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%9B%BE%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%97%B6%EF%BC%8C%E4%BC%9A%E6%8C%89%E7%85%A7%E6%80%8E%E6%A0%B7%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E3%80%81%E9%82%A3%E4%BA%9B%E7%8E%B0%E8%B1%A1%E4%BC%9A%E4%BE%9D%E4%BB%80%E4%B9%88%E9%A1%BA%E5%BA%8F%E5%8F%91%E7%94%9F%E3%80%82,%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E2%80%9C%E4%B8%8D%E5%9B%A0%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%88%E9%9D%99%E6%80%81%E5%85%B3%E7%B3%BB%EF%BC%89%EF%BC%8C%E4%BA%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE%E5%88%99%E8%A1%A8%E7%A4%BA%E2%80%9D%E9%9A%8F%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A1%8C%E4%B8%BA%EF%BC%89%E2%80%9C%E3%80%82">UML类图与顺序图_顺序图和类图的关系_lingchen336的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/2020121909185527.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332627.png" alt="img"></p>
<p>class and objects：类和对象。对象是类的实例 instance。两者关系很像static 中的method和动态中的method call。</p>
<p>static：静态方法只能被类自己和其附加类调用。静态类实例化的对象是只有一个通用的对象，而不是实例化出无数个对象。</p>
<p>Variables and referencing：java中变量是对对象的引用，比如var2&#x3D;var1不是赋值而是改变var2指向var1的引用。包括一个变量的自带方法的</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332273.png" alt="image-20230603233317997"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685806438306.png" alt="1685806438306"></p>
<p>Scope and garbage collection：对象的作用域只要有变量还在引用这个对象，他就活着。没有人引用的时候就自动垃圾回收。</p>
<p>基本设计原则：设计对象指代目标；对象方法指代其能做的操作；Locality和Modifiability；对象只能通过方法调用交互。</p>
<p> Client-Contractor model：一种思想，一个对象调用其他对象的方法得到返回值来使用它，像客户和承包商一样。现代社会大进步的原因就是大家各专其职，因此项目中各个类各专其职也能在同样的量的前提下发挥更多的作用。</p>
<ul>
<li><p>客户给承包商的合同就类似定义类和方法的规范specification。代码编写者有义务Obligations拿了钱benefits，就确保软件正确执行，不做破坏的事等。</p>
</li>
<li><p>Design by Contract：一种思想。客户端代码应当满足承包商的先决需求pre-conditions；应当对异常做处理（exception）；后置条件post-conditions在测试中作为断言assertions合并到程序中。（前置条件：前提；后置条件：方法运行后的状态）</p>
</li>
</ul>
<h3 id="Single-Responsibility-Principle-SRP"><a href="#Single-Responsibility-Principle-SRP" class="headerlink" title="Single Responsibility Principle (SRP)"></a><strong>Single Responsibility Principle (SRP)</strong></h3><p>单一责任原则：每个类有一个职责 responsibility，其所有对象都服务于这个职责。Leads to highly cohesive 内聚性高</p>
<h3 id="Open-Closed-Principle-OCP"><a href="#Open-Closed-Principle-OCP" class="headerlink" title="Open-Closed Principle (OCP)"></a>Open-Closed Principle (OCP)</h3><p>开放闭合原则：模块（类和方法）open to extension，close to modification </p>
<p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>
<p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。比如一个类以不同对象形式表现这就是扩展，因为需求改变或者有新需求。</p>
<h3 id="Do-not-Repeat-Yourself-principle-DRY"><a href="#Do-not-Repeat-Yourself-principle-DRY" class="headerlink" title="Do not Repeat Yourself principle (DRY)"></a><strong>Do not Repeat Yourself principle (DRY)</strong></h3><p>不要复读机原则（不要重复自己原则）。本模块中如果发现重复内容，建议再抽象为方法和类。</p>
<h3 id="Liskov-Substitution-Principle-LSP"><a href="#Liskov-Substitution-Principle-LSP" class="headerlink" title="**Liskov Substitution Principle (LSP) **"></a>**Liskov Substitution Principle (LSP) **</h3><p>Liskov替代原理：重写方法，不应该抱着”修改其方法“的想法。不能加强 strengthen 前置条件，不能削弱 weaken 后置条件。</p>
<p>比如父类people方法AddPeople(String name, int age) 子类Student构造方法AddPeople(String name, int age)里先校验一下学生年龄，如果年龄大于25岁则不允许add，这就修改了原来方法。这就是前置条件加强了，要求年龄的限制多了。</p>
<p>后置条件比如原来返回值大于0，现在返回值可以小于0了，那么返回值限制弱了，后置条件削弱了，不满足里氏原则。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ITPower/p/14826144.html">设计模式六大原则(二)—-里式替换原则 - 盛开的太阳 - 博客园 (cnblogs.com)</a></p>
<p>Association, Aggregation and Composition：association是两个不同东西的对应，比如家长和孩子。另外两个是子集，aggregation是彼此可以独立存在，比如班级和学生。composition是可以彼此独立存在，比如house和room。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685957816284.png" alt="1685957816284"></p>
<p>有的时候继承满足不了LSP（比如令正方形为矩形的子类），可以使用聚类来防止破坏LSP。</p>
<h3 id="Interface-Segregation-Principle-ISP"><a href="#Interface-Segregation-Principle-ISP" class="headerlink" title="Interface-Segregation Principle (ISP)"></a><strong>Interface-Segregation Principle (ISP)</strong></h3><p>接口隔离原则：首先接口应该尽量分解为小接口。客户端每个类不应该依赖他不使用的方法。就是接口用啥实现啥，别多实现。</p>
<h3 id="Dependency-Inversion-Principle-DIP"><a href="#Dependency-Inversion-Principle-DIP" class="headerlink" title="Dependency-Inversion Principle (DIP)"></a>Dependency-Inversion Principle (DIP)</h3><p>依赖倒置原则：</p>
<blockquote>
<p>如果高层模块直接调用低层模块提供的服务，那么就是具体耦合关系，这样高层模块依赖于低层模块就不可避免。但是，如果我们使用抽象耦合关系，在高层模块和低层模块之间定义一个抽象接口，高层模块调用抽象接口定义的方法，低层模块实现该接口。这样，就消除了高层模块和低层模块之间的直接依赖关系。现在，高层模块就不依赖于低层模块了，二者都依赖于抽象。同时也实现了“抽象不应该依赖于细节，细节应该依赖于抽象”。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158391778">面向对象基础设计原则：4.依赖倒转原则 - 知乎 (zhihu.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/171757199427415.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaochundong/p/dependency_inversion_principle.html">依赖倒置原则（Dependency Inversion Principle） - sangmado - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h2 id="Design-Patterns"><a href="#Design-Patterns" class="headerlink" title="Design Patterns"></a>Design Patterns</h2><h3 id="Decorator-Design-pattern"><a href="#Decorator-Design-pattern" class="headerlink" title="Decorator Design pattern"></a>Decorator Design pattern</h3><p>用于扩展系统功能的装饰模式。</p>
<p>比如我们有一个鸭子类，可以调用其鸭子叫的方法。我们初始化了一个鸭子对象，如何统计这个对象叫了几次，也就是其鸭子叫方法被调用了几次？记住OCP原则不允许我们直接修改鸭子类。</p>
<p>我们可以用一个计数类来把鸭子类包住。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332689.png" alt="image-20230605183433552" style="zoom:67%;" />

<p>装饰模式实现一个接口，接口中的方法通过该变量的同一个参数去调用同一个方法，比如本例中是鸭子呱呱的计数，每次调用++。</p>
<h3 id="Adapter-design-patterns"><a href="#Adapter-design-patterns" class="headerlink" title="Adapter design patterns"></a>Adapter design patterns</h3><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332186.png" alt="1685983233527" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685983255642.png" alt="1685983255642"></p>
<p>这个例子包括了几个原则：</p>
<ol>
<li>首先不同接口功能尽量分开，ISP，也就是说鸭子叫和计数不要写一个方法里。</li>
<li>不能直接修改类，OCP。</li>
<li>如果想鸭子叫同时计数，直接调用包装类即可，DRY。</li>
<li>GooseAdapter 只访问了 Goose 的 honk 方法而不是对其完全访问，DIP。这里如果改成继承的子类，就有全部访问权了。</li>
</ol>
<h3 id="Wrapper-design-patterns"><a href="#Wrapper-design-patterns" class="headerlink" title="Wrapper design patterns"></a>Wrapper design patterns</h3><p>Wrapper 模式包括 decorator 和 adapter。decorator 主要是外面的包裹类和里面的类都实现一个接口，比如上例的鸭子嘎嘎。adapter 是内部类不需实现。</p>
<p>Immutable View：前面提过java引用的问题，比如两个变量引用同一个对象，一改都改。这样就相当于有引用的时候，该目标对象完全暴露出来了。在wrapper里我们可以限制包装类：禁止修改对象，修改则抛出异常。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685986070602.png" alt="1685986070602"></p>
<h3 id="Composite-Design-Pattern"><a href="#Composite-Design-Pattern" class="headerlink" title="Composite Design Pattern"></a>Composite Design Pattern</h3><p>包装了一个集合。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685985869548.png" alt="1685985869548"></p>
<h3 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h3><p>比如看到绿灯汽车知道该走了，这种观察者一个变量改变影响其他变量的实现。</p>
<p>java是提供了observable的api的，当对应变量值改变时触发函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332446.png" alt="1685986641156"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685986768769.png" alt="1685986768769"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332896.png" alt="1685986796502"></p>
<p>不过这种写法违反了OCP，因为我们修改了dogbot让他主动实现observer的update。我们可以采用decorator design 方法。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685989787205.png" alt="1685989787205"></p>
<p>如果dogbots是一个接口，dogwatcher 可以实现计数功能，还可以在文件，在gui中实现dogbots，实现集合的dogbots，两者代码几乎是分离的。</p>
<p>我们先用一个ObservableDogBot类继承Observable，且实现未完成的dogbots，然后写一个dogreporter实现observer。最后<code>rover.addObserver(reporter1);</code></p>
<h3 id="Factory-Methods"><a href="#Factory-Methods" class="headerlink" title="Factory Methods"></a>Factory Methods</h3><p>如果我们设定饥饿值大于6的狗要被构造为greedyDogBot是普通狗的子类，那么PlainDogBot和greedyDogBot都直接提供出来构造方法不太好。可以通过一个构造类来判断需要返回什么对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606123312445.png" alt="image-20230606123312445"></p>
<p>这个构造方法可以返回接口类，但是实际方法里返回的都是实现了接口类的具体类，这样可以隐藏返回类类型：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026157643.png" alt="1686026157643"></p>
<p>工厂类甚至自己可以包装好类然后送回来一个包装类：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332407.png" alt="1686026296136"></p>
<p>当然工厂方法除了静态的，也可以是非静态的工厂对象。我们可以利用不同的工厂对象包装不同的包装类，这样还能进一步隐藏返回对象的一些信息。</p>
<p>比如下一个例子中，spy狗多一个watcher。我们用多态方法初始化两个 Dog Factory，但是一个是实际SpyDogFactory类型的，一个实际是PlainDogFactory类型的，因此两者调用makeDogBot的时候会返回不同的狗。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026555327.png" alt="1686026555327"></p>
<p>像计数等额外包装功能，我们也可以不用“先用一个计数类包装普通类，再用工厂类包装计数类”，而是把计数内容包装在工厂类里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026955303.png" alt="1686026955303"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026838784.png" alt="1686026838784"></p>
<h3 id="Singleton-Design-Pattern"><a href="#Singleton-Design-Pattern" class="headerlink" title="Singleton Design Pattern"></a>Singleton Design Pattern</h3><p>构造方法不一定返回必须是新创建的对象，工厂类里可以返回已有的对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332922.png" alt="1686027588395"></p>
<p>注意LSP原则。</p>
<h3 id="Object-Pool-Design-Pattern"><a href="#Object-Pool-Design-Pattern" class="headerlink" title="Object Pool Design Pattern"></a>Object Pool Design Pattern</h3><p>对象池模式，保留一个对象列表，在需要的时候返回一个特定对象。</p>
<h3 id="Strategy-Design-Pattern"><a href="#Strategy-Design-Pattern" class="headerlink" title="Strategy Design Pattern"></a>Strategy Design Pattern</h3><p>选择要执行的策略。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686027938500.png" alt="1686027938500"></p>
<p>上图是狗执行几次action的函数。我们也可以利用重写的Comparator实现条件结构，比如比较ab两狗叫了几次，叫的少的补差。</p>
<h3 id="State-Design-Pattern"><a href="#State-Design-Pattern" class="headerlink" title="State Design Pattern"></a>State Design Pattern</h3><p>可以改变对象的状态类型。</p>
<p>下面改变的几个类型都是accountState抽象类的实现类，通过多态的方式初始化。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332513.png" alt="image-20230606180142747"></p>
<h3 id="Bridge-Design-Pattern"><a href="#Bridge-Design-Pattern" class="headerlink" title="Bridge Design Pattern"></a>Bridge Design Pattern</h3><p>解耦思想。比如我们需要12种颜色的画笔，可以选择12根固定颜色的蜡笔，或者1根毛笔和12种颜料。毛笔的例子就很好地解耦了画笔和颜色。</p>
<p>例子来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/LoveLion/article/details/7464183">处理多维度变化——桥接模式（一）_LoveLion的博客-CSDN博客</a></p>
<p>下例：求父子交集。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606181219816.png" alt="image-20230606181219816"></p>
<h3 id="Flyweight-Pattern"><a href="#Flyweight-Pattern" class="headerlink" title="Flyweight Pattern"></a>Flyweight Pattern</h3><p>将那些大量的，具有很多内部状态而外部状态很少的对象进行共享，可以以类似缓存的方式共享。</p>
<p>概念来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336732854">精读《设计模式 - Flyweight 享元模式》 - 知乎 (zhihu.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606181617881.png" alt="image-20230606181617881"></p>
<h1 id="Open-Source-Software"><a href="#Open-Source-Software" class="headerlink" title="Open Source Software"></a>Open Source Software</h1><p>free of charge, free of legal restrictions on usage. </p>
<p>也需要敏捷开发，但是开发方式略有不同，毕竟不是利益相关的模式。强调个人之间的密切交互 close personal interaction，开发者也是自己的客户，因此有很多人做测试，而且修改后的小版本可以很快发布；通常分的小模块很多，世界各地的大家分别开发。</p>
<p>世界各地大家通过电子方式互相交流 electronically。</p>
<p>整体协调者 overall co-ordinator 通常由志愿者负责。</p>
<p>商业软件和OSS就像大教堂和集市的区别，大教堂需要有一个整体的建造目标，大家一同努力。集市可能由城管那样的整体协调者管大家秩序，但是大家还是偏personal一点。</p>
<p>如果自己公司自己开发项目，当然需要大量人力财力开发和后期维护；选择闭源软件，就绑定在供应商身上了（垄断技术），他们需要进一步收费咱也得交。开源软件就不用担心支付费用这类问题或者供应商倒闭问题，但是不是是开源软件就能拿来用的，注意版权问题。</p>
<p>开源软件大多数有一小部分人在开发核心core以及新功能，大多数人在correcting  defects。大多数情况下开发者更愿意维护现有fork分支而不是一味开发新分支。</p>
<p>开源软件也有一个control structure，通常由最初提出项目的人拥有软件的最终决议权，由一些商业公司管理而并非个人（这样能多保质一点），比如安卓开源软件由谷歌掌握控制权，对于提交的fork和patch有权最终决定下一个版本更新的内容。</p>
<ul>
<li>contributor：OSS中做贡献的人。</li>
<li>developer：在软件平台上开发应用的人。</li>
<li>verifier：测试 change request 是否正确的人。</li>
<li>approver：决定这些修改是否要合并进大版本的人，和verifier都需要审核面试筛选。</li>
<li>Project leads：监督单个项目的工程。</li>
</ul>
<h2 id="software-freedom"><a href="#software-freedom" class="headerlink" title="software freedom"></a>software freedom</h2><ul>
<li><p>运行程序的自由 run the program</p>
</li>
<li><p>学习程序运行原理和按自己意愿修改代码的自由 study how this program works, change it so it does your compute as you wish （当然前提是能访问到源码）</p>
</li>
<li><p>分发软件副本的自由 redistribute copies</p>
</li>
<li><p>发布自己的版本给他人的自由  distribute copies of your modified versions to others。</p>
</li>
</ul>
<h2 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h2><p>只有制作者producer有权利制作副本和创建新内容 produce copies and create new work based on it，但是可以授权允许别人复制和改编该作品 make copies of the work and adapt it。制作者可以通过收费等方式赋予这些权力给他人，或者对改编的范围加限制，因为这算是加在producer身上的一种义务，有点回报也正常。</p>
<h2 id="Copyleft"><a href="#Copyleft" class="headerlink" title="Copyleft"></a>Copyleft</h2><p>但是OSS的版权声明采用的是copyleft，一种 free software license，并不是限定他人复制改编的权力，而是赋予他人这种权力。许可证内容包括：声明源代码可用，以及改编允许的范围。</p>
<h2 id="voting"><a href="#voting" class="headerlink" title="voting"></a>voting</h2><p>有权投票的人每人最多一票；没权投票的人不能投；有权投票且选择投票的人不能被阻止投票；其须拥有充足的选择 full choice；其投票结果必须被正确统计不能被别人篡改；总票数正确相加，不能篡改；大多数时候没有人能知道任何一个投票者的选择。</p>
<p>电子投票有风险，比如数据容易被篡改，被伪造等。</p>
<h1 id="Software-Development-Tools"><a href="#Software-Development-Tools" class="headerlink" title="Software Development Tools"></a>Software Development Tools</h1><h2 id="Software-Craftsmanship-and-Clean-Code"><a href="#Software-Craftsmanship-and-Clean-Code" class="headerlink" title="Software Craftsmanship and Clean Code"></a>Software Craftsmanship and Clean Code</h2><p>注意代码整洁，比如格式、注释等。</p>
<h2 id="Saying-“No”"><a href="#Saying-“No”" class="headerlink" title="Saying “No”"></a>Saying “No”</h2><p>不要一直盲目答应老板和客户的需求，程序员更熟悉代码，而且需要帮老板规避可能发生的错误。</p>
<h2 id="Learning-from-Mistakes"><a href="#Learning-from-Mistakes" class="headerlink" title="Learning from Mistakes"></a>Learning from Mistakes</h2><h2 id="Microsoft’s-Best-Practices"><a href="#Microsoft’s-Best-Practices" class="headerlink" title="Microsoft’s Best Practices"></a>Microsoft’s Best Practices</h2><h3 id="Revision-Control-System"><a href="#Revision-Control-System" class="headerlink" title="Revision Control System"></a>Revision Control System</h3><p>版本控制。</p>
<p>roll-back：版本回滚。</p>
<p>check-out：开发者拉下来代码。</p>
<p>check-in：开发者提交自己的修订版。</p>
<p>conflict：两个人的提交出冲突了。</p>
<p>merge：合并入主分支。</p>
<h3 id="Daily-Build"><a href="#Daily-Build" class="headerlink" title="Daily Build"></a>Daily Build</h3><p>每日构建一次代码，编译链接源代码，进行一些测试，确保第二天大家能使用最新版本。</p>
<h3 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h3><p>开发人员也建议每天check-in一次。</p>
<h3 id="Build-Verification-Tests"><a href="#Build-Verification-Tests" class="headerlink" title="Build Verification Tests"></a>Build Verification Tests</h3><p>断言和单元测试。</p>
<h3 id="Bug-Database"><a href="#Bug-Database" class="headerlink" title="Bug Database"></a>Bug Database</h3><p>记录以前的bug记录，解决方法，严重程度，优先级等信息。</p>
<h3 id="War-Team-and-Bug-Triage"><a href="#War-Team-and-Bug-Triage" class="headerlink" title="War Team and Bug Triage"></a>War Team and Bug Triage</h3><p>发布前，作战小组确认系统“好到可以发布”。检查运行是否正常，剩余的bug严重程度等。</p>
<h3 id="Code-reviews-and-coding-guidelines"><a href="#Code-reviews-and-coding-guidelines" class="headerlink" title="Code reviews and coding guidelines"></a>Code reviews and coding guidelines</h3><p>团队对彼此代码进行彻底审查。</p>
<h3 id="Globalisation-and-Localisation"><a href="#Globalisation-and-Localisation" class="headerlink" title="Globalisation and Localisation"></a>Globalisation and Localisation</h3><p>针对不同语言、脚本的差异处理。</p>
<h3 id="Documentation-Generators"><a href="#Documentation-Generators" class="headerlink" title="Documentation Generators"></a>Documentation Generators</h3><p>文档生成。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Software/" rel="tag">Software</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：存算一体芯片的潜力与挑战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/29/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/"
    >技术学习：存算一体芯片的潜力与挑战</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/29/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/" class="article-date">
  <time datetime="2024-01-29T00:00:00.000Z" itemprop="datePublished">2024-01-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文学习自：存算一体芯片深度产业报告——作者：量子位</p>
<p>报告链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/557673211">存算一体是啥新趋势？值得教授学者纷纷下海造芯 | 附报告下载 - 知乎 (zhihu.com)</a>，侵删！</p>
<h1 id="存算一体技术概述"><a href="#存算一体技术概述" class="headerlink" title="存算一体技术概述"></a>存算一体技术概述</h1><p>“存算一体”技术的起因在于传统冯诺依曼架构芯片无法满足不断提升的算力与低功耗需求。随着晶体管的体积越来越小，摩尔定律逐渐失效（会引发量子隧穿等反应），导致存储器与处理器之间的数据传输成为 CPU 性能的瓶颈，相对较长时间的数据搬运导致算力受限。</p>
<p>为了解决这个问题，我们需要新的芯片架构。主要有三种解决方式：</p>
<ol>
<li>近存计算：缩短处理器芯片与存储器芯片的距离，减少数据搬运损耗。</li>
<li>内存储计算：处理器和存储器位于同一芯片的不同电路单元中。</li>
<li>内存执行计算：通过在存储器颗粒上嵌入算法，由存储器芯片内部的存储单元完成计算操作。</li>
</ol>
<h1 id="产业分析"><a href="#产业分析" class="headerlink" title="产业分析"></a>产业分析</h1><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20240129171851417.png" alt="image-20240129171851417"></p>
<p>存算一体芯片落地的优势在于在算力提高的同时，芯片体积的减小和数据传输功耗的减少，使得芯片良率、成本、功耗等都有所改善。然而，实际应用的挑战主要在于评估市场需求和客户转换成本。重要的考量是，大规模采用新型芯片是否能够在成本和能耗方面带来足够的改进，以证明其经济效益；新架构芯片的先进生产工艺制造能力；客户对低功耗和高算力的需求；以及封装、测试、工具链、EDA 等相辅相成的产业链生态仍缺乏相应的研发公司。</p>
<p>当下大多数初创公司的思路是先聚焦特定场景，在垂直领域内站稳脚跟后技术外溢到更丰富的应用场景。主要的应用场景包括小算力低功耗场景（知存科技、九天睿芯和闪易半导体等）和大算力场景（千芯科技，后摩智能等）。</p>
<p>目前已知的商业模式主要分为三种：IP授权，定制&#x2F;联合开发以及自主SoC芯片。</p>
<p>当前国内外存算一体技术发展特征如下：</p>
<ul>
<li>成立时间不同会影响技术路线选择，国内外实现产品化的公司数量不多，离规模化还有一定距离</li>
<li>技术路线：大公司选择最容易落地的，初创公司在确保技术先进性基础上选择最容易落地的</li>
<li>国外已形成完整的自研技术链，大规模量产上国内外均未实现突破</li>
<li>不同的业务场景均已呈现出各自的优势，在商业模式上国内外都处在探索阶段</li>
<li>虽然业内尚未形成完整的生态，产业链部分环节已经出现针对存算一体进行技术研发的公司</li>
</ul>
<h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>为了推动存算一体技术的未来发展，重点应放在解决关键技术难题上，并且寻找适合快速应用推广的场景。随着新型存储器技术，尤其是RRAM和MRAM的不断进步，预计将大幅推进存算一体架构的发展。这些技术的应用，尤其是在终端推理和物联网领域，预示着存算一体技术将在这些领域发挥重要作用。为了实现从初步商业化到大规模商业化的转变，技术创新与产业发展必须紧密协同，共同推动这一技术的成熟和应用普及。</p>
<h1 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h1><p>作为一名物联网工程专业的大学生，深入了解存算一体技术让我领略了科技创新的魅力及其在未来应用的广阔前景。虽然我尚缺乏商业模式和产品上市的实践经验，但这次学习经历让我认识到理论与实践结合的重要性，以及跨学科知识对于技术创新的贡献。</p>
<p>通过研究这一技术，我明白了在物联网设备设计中，如何有效融合硬件和软件来提高性能同时降低能耗的重要性。这一认识不仅提升了我的专业技能，也激发了我对如何将技术创新转化为实际应用的深入思考。</p>
<p>此外，我也看到了自己在商业知识和市场分析方面的不足，这提示我在未来的学习中需更多关注这些领域。我期待将这次学习的感悟转化为动力，在未来的学习和工作中不断探索、学习和创新，为智能化世界贡献我的力量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chip/" rel="tag">Chip</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：STM32 F407 霸天虎开发板"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/26/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9ASTM32%20F407%20%E9%9C%B8%E5%A4%A9%E8%99%8E%E5%BC%80%E5%8F%91%E6%9D%BF/"
    >技术学习：STM32 F407 霸天虎开发板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/26/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9ASTM32%20F407%20%E9%9C%B8%E5%A4%A9%E8%99%8E%E5%BC%80%E5%8F%91%E6%9D%BF/" class="article-date">
  <time datetime="2023-11-26T00:00:00.000Z" itemprop="datePublished">2023-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>博主开始探索嵌入式以来，其实很早就开始玩 stm32 了。但是学了一段时间之后总是感觉还是很没有头绪，不知道在学什么。前前后后分别尝试了江协科技、正点原子、野火霸天虎三次 stm32 的课程学习。江协科技的 stm32f103c8t6 课程看了一段时间，感觉对一些外设的调用方法有一个基础的认知了，但是没有很明白到底在学什么；正点原子则是有点听不懂，半字也借给同学了就有一段时间没学，感觉自认为 stm32 学的有两把刷子了。后来听前辈说江协科技的 stm32 课程不如 51 单片机的质量好，其实课程讲的一般，我就想：是不是应该重新好好学一下 stm32 课程了。</p>
<p>这次选择的是野火的  F407 霸天虎课程，第一是听大家说，入门选野火或者正点最好。第二是野火的大师进阶篇的一些内容，涉及到一些原理等的学习讲解，我觉得对我会非常有帮助，因此正好就买了这款开发板从入门到中级到大师原理一起学习了。</p>
<p>本系列博文笔记主要基于野火相应课程，b站地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vt411X7PK/?spm_id_from=333.337.search-card.all.click&vd_source=05baa16b109824edfe68909895264c33">野火F407开发板-霸天虎视频-【入门篇】_哔哩哔哩_bilibili</a> ，仅供学习参考不做任何商业用途使用，侵删！</p>
<h2 id="调试器介绍"><a href="#调试器介绍" class="headerlink" title="调试器介绍"></a>调试器介绍</h2><p>我选择的是高速版，支持 SW 和 JTAG 两种连接方式。SW 模式则只需要连接 VREF（3V3）, TMS（数据）, TCK, RESET, GND 五个引脚。</p>
<h2 id="程序烧录配置"><a href="#程序烧录配置" class="headerlink" title="程序烧录配置"></a>程序烧录配置</h2><p>芯片型号：STM32F407ZGTX。</p>
<p><strong>DAP 仿真烧录</strong>自然非常简单。</p>
<p><strong>串口一键下载 ISP</strong> 下载速度慢，不能调试，但是成本很低。可以使用 FlyMcu 等软件。</p>
<p><strong>2023.11.2 补充。</strong></p>
<p><strong>警告，建议如果 flymcu 不能烧录，就不要尝试这种玩法了，看看课学学得了。因为我自己乱捣鼓一通后把开发板锁了。</strong></p>
<p><strong>下面的内容我不太清楚具体是哪一步出现了锁死 flash 的问题，总之不要尝试！学习一下理论得啦。</strong></p>
<p><strong>如果和我一样锁死了，请见野火大师篇程序，里面有一个解除写保护的代码，运行一下。</strong></p>
<p>ISP 下载方式：允许我们不拆下芯片来下载。对于上个世纪嵌入式学习来说这是一个很大的突破，因为当时是要把芯片拆下来烧录编程的。</p>
<p>ISP 厂商出产的时候就选定了一种串行外设对芯片内部 FLASH 进行编程，我们不能修改。常用串口下载方式，成本低，但是不能调试仿真。</p>
<p>普通 ISP 需要手动配置 boot loader，一键 ISP 不用，硬件电路和上位机配合达到一键下载的效果（手动配置：00是用户闪存启动，10是系统 SRAM&#x2F;ISP 启动，普通 ISP 要手动改跳线帽）。</p>
<p>一键下载电路的具体原理流程如下：</p>
<ol>
<li>RTS 低电平，Q1 是一个 PNP 三极管，导通，BOOT0 拉高。</li>
<li>DTS 高电平，Q2 NPN 导通，U18 是一个由 EN 控制开关的模拟开关，2 脚被导通为低电平，连接1脚拉低 NRST 复位。程序下载执行。</li>
<li>U18 模拟开关的作用是稳定电路。开发板复位的时候 DTR RTS 是不稳定的状态，如果没有这个模拟开关，DTR RTS 可能进入 ISP 状态，复位，进入 ISP 状态，复位，进入……一直运行不起来了。模拟开关右侧电容使得 VCC 需要花一点时间充电给 EN，而不是立刻激活 EN（EN 1.8V 左右）。这时候 DTR RTS 已经稳定了，可以导通 U18 12 引脚来给 NRST 复位了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698858387784.png" alt="1698858387784"></p>
<p>不过 FlyMcu 实际配置方式是反过来的，因为他的协议是 232（+3<del>+15 是 0，-3</del>-15 是 1），和 TTL（3.3v 是1,0v 是0）正相反。</p>
<p><em>但是实际操作的时候可能遇到一种状况：部分开发板无法使用 FlyMcu 写入。我就碰到了。解决办法是使用 stm32 cube programmer 烧录程序。</em></p>
<p><em>配置如下：开发板上 boot 连接 3v3，RTS DTR&#x3D;0，选中 read unprotect，建立连接后再烧录程序。</em></p>
<p><em>但是不知道是波特率或者校验位的问题，我每次能成功烧录进去，然后过一会就显示断开找不到设备了。可能是因为波特率没有76800的选项。</em></p>
<h1 id="STM32-介绍"><a href="#STM32-介绍" class="headerlink" title="STM32 介绍"></a>STM32 介绍</h1><blockquote>
<p>正点原子网课：单片机和电脑的类比：内存是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SRAM&spm=1001.2101.3001.7020">SRAM</a>，硬盘是 FLASH，主板是外设。</p>
</blockquote>
<p>st：意法半导体公司，SoC 厂商。</p>
<p>m：微控制器。微控制器和微处理器相比性能比较拉一点，主频低，微处理器能跑一些大 os（linux）。</p>
<p>32：32位微控制器。</p>
<blockquote>
<p>正点原子网课：8051，X86 属于 CISC；ARM, MIPS, RISC-V 属于 RISC.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012212735.png" alt="image-20230401221223643"></p>
<p>冯诺依曼和哈佛结构的主要区别：程序存储器和数据存储器是否分开存储。不分开是冯诺依曼，分开是哈佛。哈佛执行效率更高，冯诺伊曼资源占据更少。</p>
<p>CORTEX-M 系列介绍<br>ARM 公司（做精简指令集计算机的）只设计内核架构和授权知识产权，不参与设计芯片，给其他合作公司授权设计芯片。半导体厂商再根据架构完善周边电路并制作芯片。现在95%手机、平板都是 ARM 架构的， ARM 公司是真的牛。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012216885.png" alt="image-20230401221658811"></p>
<p>其优点在于低功耗低成本高性能，且支持16&#x2F;32位双指令集。</p>
<p>ARM 有9个版本，从 v6 开始出现 cortex 的命名。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012219288.png" alt="image-20230401221918218"></p>
</blockquote>
<p>随着需求不断发展，stm32 在一众 8&#x2F;16位 MCU 中脱颖而出。</p>
<p>stm32 自带许多通信接口，如 spi i2c uart 等；扫地机，无人机，手环等都可以是 stm32 的作品。</p>
<p>如何选型？以下是几大类 stm32 的特点。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013709264.png" alt="image-20231102013709264"></p>
<p>本课程学习使用的开发板命名方式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013830412.png" alt="image-20231102013830412"></p>
<p>选型：满足项目需求的前提下，尽可能选便宜的，比如主频低，功耗低，引脚少，flash 少。</p>
<p>引脚分配：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860405030.png" alt="1698860405030"></p>
<p>看手册的重点：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860693691.png" alt="1698860693691"></p>
<p>外设资源，芯片功能，引脚，引脚大致分类，内存，封装……</p>
<p>哎想起前两天面试被问，如果选型 MCU 我应该看哪些因素。我只想到了外设和内存hhh。属于是只会写代码的笨比了。这也是我开始重新看野火课程的原因之一。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>虽然正式编程没有必要用寄存器编程，通常都是库函数或者 hal 库。但是还是有必要学一下原理的。</p>
<h2 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h2><p>芯片视图如下。</p>
<p>丝印：芯片上印的信息。型号，内核，生产批次等。</p>
<p>引脚：左上角是有小圆点的，从左上-左下-右下-右上逆时针看。或者如果没有小圆点，把丝印方向摆正，从左上角开始看。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121423731.png" alt="image-20231102121423731"></p>
<p>芯片内部组成：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121841662.png" alt="image-20231102121841662"></p>
<p>寄存器映射：32位，2^32^&#x3D;4GB，因此所有程序都需要通过内存 4GB 去映射访问。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102122058475.png" alt="image-20231102122058475"></p>
<p>block7：M4 芯片内外设，比如一些通信总线这些都算外设。</p>
<p>block1：内存。</p>
<p>block0：代码。不过实际上由于设计工艺的问题，block0 block1 都只用了很少的一部分来存代码或者作为内存。</p>
<p>外设寄存器放在 block2 中。根据不同块速度不一样，又具体分为不同速度的外设（AHB APB）。</p>
<p>总线速度：AHB&gt;APB2&gt;APB1. APB1 是较低速的外设，包括 I2C UART SPI 看门狗等。</p>
<p>我们想要操作特定的外设，其实就是控制他的寄存器。控制寄存器就要找到寄存器相应的地址往里面写入数据，寄存器地址就是内存中的地址映射。</p>
<p>比如 GPIOF 我们想让其端口全部输出高电平。我们查找 stm32f407 手册，发现 GPIOF 的地址是 0x40021400，GPIOF 的 ODR（output data register）相对起始地址的偏移地址是14，则我们需要给 0x40021414 的地址写入数据 0xFFFF.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102123404182.png" alt="image-20231102123404148"></p>
<p>51 单片机库函数中封装的 reg51.h 中，利用 sfr 定义寄存器地址；而 stm32 库函数中使用宏定义，这些就是寄存器映射操作。<strong>对芯片里一个特殊功能的内存单元起别名的过程就是寄存器映射。</strong> 给这个地址再分配一个地址交重映射，stm32 中不咋常用。</p>
<h2 id="C语言对寄存器的封装"><a href="#C语言对寄存器的封装" class="headerlink" title="C语言对寄存器的封装"></a>C语言对寄存器的封装</h2><p>这样逐个地址，哪怕已经进行了寄存器映射，还是很复杂。</p>
<p>c 语言库函数实际进行的封装操作是使用结构体批量定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIO 外设基地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BASE (AHB1PERIPH_BASE + 0x0000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE (AHB1PERIPH_BASE + 0x0400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_BASE (AHB1PERIPH_BASE + 0x0800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_BASE (AHB1PERIPH_BASE + 0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE (AHB1PERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE (AHB1PERIPH_BASE + 0x1400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_BASE (AHB1PERIPH_BASE + 0x1800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH_BASE (AHB1PERIPH_BASE + 0x1C00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO 寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER; <span class="comment">/*GPIO 模式寄存器 地址偏移: 0x00 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER; <span class="comment">/*GPIO 输出类型寄存器 地址偏移: 0x04 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR; <span class="comment">/*GPIO 输出速度寄存器 地址偏移: 0x08 */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR; <span class="comment">/*GPIO 上拉/下拉寄存器 地址偏移: 0x0C */</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR; <span class="comment">/*GPIO 输入数据寄存器 地址偏移: 0x10 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR; <span class="comment">/*GPIO 输出数据寄存器 地址偏移: 0x14 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL; <span class="comment">/*GPIO 置位/复位寄存器低 16 位部分 地址偏移: 0x18 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH; <span class="comment">/*GPIO 置位/复位寄存器高 16 位部分 地址偏移: 0x1A */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR; <span class="comment">/*GPIO 配置锁定寄存器 地址偏移: 0x1C */</span></span><br><span class="line">	<span class="type">uint32_t</span> AFR[<span class="number">2</span>]; <span class="comment">/*GPIO 复用功能配置寄存器 地址偏移: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 GPIO_TypeDef 把地址强制转换成指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA ((GPIO_TypeDef *) GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB ((GPIO_TypeDef *) GPIOB_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC ((GPIO_TypeDef *) GPIOC_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD ((GPIO_TypeDef *) GPIOD_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE ((GPIO_TypeDef *) GPIOE_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF ((GPIO_TypeDef *) GPIOF_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG ((GPIO_TypeDef *) GPIOG_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH ((GPIO_TypeDef *) GPIOH_BASE)</span></span><br></pre></td></tr></table></figure>

<p>所有外设都是如此，首先定义总线 APB AHB 地址，然后每个外设在其基础上进行偏移，每个外设的不同部分再在该外设基址上进行偏移。</p>
<h1 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h1><h2 id="寄存器方式"><a href="#寄存器方式" class="headerlink" title="寄存器方式"></a>寄存器方式</h2><p>要命啊，一看名字我就不想试。寄存器新建不得麻烦死。</p>
<p>哎算了为了学习原理，干了。</p>
<p>我们尝试自己写一个寄存器的库函数来引用。</p>
<p>首先我们需要引用 st 官方启动文件 stmf4xx.s，具体用途后面章节再展开讲解。然后我们自己新建一个 stm32f4xx.h 文件来映射寄存器。不过只是把这个文件包含进项目，编译会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Objects\led_reg.axf: Error: L6218E: Undefined symbol SystemInit (referred from startup_stm32f40xx.o).</span><br></pre></td></tr></table></figure>

<p>进入启动文件后，可以看到这么一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>import 的作用相当于 extern，所以没有找到这个函数的定义，需要我们自己去定义。这就是为什么简单引入了启动文件会报错。</p>
<p>而 __main 是当我们定义了 main() 函数后，编译器会自动链接一些c语言库定义好的函数，用于初始化堆栈并且调用我们的 main().</p>
<p><strong>注意，如果想要生成 __main 函数，必须勾选下面这一项。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102200243099.png" alt="image-20231102200243099"></p>
<p>野火你讲的是真好啊。我之前草草学了学 stm32 单片机用法，比赛的时候自己想移植代码，改了启动文件也不好使，就是报错。原来是这个原因。</p>
<p>那么我们只需要定义这么一个函数，哪怕内容是空都无所谓。</p>
<p>最终我们定义的初步项目框架如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698926683862.png" alt="1698926683862"></p>
<p>stm32f4xx.h：内容为空，有这么个东西就行。</p>
<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个程序可以烧录到板子上的。烧录成功之后没有任何反应（因为本来程序也没做什么哈哈），但是这就是一个大进步了。</p>
<h3 id="点灯——51单片机版"><a href="#点灯——51单片机版" class="headerlink" title="点灯——51单片机版"></a>点灯——51单片机版</h3><p>51单片机版就是引用 reg51.h 头文件，在其中声明了各个引脚的地址。我们只需要直接给引脚赋值即可。</p>
<p>调用代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 0 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	PA0=<span class="number">0xFE</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来我们需要定义 LED 灯的寄存器位置。阅读原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698939342199.png" alt="1698939342199"></p>
<p>大致可以看出，板子上的这个 RGB LED 通过三个引脚来控制 RGB 亮度。输出低电平则导通点亮。</p>
<p>具体输出方式是通过 ODR 进行输出。查找 stm32f4xx 中文参考手册可见：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940158585.png" alt="1698940158585"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940257044.png" alt="1698940257044"></p>
<p>那么我们就要给 0x4002 1400 +14 的地址赋值，让 1&lt;&lt;6 1&lt;&lt;7 1&lt;&lt;8 的位分别赋值为低电平.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	 *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这样也不亮。亮就怪了，stm32 寄存器是需要先做初始化配置的。</p>
<h3 id="点灯——stm32-版"><a href="#点灯——stm32-版" class="headerlink" title="点灯——stm32 版"></a>点灯——stm32 版</h3><p>首先我们要设置 GPIO 模式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940961543.png" alt="1698940961543"></p>
<p>想点灯 输出高低电平，是 01 通用输出模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br></pre></td></tr></table></figure>

<p>意思是先把 PF6 模式位置为00，然后赋值为01通用输出。</p>
<p>配置完模式之后，还需要配置时钟，stm32 每个外设都需要配置时钟。</p>
<p>前面提到过 GPIO 是在 AHB1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103516061.png" alt="1699103516061"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103724261.png" alt="1699103724261"></p>
<p>全部代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40023800</span>+<span class="number">0x30</span>)|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们把这几个地址值提取出来，宏定义映射寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx.h</span></span><br><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1_ENR    *(unsigned int *)(0x40023800+0x30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER     *(unsigned int *)(0x40021400+0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR       *(unsigned int *)(0x40021400+0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点灯——流水灯闪烁"><a href="#点灯——流水灯闪烁" class="headerlink" title="点灯——流水灯闪烁"></a>点灯——流水灯闪烁</h3><p>利用软件延时实现 RGB 流水灯闪烁。很简单，前面已经看了3个 LED 通道 PF678 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>));   </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>); </span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//毫秒级的延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span></span><br><span class="line">&#123;    </span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">while</span>(time--)</span><br><span class="line">   &#123;</span><br><span class="line">      i=<span class="number">4000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--) ;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点灯——GPIO-具体功能框图对应"><a href="#点灯——GPIO-具体功能框图对应" class="headerlink" title="点灯——GPIO 具体功能框图对应"></a>点灯——GPIO 具体功能框图对应</h3><p>GPIO：通用输入输出引脚。我们可以通过编程来输出或者读取数据。大部分 GPIO 是已经连接、定义好了一些功能（比如上面尝试过的 PF6 LED），有的引脚有多个功能支持重新映射。</p>
<p>STM32 GPIO 除了 adc 是 3.3v，其他 GPIO 都是 5v 容忍。</p>
<p>GPIO 框图（<strong>重点</strong>）如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231104221140325.png" alt="image-20231104221140325"></p>
<p>先从输出开始看。最右侧的 IO 引脚是连接在芯片周围一圈的144个引脚之一。除了 IO 引脚，此图中其他所有部分都是封装在芯片内部我们看不到的。</p>
<p>往左有两个保护二极管。当电压大于 5V，电流会往上 VDD_FT 走。当电压为负电压，电流会由 VSS 往 IO 引脚走。</p>
<p>上下拉电阻：比武外接一个低电平工作的设备，但是我们不希望一上电外设就工作，可以设置上拉电阻，稳定一段时间。</p>
<p>GPIO 输出的数据来源：复位寄存器 BSRR，或者 ODR 设置（图中的3下路部分）。复位寄存器高16位复位（写1置0）低16位置位（写1置1），置位优先级更高。</p>
<p>配置 GPIO 模式（输入&#x2F;输出，选择哪一路）通过前面用过的 MODER 配置。</p>
<p>输出模式（图中输出控制部分）配置端口输出类型寄存器 OTYPER，比如推挽输出，开漏输出。</p>
<p>推挽输出：有直接驱动能力，输出0就是低电平，输出1就输出可以工作的高电平。原理是采用了一个放大的电路？</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699356797818.png" alt="1699356797818"></p>
<p>输入（INT）为高电平时，反向后 PMOS 导通，输出高电平。输入为低电平时，反向后 NMOS 导通，输出低电平。我们可以用一个小电流去驱动出来一个大电流。</p>
<p>开漏输出：自己本身没有输出高电平的手段。低电平可以接地，高电平没有 PMOS 管，是浮空状态。需要外接一个电阻。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357078909.png" alt="1699357078909"></p>
<p>stm32 输出 5V 电压的方法就是开漏输出外接电阻。通过接两个三极管的方式反向。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357296750.png" alt="1699357296750"></p>
<p>框图中的模拟部分输入输出则不用配置这些模式信息，直接由外设接到保护二极管再接到输出引脚。</p>
<p>框图中的输入部分经过保护电压后，还需要施密特触发器调整一下。比如原来电压的数值并非精确的0或 3.3V，施密特触发器将高于 1.8V 的全部视作1，低于的全部视作0后输入芯片。模拟部分则不需要经过施密特触发器。</p>
<p>因此配置 GPIO 输出的步骤如下：</p>
<ol>
<li>GPIO 功能，通用输出、复用功能、模拟输入等 MODER；</li>
<li>输出推挽 or 开漏 OTYPER；</li>
<li>输出速度 OSPEEDR；</li>
<li>上下拉电阻是否需要开启 PUPDR；</li>
<li>具体输出内容 BSRR or ODR.</li>
</ol>
<p>输入部分后面输入实验介绍~</p>
<p>按整个流程重新串一遍代码，如下：（其实和前面差不多，就是重新按照流程串了一遍）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE    (unsigned int *)    0x40023800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE  (unsigned int *)    0x40021400</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1ENR         *(RCC_BASE+0x30)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER         *(GPIOF_BASE+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OSPEEDR       *(GPIOF_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_PUPDR         *(GPIOF_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR           *(GPIOF_BASE+0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BSRR          *(GPIOF_BASE+0x18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_AHB1ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    GPIOF_MODER &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    GPIOF_MODER |= (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录前记得勾选：use MicroLib.</p>
<h2 id="构建库方式"><a href="#构建库方式" class="headerlink" title="构建库方式"></a>构建库方式</h2><h3 id="点灯——自己尝试构建库函数版"><a href="#点灯——自己尝试构建库函数版" class="headerlink" title="点灯——自己尝试构建库函数版"></a>点灯——自己尝试构建库函数版</h3><p>寄存器方法了解到这里就好，野火课程主要是库函数写代码。首先我们自己尝试构建一下库函数。</p>
<p>还是基于上次实验代码修改即可。首先对 .h 文件做一些修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个是防止多次引用头文件重复定义。</p>
<p>然后，像之前一条条定义太麻烦了。其实我们注意到每个寄存器都是4字节，我们可以用固定大小的结构体定义。比如 GPIO ABCDEF 结构都一样，我们只需要统一定义结构体和各自的基址即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span>	<span class="comment">// 包含了 uint32_t uint16_t</span></span></span><br><span class="line"><span class="comment">/* GPIO寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER;    <span class="comment">/*GPIO模式寄存器						地址偏移: 0x00      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*GPIO输出类型寄存器				地址偏移: 0x04      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*GPIO输出速度寄存器				地址偏移: 0x08      */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*GPIO上拉/下拉寄存器			地址偏移: 0x0C      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR;      <span class="comment">/*GPIO输入数据寄存器				地址偏移: 0x10      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR;      <span class="comment">/*GPIO输出数据寄存器				地址偏移: 0x14      		*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL;    <span class="comment">/*GPIO置位/复位寄存器 低16位部分	地址偏移: 0x18 	*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH;    <span class="comment">/*GPIO置位/复位寄存器 高16位部分	地址偏移: 0x1A  */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR;     <span class="comment">/*GPIO配置锁定寄存器				地址偏移: 0x1C      */</span></span><br><span class="line">    <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*GPIO复用功能配置寄存器		地址偏移: 0x20-0x24 		*/</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GPIOF ((GPIO_TypeDef *)GPIOF_BASE)</span></span><br></pre></td></tr></table></figure>

<p>main.c 中可以把对应寄存器替换为 GPIOF-&gt;寄存器名了。</p>
<p>然后我们直接对寄存器做操作，还是有点直接了，最好是我们不需要关注寄存器有哪些，直接调用一个 GPIO 设置函数即可使用，封装性可移植性都会好很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRL=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRH=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>比如首先我们简单写了这样一个置位函数，使用方法为 <code>GPIO_SetBits(GPIOF_Base,1&lt;&lt;6)</code> .</p>
<p>以及我们可以在 <code>stm32f4xx_gpio.h</code> 里批量定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6          (uint16_t)(1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7          (uint16_t)(1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8          (uint16_t)(1&lt;&lt;8)</span></span><br></pre></td></tr></table></figure>

<p>这样 GPIO 使用用 Set Reset 函数已经非常规范了。那么初始化操作我们也可以封装成一个函数。</p>
<p>初始化需要设置 MODER PUPDR OSPEEDR OTYPER，我们可以定义一个结构体用于存储这些初始化变量，初始化的时候新建一个这样的结构体并赋值，传入初始化函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="comment">//每个模块具体的值可以定义一个枚举类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Mode_IN=<span class="number">0x00</span>;</span><br><span class="line">    GPIO_Mode_OUT=<span class="number">0x01</span>;</span><br><span class="line">    GPIO_Mode_AF=<span class="number">0x02</span>;</span><br><span class="line">    GPIO_Mode_AN=<span class="number">0x03</span>;</span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;</span><br><span class="line">    GPIOMode_TypeDef MODER;</span><br><span class="line">    GPIOPuPd_TypeDef PUPDR;</span><br><span class="line">    GPIOOType_TypeDef OTYPER;</span><br><span class="line">    GPIOOSpeed_TypeDef OSPEEDR;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>具体使用的时候首先我们初始化一个 GPIO_InitTypeDef 变量，并且给其中的每一个子元素都赋值。然后传入 GPIO_Init 函数中，里面就是一系列根据手册而来的位操作，这里我感觉前面原理懂差不多就不用非跟着敲了。</p>
<h3 id="分析-stm32-固件库函数"><a href="#分析-stm32-固件库函数" class="headerlink" title="分析 stm32 固件库函数"></a>分析 stm32 固件库函数</h3><p>前面基本上都是了解固件库编程，从51过渡到 stm32. 后面所有固件编程固件库的使用方法都和前面的 GPIO 类似。</p>
<p>固件是什么？其实就是程序，固化到 EEPROM 或 FLASH 中，操作最底层的设备。<strong>不是具体的应用，而是只操作最底层的设备。比如点灯算应用，给应用工程师提供库函数的工作是固件工程师的。</strong></p>
<p>stm32 官方 stmf4 固件库下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/zh/embedded-software/stm32-standard-peripheral-libraries/products.html?querycriteria=productId=LN1939">STM32标准外设软件库: 相关产品</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231108222206160.png" alt="image-20231108222206160"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     22:16                Libraries</span><br><span class="line">d-----         2023/11/8     22:16                Project</span><br><span class="line">d-----         2023/11/8     22:17                Utilities</span><br><span class="line">d-----         2023/11/8     22:17                _htmresc</span><br><span class="line">-ar---         2023/11/8     22:15          88007 Package_license.html</span><br><span class="line">-ar---         2023/11/8     22:15          19611 Package_license.md</span><br><span class="line">-ar---         2023/11/8     22:15         152599 Release_Notes.html</span><br><span class="line">-ar---         2023/11/8     22:15       37185187 stm32f4xx_dsp_stdperiph_lib_um.chm</span><br></pre></td></tr></table></figure>

<p>.chm：使用帮助文档。</p>
<p>.html .md：一些版本更新，包许可证相关信息。</p>
<p>Utilities：一些第三方其他软件。</p>
<p>Project：样例，模板。</p>
<p>Libraries：库，CMSIS 是一些 ARM 公司的标准，Driver 是固件。inc 是头文件，src 是c文件。</p>
<p>我们根据上节课写的项目来进行库函数文件功能分析。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>所属类别</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>startup_stm32f40xx.s</td>
<td>片上外设</td>
<td>汇编启动文件</td>
</tr>
<tr>
<td>stm32f4xx.h</td>
<td>片上外设</td>
<td>外设寄存器映射</td>
</tr>
<tr>
<td>system_stm32f4xx.c &#x2F; system_stm32f4xx.h</td>
<td>片上外设</td>
<td>初始化系统时钟</td>
</tr>
<tr>
<td>stm32f4xx_xxxx.c &#x2F; stm32f4xx_xxxx.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cm4.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cmFunc.h &#x2F; core_cmSimd.h</td>
<td>内核</td>
<td>内核外设的一些操作函数</td>
</tr>
<tr>
<td>misc.c &#x2F; misc.h</td>
<td>内核</td>
<td>中断相关函数（优先级分组，系统中断）</td>
</tr>
<tr>
<td>stm32f4xx_it.c &#x2F; stm32f4xx_it.h</td>
<td>内核</td>
<td>中断服务函数（所有中断入口）</td>
</tr>
<tr>
<td>main.c</td>
<td></td>
<td>main 函数</td>
</tr>
</tbody></table>
<ol>
<li>startupxxxx.s：启动文件。</li>
<li>stm32f4xx.h：外设寄存器映射。</li>
<li>跳到 system_Init 函数，这个函数当时我们为了执行只写了一个空函数，而 stm32 官方固件库模板里面是有的，在 system_stm32f4xx.c 里，初始化系统时钟。</li>
<li>stm32f4xx.c：具体外设驱动，比如上节课写的 gpio。</li>
<li>core_cm4.h：内核寄存器映射。</li>
<li>misc：中断。</li>
</ol>
<h3 id="构建库函数"><a href="#构建库函数" class="headerlink" title="构建库函数"></a>构建库函数</h3><p>创建一个通用的模板，后面写程序直接使用这个模板。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     23:27                Libraries</span><br><span class="line">d-----         2023/11/8     23:27                Listing</span><br><span class="line">d-----         2023/11/8     23:27                Output</span><br><span class="line">d-----         2023/11/8     23:27                Project</span><br><span class="line">d-----         2023/11/8     23:27                User</span><br><span class="line">-a----         2020/2/27     13:45            401 keilkill.bat</span><br></pre></td></tr></table></figure>

<p>前面都是新建的文件夹，keilkill.bat 是从 keil 编译程序中复制出来的一个脚本，可以删掉中间文件。</p>
<p>把固件库 Lib 里的 CMSIS 和 Driver 文件拷贝到 Libraries 文件夹中。CMSIS 中只保留 Device Include 文件夹。Device 中包含外设相关（比如 stm32f4xx.h system_stm32f4xx），Include 中只包含内核相关。</p>
<p>把 main.c stm32f4xx_it.c &#x2F; stm32f4xx_it.h stm32f4xx_conf.h 拷贝到 User 文件夹中。</p>
<p>在 Project 文件夹里可以包含多给项目文件，不光只有 Keil 的。比如 IAR 的我们新建一个 IAR 文件夹，Keil 我们新建一个 RVMDK(uv5) 文件夹。RealView 是包含不止 MDK 的开发工具集合的称呼，MDK 是 MCU 开发工具集成包，uVersion 是 IDE，Keil 是公司名字。</p>
<p>uVision 里新建工程，新建在 RVMDK(uv5) 文件夹下。</p>
<p>新建组、添加文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002542997.png" alt="image-20231109002542997"></p>
<p>STM32F4xx_StdPeriph_Driver 添加 STM32F4xx_StdPeriph_Driver&#x2F;src 下的所有文件，屏蔽掉 dma2d fmc ltdc，后两个是 sd 和 lcd 屏幕组件。</p>
<p>头文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002823229.png" alt="image-20231109002823229"></p>
<p>宏定义如下：</p>
<p>USE_STDPERIPH_DRIVER,STM32F40_41xxx</p>
<p>我现在好想明白为什么宏定义在这里了，这样后面换单片机型号的时候可以直接修改这个宏定义。</p>
<p><strong>PS：我下载的是 1.8.1 版本 stm32f4xx.h 库函数，里面出现了一段重复定义导致编译产生了200多个 warning。我把下面那一段删掉了就好了。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/true" alt="jingqing3948_1-1699463889291.png"></p>
<p>Output 里设置 Output 文件夹，不然都在 Proj 里太乱。</p>
<p>记得勾选 MicroLib。</p>
<h3 id="点灯——官方库函数版"><a href="#点灯——官方库函数版" class="headerlink" title="点灯——官方库函数版"></a>点灯——官方库函数版</h3><p>在 User 文件夹中新建 LED 文件夹，里面新建 bsp_led.c，代表板级支持包 LED 代码，也就是只针对我们当前这一款开发板的点灯程序。</p>
<ol>
<li><p>设置时钟：rcc 时钟，在 stm32f4xx_rcc.c 中：</p>
</li>
<li><pre><code class="c">/**
  * @brief  Enables or disables the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.   
  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
  *            @arg RCC_AHB1Periph_CRC:         CRC clock
  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
  *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其他部分基本也是参照库函数（主要是 stm32f4xx_gpio.h）最终呈现如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &quot;bsp_led.h&quot;</span><br><span class="line"></span><br><span class="line">void LED_GPIO_Config(void)&#123;</span><br><span class="line">    //RCC set function in stm32f4xx_rcc.h</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        //Init structure</span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">        GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;</span><br><span class="line">        GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;</span><br><span class="line">        GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        //init function</span><br><span class="line">        GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

置位可以使用 `GPIO_SetBits` 或 `GPIO_ResetBits`。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      GPIO_ResetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">      GPIO_SetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

没有上下拉的时候推挽输出会直接被 ODR 值所影响，哪怕没有赋值其中本来的值也会影响。所以推挽输出无上下拉，不置位 LED 也会被点亮，因为 ODR 默认值0.
</code></pre>
</li>
</ol>
<h2 id="输入——按键点灯"><a href="#输入——按键点灯" class="headerlink" title="输入——按键点灯"></a>输入——按键点灯</h2><p>开发板按键电路如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109191525189.png" alt="image-20231109191525189"></p>
<p>按键未按下接地，按下后为高电平。电容起到消抖作用，软件处理就不需要手动延时消抖了。</p>
<p>编程没啥难度，就是改了一下输入模式。使用 <code>ReadInputDataBits</code> 读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsp_button.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Button_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_InitTypeDef GPIOInitStruct;</span><br><span class="line">        GPIOInitStruct.GPIO_Mode=GPIO_Mode_IN;</span><br><span class="line">        GPIOInitStruct.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">        GPIOInitStruct.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIOInitStruct.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;</span><br><span class="line">        </span><br><span class="line">        GPIO_Init(GPIOA,&amp;GPIOInitStruct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0))GPIO_SetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        <span class="keyword">else</span> GPIO_ResetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现按键按下后翻转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET)&#123;</span><br><span class="line">            <span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET);</span><br><span class="line">            GPIO_ToggleBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要等到按键松开的时候再翻转，轮询直到松开。</p>
<h2 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h2><p>之前51单片机常见位定义。比如 PA 引脚有8个 IO 口，我们可以定义 <code>sbit LED1=PA^0</code> 这样单独操作某一位。</p>
<p>stm32 里没有直接的位定义方式。一种解决办法是我们利用与或操作不影响其他位的同时操作特定位；另一种就是位带操作。</p>
<p>stm32 里有一部分别名区域，用于映射外设、SRAM 中特定的位带区，我们操作这一部分别名区域时就可以实现对外设、SRAM 位带区与的位操作。</p>
<p>片上外设位带区：0X4000 0000<del>0X400F 0000，别名区：0X4200 0000</del>0X43FF FFFF，包含 APB12，AHB1 外设。</p>
<p>SRAM 位带区：0X2000 0000<del>0X200F 0000，别名区：0X2200 0000</del>0X23FF FFFF</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109220918350.png" alt="image-20231109220918350"></p>
<p>外设地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x42000000+ (A-0x40000000)<em>8</em>4 +n*4  （n是位序号）</p>
<p>SRAM 地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x22000000+ (A-0x20000000)<em>8</em>4 +n*4</p>
<p>扩大了32倍，可以对32位寄存器中的每一位进行操作。</p>
<p>统一公式：<code>\#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</code></p>
<p>使用：比如我们操作一个 GPIO 的位操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br><span class="line"><span class="comment">// 把一个地址转换成一个指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr) *((volatile unsigned long *)(addr))</span></span><br><span class="line"><span class="comment">// 把位带别名区地址转换成指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO ODR 和 IDR 寄存器地址映射</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR_Addr (GPIOF_BASE+20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_IDR_Addr (GPIOF_BASE+16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独操作 GPIO 的某一个 IO 口，n(0,1,2...15),</span></span><br><span class="line"><span class="comment">// n 表示具体是哪一个 IO 口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFout(n) BIT_ADDR(GPIOF_ODR_Addr,n) <span class="comment">//输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFin(n) BIT_ADDR(GPIOF_IDR_Addr,n) <span class="comment">//输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line">PFout(<span class="number">6</span>)= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这个概念学学就好，好像实际应用没啥意义。我们微处理器考试也考过hh。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-问题解决：ubuntu 安装 emscripten 时 install latest 报错"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E6%8A%A5%E9%94%99/"
    >问题解决：ubuntu 安装 emscripten 时 install latest 报错</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E6%8A%A5%E9%94%99/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A0%B4%E6%B5%AA%EF%BC%88%E9%81%87%E5%88%B0%E7%9A%84bug%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/">破浪（遇到的bug及解决方案）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>学习官网参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm">Compiling a New C&#x2F;C++ Module to WebAssembly - WebAssembly | MDN (mozilla.org)</a></p>
<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>形如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Downloading URL &#x27;https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2&#x27;: &lt;urlopen error [Errno 104] Connection reset by peer&gt;</span><br><span class="line">error: installation failed!</span><br></pre></td></tr></table></figure>

<p>OS：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux jingqing 5.19.0-35-generic #36~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 17 15:17:25 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="产生错误原因分析"><a href="#产生错误原因分析" class="headerlink" title="产生错误原因分析"></a>产生错误原因分析</h2><blockquote>
<p>emsdk install latest报错（因为从谷歌中下载，cmd中命令形式访问不到google）<br>版权声明：本文为CSDN博主「小白啥时候能进阶成功」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34754747/article/details/103815349">https://blog.csdn.net/qq_34754747/article/details/103815349</a></p>
</blockquote>
<p>非常感谢博主的答疑解惑，不过我没有看得太懂原文中的解决方案，网上搜到的大多数方案也是 windows 环境下的解决方案，因此我决定自己写一个 ubuntu 系统下的补安装。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>说白了就是我自己复制链接到浏览器里，下载安装这几个包，放到 emsdk 的指定位置。</p>
<p>这里有两个要注意的点，这一部分主要是分析，不想看的同学可以直接跳到<a href="#solution">具体步骤</a>处：</p>
<ol>
<li><p>emsdk install 的默认安装规则是：不管你有没有安装过这些包，我 install latest 都是重新安装，保证最新版本。但是现在问题是 install latest 有问题，我要手动安装包放进去。<br>我们打开 emsdk.py 通过搜索关键词可以找到报错信息的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:675</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On success, returns the filename on the disk pointing to the destination file that was produced</span></span><br><span class="line"><span class="comment"># On failure, returns None.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, dstpath, download_even_if_exists=<span class="literal">False</span>, filename_prefix=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">  debug_print(<span class="string">&#x27;download_file(url=&#x27;</span> + url + <span class="string">&#x27;, dstpath=&#x27;</span> + dstpath + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  file_name = get_download_target(url, dstpath, filename_prefix)</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(file_name) <span class="keyword">and</span> <span class="keyword">not</span> download_even_if_exists:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File &#x27;&quot;</span> + file_name + <span class="string">&quot;&#x27; already downloaded, skipping.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> file_name</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    u = urlopen(url)</span><br><span class="line">    mkdir_p(os.path.dirname(file_name))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      file_size = get_content_length(u)</span><br><span class="line">      <span class="keyword">if</span> file_size &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s, %s Bytes&quot;</span> % (file_name, url, file_size))</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s&quot;</span> % (file_name, url))</span><br><span class="line"></span><br><span class="line">      file_size_dl = <span class="number">0</span></span><br><span class="line">      <span class="comment"># Draw a progress bar 80 chars wide (in non-TTY mode)</span></span><br><span class="line">      progress_max = <span class="number">80</span> - <span class="number">4</span></span><br><span class="line">      progress_shown = <span class="number">0</span></span><br><span class="line">      block_sz = <span class="number">256</span> * <span class="number">1024</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27; [&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          buffer = u.read(block_sz)</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> buffer:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          file_size_dl += <span class="built_in">len</span>(buffer)</span><br><span class="line">          f.write(buffer)</span><br><span class="line">          <span class="keyword">if</span> file_size:</span><br><span class="line">              percent = file_size_dl * <span class="number">100.0</span> / file_size</span><br><span class="line">              <span class="keyword">if</span> TTY_OUTPUT:</span><br><span class="line">                  status = <span class="string">r&quot; %10d  [%3.02f%%]&quot;</span> % (file_size_dl, percent)</span><br><span class="line">                  <span class="built_in">print</span>(status, end=<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">while</span> progress_shown &lt; progress_max * percent / <span class="number">100</span>:</span><br><span class="line">                      <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                      sys.stdout.flush()</span><br><span class="line">                      progress_shown += <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    errlog(<span class="string">&quot;Error: Downloading URL &#x27;&quot;</span> + url + <span class="string">&quot;&#x27;: &quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;SSL: CERTIFICATE_VERIFY_FAILED&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e) <span class="keyword">or</span> <span class="string">&quot;urlopen error unknown url type: https&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e):</span><br><span class="line">      errlog(<span class="string">&quot;Warning: Possibly SSL/TLS issue. Update or install Python SSL root certificates (2048-bit or greater) supplied in Python folder or https://pypi.org/project/certifi/ and try again.&quot;</span>)</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    exit_with_error(<span class="string">&quot;aborted by user, exiting&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> file_name</span><br></pre></td></tr></table></figure>

<p>大致一看能看明白逻辑，如果 download_even_if_exists &#x3D; True 那么无论包是否已经存在都要安装，否则为 False 就只安装不存在的包，我们需要为 False。</p>
<p>搜索函数名查看在哪里使用了这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:1411</span></span><br><span class="line"></span><br><span class="line">received_download_target = download_file(url, download_dir, <span class="keyword">not</span> KEEP_DOWNLOADS, filename_prefix)</span><br></pre></td></tr></table></figure>

<p>这个 KEEP_DOWNLOADS 是一个环境变量，默认为0，我们需要他为1，传入函数的参数则为0（False），即已存在文件不再重复下载。</p>
<p>在终端输入 <code>./emsdk --help</code> 可以看到提示信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment:</span><br><span class="line">      EMSDK_KEEP_DOWNLOADS=1     - if you want to keep the downloaded archives.</span><br><span class="line">      EMSDK_NOTTY=1              - override isatty() result (mainly to log progress).</span><br><span class="line">      EMSDK_NUM_CORES=n          - limit parallelism to n cores.</span><br><span class="line">      EMSDK_VERBOSE=1            - very verbose output, useful for debugging.</span><br></pre></td></tr></table></figure>

<p>也就是说只要安装时单独指定此变量值为1即可。</p>
</li>
<li><p>第二步就是如何下载文件了。下载什么文件？放到哪个目录下？</p>
<p>这里大家可以通过 download_file 的 print debug 调试来查看他校验文件是否存在是去哪里校验的，我就不再具体展开讲调试步骤了，结论就是：他在 emsdk&#x2F;downloads&#x2F; 目录下先查找一下待下载的压缩包是否存在，那么我们复制报错信息中的 url 下载文件到这个 downloads 文件夹下即可（没有就新建）。</p>
</li>
</ol>
<h2 id="solution">具体步骤</h2>

<ol>
<li><p>首先要安装所缺的所有包，一个个安装，报错信息里提示什么安装什么。比如文章开头的报错信息中下载链接是：<a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2%EF%BC%8C%E5%B0%B1%E5%85%88%E5%AE%89%E8%A3%85%E8%BF%99%E4%B8%AA%E3%80%82">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2，就先安装这个。</a></p>
<p>node: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>wasm-binaries: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>安装完成后要重命名 b90507fcf011da61bacfca613569d882f7749552-wasm-binaries.tbz2。</p>
</li>
<li><p>移入 emsdk&#x2F;downloads 文件夹下，不用解压。</p>
</li>
<li><p>执行 <code>EMSDK_KEEP_DOWNLOADS=1</code> 变量赋值。</p>
</li>
<li><p>执行 <code>./emsdk install latest</code>  。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jingqing3948@jingqing:~/Webassembly/emsdk$ ./emsdk install latest</span><br><span class="line">Resolving SDK alias &#x27;latest&#x27; to &#x27;3.1.44&#x27;</span><br><span class="line">Resolving SDK version &#x27;3.1.44&#x27; to &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;</span><br><span class="line">Installing SDK &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;..</span><br><span class="line">Skipped installing node-16.20.0-64bit, already installed.</span><br><span class="line">Skipped installing releases-b90507fcf011da61bacfca613569d882f7749552-64bit, already installed.</span><br><span class="line">All SDK components already installed: &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;.</span><br></pre></td></tr></table></figure>

<p>好哎，看来是自己单独安装的文件包都可以用，他会自己解压文件包后提示 All SDK components already installed。</p>
<p>接下来就是下一步：<code>./emsdk activate latest</code>.</p>
<p>最后是 <code>source ./emsdk_env.sh</code> 配置好环境变量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-效率提升：Win11磁贴配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%EF%BC%9AWin11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/"
    >效率提升：Win11磁贴配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%EF%BC%9AWin11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B8%8F%E6%98%9F%E9%80%90%E8%B7%AF%EF%BC%88%E5%88%9B%E6%96%B0%E6%8E%A2%E7%B4%A2%EF%BC%89/">踏星逐路（创新探索）</a> / <a class="article-category-link" href="/categories/%E8%B8%8F%E6%98%9F%E9%80%90%E8%B7%AF%EF%BC%88%E5%88%9B%E6%96%B0%E6%8E%A2%E7%B4%A2%EF%BC%89/Efficiency/">Efficiency</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近电脑还是升级到 win11 了。我之前采用的美化方案是桌面上的图标全部移到 win10 开始菜单里的全屏菜单上，用磁贴贴一排。每次要访问文件的时候都去开始菜单里找，而不是放在桌面上，这样桌面也可以空出来欣赏壁纸。参考配置链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/45120814/answer/1007955630">如何让Windows 10系统桌面变得更好看？ - 知乎 (zhihu.com)</a></p>
<p>但是升级到 win11 对我而言影响最大的就是压根没有全屏桌面和磁贴功能了。因此我搜了很多解决方案，加上一些自己的改进，最终把桌面磁贴恢复成如上图所示。一个自己喜欢看的桌面还是会对生产力的提高有很大帮助的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712234132339.png" alt="image-20230712234132339"></p>
<h2 id="软件安装：start11"><a href="#软件安装：start11" class="headerlink" title="软件安装：start11"></a>软件安装：start11</h2><p>首先，恢复开始菜单这一操作最离不开的就是 start11 这款软件。他让 win11 的开始菜单又有了全屏菜单选项，也支持了自定义磁贴在上面。虽然调整磁贴位置的时候偶尔会花几秒重启，但大多数时候还是没问题的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235022366.png" alt="image-20230712235022366"></p>
<p>正版软件是免费试用的，欢迎付费支持原作者。或采用博主的同款方案：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru">https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru</a><br>提取码：1fru<br>–来自百度网盘超级会员V2的分享</p>
<p>首先如果是按博主的磁贴方法配置，就要选“win10配置”。或者你觉得其他风格也还不错都可以选。并且 ENABLE start11.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235704628.png" alt="image-20230712235704628"></p>
<p>点击“配置菜单”，进行如下配置：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235738298.png" alt="image-20230712235738298"></p>
<p>在“自定义菜单视觉外观”里，可以设置全屏菜单的颜色、透明度等，比如我使用的是有一定透明度的毛玻璃的样式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000601091.png" alt="image-20230713000601091"></p>
<p>然后在“控制”栏里设定如何打开 start11，确保可以打开：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235840844.png"></p>
<p>接着，点击 win 图标就可以打开全屏菜单了。</p>
<h2 id="磁贴配置"><a href="#磁贴配置" class="headerlink" title="磁贴配置"></a>磁贴配置</h2><p>对于大部分软件，只要右键-固定到开始屏幕&#x2F;固定到 start11，就可以在全屏菜单里看到刚刚贴上的磁贴了。</p>
<p>如果贴失败，可以尝试以下的方法：</p>
<ul>
<li>右键快捷方式，点击“打开文件所在位置”，再尝试把该文件的 .exe 文件固定到开始屏幕。</li>
<li>反复尝试，因为可能有一定的延迟。可以取消固定再次固定，等待一会看开始菜单是否出现。</li>
</ul>
<p>然后可以手动分组磁贴（把他们移到临近的位置），调整磁贴背景色，调整磁贴大小（有小正方形，中正方形，长方形，大正方形四种可以选择），调整磁贴布局位置。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000428410.png" alt="image-20230713000428410"></p>
<h2 id="图片磁贴配置"><a href="#图片磁贴配置" class="headerlink" title="图片磁贴配置"></a>图片磁贴配置</h2><p>这里是最自由发挥的部分。高情商：自由发挥。低情商：都要自己做很麻烦。</p>
<p>之前 win10 是有一款快捷工具可以输入自定义图片，按自己想要的格式裁剪并自动在全屏菜单中输出的，叫 Tile Genie.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000854968.png" alt="image-20230713000854968"></p>
<p>但是它好像并不能在 start11 中使用。我尝试了一下导出的都是不能显示的图片块，所以只能放弃这种方法。如果读者的 Tile Genie 是没有问题可以正常显示图片那再好不过了，后面的内容都可以不用看了。</p>
<p>如果导出失败……我采用的方法是手动裁剪固定图片。很笨，但是有结果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001102790.png" alt="image-20230713001102790"></p>
<p>首先，自行裁剪图片，计算公式为：中正方形 150*150，长方形 306*150，大正方形 306*306，边界线是6（像素）.</p>
<p>我采用的图像裁剪方法是：<a target="_blank" rel="noopener" href="https://www.iloveimg.com/zh-cn/crop-image">免费在线裁剪图像文件 (iloveimg.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178422454.png" alt="1689178422454"></p>
<p>然后把导出图片找一个合适的地方存储起来，注意贴上磁贴之后就不能再移动修改这些图片了。</p>
<p>在全屏菜单中右键-固定文件，选定文件路径添加。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001454756.png" alt="image-20230713001454756"></p>
<p>刚固定上是这种形式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178534062.png" alt="1689178534062"></p>
<p>然后右键-调整大小，调整为想要的大小。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001613170.png" alt="image-20230713001613170"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001632462.png" alt="image-20230713001632462"></p>
<p>最后一步，右键-图标-选择自定义磁贴图像，再次选择此文件，然后他就被当做图标全屏显示了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001653804.png" alt="image-20230713001653804"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：RFID"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ARFID/"
    >北邮国院笔记：RFID</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ARFID/" class="article-date">
  <time datetime="2023-07-24T23:00:00.000Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要围绕考试提纲里的所有问题展开，没有拓展内容，Exam oriented Study。</p>
<p>关注微信公众号：灰海宽松，回复 “RFID” 可获取本文pdf格式。</p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h2 id="Comparison-of-different-automatic-identification-technologies"><a href="#Comparison-of-different-automatic-identification-technologies" class="headerlink" title="Comparison of different automatic identification technologies"></a>Comparison of different automatic identification technologies</h2><p>首先明确一下比较对象。human identification（cost too high）是人力识别就不用说了。</p>
<p>fingerprint identification: </p>
<ul>
<li>stability 稳定，精确度高；</li>
<li>high speed, 快速匹配；</li>
<li><strong>security issues</strong>: 容易被复制。</li>
</ul>
<p>face recognition:</p>
<ul>
<li>easy to be influenced by surroundings, hair, age…</li>
</ul>
<p>speech recognition:</p>
<ul>
<li>easy to use and accept by user;</li>
<li>not involve privacy;</li>
<li>due to international standards, is hard to promoting</li>
</ul>
<p>1d barcode:</p>
<ul>
<li>limit storage capacity, 点线组合少;</li>
<li>need to combine with database;</li>
<li>barcode size is large;</li>
<li>poor fault tolerance, 本来就需要摄像头可见，如果被污损遮挡很容易就无法识别;</li>
</ul>
<p>2d barcode recognition:</p>
<ul>
<li>larger storage capacity;</li>
<li>high information density;</li>
<li>powerful fault tolerance;</li>
<li>support for encryption 容量大了就支持更多编码解码等安全措施了。</li>
</ul>
<p>rfid：</p>
<ul>
<li>low cost;</li>
<li>low power consumption;</li>
<li>high accuracy;</li>
<li>non-contract, fast speed; 不用接触（哪怕是visual，薄纱条码）</li>
<li>certain computing and storage capabilities;</li>
</ul>
<p>主要考虑各个的缺点，人脸和声音特征点多速度慢，而且人脸容易被影响，声音由于国际标准技术难以提升；条码需要视觉可见；指纹容易被盗取。</p>
<h2 id="The-main-features-of-RFID"><a href="#The-main-features-of-RFID" class="headerlink" title="The main features of RFID"></a>The main features of RFID</h2><ul>
<li><p>Non-contact automatic and rapid identification 快速薄纱复杂的人脸和声音，无接触薄纱条码和指纹</p>
</li>
<li><p>Permanently store a certain amount of data 永久存储一定量数据</p>
</li>
<li><p>Simple logical processing 其包含的简单逻辑电路允许做一定的逻辑处理，比如安全协议、算法</p>
</li>
<li><p>Reflection signal strength is affected by the distance  and other factors significantly 信号受到距离，读写器功率，其他信号，其他标签的干扰</p>
</li>
<li><p>Low cost, can be deployed at a large scale</p>
</li>
</ul>
<h2 id="Constraints-of-RFID-technology"><a href="#Constraints-of-RFID-technology" class="headerlink" title="Constraints of RFID technology"></a>Constraints of RFID technology</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687019780697.png" alt="1687019780697"></p>
<h2 id="Core-technologies-of-RFID"><a href="#Core-technologies-of-RFID" class="headerlink" title="Core technologies of RFID"></a>Core technologies of RFID</h2><p>Anti-collision mechanism：rfid并不支持传统的cmsa&#x2F;ca无线通信协议，需要采取一些措施防碰撞（reader-reader, tag-reader, tag-tag)</p>
<p>Efficient information storage, retrieval and mining: 尽量节能的信息存储，检索，挖掘</p>
<p>Make full use of the attenuation laws of backscatter signal to assist in positioning and mobile behavior sensing: 我们知道rfid信号会随着距离衰减。反之我们也可以利用这一点来定位物体位置和移动行为感知。</p>
<p>Security certification and privacy protection: 如何利用逻辑门电路校验安全性。</p>
<h2 id="The-advantage-of-RFID-in-IoT-and-the-development-trend"><a href="#The-advantage-of-RFID-in-IoT-and-the-development-trend" class="headerlink" title="The advantage of RFID in IoT, and the development trend"></a>The advantage of RFID in IoT, and the development trend</h2><p>充电方式：Backscatter, small node and indefinitely time of endurance. but rely on reader, one to many centralized communication 利用无线电 ratio signal 充电的方式</p>
<p>ptp communication: 建立 channel awareness technologies 使得支持被动点对点通信来建立分布式系统</p>
<p>Combine with Sensors: 开发更多应用方式。</p>
<p>RFID and IoT:</p>
<ul>
<li>embed intelligence in the physical object, so that simple physical objects can also “say”. </li>
<li>allows a physical object to be uniquely identified in a way similar to the “IP address” of a computing node in the Internet. </li>
<li>provides a low-cost communication way to achieve effective communication between nodes. </li>
<li>makes the physical objects in a passive environment achieve “passive intelligence“, providing fundamental guarantee for the “thing-thing connection”</li>
</ul>
<h1 id="2-Identification"><a href="#2-Identification" class="headerlink" title="2. Identification"></a>2. Identification</h1><p>简单说RFID就是物体上贴tag，用reader上的antenna去读取，这三个是主要组成。</p>
<h2 id="Reader’s-function"><a href="#Reader’s-function" class="headerlink" title="Reader’s function"></a>Reader’s function</h2><p>Energy supply: 比如有的标签自身不带能量需要reader提供信号中蕴含的能量</p>
<p>Communication: 最基本的功能，和tag识别，通信</p>
<p>Security Assurance: 比如加密解密</p>
<p>扩展功能：比如自组网 ad-hoc, 管理天线 antenna management 中间件接口 interface of middle components 连接外设 connecting peripherals</p>
<h2 id="Reader’s-classification"><a href="#Reader’s-classification" class="headerlink" title="Reader’s classification"></a>Reader’s classification</h2><p>按频率：LF HF算低频，UHF和SHF算高频（ultra super)，高频数据传输速度快，距离远，但是衰减快 signal attenuation，收到障碍物影响大  sensitive to obstacles。</p>
<p>按外观：</p>
<ul>
<li>Fixed 固定有线的，高度集成，快速启动 set up</li>
<li>portable 可移动的像手持手机一样，small, charging battery, easy to move</li>
<li>Industrial 为工厂目的而生，比如集成其他 sensor</li>
</ul>
<h2 id="Influencing-factors-of-R-W-range"><a href="#Influencing-factors-of-R-W-range" class="headerlink" title="Influencing factors of R&amp;W range"></a>Influencing factors of R&amp;W range</h2><p>许多东西都有说明书，规范，来提醒我们怎么不把东西玩坏比如手机提示不要放水里玩。</p>
<p>RFID的R&amp;W range是其中一种。影响因素如下：</p>
<ul>
<li><p>The way that antenna is coupled 天线耦合方式，比如把两个天线绑一起太近互相干扰。</p>
</li>
<li><p>The output power of the reader’s RF signal 功率，太低可能无法激发tags</p>
</li>
<li><p>The frequency of RF carrier signal 合适的频率</p>
</li>
<li><p>Antenna direction 天线，读取器天线和标签天线极性方向 polarization 相匹配时识别范围最大</p>
</li>
<li><p>Operation environment condition</p>
</li>
<li><p>Movement speed of tags</p>
</li>
</ul>
<h2 id="Reader’s-components-and-their-functions"><a href="#Reader’s-components-and-their-functions" class="headerlink" title="Reader’s components and their functions"></a>Reader’s components and their functions</h2><p>Signal Processing and Control Module: 主要是控制功能，协调一些本地计算</p>
<ul>
<li>Communicate with upper computer,  and execute command from it</li>
<li>Control communication process with tags</li>
<li>Encode and decode signal</li>
<li>Perform anti-collision algorithm</li>
<li>Encrypt and decrypt the data  transferred between reader and tag</li>
<li>Identity certification between reader and tag</li>
</ul>
<p>Inductively Coupled RF Module: 主要是产生能量和调制发送信号功能</p>
<ul>
<li>Generate high frequency send energy, activate RF tags and  provide energy (passive RF tags) </li>
<li>Modulate signal to sent,  transferring data to RF tags</li>
<li>Receive and demodulate RF signal  from RF tags.</li>
</ul>
<h2 id="Tag’s-functions"><a href="#Tag’s-functions" class="headerlink" title="Tag’s functions"></a>Tag’s functions</h2><ul>
<li>data storage</li>
<li>energy harvesting 吸收能量，与reader的 energy supply 对应</li>
<li>contactless with R&amp;W 不用接触就能通信，与 reader 的 communication with tags 对应</li>
<li>Security Encryption 与 reader 的 Security Assurance 对应</li>
<li>Collision Concessions 碰撞让步</li>
</ul>
<h2 id="Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability"><a href="#Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability" class="headerlink" title="Tag classification: by package form, by power source, by work frequency, by R&amp;W capability"></a>Tag classification: by package form, by power source, by work frequency, by R&amp;W capability</h2><p>Package form 也就是外观上的分类：</p>
<ul>
<li>card-like</li>
<li>label-like</li>
<li>Implantable, 比如动物植物体内</li>
<li>Accessories-like 附件类标签，比如纽扣型的，这一类主要是方便携带</li>
</ul>
<p>By Power Source 按能源供应方式分类：</p>
<ul>
<li>active 自己有电池供电</li>
<li>passive 依靠 carrier signal 读取器发来的载波信号获取能量</li>
<li>semi-passive 有电池作为后备隐藏能源，平时主要是passive 方式</li>
</ul>
<p>By Work Frequency</p>
<p>LF HF UHF。UHF读写性能，距离最好，更多会使用 active 型。</p>
<p>By R&amp;W Capability</p>
<p>read-only 和 R&amp;W 两种，结构复杂度也有所不同</p>
<h2 id="Two-work-modes-of-RFID-middleware"><a href="#Two-work-modes-of-RFID-middleware" class="headerlink" title="Two work modes of RFID middleware"></a>Two work modes of RFID middleware</h2><p>interactive, independent。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618045820043.png" alt="image-20230618045820043"></p>
<p>交互模式大概就是一直接收主机的命令，你让我读我就读，读完把结果还给你。</p>
<p>独立模式是可以不接收主机命令自行按预设的程序和读取到的结果信息循环执行指令，并将结果返回给主机。</p>
<h1 id="3-Wireless-Communication-Principle-of-RFID"><a href="#3-Wireless-Communication-Principle-of-RFID" class="headerlink" title="3. Wireless Communication Principle of RFID"></a>3. Wireless Communication Principle of RFID</h1><h2 id="Different-work-principles-of-different-carrier-frequency"><a href="#Different-work-principles-of-different-carrier-frequency" class="headerlink" title="Different work principles of different carrier frequency"></a>Different work principles of different carrier frequency</h2><p>不同频率载波也适用不同的工作原则。</p>
<p>前面已经有所涉及，比如LF HF适用于近距离，UHF SHF适合远距离。</p>
<p>前者适用 Inductively Coupled RF Module 电感耦合，通过感应方式获取能量。</p>
<p>后者适用 Electromagnetic Backscatter Coupled RF Module 电磁反向散射耦合，持续不断发送射频信号来供给能量。backscatter 指的是接收机信号调制后通过发送机天线产生可被识别的信号。</p>
<p>两者的能量消耗都和距离平方成正比 squared distance</p>
<h2 id="Signal-voltage-and-energy-dB-dBm，重点：如何计算"><a href="#Signal-voltage-and-energy-dB-dBm，重点：如何计算" class="headerlink" title="Signal voltage and energy: dB, dBm，重点：如何计算"></a>Signal voltage and energy: dB, dBm，重点：如何计算</h2><p>变化的电压通常用 $V(t)&#x3D;v_0cos(\omega t)$ 表示。</p>
<p>功率P&#x3D;VI&#x3D;V^2&#x2F;R这不用多说。平均功率 $&#x3D;\frac{v_0^2}{2R}$ 很简单推因为正余弦平均就是&#x2F;根2.</p>
<p>相对变化 The relative change，这是一个比较新鲜的而且信号变化中比较重要的指标。</p>
<p>$G_{dB}&#x3D;10log_{10}\frac{P2}{P1}$ </p>
<p>参考功率 referenced power $dBm&#x3D;10log_{10}\frac{P}{10^{-3}}$</p>
<p>dBm单位是功率的W，GdB单位是dB，代表一个比值。</p>
<h2 id="Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0"><a href="#Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0" class="headerlink" title="Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0"></a>Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0</h2><p>一些阅读器通过调制使得正弦电压信号携带信息的方法。</p>
<p>OOK：on off keying，高功率1低功率0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036831437.png" alt="1687036831437"></p>
<p>问题在于，低功率0的部分标签没法被激活，也无法正常工作。也就是说0信号标签压根启动不了，没法接收0信号。</p>
<p>PIE解决方法：长高功率是1，短高功率是0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036892748.png" alt="1687036892748"></p>
<p>然后涉及到tags对reader发来的信号进行解码。空间中的信号发过来是有方向的矢量叠加，tags如何通过编码机制识别信号？</p>
<p>FM0编码方式：位窗起始处翻转信号表示1，中间翻转表示0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687037382818.png" alt="1687037382818"></p>
<p>FM0属于 FSK frequent shift key 通过信号变化频率来识别的机制。</p>
<h2 id="Link-budget-重点"><a href="#Link-budget-重点" class="headerlink" title="Link budget (重点)"></a>Link budget (重点)</h2><p>Link budget: forward link budget  and backward link budget 发射过程中能量增减的总和</p>
<p>reader transmit energy(+) path loss(-) tag activate energy(-)</p>
<ul>
<li>pass loss: 读取器天线向360度的发送能量。其中只有一部分区域可以被tags antenna读取到，这一部分被称作 Effective  Aperture (Ae) of the tag antenna。能量&#x3D;有效面积*密度 $P_t&#x3D;\rho A_e$ 。总共发送的能量比收到的能量就等于总表面积比有效面积 $\frac{P_{TX}}{P_{RX}}&#x3D;\frac{A_e}{4\pi r^2}$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618174327976.png" alt="image-20230618174327976"></p>
<p>来看上例，发送方30dBm对应1W，tag接收到-10dBm对应10^-4W. 然后5dB的衰减到-15dBm。这个5dB衰减就是两个dBm做差得到的。</p>
<p>所以，dBm相当于对功率P的另一种衡量方式，为什么这么麻烦的要用log来表示？因为两个dBm的差值就是分贝（放大系数），所以由一个dBm能量转到另一个只需要加减两者间差的分贝即可，很方便。</p>
<p>从tags反射回来的信号 reflection link 和路径四次方成反比 inversely proportional. $P_{RX,back}:\frac{1}{r^4}$</p>
<h2 id="Antenna-gain-and-polarization-EIRP"><a href="#Antenna-gain-and-polarization-EIRP" class="headerlink" title="Antenna gain and polarization, EIRP"></a>Antenna gain and polarization, EIRP</h2><p>antenna gain: 输入条件相同情况下，实际情况某一点能量密度&#x2F;理想条件下的密度单元。反应了天线 concentrates the input power 的能力。就比如把阅读器放中间，标签围一圈，360度去读取周围标签对能量消耗就大，可能因此传输距离也近；但是如果把标签集中放在一块区域，周围放置的 reader 利用定向天线 Directional antenna，固定读取某一个角度范围内的tags能量利用效率就高。</p>
<p>Polarization：事物在一定条件下发生极化 polarization，使得其表现的和原有状态不一样  its properties deviate from the  original state。</p>
<p>EIRP, Equivalent Isotropic Radiated Power: 天线在所指方向上获得最大增益效果 maximum gain effect 所需要的能量。</p>
<p>For example, FCC regulations in the United States, a non-irradiated  transmitter can transmit 1W of energy signals, and can use 6dBi antenna; antenna gain increased by 1dB, transmission energy needs to  be reduced by 1dB. In fact, FCC is not more than  36dBm(30dBm+6dBi).</p>
<h2 id="Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式"><a href="#Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式" class="headerlink" title="Effects of antenna gain，重点：分析 link budget，几个计算公式"></a>Effects of antenna gain，重点：分析 link budget，几个计算公式</h2><p>directional gain: radiation density of one direction d &#x2F; average value in all direction</p>
<p>power gain: radiation efficiency of that direction G</p>
<p>平面角：单位rad，比如圆周180度单位角&#x3D;2pi rad</p>
<p>立体角：单位sr，比如球面立体角&#x3D;4pi sr</p>
<p>能量增益G的计算方法是4pi&#x2F;立体角大小。比如波束宽度72°也就是2pi&#x2F;5大概是1.25rad， $G&#x3D;\frac{4\pi}{1.25^2}$</p>
<p>dipole antenna: 垂直于轴沿各个方向发送信号，比全向天线 omnidirectional antenna 小2.2dB。</p>
<p>Effective aperture $A&#x3D;G\frac{\lambda ^2}{4\pi}$</p>
<p>$P_{RX}&#x3D;P_{TX}G_{RX}G_{TX}(\frac{\lambda}{4\pi r})^2$</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619104251622.png" alt="image-20230619104251622"></p>
<p>$R_{forward}&#x3D;\frac{\lambda}{4\pi}\sqrt{\frac{P_{TX,reader}T_bG_{reader}G_{tag}}{P_{min,tag}}}$</p>
<p>$R_{reverse}&#x3D;\frac{\lambda}{4\pi}\sqrt[4]{\frac{P_{TX,reader}T_bG_{reader}^2G_{tag}^2}{P_{min,reader}}}$</p>
<h1 id="4-Tag-Identification-Protocol"><a href="#4-Tag-Identification-Protocol" class="headerlink" title="4. Tag Identification Protocol"></a>4. <strong>Tag</strong> Identification Protocol</h1><h2 id="Checksum-procedure-parity-checks-LRC-CRC"><a href="#Checksum-procedure-parity-checks-LRC-CRC" class="headerlink" title="Checksum procedure: parity checks, LRC, CRC"></a>Checksum procedure: parity checks, LRC, CRC</h2><p>奇偶校验不多说，查1的个数，poor error recognition。电路通过所有位异或是偶校验，结果为1说明有错误；再取反是奇校验。</p>
<p>LRC longitudinal redundancy check (LRC) procedure 循环冗余检测，所有字节进行异或运算，得到的结果是LRC校验码。也就是说数据发送到终点后，所有字节（数据和LRC）进行字节异或运算结果应该为0. 也有一些错误无法纠正，主要用于小的数据块校验。</p>
<p>CRC (cyclic redundancy check) procedure</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142701838.png" alt="1687142701838"></p>
<p>接收方计算原数据+CRC数据拼接起来的CRC数据值，应该为0. 不能纠错，不过检错效率很高。</p>
<h2 id="ASK-FSK-PSK"><a href="#ASK-FSK-PSK" class="headerlink" title="ASK, FSK, PSK"></a>ASK, FSK, PSK</h2><p>amplitude Shift Keying: 幅度调制，y轴上的调制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142836442.png" alt="1687142836442"></p>
<p>计算方法2：duty factor: $m&#x3D;1-\frac{u_1}{u_0}$</p>
<p>$U_{ASK}(t) &#x3D;(m·u_{code}(t)+1−m)·u_{HF}(t)$</p>
<p>Frequency shift keying: 频率上的改变。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143205258.png" alt="1687143205258"></p>
<p>Phase shift keying: 频率相位翻转180.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143252934.png" alt="1687143252934"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143276722.png" alt="1687143276722"></p>
<h2 id="Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags"><a href="#Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags" class="headerlink" title="Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags"></a>Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags</h2><p>Compared with the reader, limited by hardware resources, tags have very limited storage capacity and computing. </p>
<p>标签受制于硬件资源，存储容量和计算能力都不高。</p>
<h2 id="TDMA-FDMA-CSMA"><a href="#TDMA-FDMA-CSMA" class="headerlink" title="TDMA, FDMA, CSMA"></a>TDMA, FDMA, CSMA</h2><p>首先主要有两种方式，一个是reader broadcast 广播到诸多 tags，一个是多个 tags Multi-access 每个tags单独访问reader。</p>
<p>TDMA FDMA是multi-access, CSMA是broadcast</p>
<p>FDMA: 多个频率通道 several frequency channels 传输数据。</p>
<p>TDMA: </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619212501183.png" alt="image-20230619212501183"></p>
<h2 id="ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程"><a href="#ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程" class="headerlink" title="ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程"></a>ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程</h2><p>Pure ALOHA algorithm：收到成功确认 ack 后就不再发送。否则一直随机等待后继续发送。简单但是通道利用率 channel utilization 低，poor performance.</p>
<p>offered load G：单位时间 tau 里同时发送的应答器数量</p>
<p>s-aloha: 规定时间片 slot，一个时间片只能发一次，冲突就下一次时间片去发。channel utilization 几乎是 pure 的两倍。</p>
<p>$S &#x3D; G × e^{-G}$ G&#x3D;1最大</p>
<p>frame S-ALOHA: 规定一个周期 frame，包含若干个 slots，会更加有组织有秩序。reader 广播一个 frame length，tags 自己选择组织时间片（0~f-1），每个时间片开始 reader 轮询一下tag里sn信号是不是0，是0就发送，不是0就-1.</p>
<p>conflict slot, single slot, idle slot（空）</p>
<p>逻辑，电路设计，内存都比较简单，但是 frame length 长度不固定。tags 远远多于 frame length 冲突时间片就太多，tags 太少空时间片太多太浪费。负载 G&#x3D;1 也就是 length&#x3D;tags 利用率最好。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620001137399.png" alt="image-20230620001137399"></p>
<p>DFSA：利用以前的 frame 冲突反馈结果，和一些机器学习算法推测合适的 frame length。</p>
<p>EPC Global（第五章介绍）规范里使用了一种Q算法。简单说就是如果冲突太多了，当前 frame 就别继续了，中断，新开一个大容量 frame. 同理 空闲太多了就新开一个小 frame。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620002424045.png" alt="image-20230620002424045"></p>
<p>Qfp是指定的初始值。每次先取整，然后发起 query。</p>
<p>没有回复：Qfp-C C是一个参数，比如0.1.</p>
<p>有冲突&gt;1：+C。注意有上下限。</p>
<p>ALOHA 算法公平。<strong>但是可能发生饥饿</strong> ，比如有一个 tag 每次都是有冲突的 slot，一直没有办法被处理。</p>
<h2 id="Binary-tree-based-protocols-BT-QT-重点：执行过程"><a href="#Binary-tree-based-protocols-BT-QT-重点：执行过程" class="headerlink" title="Binary tree based protocols: BT, QT, 重点：执行过程"></a>Binary tree based protocols: BT, QT, 重点：执行过程</h2><p>第二种算法，基于二进制数。就像二叉树不断拆分冲突的结点变为两个结点，直到节点里只有一个 tag。</p>
<p>random binary tree BT：随机。</p>
<p>binary query tree QT：排序，查询。</p>
<p>每一个 tag 需要有一个计数器来记录自己的状态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620003431357.png" alt="image-20230620003431357"></p>
<p>每一个tag都会被识别，不会饥饿，但是需要存储每个tag的状态。</p>
<p>比如看下面的例子：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620004226401.png" alt="image-20230620004226401"></p>
<p>首先 tag1234 随机选一个数，比如选了0010，SN分别加自己选的数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010150624.png" alt="image-20230620010150624"></p>
<p>找SN&#x3D;0的，发现有是有，但是他们几个都冲突了。那么继续分，比如1011，SN&#x3D;1021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010254069.png" alt="image-20230620010254069"></p>
<p>2的SN&#x3D;0而且不冲突，把2读取了之后2不再继续参与。然后当有tag读取后，所有其他SN-&#x3D;1</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010408026.png" alt="image-20230620010408026"></p>
<p>&#x3D;0的是14，但是他俩冲突。然后再重新划分一下，比如011, SN&#x3D;0021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010452073.png" alt="image-20230620010452073"></p>
<p>然后处理1，其他-&#x3D;1，处理4，其他-&#x3D;1，处理3.</p>
<p>QT 不需要存储状态，如何实现？读取tag的序列号比较。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010802734.png" alt="image-20230620010802734"></p>
<p>不会饿死，也不需要一个可以读写的cnt，识别的时间和 tag id 有关。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011058481.png" alt="image-20230620011058481"></p>
<h2 id="Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程"><a href="#Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程" class="headerlink" title="Binary search: Manchester code instead of NRZ code, 重点：执行过程"></a>Binary search: Manchester code instead of NRZ code, 重点：执行过程</h2><p>具体分辨哪一位有冲突。1代表冲突。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011804411.png" alt="image-20230620011804411"></p>
<p>NRZ混合没法检测错误。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011902936.png" alt="image-20230620011902936"></p>
<p>曼彻斯特可以，一个上升一个下降，合起来是0或者1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011942870.png" alt="image-20230620011942870"></p>
<p>查询的流程：</p>
<ul>
<li>request：发送一个序列号给tags的transponder，如果tags的序列号小于给定序列号返回。</li>
<li>select：给定一个特定序列号，返回等序列号的tag。</li>
<li>read_data：返回所选tag的信息。</li>
<li>unselect：读取完data了，这个tag退出选择流程。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620012706251.png" alt="image-20230620012706251"></p>
<p>第一次迭代：返回uplink是所有transponder的id的共同信息（通过曼彻斯特编码找出没有冲突的位）。046位冲突了（从右往左），8个可能。</p>
<p>第二次迭代：限定 bit6 为0的request。发现有3个还是冲突04位（最高位冲突位&#x3D;0，其他冲突位&#x3D;1，如果range是大于等于，则正好相反）。</p>
<p>第三次迭代：限定bit4为0的request……</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620013603192.png" alt="image-20230620013603192"></p>
<p>长度 L(N)&#x3D;log2(N)+1</p>
<h2 id="Dynamic-binary-search-重点：执行过程"><a href="#Dynamic-binary-search-重点：执行过程" class="headerlink" title="Dynamic binary search, 重点：执行过程"></a>Dynamic binary search, 重点：执行过程</h2><p>Binary Search 是每次都传输完整二进制字符串. 其实我们只需要动态改变的部分.</p>
<p>比如我们查询1010 1111 1111, 那返回值前面一定是1010呀, 就不用传输了. 前缀叫 NVB, Number of Valid Bits</p>
<p>每次请求发送的信息: Request+NVB&#x3D;4+1010</p>
<h2 id="Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of ALOHA based anti-collision algorithm"></a>Advantages and disadvantages of ALOHA based anti-collision algorithm</h2><p>simple</p>
<p>good identification performance</p>
<p>results can be statistically analyzed 结果可以被统计化分析</p>
<p>缺点就是可能 starvation 饥饿，delay trend to ∞</p>
<h2 id="Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of binary tree based anti-collision algorithm"></a>Advantages and disadvantages of binary tree based anti-collision algorithm</h2><p>simple</p>
<p>intermediate state variables 不需要存储中间状态变量（QT）</p>
<p>缺点：查询时间受到 tags id 和 长度限制，比如二叉树沿着一个方向一直偏。</p>
<h1 id="5-EPCglobal-Standard-protocol"><a href="#5-EPCglobal-Standard-protocol" class="headerlink" title="5. EPCglobal Standard &amp; protocol"></a>5. EPCglobal Standard &amp; protocol</h1><h2 id="Concept-of-EPC-global-network"><a href="#Concept-of-EPC-global-network" class="headerlink" title="Concept of EPC global network"></a>Concept of EPC global network</h2><p>EPCglobal Network: a technology that </p>
<ul>
<li>allows trading partners to document and determine the location of individual goods </li>
<li>if possible in real time</li>
<li>additional information: such as 生产使用日期，能否被贸易伙伴交换</li>
</ul>
<h2 id="Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network"><a href="#Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network" class="headerlink" title="Five basic services of EPC global network, interaction of different components of EPCglobal network"></a>Five basic services of EPC global network, interaction of different components of EPCglobal network</h2><p>Electronic product code (EPC)</p>
<p>The identification system</p>
<p>EPCglobal Middleware</p>
<p>Discovery Service (DS)</p>
<p>EPC Information Services (EPCIS)</p>
<p>EPC码是唯一标识对象的代码。识别系统包括对象上的可被读取的包含EPC码的transponder和读取器reader可以识别EPC，然后通过EPCglobal Middleware传到网上，通过DS在 EPCglobal network 查找EPC码的相关信息（包括object naming service）。可以通过EPCIS和其他贸易伙伴交换EPC相关信息。</p>
<p>这其中的交互：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619112053963.png" alt="image-20230619112053963"></p>
<p>transponder and reader : data acquisition</p>
<p>Middleware</p>
<p>Discovery services</p>
<p>EPC Information Services : access to EPC-related data</p>
<h2 id="EPC-code-组成"><a href="#EPC-code-组成" class="headerlink" title="EPC code 组成"></a>EPC code 组成</h2><p>Domain Manager Number + Object Class Number + Serial Number</p>
<h2 id="Basic-procedures-of-the-EPC-Network"><a href="#Basic-procedures-of-the-EPC-Network" class="headerlink" title="Basic procedures of the EPC Network"></a>Basic procedures of the EPC Network</h2><p>EPC码用于标识对应对象</p>
<p>all information about the object 在EPCGlobal Network里注册 administer</p>
<p>each company in the EPCglobal Network: 各个公司管理数据集和数据对象</p>
<p>access rights to object data: 包含在EPCIS里，指明了trading partners 之间访问权限</p>
<ol>
<li><p>the manufacturer：把transponder和product绑定</p>
</li>
<li><p>all data assigned to the product：在EPCIS里</p>
</li>
<li><p>EPCIS registers the entries with EPC Discovery Services：注册了DS之后方能找得到EPCIS</p>
</li>
<li><p>product：卖给零售商 retailer</p>
</li>
<li><p>At the retailer’s goods-in point 数据存储在零售商EPCIS中</p>
</li>
<li><p>registered by EPCIS with EPC Discovery Services </p>
</li>
<li><p>The company prefix send to root EPCIS</p>
</li>
<li><p>root -&gt; local -&gt; the EPCIS</p>
</li>
</ol>
<h2 id="Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0"><a href="#Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0" class="headerlink" title="Binary tree based variant algorithm for EPCglobal Class 0"></a>Binary tree based variant algorithm for EPCglobal Class 0</h2><p>这种tag是只读的，制造商赋值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687148304873.png" alt="1687148304873"></p>
<h2 id="EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs"><a href="#EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs" class="headerlink" title="EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs"></a>EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs</h2><p>EPC C1G1：查询tags EPC的一种标准。</p>
<p>被动标签，支持kill和lock两种操作。</p>
<p>pingID：掩码，用于查询tag EPC</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197150310.png" alt="1687197150310"></p>
<p>EPC C1G2 有 OSI 的七层模型，两条数据链路（R-T）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197271532.png" alt="1687197271532"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687198440696.png" alt="1687198440696"></p>
<p>上电 ready</p>
<p>发 query 命令，aribtrate 仲裁。选择随机数生成时间片。</p>
<p>slot&#x3D;0 的开始 reply </p>
<p>tag 发 ack 给 reader，acknowledged 状态。</p>
<p>tag 收到 reader 的命令后进入 open，校验后进入 secured，完成 killed。</p>
<p>4个识别 tags 的命令：Select command, Query command, QueryRep command, QueryAdjust command</p>
<p>select 指明要查哪些 tags 的集合。</p>
<p>query 启动新的识别过程。</p>
<p>Rep 开启下一轮 slot 查询，标签 SN–，到0时读取。</p>
<p>Adjust 调整时隙数，选择新的时隙计数器等。</p>
<p>两大性能问题：</p>
<ul>
<li>Build a set of tags involved in the recognition process，如何建立正确的tags集合来查询（select 和 query 负责）</li>
<li>Select the way of data encoding, for the readerto-tag, the tag-to-reader, the reader itself and the  tag itself 根据环境调整编码方式</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RFID/" rel="tag">RFID</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=1357960253&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>