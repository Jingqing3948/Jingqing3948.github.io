<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />

      <meta name="google-site-verification" content="YwYbA1LbL6DK2afClSAZcmUaT2QiD4rluljLHHU4120" />
      
      <title> 灰海宽松的博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">灰海宽松的博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['没有一条路无风无浪', '常应常静，常清净矣', 'Love the Life You Live'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-技术学习：黑马程序员 Redis"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2025/05/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Redis/"
    >技术学习：黑马程序员 Redis</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/05/21/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98%20Redis/" class="article-date">
  <time datetime="2025-05-20T23:00:00.000Z" itemprop="datePublished">2025-05-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习自：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t/?p=2&share_source=copy_web&vd_source=dcdc734e318da0cd82bcccb180b12b40">【黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目】 </a></p>
<h2 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs. NoSQL"></a>SQL vs. NoSQL</h2><ul>
<li>S：结构化，比如在 MySQL 我们需要定义一个表，第一个属性是 id 第二个是 name 第三个是 age…… 定义好表之后所有新插入的数据都必须遵循这个结构，各个表还可能有外键等关联，所以总的来说不能随意修改表的属性。而 NoSQL 结构要求没那么严格，比如下面这种 Redis 定义方式也可以，就是没啥章法：</li>
</ul>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505211052874.png" alt="image-20250521105232832" style="zoom:67%;" />

<p>​	除了键值类型，还有文档类型，列类型，图类型等 NoSQL。</p>
<ul>
<li><p>R：关联的，SQL 数据库的各个属性之间有关联而 NoSQL 未必。</p>
</li>
<li><p>SQL 语句查询：关系型数据库都支持，而非关系型不支持。</p>
</li>
<li><p>ACID 事务：NoSQL 不支持。</p>
</li>
<li><p>存储位置：SQL 在硬盘，NoSQL 在内存。</p>
</li>
<li><p>SQL 对安全一致性要求较高，NoSQL 对性能要求较高。</p>
</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis Remote Dictionary Server 是一种基于内存的<strong>键值对</strong>数据库，被创造的原因就是 MySQL 性能太差。里面没有表什么的结构，就是存储一对一对的键值，所以是 NoSQL 数据库。值可以是复杂的数据形式，比如键是 1001，值是 {name: “xxx”, age:”19”}…… 这样的 json 格式。</p>
<p>Redis 是<strong>单线程</strong>的，但是效率仍然比 MySQL 高很多，因为内存存取速度远大于硬盘，C 语言编写，IO 多路复用等特点。</p>
<p>支持<strong>数据持久化</strong>，定期将数据从内存持久化到磁盘存储。</p>
<p>支持主从集群，分片集群。</p>
<p>支持多语言客户端。</p>
<h1 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h1><p>安装部分就跳过不做过多赘述了。</p>
<p>Redis 默认启动方式是前台启动，会阻塞整个会话窗口。可以通过修改配置文件的方式改为后台启动。或者在 system 文件夹内新建一个系统服务 .service 文件，实现开机自启动。</p>
<p>配置完成后，终端客户端连接：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">start</span> redis # 启动 redis 后台服务</span><br><span class="line">$ redis-cli -h <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> [-p port] [-a password] # 客户端终端方式连接 redis-cli</span><br><span class="line">&gt; AUTH password # 输入用户名和密码进行登录，也可以在上面 -a 那一步登录 不过这样不安全</span><br><span class="line">&gt; <span class="built_in">ping</span> # 如果成功登录了就会收到：PONG 否则会受到权限不够的提示</span><br><span class="line"></span><br><span class="line">&gt; SELECT <span class="number">1</span> # 选择一个库，<span class="number">0</span>-<span class="number">15</span></span><br><span class="line">&gt; get key # 获取某个键对应的值</span><br><span class="line">&gt; <span class="built_in">set</span> key value # 添加一个键值对</span><br></pre></td></tr></table></figure>

<p>图形化客户端连接：其实不是官方开发的是 Github 上有人发布的开源图形化客户端。</p>
<h2 id="Redis-通用命令"><a href="#Redis-通用命令" class="headerlink" title="Redis 通用命令"></a>Redis 通用命令</h2><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p><code>Keys pattern</code> 查询符合某种模式的键，比如 <code>keys a*</code> 是查询 a 打头的所有键值。</p>
<p>这个查询并不高效，而且会阻塞其他请求，所以在生产环境中尽量不要使用，特别是不要在主节点上使用。</p>
<h3 id="Del"><a href="#Del" class="headerlink" title="Del"></a>Del</h3><p><code>Del key1 key2 ...</code> 删除键值对。返回值是成功删除的键数量。</p>
<h3 id="MSet"><a href="#MSet" class="headerlink" title="MSet"></a>MSet</h3><p><code>msel k1 v1 k2 v2 ...</code> 批量添加键值对。</p>
<h3 id="Exists"><a href="#Exists" class="headerlink" title="Exists"></a>Exists</h3><p><code>exists key</code> 查询指定键是否存在。</p>
<h3 id="Expire"><a href="#Expire" class="headerlink" title="Expire"></a>Expire</h3><p>给键值对设定一个有效期，到期自动删除。</p>
<p><code>expire key seconds</code></p>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p><code>ttl key</code> 查询这个键还有多久过期。-1表示永久有效，-2表示已过期。</p>
<h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><p>key 一般是 string 类型，而 value 类型多种多样。</p>
<ul>
<li>String：字符串。</li>
<li>hash</li>
<li>list</li>
<li>set</li>
<li>sortedset</li>
</ul>
<p>以上为基本数据类型。</p>
<ul>
<li>geo</li>
<li>bitmap</li>
<li>hyperlog</li>
</ul>
<p>以上为特殊数据类型。</p>
<p>在 redis 里面输入 <code>help @想要查询的 command 名称</code> 就可以进行查询。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>最简单的存储方式，字符串类型。具体可以分为三类：String，int，float。</p>
<p>是的 int 和 float 在 redis 里被视作属于 string。</p>
<p>这些底层存储方式都是字节数组，只不过数字会被直接转化为对应的二进制，这样能存储的范围更大。</p>
<table>
<thead>
<tr>
<th>字符串常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>Set key value</code></td>
<td>添加键值对，如果存在则覆盖</td>
</tr>
<tr>
<td><code>Get key</code></td>
<td>获取这个键的值</td>
</tr>
<tr>
<td><code>MSet k1 v1 k2 v2</code></td>
<td>批量添加</td>
</tr>
<tr>
<td><code>MGet k1 k2 k3</code></td>
<td>批量获取</td>
</tr>
<tr>
<td><code>INCR key</code></td>
<td>让一个整形 Key 对应的值自增1</td>
</tr>
<tr>
<td><code>INCRBY key step</code></td>
<td>指定步长的自增，如步长是2。可以指定为负数来取代 DECR 的功能。</td>
</tr>
<tr>
<td><code>INCRBYFLOAT key step</code></td>
<td>浮点数据的指定长度的自增</td>
</tr>
<tr>
<td><code>SETNX k v</code></td>
<td>添加一个 String 类型的键值对，如果存在则不执行返回0. 其实 <code>set key value nx</code> 也能实现同样的效果</td>
</tr>
<tr>
<td><code>SETEX k v seconds</code></td>
<td>添加一个 String 类型的键值对并指定有效期。<code>set key value ex</code> 也能实现同样的效果</td>
</tr>
</tbody></table>
<h4 id="Key-的层级格式"><a href="#Key-的层级格式" class="headerlink" title="Key 的层级格式"></a>Key 的层级格式</h4><p>Redis 没有 MySQL 的 Table，如何区分不同的 key 意义呢，比如一个商品 id 是1，一个顾客 id 也是1.</p>
<p>Redis 允许键值进行拼接，如：<code>项目名:业务名:类型:id</code> 这样。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:user:<span class="number">1</span> &#x27;&#123;&quot;id&quot;:<span class="number">1</span>, &quot;name&quot;:&quot;Jack&quot;, &quot;age&quot;: <span class="number">21</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:user:<span class="number">2</span> &#x27;&#123;&quot;id&quot;:<span class="number">2</span>, &quot;name&quot;:&quot;Rose&quot;, &quot;age&quot;: <span class="number">18</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:product:<span class="number">1</span> &#x27;&#123;&quot;id&quot;:<span class="number">1</span>, &quot;name&quot;:&quot;小米<span class="number">11</span>&quot;, &quot;price&quot;: <span class="number">4999</span>&#125;&#x27;</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; <span class="built_in">set</span> project:product:<span class="number">2</span> &#x27;&#123;&quot;id&quot;:<span class="number">2</span>, &quot;name&quot;:&quot;荣耀<span class="number">6</span>&quot;, &quot;price&quot;: <span class="number">2999</span>&#125;&#x27;</span><br><span class="line">OK</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看图形化客户端可以发现：Key 已经形成层级结构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212230806.png" alt="image-20250521223051719"></p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>无序字典，类似 java HashMap.</p>
<p>之前我们学过，String 处理对象的方式是变成 json 字符串，但是这样缺点是修改比较难操作。而 Hash 数据结构是可以真正将所有字段都分开存储方便操作。</p>
<table>
<thead>
<tr>
<th>Hash 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>HSET key field value</code></td>
<td>添加或者修改 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HGET key field</code></td>
<td>获取一个 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HMSET key f1 v1 ...</code></td>
<td>批量添加多个 hash 类型 key 的 field 的值（Redis 4.0+ 推荐用 HSET）</td>
</tr>
<tr>
<td><code>HMGET key f1 f2 ...</code></td>
<td>批量获取多个 hash 类型 key 的 field 的值</td>
</tr>
<tr>
<td><code>HGETALL key</code></td>
<td>获取一个 hash 类型的 key 中的所有的 field 和 value</td>
</tr>
<tr>
<td><code>HKEYS key</code></td>
<td>获取一个 hash 类型的 key 中的所有 field</td>
</tr>
<tr>
<td><code>HVALS key</code></td>
<td>获取一个 hash 类型的 key 中的所有 value</td>
</tr>
<tr>
<td><code>HINCRBY key field step</code></td>
<td>让一个 hash 类型 key 的字段值自增，并指定步长</td>
</tr>
<tr>
<td><code>HSETNX key field value</code></td>
<td>添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</td>
</tr>
</tbody></table>
<p>添加完字段之后，图形化界面中可视化结构：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212241594.png" alt="image-20250521224155538"></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>大致可以看做 java 的双向链表结构。有序，插入删除速度快，查询速度一般。</p>
<p>常常用于存储有顺序的数据，比如排队，朋友圈点赞列表等。</p>
<table>
<thead>
<tr>
<th>List 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>LPUSH key element ...</code></td>
<td>向列表左侧插入一个或多个元素</td>
</tr>
<tr>
<td><code>LPOP key</code></td>
<td>移除并返回列表左侧的第一个元素，没有则返回 nil</td>
</tr>
<tr>
<td><code>RPUSH key element ...</code></td>
<td>向列表右侧插入一个或多个元素</td>
</tr>
<tr>
<td><code>RPOP key</code></td>
<td>移除并返回列表右侧的第一个元素</td>
</tr>
<tr>
<td><code>LRANGE key start end</code></td>
<td>返回一段脚标范围内的所有元素（脚标从左0开始向右逐渐增加）</td>
</tr>
<tr>
<td><code>BLPOP key [key ...] timeout</code></td>
<td>与 LPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil</td>
</tr>
<tr>
<td><code>BRPOP key [key ...] timeout</code></td>
<td>与 RPOP 类似，但在没有元素时会等待指定时间（阻塞），不是直接返回 nil</td>
</tr>
</tbody></table>
<p>用 List 模拟栈：只用 LPUSH 和 LPOP 或者 RPUSH RPOP 同向。</p>
<p>用 List 模拟队列：LPUSH+RPOP 或 RPUSH+LPOP 不同向。</p>
<p>用 List 模拟阻塞队列：首先需要入口和出口在不同边；其次出队使用 BLPOP 或者 BRPOP。</p>
<p><em>阻塞队列：当队列为空的时候，取元素的线程会等待一段时间直到队列非空。应用：线程池，待处理的任务先到等待队列，等待有空闲的线程时再开始被执行。这样不用一直创建新的线程，只利用现有的最大线程数，节约资源和响应速度。</em></p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>类似 Java 中的 HashSet，无序，不重复，查找快，支持并集差集交集等运算。</p>
<table>
<thead>
<tr>
<th>Set 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>SADD key member ...</code></td>
<td>向 set 中添加一个或多个元素</td>
</tr>
<tr>
<td><code>SREM key member ...</code></td>
<td>移除 set 中的指定元素</td>
</tr>
<tr>
<td><code>SCARD key</code></td>
<td>返回 set 中元素的个数</td>
</tr>
<tr>
<td><code>SISMEMBER key member</code></td>
<td>判断一个元素是否存在于 set 中</td>
</tr>
<tr>
<td><code>SMEMBERS key</code></td>
<td>获取 set 中的所有元素</td>
</tr>
<tr>
<td><code>SINTER key1 key2 ...</code></td>
<td>求 key1 与 key2 的交集</td>
</tr>
<tr>
<td><code>SDIFF key1 key2 ...</code></td>
<td>求 key1 与 key2 的差集</td>
</tr>
<tr>
<td><code>SUNION key1 key2 ...</code></td>
<td>求 key1 和 key2 的并集</td>
</tr>
</tbody></table>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>有点类似 java 的 treeset 但是底层逻辑差得很远。</p>
<p><em>java 的 treeset：一种有序集合，底层逻辑是红黑树。红黑树类似 AVL 树，这两种树在排序的同时也会保证树的左右子节点深度，数量差别不大以免树结构的复杂度变得和线性结构差不多，AVL 是规定左右子节点深度差不能超过1，而红黑树要求松一些，规定从根到叶子的最长路径不可能达到最短路径的2倍长，所以旋转操作相对 AVL 少一些，AVL 更适用于查找操作远多于插入删除操作数量的情况。</em></p>
<p>SortedSet 每个元素都带有一个 score 属性可以排序，通过跳表+hash表排序。</p>
<p><em>跳表结构大概如下，来加速单链表的查找效率。可以再多建几级索引。图源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Appleeatingboy/article/details/119948340">跳表的原理与实现 [图解]_跳表实现-CSDN博客</a></em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505212313909.png" alt="img"></p>
<p>SortedSet 由于其排序效率高，常常被用于实现如排行榜这样的功能。</p>
<table>
<thead>
<tr>
<th>Sorted Set 常用命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZADD key score member</code></td>
<td>添加一个或多个元素到 sorted set，如果已经存在则更新其 score 值</td>
</tr>
<tr>
<td><code>ZREM key member</code></td>
<td>删除 sorted set 中的一个指定元素</td>
</tr>
<tr>
<td><code>ZSCORE key member</code></td>
<td>获取 sorted set 中指定元素的 score 值</td>
</tr>
<tr>
<td><code>ZRANK key member</code></td>
<td>获取 sorted set 中指定元素的排名（从 0 开始）</td>
</tr>
<tr>
<td><code>ZCARD key</code></td>
<td>获取 sorted set 中的元素个数</td>
</tr>
<tr>
<td><code>ZCOUNT key min max</code></td>
<td>统计 score 值在指定范围内的元素个数</td>
</tr>
<tr>
<td><code>ZINCRBY key increment member</code></td>
<td>让 sorted set 中指定元素自增，步长为指定的 increment 值</td>
</tr>
<tr>
<td><code>ZRANGE key start stop</code></td>
<td>按 score 排序，获取指定排名范围内的元素 <em>如前十名</em></td>
</tr>
<tr>
<td><code>ZRANGEBYSCORE key min max</code></td>
<td>按 score 排序，获取指定 score 范围内的元素 <em>如60分~70分</em></td>
</tr>
<tr>
<td><code>ZDIFF / ZINTER / ZUNION</code></td>
<td>分别用于求差集、交集、并集</td>
</tr>
</tbody></table>
<p>以上都是升序，降序就在 Z 后面加 REV。</p>
<h2 id="Redis-的-Java-客户端"><a href="#Redis-的-Java-客户端" class="headerlink" title="Redis 的 Java 客户端"></a>Redis 的 Java 客户端</h2><p>主要有一下三种：</p>
<table>
<thead>
<tr>
<th>客户端</th>
<th>简介</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Jedis</td>
<td>以 Redis 命令作为方法名称，学习成本低，简单实用。</td>
<td>实例非线程安全，多线程环境下需基于连接池使用。</td>
</tr>
<tr>
<td>Lettuce</td>
<td>基于 Netty 实现，支持同步、异步和响应式编程方式，线程安全。</td>
<td>支持 Redis 的哨兵模式、集群模式和管道模式。</td>
</tr>
<tr>
<td>Redisson</td>
<td>基于 Redis 实现的分布式、可伸缩 Java 数据结构集合。</td>
<td>提供如 <code>Map</code>、<code>Queue</code>、<code>Lock</code>、<code>Semaphore</code>、<code>AtomicLong</code> 等强大功能，适合分布式场景。</td>
</tr>
</tbody></table>
<p>spring data redis 整合了前两种。</p>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>使用方式很简单：引入依赖，建立连接，使用，释放资源。</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在 pom.xml 文件中粘贴：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505221740557.png" alt="image-20250522173946616"></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jedis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一部分依赖是必须引入的，第二部分是测试用的。</p>
<p>执行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">SetUp</span><span class="params">()</span>&#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.73.129&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;369789&quot;</span>);</span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;虎哥&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 插入hash数据</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">        jedis.hset(<span class="string">&quot;user:1&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;21&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line">        Map&lt;String, String&gt; map = jedis.hgetAll(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>Jedis 线程不安全，而且频繁创建销毁 Jedis 线程性能损耗比较大。</p>
<p><em>线程不安全的大概原因：每次 set 的时候都要调用 connect 方法。在 connect 方法里，一个实例的多个线程都共用一个 socket, inputstream, outputstream。所以如果线程1正在读写，线程2把 socket重新初始化了，那么1的连接就断了。或者两个线程同时读写，inputstream outputstream 共用可能就会导致输入或读取数据错误。<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1678172">使用jedis面临的非线程安全问题-腾讯云开发者社区-腾讯云</a></em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505222302284.png" alt="img"></p>
<blockquote>
<p>图源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84481313">java客户端：Jedis和Jedis连接池的基本使用和配置 - 知乎</a></p>
</blockquote>
<p>创建连接池代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFacotry</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">//配置连接池</span></span><br><span class="line">         <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">         poolConfig.setMaxTotal(<span class="number">8</span>);<span class="comment">// 最大连接数</span></span><br><span class="line">         poolConfig.setMaxIdle(<span class="number">8</span>);<span class="comment">// 最大空闲连接数</span></span><br><span class="line">         poolConfig.setMinIdle(<span class="number">0</span>);<span class="comment">// 最小空闲连接数，防止空闲连接被释放</span></span><br><span class="line">         poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">         <span class="comment">//创建连接池对象</span></span><br><span class="line">         jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,</span><br><span class="line">                 <span class="string">&quot;192.168.150.101&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;123321&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建 Jedis 的时候改成使用连接池的获取代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis = JedisConnectionFactory.getJedis();</span><br></pre></td></tr></table></figure>

<p><code>jedis.close()</code> 函数底层如果判断有连接池的时候，就不会 close 关闭 Jedis 资源了，而是归还资源，所以不需要改。</p>
<h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h3><p>SpringData 是 Spring 的数据操作模块，其中的 Redis 集成模块叫做 SpringDataRedis。整合了多个 Redis 客户端，并提供了统一的访问 API。</p>
<p>支持 JDK json 字符串 对象等的序列化和反序列化，因为现在我们直接操作 Jedis 传入的都是 byte[] 数组，如果想传入 json 或者对象需要自己手动调整序列化。</p>
<table>
<thead>
<tr>
<th>API</th>
<th>返回值类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>redisTemplate.opsForValue()</code></td>
<td><code>ValueOperations</code></td>
<td>操作 <code>String</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForHash()</code></td>
<td><code>HashOperations</code></td>
<td>操作 <code>Hash</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForList()</code></td>
<td><code>ListOperations</code></td>
<td>操作 <code>List</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForSet()</code></td>
<td><code>SetOperations</code></td>
<td>操作 <code>Set</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate.opsForZSet()</code></td>
<td><code>ZSetOperations</code></td>
<td>操作 <code>SortedSet</code> 类型数据</td>
</tr>
<tr>
<td><code>redisTemplate</code></td>
<td>-</td>
<td>通用的命令接口</td>
</tr>
</tbody></table>
<p>使用起来也非常简单。首先在 IDEA 里面创建项目的时候就可以创建 spring initilize 的项目，然后导入相关依赖（redis，连接池等），配置连接，直接使用。</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Jackson依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yaml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SpringDataRedis 默认引入了 Lettuce 的依赖，如果想在上面的配置文件中使用 jedis 也可以只不过就是需要在 pom.xml 里面也引入 jedis 的依赖。</p>
<p>代码测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;springtest&quot;</span>,<span class="string">&quot;springtest&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;springtest&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;value &quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Redis 数据库中可见真正存入的数据形式其实是：\xAC\xED\x00\x05t\x00\x0Aspringtest，前面这一串可能就是 Spring Redis 的自动序列化用于记录对象格式的，反正 System.out.print 输出的是没有乱码的。</p>
<p><em>老师的案例里面，老师是写入的 name xxx 键值对，然后再去终端执行 redis 命令 <code>get name</code> 发现获取到的值并没有更新，也是一样的道理，因为老师实际存入的键也是类似 <code>\乱码 \乱码 name</code> 这样的形式，和 <code>get name</code> 访问的键不一样.</em></p>
<p>这种方式的主要两个问题：可读性差；内存占用大。Java 的 String 也会被视作是一种对象，而非单纯的 String。</p>
<p>想要“写入什么值就存入什么值”，就必须去改写 RedisTemplate 的序列化方法（其实底层调用的是 <code>JDKSerializationRedisSerializer</code> 的序列化方法）。</p>
<p>对于字符串，或者键，可以将底层序列化方法改成：<code>StringRedisSerializer</code>，这个是专门处理字符串的序列化方法。</p>
<p>对于对象，可以用 <code>GenericJackson2JsonRedisSerializer</code> 转 JSON 字符串的序列化方法。</p>
<p>具体修改：新建一个 <code>RedisConfig</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span>&#123; <span class="comment">// 这里可见我们直接让 key 默认就是 String 类型了</span></span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 创建JSON序列化工具，用于对象处理</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置Value的序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码是所有 key 都用字符串序列化方法，而所有的 value 都用 json 对象处理方法。</p>
<p>使用的时候，唯一区别就是声明要使用的 RedisTemplate 类是 &lt;String, Object&gt; 的，也就是我们刚刚生成的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br></pre></td></tr></table></figure>

<p>重新运行后发现数据库里面的键值都没有乱码了（值的话，可能 String Object 转换成 JSON 也是 String 的形式）。</p>
<p>尝试传入对象也非常顺利，假设新建了一个 User 对象，数据库中成功传入后的 json value 如下（第一句话就是帮助反序列化还原用的）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505231149205.png" alt="image-20250523114928080"></p>
<p>并且 java 输出里面自动反序列化成对象的输出形式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value User(name=jingqing, age=22)</span><br></pre></td></tr></table></figure>



 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：Software Engineering 软件工程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/12/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ASoftware%20Engineering%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"
    >北邮国院笔记：Software Engineering 软件工程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/12/01/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ASoftware%20Engineering%20%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" class="article-date">
  <time datetime="2024-12-01T00:00:00.000Z" itemprop="datePublished">2024-12-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="software-types"><a href="#software-types" class="headerlink" title="software types"></a>software types</h2><p>general: developed for a general market. (ps, office)</p>
<p>custom: developed for a particular aim. (embeded system)</p>
<h2 id="good-software-features"><a href="#good-software-features" class="headerlink" title="good software features"></a>good software features</h2><p>delivers required functionality</p>
<p>usable</p>
<p>efficient</p>
<p>dependable</p>
<p>maintainable</p>
<p>understandable</p>
<p>cost-effective</p>
<p>security</p>
<h2 id="what-is-software-engineering"><a href="#what-is-software-engineering" class="headerlink" title="what is software engineering?"></a>what is software engineering?</h2><p>using proper theories, tools, methods(organized and systematic), constraints to develop high quantity software.</p>
<h2 id="4-layers"><a href="#4-layers" class="headerlink" title="4 layers"></a>4 layers</h2><p>Tools, method, process, quality focus.</p>
<h2 id="Why-important"><a href="#Why-important" class="headerlink" title="Why important?"></a>Why important?</h2><p>large scale projects are hard to finish in time properly because of time, budget, disaster, etc. guiding scientific principles and universally applicable methods can reduce practice and frequent failures.</p>
<h2 id="General-issues-that-affect-software"><a href="#General-issues-that-affect-software" class="headerlink" title="General issues that affect software"></a>General issues that affect software</h2><p>Heterogeneity (distributed systems, different type of devices), business and social change, security and trust, scale.</p>
<h1 id="Software-process"><a href="#Software-process" class="headerlink" title="Software process"></a>Software process</h1><p>a set of structured activities to produce software.</p>
<p>includes: required specification, development(analysis, design, implementation), validation (test), evolution.</p>
<ul>
<li>required specification: what should this system do? a complete desc of the problem and environment constraints. contains: system function, future extension, documentation amount, time and preformance response</li>
<li>analysis: create a conceptual model.</li>
<li>design: implementable model (architecture, components of this system).</li>
<li>implementation: implementation of interfaces.</li>
<li>testing: unit, functional, integration, system, acceptance. test and implementation should run in parallel.</li>
<li>deployment: install, run and test on real environment.</li>
<li>evolution: corrective, adaptive, perfective, preventive.</li>
</ul>
<h2 id="process-models"><a href="#process-models" class="headerlink" title="process models"></a>process models</h2><p>a abstraction of process. activities must be modelled to be managed.</p>
<h3 id="waterfall"><a href="#waterfall" class="headerlink" title="waterfall"></a>waterfall</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332918.png" alt="1685629715429"></p>
<p>易于管理 monitor，结构化很好。前面的模块必须完成才能跳到下一个，也就要求我们在最初设计的时候对需求很清楚，但是很难不遇到一些问题，很难按照正常流程正常走。</p>
<h3 id="evolutionary-development"><a href="#evolutionary-development" class="headerlink" title="evolutionary development"></a>evolutionary development</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685629943510.png" alt="1685629943510"></p>
<p>交互性的活动，及时的反馈。核心需求能很好的满足，但是扩展性很差，结构性很差，缺少过程中的可见性。适合小型项目。</p>
<h3 id="rational-unified-process"><a href="#rational-unified-process" class="headerlink" title="rational unified process"></a>rational unified process</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685630556923.png" alt="1685630556923"></p>
<p>inception: 分析项目可行性。</p>
<p>elaboration: 分析风险，架构。</p>
<p>construction: iterative 迭代开发到 beta 版本为止。</p>
<p>transition: 交付到客户手中。</p>
<p>通用的完整流程，动态。但是开销大了。</p>
<h3 id="Agile-Software-Development"><a href="#Agile-Software-Development" class="headerlink" title="Agile Software Development"></a>Agile Software Development</h3><p>现代软件开发流程：敏捷开发。</p>
<p>Rapid software development 快速开发：争取每一版都交一个可以交付的东西给客户。</p>
<p>敏捷开发：系统在一次一次迭代小增量过程中建立而成。specification, design, implementation, testing 并行。专注于代码，轻量级代码频繁发布，维护简单。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/8a04dc9794b9fae3b772c1efab38b648.png" alt="image-20230507002834816"></p>
<p>Individuals and interactions over processes and tools </p>
<p>Working software over comprehensive documentation </p>
<p>Customer collaboration over contract negotiation </p>
<p>Responding to change over following a plan</p>
<p>敏捷开发需要程序员之外的项目经理，运营，测试……</p>
<p>敏捷开发重视价值，不要设计没价值的东西。实践一定要解决文分体，文档一定要有对应受众，不要过度设计系统。</p>
<p>敏捷开发注重 steer而不是percise prediction。由customer priorities 和 programmer estimates of  feature difficulty 共同制定不断迭代的计划。</p>
<p>开发原则：</p>
<p>• Emphasis on simple design and refactoring.</p>
<p>• Removing duplication.</p>
<p>• Increasing cohesion. </p>
<p>• Reducing coupling</p>
<p>常见的敏捷开发方法：如极限开发 Extreme Programming.</p>
<ul>
<li>每天构建几次新版本</li>
<li>每两周给用户提交一版增量</li>
<li>需求由用户描述</li>
<li>程序员Pair programming（两个人坐一起一起开发，效率差不多，而且对彼此代码更加了解）</li>
<li>先开发测试单元，再写代码</li>
<li>测试过了才算构建完成</li>
</ul>
<p>Test Driven Development (TDD): </p>
<ul>
<li>Define both an interface and a specification. </li>
<li>先写test后写code。</li>
<li>基于增量设计测试 Incremental。</li>
<li>每次构建后自动化测试 Automated。</li>
<li>客户参与测试 User involvement，测试包括程序员单元测试（unit test），客户确认测试（acceptance test，看是否符合需求）。</li>
</ul>
<p>敏捷开发的问题：</p>
<ul>
<li><p>客户易失去积极性 customers interests.</p>
</li>
<li><p>团队成员未必喜欢团队开发。</p>
</li>
<li><p>多方利益相关，prioritising change is difficult.</p>
</li>
<li><p>难维持简洁性，maintaining simplicity.</p>
</li>
<li><p>频繁变化，合同设计困难 contract。</p>
</li>
</ul>
<p>适用于多变的，客户要求明确的中小型系统。</p>
<h2 id="requirements"><a href="#requirements" class="headerlink" title="requirements"></a>requirements</h2><p>确定需求是软工设计中最重要的部分。</p>
<ul>
<li><p>feature to satisfy customer.</p>
</li>
<li><p>indicates what should this sys do.</p>
</li>
<li><p>可能是高层抽象的需求 high-level abstract 或者底层具体的 low-level specific.</p>
</li>
</ul>
<p>Stakeholder 利益相关者：受系统影响的组织或个人（当然有的软件可能是针对市场需求开发，而不存在具体的用户）。这些人站在不同角度上有不同见解。</p>
<p>客户不一定清晰描述其需求，也不一定清楚产品特性和功能，且其需求可能不断变化。</p>
<p>在确定需求环节投入的额外时间长远角度来看会节省更多的时间和金钱。</p>
<p>需求分为：functional 和 non functional.</p>
<h3 id="functional-requirements"><a href="#functional-requirements" class="headerlink" title="functional requirements"></a>functional requirements</h3><p>定义系统的需求，要干什么。比如教务系统对于老师和学生端提供的不同的服务。</p>
<p>这一部分要完整 completeness 清晰一致 consistency 的描述大需求，避免不必要的误解。</p>
<h3 id="non-functional-requirements"><a href="#non-functional-requirements" class="headerlink" title="non-functional requirements"></a>non-functional requirements</h3><p>这一部分比功能性更重要，相当于不满足这一部分系统错误，不满足功能需求系统有一些小bug。</p>
<p>Define system properties and constraints，比如时空复杂度，设备 capability。</p>
<p>Process requirements：比如质量标准，编程语言等。</p>
<p>Organisational requirements: 如系统要符合IT政策规定。</p>
<p>external requirements: 比如“用户密码不能泄露”。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332607.png" alt="1685634113657"></p>
<p>非功能性需求需要定量描述指标。不然比如“希望程序跑的快一点”这就很模糊。要有measure的方法区测量quantitative定量指标。</p>
<h3 id="Requirement-conflicts"><a href="#Requirement-conflicts" class="headerlink" title="Requirement conflicts"></a>Requirement conflicts</h3><p>要trade-off权衡需求，让所有人都同意一个最优需求。</p>
<h3 id="Requirement-document"><a href="#Requirement-document" class="headerlink" title="Requirement document"></a>Requirement document</h3><p>Software Requirements Specification (SRS) 软件需求规范，确认测试的参考规范，指明了应该实现的需求，但是不指明如何实现。</p>
<h3 id="Requirements-Capture"><a href="#Requirements-Capture" class="headerlink" title="Requirements Capture"></a>Requirements Capture</h3><p>Background Reading</p>
<p>Interviewing</p>
<p>Observation（观察用户使用系统的情况）</p>
<p>Document or Record Sampling（专业的observation）</p>
<p>Questionnaires</p>
<h2 id="敏捷开发中的需求"><a href="#敏捷开发中的需求" class="headerlink" title="敏捷开发中的需求"></a>敏捷开发中的需求</h2><h3 id="usr-stories"><a href="#usr-stories" class="headerlink" title="usr stories"></a>usr stories</h3><p>用户需求被称作用户故事，一两句话写在卡片上。</p>
<p>customer 给他们排序需求，development team分解实现任务。</p>
<p><em>As a user,  I want to backup my entire hard drive  so that I won’t lose any work.</em></p>
<p>写在 stories cards 上，按顺序贴在墙上大家讨论，注意重点不是记录而是大家的讨论。</p>
<h3 id="Project-glossary"><a href="#Project-glossary" class="headerlink" title="Project glossary"></a>Project glossary</h3><p>一些项目相关的专业术语，建议总结出来方便大家理解讨论。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230601235612956.png" alt="image-20230601235612956"></p>
<h3 id="Epics"><a href="#Epics" class="headerlink" title="Epics"></a>Epics</h3><p>大的 usr story。通常开始讨论前被拆分为小的块。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230601235720919.png" alt="image-20230601235720919"></p>
<h3 id="Acceptance-Criteria"><a href="#Acceptance-Criteria" class="headerlink" title="Acceptance Criteria"></a>Acceptance Criteria</h3><p>验收标准，通常写在故事卡背面，有助于理解需求和 invite negotiation with the team about the business  value that we are trying to create.</p>
<h3 id="Non-functional-Requirements-as-User-Stories"><a href="#Non-functional-Requirements-as-User-Stories" class="headerlink" title="Non-functional Requirements as User Stories"></a>Non-functional Requirements as User Stories</h3><p>比如用户表示：我希望电脑打cf fps高于100.</p>
<h3 id="usr-stories注意事项"><a href="#usr-stories注意事项" class="headerlink" title="usr stories注意事项"></a>usr stories注意事项</h3><ol>
<li>谁都能写，最好让更多的成员写。</li>
<li>整个 agile development 过程中都可以写。一开始开故事讨论会确定基本，后续随时可以添加。</li>
</ol>
<h3 id="Product-backlog"><a href="#Product-backlog" class="headerlink" title="Product backlog"></a>Product backlog</h3><p>需求按优先级排列的需求表。综合考虑多方因素。</p>
<p>MoSCoW：一种 dsdm 动态系统开发方法。</p>
<ul>
<li>must have：最重要的。</li>
<li>should have：如果时间资源超限可以被取代。</li>
<li>could have：用户期望的需求，完成后用户满意度会高。但是不必要。</li>
<li>want to have: 当前阶段不重要的。</li>
</ul>
<h3 id="Estimating"><a href="#Estimating" class="headerlink" title="Estimating"></a>Estimating</h3><p>估计项目用时。</p>
<blockquote>
<p> story point：故事点，用于表示完成一个产品待办项或者其他任何某项工作所需的所有工作量的估算结果。</p>
<p> 当采用故事点估算时，我们为每个待办项分配一个点数。待办项估算结果的原生数据并不重要，我们只关注最后得到的相对估算结果。一个估算值为2的用户故事应该是估算值为1的用户故事的2倍。而它也应该是另一个估算值为3的用户故事的三分之二。</p>
<p> 团队不要采用100、200、300，或者1百万、2百万、3百万，而要使用1、2、3。估算结果是比值，而不是绝对值。</p>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/351172855">敏捷开发中到底什么是故事点（Story Point）？ - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="评判-good-usr-story"><a href="#评判-good-usr-story" class="headerlink" title="评判 good usr story"></a>评判 good usr story</h3><p>INVEST原则。</p>
<p>– Independent – Negotiable – Valuable – Estimatable – Small – Testable</p>
<h3 id="Prototyping"><a href="#Prototyping" class="headerlink" title="Prototyping"></a>Prototyping</h3><p>physical：比如画gui。</p>
<p>logical：元素，元素之间的关联……</p>
<p>Low-fidelity 低保真：最简单，比如手绘图，纸板做的，快速验证产品概念的可行性。</p>
<p>Medium-fidelity 中保真：数字模型。</p>
<p>high-fidelity：如3d打印，最接近产品但是制作麻烦。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685636483862.png" alt="1685636483862"></p>
<h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>仅仅从用户的需求来看得到的消息不全面，还需要分析。用户可能认为你明白了，或者他考虑不全面，觉得一些地方是不需要的。</p>
<p>因此我们需要分析来 Refining requirements。</p>
<p>gather requirements-analyse in real world context-develop the architecture</p>
<p>分析包括：Textual analysis (针对文档分析)，Entities and concepts（应用层面分析），Experience（过往经验分析）</p>
<h3 id="conceptual-model"><a href="#conceptual-model" class="headerlink" title="conceptual model"></a>conceptual model</h3><p>面向对象的UML图。</p>
<blockquote>
<p>边界类用于系统外部环境与内部交互进行建模的类。我的理解是不同系统之间的胶合层。能够减少系统之间的耦合。</p>
<p>控制类用于对一个或几个用例所特有的控制行为进行建模。控制类源于对用例场景中行为的定义。</p>
<p>实体类是对必须存储的信息和相关行为建模的类。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/iron_sky/article/details/45478455">UML-分析类_Iron_Sky的博客-CSDN博客</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602013913446.png" alt="image-20230602013913446"></p>
<p>attributes: 属性和相应数据类型。比如姓名，字符串。</p>
<p>Operations：行为方法。一个operation一般只做一件事。</p>
<p>relationships: – Association – Inheritance.</p>
<ul>
<li>associations 指两个类之间存在双向联系。比如一个老师教多个学生。有1对1,1对多等关系。</li>
<li>Inheritance 继承，父类泛化子类特化。</li>
</ul>
<p>Activities:  </p>
<ol>
<li>Identify Entity, Boundary and Control classes </li>
<li>Identify class relationships </li>
<li>A conceptual class diagram </li>
<li>Identify attributes for each entity class </li>
<li>Add constraints</li>
</ol>
<h2 id="design"><a href="#design" class="headerlink" title="design"></a>design</h2><p>design 是把分析模型转换成设计模型，不是代码实现！implementation才是实现。</p>
<p>design must have a purpose: how things works.</p>
<p>A software design: enough information for a  development team to implement the solution.</p>
<h3 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h3><ul>
<li>finish non-functional requirements</li>
<li>break down the overall task.</li>
<li>Create a ‘skeleton’ of the system 创建易于实现的骨架结构。</li>
</ul>
<h3 id="Fundamental-Concepts"><a href="#Fundamental-Concepts" class="headerlink" title="Fundamental Concepts"></a>Fundamental Concepts</h3><ul>
<li>Abstraction：抽象类和行为的功能。</li>
<li>Encapsulation：information hiding。限制某些对象对内容的直接访问。</li>
<li>Modularity：封装成模块，提供接口给其他模块。</li>
<li>Coupling：耦合，模块间关系紧密程度。最好是loose 松耦合，这样不容易牵一发而动全身。</li>
<li>Cohesion：内聚，模块内部自己元素的相关度。最好是high的。</li>
<li>Refactoring：在代码正常完成要求的前提下修正代码减少重复。主要改进非功能属性。</li>
</ul>
<p>面向对象设计的好处：对象就是实体；对象可以重用，继承；有的系统对象是现实世界的明显映射。</p>
<h3 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h3><p>conceptual class diagram</p>
<p>Class Relationships</p>
<p>operations</p>
<p>Describing methods</p>
<p>Captures implementation requirements</p>
<p>Produce detailed design class diagram</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>分析和设计阶段基本上把创意都列出来了。实现就是比较机械地按照前面的设计去敲代码。</p>
<p>利用一些组件去实现。组件主要包括：excutable 可执行文件，file 源码和数据，document，table 数据库表。</p>
<p>implementing subsystem 实现部分功能，利用打包功能导出一个有接口的模块.</p>
<p>Integration Build Plan 迭代构建项目,每次构建指出构建实现的功能和构建需要的子系统、组件。</p>
<p>OOP：有类，对象，方法。但是关联不是双向的，而是只能单向的，比如：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332479.png" alt="1685692184183"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685692194908.png" alt="1685692194908"></p>
<p>一对多可以在一个类里包含另一个类的一个对象集合。</p>
<p>类的实现要从最小耦合到最大耦合 least  coupled to most coupled。</p>
<h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><p>在交付给用户前尽可能发现错误，验证每个阶段的结果。测试占据了40%。</p>
<p>组件层面：开发者测试。</p>
<p>集成测试：测试工程师，专注于质量。</p>
<ul>
<li>Validation testing：验证测试，测试系统正常需求已经满足。</li>
<li>Defect testing：检测系统的缺陷。</li>
</ul>
<h3 id="Testing-policies"><a href="#Testing-policies" class="headerlink" title="Testing policies"></a>Testing policies</h3><p>我们不可能把所有可能情况都找到并且测试出来。因此只能选取有代表性的子集。</p>
<p>好的测试：测试人员能预料到可能哪里出错；没有多余的测试用例；应选取“最可能出错”的用例；合适的复杂程度。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685693050733.png" alt="1685693050733"></p>
<p>test case：输入的规范和预期的输出。</p>
<p>test data：输入。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685693215844.png" alt="1685693215844"></p>
<h3 id="testing-strategy"><a href="#testing-strategy" class="headerlink" title="testing strategy"></a>testing strategy</h3><p>what 测试用例？when 测试？how to 测试？如何比对输出是否正确？</p>
<p>test cases 示例（正确的输入。错误的输入比如学号输入英文）：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602160905111.png" alt="image-20230602160905111"></p>
<p>Test Procedures 测试程序，通常设置为可通用的，便于之后修改重用。这个程序不一定是代码，可能以流程指导的形式（比如按下login按钮，输入账号99001122登录……）</p>
<p>test matrix: </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602161119974.png" alt="image-20230602161119974"></p>
<p>发现缺陷：比如上例，错误的密码也能登录，于是测试工程师把错误信息返回给开发者：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230602161157432.png" alt="image-20230602161157432"></p>
<h3 id="Testing-Techniques"><a href="#Testing-Techniques" class="headerlink" title="Testing: Techniques"></a>Testing: Techniques</h3><p>黑盒测试，black box&#x2F;behavior test，即我们要测试的模块，对我们来说像一个内部结构不可见的黑盒子，我们重点关注他行为对不对，与外界的接口是否正确，访问外界数据库正不正确。</p>
<ul>
<li>Partition testing：典型的黑盒测试，把数据分成等效的几个区域，比如正数负数0.</li>
<li>Scenario-based testing：从用户角度触发，分析用户可能的正确和错误操作。</li>
<li>Regression Testing：集成测试，随着添加增量也不断添加新测试，每次运行所有测试用例，确保系统更新的时候以前的功能没有受干扰。</li>
</ul>
<p>白盒测试，white&#x2F;glass&#x2F;clear box test，主要关注程序内部结构按规范运行，所有内部组件都正确。</p>
<p>确保盒内的所有路径都被正确执行过；考虑正确和错误用例；在边界内外测试；尽量使用内部数据结构。</p>
<ul>
<li>Basis Path Testing：执行所有路径的最少用例数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685696256126.png" alt="1685696256126"></p>
<p>总体测试流程：白盒测试，建立 test harness 测试装置，测试正确性，测试健壮性；然后黑盒测试。</p>
<h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="number">20</span>, student.getAge());<span class="comment">//判断返回值是不是20岁</span></span><br></pre></td></tr></table></figure>

<p>在开发代码前编写测试。 simple, short-cycled mechanism。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332492.png" alt="1685710646767"></p>
<p>small cycle：编写测试，编写代码，测试失败，修改代码，测试通过。</p>
<h1 id="Software-architecture"><a href="#Software-architecture" class="headerlink" title="Software architecture"></a>Software architecture</h1><p>功能需求和软件架构关系紧密，非功能需求是软件架构的选择结果（好的架构运行效率高之类的）。可以以表格或图的形式，比如UML图。</p>
<p>设计难以更改。敏捷开发的早期阶段就是设计系统架构。</p>
<p>好处：</p>
<ul>
<li>system analysis：利于分析系统是否满足非功能需求。</li>
<li>large-scale reuse：架构可重用，更安全、更快。</li>
<li>Stakeholder communication：可以 成为一个讨论点。</li>
</ul>
<h1 id="Project-management"><a href="#Project-management" class="headerlink" title="Project management"></a>Project management</h1><p>让项目能在有限的时间和预算范围内按预期保质落地。</p>
<p>软件工程比较灵活，没有标准的完全正确的方案，需要随机应变，敏锐的洞察力。</p>
<h2 id="Project-planning"><a href="#Project-planning" class="headerlink" title="Project planning"></a>Project planning</h2><p>最耗时的环节。</p>
<p>计划只有在项目完成时才算完成，因为计划在项目开发阶段也不断变化。</p>
<p>计划可能包括多种，如质量计划，员工开发计划……</p>
<h2 id="Activity-organisation"><a href="#Activity-organisation" class="headerlink" title="Activity organisation"></a>Activity organisation</h2><p>活动应该组织成切实的输出以及可以判断的进度。</p>
<p>milestone：标志阶段的结束，不一定是能输出给用户的成果。比如文档，或者逻辑阶段的结束。</p>
<p>Deliverables：可以交付给用户的设计，规格等成果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332283.png" alt="image-20230602221047262"></p>
<h2 id="Project-scheduling"><a href="#Project-scheduling" class="headerlink" title="Project scheduling"></a>Project scheduling</h2><p>估计项目时间预算的花费，并按顺序排布。</p>
<p>比较难估计。通常根据过往项目经验估计。</p>
<p>先把大项目分解为几个小项目，然后并发的组织任务——尽可能充分利用劳动力 workforce，以及 Minimise task dependencies 尽量减少因为前面的任务没完成对后面任务的延误。</p>
<p>要对错误有预期，没错误是不可能的。约30%预料到的问题+20%未预料到的问题。</p>
<p>通常用图表表示：</p>
<p>任务表：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724379869.png" alt="1685724379869"></p>
<p>活动网：最长的是关键路径，因为这条路径任务要是延期了，整个工期都要延期。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724395138.png" alt="1685724395138"></p>
<p>甘特图：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685724424966.png" alt="1685724424966"></p>
<p>Monitoring&#x2F;Reporting：定期周会周报监督进度。</p>
<h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>代码行数，代码中的缺陷，测试用例通过情况。</p>
<h3 id="People-in-the-process"><a href="#People-in-the-process" class="headerlink" title="People in the process"></a>People in the process</h3><p>选择成员，管理，激励他们，解决大家遇到的技术和非技术问题。</p>
<ul>
<li>Consistency：对大家态度一致。</li>
<li>Respect：大家拥有技能不同，互相尊重。</li>
<li>Inclusion：让大家都参与进项目，聆听所有人的意见。</li>
<li>Honesty：进度保持诚实。</li>
</ul>
<h3 id="Group-working"><a href="#Group-working" class="headerlink" title="Group working"></a>Group working</h3><p>不仅仅是个人的集合。团队能力的组成，凝聚力，沟通，大型团队的层次结构。</p>
<p>敏捷开发的团队合作方法：Scrum approcah，有一个Scrum master，日会，跟随进度，记录决策，和客户等沟通。</p>
<p>项目被分解为易于管理和理解的小部分。不稳定的需求不影响项目进度。团队成员对项目把控更到位 visibility，客户能常常看到项目进度，双方交流更相信彼此。</p>
<h2 id="Risk-management"><a href="#Risk-management" class="headerlink" title="Risk management"></a>Risk management</h2><p>失败是常有的事。我们要做好备选方案，推迟时间或者放弃目标。</p>
<p>风险管理是预测可能的失败，决定该在什么地方制定备选方案 alternative plans 。</p>
<p>Project risks：项目开发或者资源的问题。比如项目员工走了；原材料没法及时收到了；项目要求时间提前了。</p>
<p>Product risks：产品质量和性能的问题。比如开发软件出bug了，开发出的软件质量不行，用户对gui不满意，有没考虑到的错误。</p>
<p>Business risks：开发，采购组织的问题。比如上市了发现其他公司的技术，竞品比我们的好；负责该系统的组织因财务原因倒闭了。</p>
<p>Project+Product：需求一直变；分析阶段太慢了；开发团队技能能力不行；项目比预想的要大。</p>
<h3 id="Risk-Identification"><a href="#Risk-Identification" class="headerlink" title="Risk Identification"></a>Risk Identification</h3><p>识别风险。</p>
<h3 id="Risk-Analysis"><a href="#Risk-Analysis" class="headerlink" title="Risk Analysis"></a>Risk Analysis</h3><p>评估风险的影响。</p>
<h3 id="Risk-Planning"><a href="#Risk-Planning" class="headerlink" title="Risk Planning"></a>Risk Planning</h3><p>制定应对风险的计划。</p>
<h3 id="Risk-Monitoring"><a href="#Risk-Monitoring" class="headerlink" title="Risk Monitoring"></a>Risk Monitoring</h3><p>在项目开发过程中监控风险。</p>
<h3 id="Avoidance-Strategies"><a href="#Avoidance-Strategies" class="headerlink" title="Avoidance Strategies"></a>Avoidance Strategies</h3><p>尽量使用熟悉的模式，但是也接受新技术，时刻关注市场动向；</p>
<p>对员工合理培训，确保技术没被掌握在一个人手中；创造良好的工作环境；</p>
<p>员工不要欺瞒进度，高管要时刻了解进度以及其对项目的重要性。</p>
<h3 id="Contingencies-突发事件"><a href="#Contingencies-突发事件" class="headerlink" title="Contingencies 突发事件"></a>Contingencies 突发事件</h3><p>换人，换工具，换资源。</p>
<p>改变，舍弃一部分目标。</p>
<p>争取做的改动最小，但是损失也降到最小。</p>
<p>我们知道敏捷开发持续提交小版本，因此经常进行测试修改当阶段错误。但是缺陷在于敏捷开发不注重长远眼光 long term planning，因此可能带来一些问题。</p>
<h2 id="Quality-Management"><a href="#Quality-Management" class="headerlink" title="Quality Management"></a>Quality Management</h2><p>对质量的评估，最好从软件开发过程中抽离出来。因为开发的过程会错误影响开发者自己对质量的评估（我都这么努力了，做出来的东西肯定很好吧）。</p>
<p>瀑布模型中在系统实现后单独测试软件质量。敏捷开发在每次发布新版本的时候测试。因为主要是在实际使用场合的测试，因此会比“为了达成测试而开发”的系统想的更多一些。</p>
<p>好的软件符合目的 Fitness for purpose，标准好，易于使用，高效，代码写的好（当然从用户角度来说他看不到这一层。但是代码写得好是前提，比如时间复杂度运行得快）。开发者需要考虑用户的需求前提下，自己用专业知识思维去想：这个需求实现合理吗。然后多喝用户沟通表达看法。</p>
<p>区分bug和特性：正常运行的是特性。有的时候哪怕系统除了意想不到的bug，但是功能意外的很合适，这也可以是特性。</p>
<p>特性很难移除，当用户开始依赖特性功能的时候，移除用户可能不乐意不习惯；而且向后（版本）兼容变得很难。</p>
<p>软件标准有很多好处，新员工快速入手，大家更熟悉项目等，但是标准可能对一些过去常常发生而现在不怎么出现的问题采取忽略的态度，从而兼容性上出现问题；而且可能浪费很多时间填文书。注重标准好的部分。</p>
<h2 id="Design-principle"><a href="#Design-principle" class="headerlink" title="Design principle"></a>Design principle</h2><p>设计的软件不仅要正确，高效运行，还要在限定时间，人力，软件，经济条件下。差代码后期可能要花很多时间弥补隐患；而且不同模块的代码经常交互，差代码还会有安全隐患。</p>
<p>我们仅仅想着怎么“正确”地编写代码是不够的，还要更省事省力地去开发。</p>
<p>Software lifespan：软件生命周期，软件是一直在持续开发的，比如新技术，客户新需求。</p>
<p>Software scale：项目大多数规格很大，很多人开发，代码多，多次修订。</p>
<p>Decomposition：项目分解为小模块开发。有Locality（实现一个模块可以不用检查其他模块的实现）和Modifiability（修改一个模块也不用考虑用使用这个模块的模块）的特点。</p>
<p>Specification and implementation：规范连接了设计和实现，规定了模块应该提供哪些服务以及如何使用服务。模块之间的交互应该仅仅限于规范，以此实现分解后模块的locality和modifiability。</p>
<p>Classes and Methods：面向对象思想中的模块为类。</p>
<p>Separation：分开考虑一个模块要实现的功能what和如何实现how。一个应用程序级别，一个实现级别。</p>
<p>Splitting Methods and Classes：设计方法和类的时候好好考虑如何拆分方法和类。类太大了考虑一下要不要拆，几个变量模式比较常用考虑一下要不要抽象成类。</p>
<p>Helper Methods and Classes：有一些方法和类只是为了抽象出来辅助拆分代码用的，这种一般是私有的helper method和嵌套的nested class，只在特定类里起作用，对其他类是private的。</p>
<p>Reuse：用以前的代码重复实现功能，节约代码，而且一改全改。重用代码可能厂商提供，编程语言提供，早期开发者开发。</p>
<p>Abstraction and generalisation：抽象是提取一些概念，比如接口，类；泛化是提取一些重复元素，以便代码重用，比如父类。</p>
<p>UML class diagrams：比代码更高的层次，是面向对象编程很重要的内容。</p>
<p>Static v. Dynamic：匹配静态内容和代码运行时产生的内容。对应UML中的类图 class diagram 和顺序图 sequence diagram。</p>
<p>图源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lingchen336/article/details/111400141#:~:text=UML%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%9B%BE%E6%98%AF%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%97%B6%EF%BC%8C%E4%BC%9A%E6%8C%89%E7%85%A7%E6%80%8E%E6%A0%B7%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E9%82%A3%E4%BA%9B%E6%96%B9%E6%B3%95%E3%80%81%E9%82%A3%E4%BA%9B%E7%8E%B0%E8%B1%A1%E4%BC%9A%E4%BE%9D%E4%BB%80%E4%B9%88%E9%A1%BA%E5%BA%8F%E5%8F%91%E7%94%9F%E3%80%82,%E7%B1%BB%E5%9B%BE%E8%A1%A8%E7%A4%BA%E2%80%9C%E4%B8%8D%E5%9B%A0%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%88%E9%9D%99%E6%80%81%E5%85%B3%E7%B3%BB%EF%BC%89%EF%BC%8C%E4%BA%8C%E9%A1%BA%E5%BA%8F%E5%9B%BE%E5%88%99%E8%A1%A8%E7%A4%BA%E2%80%9D%E9%9A%8F%E6%97%B6%E9%97%B4%E5%8F%98%E5%8C%96%E7%9A%84%E9%83%A8%E5%88%86%EF%BC%88%E5%8A%A8%E6%80%81%E8%A1%8C%E4%B8%BA%EF%BC%89%E2%80%9C%E3%80%82">UML类图与顺序图_顺序图和类图的关系_lingchen336的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/2020121909185527.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332627.png" alt="img"></p>
<p>class and objects：类和对象。对象是类的实例 instance。两者关系很像static 中的method和动态中的method call。</p>
<p>static：静态方法只能被类自己和其附加类调用。静态类实例化的对象是只有一个通用的对象，而不是实例化出无数个对象。</p>
<p>Variables and referencing：java中变量是对对象的引用，比如var2&#x3D;var1不是赋值而是改变var2指向var1的引用。包括一个变量的自带方法的</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332273.png" alt="image-20230603233317997"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685806438306.png" alt="1685806438306"></p>
<p>Scope and garbage collection：对象的作用域只要有变量还在引用这个对象，他就活着。没有人引用的时候就自动垃圾回收。</p>
<p>基本设计原则：设计对象指代目标；对象方法指代其能做的操作；Locality和Modifiability；对象只能通过方法调用交互。</p>
<p> Client-Contractor model：一种思想，一个对象调用其他对象的方法得到返回值来使用它，像客户和承包商一样。现代社会大进步的原因就是大家各专其职，因此项目中各个类各专其职也能在同样的量的前提下发挥更多的作用。</p>
<ul>
<li><p>客户给承包商的合同就类似定义类和方法的规范specification。代码编写者有义务Obligations拿了钱benefits，就确保软件正确执行，不做破坏的事等。</p>
</li>
<li><p>Design by Contract：一种思想。客户端代码应当满足承包商的先决需求pre-conditions；应当对异常做处理（exception）；后置条件post-conditions在测试中作为断言assertions合并到程序中。（前置条件：前提；后置条件：方法运行后的状态）</p>
</li>
</ul>
<h3 id="Single-Responsibility-Principle-SRP"><a href="#Single-Responsibility-Principle-SRP" class="headerlink" title="Single Responsibility Principle (SRP)"></a><strong>Single Responsibility Principle (SRP)</strong></h3><p>单一责任原则：每个类有一个职责 responsibility，其所有对象都服务于这个职责。Leads to highly cohesive 内聚性高</p>
<h3 id="Open-Closed-Principle-OCP"><a href="#Open-Closed-Principle-OCP" class="headerlink" title="Open-Closed Principle (OCP)"></a>Open-Closed Principle (OCP)</h3><p>开放闭合原则：模块（类和方法）open to extension，close to modification </p>
<p>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>
<p>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。比如一个类以不同对象形式表现这就是扩展，因为需求改变或者有新需求。</p>
<h3 id="Do-not-Repeat-Yourself-principle-DRY"><a href="#Do-not-Repeat-Yourself-principle-DRY" class="headerlink" title="Do not Repeat Yourself principle (DRY)"></a><strong>Do not Repeat Yourself principle (DRY)</strong></h3><p>不要复读机原则（不要重复自己原则）。本模块中如果发现重复内容，建议再抽象为方法和类。</p>
<h3 id="Liskov-Substitution-Principle-LSP"><a href="#Liskov-Substitution-Principle-LSP" class="headerlink" title="**Liskov Substitution Principle (LSP) **"></a>**Liskov Substitution Principle (LSP) **</h3><p>Liskov替代原理：重写方法，不应该抱着”修改其方法“的想法。不能加强 strengthen 前置条件，不能削弱 weaken 后置条件。</p>
<p>比如父类people方法AddPeople(String name, int age) 子类Student构造方法AddPeople(String name, int age)里先校验一下学生年龄，如果年龄大于25岁则不允许add，这就修改了原来方法。这就是前置条件加强了，要求年龄的限制多了。</p>
<p>后置条件比如原来返回值大于0，现在返回值可以小于0了，那么返回值限制弱了，后置条件削弱了，不满足里氏原则。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ITPower/p/14826144.html">设计模式六大原则(二)—-里式替换原则 - 盛开的太阳 - 博客园 (cnblogs.com)</a></p>
<p>Association, Aggregation and Composition：association是两个不同东西的对应，比如家长和孩子。另外两个是子集，aggregation是彼此可以独立存在，比如班级和学生。composition是可以彼此独立存在，比如house和room。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685957816284.png" alt="1685957816284"></p>
<p>有的时候继承满足不了LSP（比如令正方形为矩形的子类），可以使用聚类来防止破坏LSP。</p>
<h3 id="Interface-Segregation-Principle-ISP"><a href="#Interface-Segregation-Principle-ISP" class="headerlink" title="Interface-Segregation Principle (ISP)"></a><strong>Interface-Segregation Principle (ISP)</strong></h3><p>接口隔离原则：首先接口应该尽量分解为小接口。客户端每个类不应该依赖他不使用的方法。就是接口用啥实现啥，别多实现。</p>
<h3 id="Dependency-Inversion-Principle-DIP"><a href="#Dependency-Inversion-Principle-DIP" class="headerlink" title="Dependency-Inversion Principle (DIP)"></a>Dependency-Inversion Principle (DIP)</h3><p>依赖倒置原则：</p>
<blockquote>
<p>如果高层模块直接调用低层模块提供的服务，那么就是具体耦合关系，这样高层模块依赖于低层模块就不可避免。但是，如果我们使用抽象耦合关系，在高层模块和低层模块之间定义一个抽象接口，高层模块调用抽象接口定义的方法，低层模块实现该接口。这样，就消除了高层模块和低层模块之间的直接依赖关系。现在，高层模块就不依赖于低层模块了，二者都依赖于抽象。同时也实现了“抽象不应该依赖于细节，细节应该依赖于抽象”。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158391778">面向对象基础设计原则：4.依赖倒转原则 - 知乎 (zhihu.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/171757199427415.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaochundong/p/dependency_inversion_principle.html">依赖倒置原则（Dependency Inversion Principle） - sangmado - 博客园 (cnblogs.com)</a></p>
</blockquote>
<h2 id="Design-Patterns"><a href="#Design-Patterns" class="headerlink" title="Design Patterns"></a>Design Patterns</h2><h3 id="Decorator-Design-pattern"><a href="#Decorator-Design-pattern" class="headerlink" title="Decorator Design pattern"></a>Decorator Design pattern</h3><p>用于扩展系统功能的装饰模式。</p>
<p>比如我们有一个鸭子类，可以调用其鸭子叫的方法。我们初始化了一个鸭子对象，如何统计这个对象叫了几次，也就是其鸭子叫方法被调用了几次？记住OCP原则不允许我们直接修改鸭子类。</p>
<p>我们可以用一个计数类来把鸭子类包住。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332689.png" alt="image-20230605183433552" style="zoom:67%;" />

<p>装饰模式实现一个接口，接口中的方法通过该变量的同一个参数去调用同一个方法，比如本例中是鸭子呱呱的计数，每次调用++。</p>
<h3 id="Adapter-design-patterns"><a href="#Adapter-design-patterns" class="headerlink" title="Adapter design patterns"></a>Adapter design patterns</h3><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332186.png" alt="1685983233527" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685983255642.png" alt="1685983255642"></p>
<p>这个例子包括了几个原则：</p>
<ol>
<li>首先不同接口功能尽量分开，ISP，也就是说鸭子叫和计数不要写一个方法里。</li>
<li>不能直接修改类，OCP。</li>
<li>如果想鸭子叫同时计数，直接调用包装类即可，DRY。</li>
<li>GooseAdapter 只访问了 Goose 的 honk 方法而不是对其完全访问，DIP。这里如果改成继承的子类，就有全部访问权了。</li>
</ol>
<h3 id="Wrapper-design-patterns"><a href="#Wrapper-design-patterns" class="headerlink" title="Wrapper design patterns"></a>Wrapper design patterns</h3><p>Wrapper 模式包括 decorator 和 adapter。decorator 主要是外面的包裹类和里面的类都实现一个接口，比如上例的鸭子嘎嘎。adapter 是内部类不需实现。</p>
<p>Immutable View：前面提过java引用的问题，比如两个变量引用同一个对象，一改都改。这样就相当于有引用的时候，该目标对象完全暴露出来了。在wrapper里我们可以限制包装类：禁止修改对象，修改则抛出异常。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685986070602.png" alt="1685986070602"></p>
<h3 id="Composite-Design-Pattern"><a href="#Composite-Design-Pattern" class="headerlink" title="Composite Design Pattern"></a>Composite Design Pattern</h3><p>包装了一个集合。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685985869548.png" alt="1685985869548"></p>
<h3 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h3><p>比如看到绿灯汽车知道该走了，这种观察者一个变量改变影响其他变量的实现。</p>
<p>java是提供了observable的api的，当对应变量值改变时触发函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332446.png" alt="1685986641156"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685986768769.png" alt="1685986768769"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332896.png" alt="1685986796502"></p>
<p>不过这种写法违反了OCP，因为我们修改了dogbot让他主动实现observer的update。我们可以采用decorator design 方法。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1685989787205.png" alt="1685989787205"></p>
<p>如果dogbots是一个接口，dogwatcher 可以实现计数功能，还可以在文件，在gui中实现dogbots，实现集合的dogbots，两者代码几乎是分离的。</p>
<p>我们先用一个ObservableDogBot类继承Observable，且实现未完成的dogbots，然后写一个dogreporter实现observer。最后<code>rover.addObserver(reporter1);</code></p>
<h3 id="Factory-Methods"><a href="#Factory-Methods" class="headerlink" title="Factory Methods"></a>Factory Methods</h3><p>如果我们设定饥饿值大于6的狗要被构造为greedyDogBot是普通狗的子类，那么PlainDogBot和greedyDogBot都直接提供出来构造方法不太好。可以通过一个构造类来判断需要返回什么对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606123312445.png" alt="image-20230606123312445"></p>
<p>这个构造方法可以返回接口类，但是实际方法里返回的都是实现了接口类的具体类，这样可以隐藏返回类类型：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026157643.png" alt="1686026157643"></p>
<p>工厂类甚至自己可以包装好类然后送回来一个包装类：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332407.png" alt="1686026296136"></p>
<p>当然工厂方法除了静态的，也可以是非静态的工厂对象。我们可以利用不同的工厂对象包装不同的包装类，这样还能进一步隐藏返回对象的一些信息。</p>
<p>比如下一个例子中，spy狗多一个watcher。我们用多态方法初始化两个 Dog Factory，但是一个是实际SpyDogFactory类型的，一个实际是PlainDogFactory类型的，因此两者调用makeDogBot的时候会返回不同的狗。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026555327.png" alt="1686026555327"></p>
<p>像计数等额外包装功能，我们也可以不用“先用一个计数类包装普通类，再用工厂类包装计数类”，而是把计数内容包装在工厂类里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026955303.png" alt="1686026955303"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686026838784.png" alt="1686026838784"></p>
<h3 id="Singleton-Design-Pattern"><a href="#Singleton-Design-Pattern" class="headerlink" title="Singleton Design Pattern"></a>Singleton Design Pattern</h3><p>构造方法不一定返回必须是新创建的对象，工厂类里可以返回已有的对象。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332922.png" alt="1686027588395"></p>
<p>注意LSP原则。</p>
<h3 id="Object-Pool-Design-Pattern"><a href="#Object-Pool-Design-Pattern" class="headerlink" title="Object Pool Design Pattern"></a>Object Pool Design Pattern</h3><p>对象池模式，保留一个对象列表，在需要的时候返回一个特定对象。</p>
<h3 id="Strategy-Design-Pattern"><a href="#Strategy-Design-Pattern" class="headerlink" title="Strategy Design Pattern"></a>Strategy Design Pattern</h3><p>选择要执行的策略。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686027938500.png" alt="1686027938500"></p>
<p>上图是狗执行几次action的函数。我们也可以利用重写的Comparator实现条件结构，比如比较ab两狗叫了几次，叫的少的补差。</p>
<h3 id="State-Design-Pattern"><a href="#State-Design-Pattern" class="headerlink" title="State Design Pattern"></a>State Design Pattern</h3><p>可以改变对象的状态类型。</p>
<p>下面改变的几个类型都是accountState抽象类的实现类，通过多态的方式初始化。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202505152332513.png" alt="image-20230606180142747"></p>
<h3 id="Bridge-Design-Pattern"><a href="#Bridge-Design-Pattern" class="headerlink" title="Bridge Design Pattern"></a>Bridge Design Pattern</h3><p>解耦思想。比如我们需要12种颜色的画笔，可以选择12根固定颜色的蜡笔，或者1根毛笔和12种颜料。毛笔的例子就很好地解耦了画笔和颜色。</p>
<p>例子来源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/LoveLion/article/details/7464183">处理多维度变化——桥接模式（一）_LoveLion的博客-CSDN博客</a></p>
<p>下例：求父子交集。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606181219816.png" alt="image-20230606181219816"></p>
<h3 id="Flyweight-Pattern"><a href="#Flyweight-Pattern" class="headerlink" title="Flyweight Pattern"></a>Flyweight Pattern</h3><p>将那些大量的，具有很多内部状态而外部状态很少的对象进行共享，可以以类似缓存的方式共享。</p>
<p>概念来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/336732854">精读《设计模式 - Flyweight 享元模式》 - 知乎 (zhihu.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230606181617881.png" alt="image-20230606181617881"></p>
<h1 id="Open-Source-Software"><a href="#Open-Source-Software" class="headerlink" title="Open Source Software"></a>Open Source Software</h1><p>free of charge, free of legal restrictions on usage. </p>
<p>也需要敏捷开发，但是开发方式略有不同，毕竟不是利益相关的模式。强调个人之间的密切交互 close personal interaction，开发者也是自己的客户，因此有很多人做测试，而且修改后的小版本可以很快发布；通常分的小模块很多，世界各地的大家分别开发。</p>
<p>世界各地大家通过电子方式互相交流 electronically。</p>
<p>整体协调者 overall co-ordinator 通常由志愿者负责。</p>
<p>商业软件和OSS就像大教堂和集市的区别，大教堂需要有一个整体的建造目标，大家一同努力。集市可能由城管那样的整体协调者管大家秩序，但是大家还是偏personal一点。</p>
<p>如果自己公司自己开发项目，当然需要大量人力财力开发和后期维护；选择闭源软件，就绑定在供应商身上了（垄断技术），他们需要进一步收费咱也得交。开源软件就不用担心支付费用这类问题或者供应商倒闭问题，但是不是是开源软件就能拿来用的，注意版权问题。</p>
<p>开源软件大多数有一小部分人在开发核心core以及新功能，大多数人在correcting  defects。大多数情况下开发者更愿意维护现有fork分支而不是一味开发新分支。</p>
<p>开源软件也有一个control structure，通常由最初提出项目的人拥有软件的最终决议权，由一些商业公司管理而并非个人（这样能多保质一点），比如安卓开源软件由谷歌掌握控制权，对于提交的fork和patch有权最终决定下一个版本更新的内容。</p>
<ul>
<li>contributor：OSS中做贡献的人。</li>
<li>developer：在软件平台上开发应用的人。</li>
<li>verifier：测试 change request 是否正确的人。</li>
<li>approver：决定这些修改是否要合并进大版本的人，和verifier都需要审核面试筛选。</li>
<li>Project leads：监督单个项目的工程。</li>
</ul>
<h2 id="software-freedom"><a href="#software-freedom" class="headerlink" title="software freedom"></a>software freedom</h2><ul>
<li><p>运行程序的自由 run the program</p>
</li>
<li><p>学习程序运行原理和按自己意愿修改代码的自由 study how this program works, change it so it does your compute as you wish （当然前提是能访问到源码）</p>
</li>
<li><p>分发软件副本的自由 redistribute copies</p>
</li>
<li><p>发布自己的版本给他人的自由  distribute copies of your modified versions to others。</p>
</li>
</ul>
<h2 id="Copyright"><a href="#Copyright" class="headerlink" title="Copyright"></a>Copyright</h2><p>只有制作者producer有权利制作副本和创建新内容 produce copies and create new work based on it，但是可以授权允许别人复制和改编该作品 make copies of the work and adapt it。制作者可以通过收费等方式赋予这些权力给他人，或者对改编的范围加限制，因为这算是加在producer身上的一种义务，有点回报也正常。</p>
<h2 id="Copyleft"><a href="#Copyleft" class="headerlink" title="Copyleft"></a>Copyleft</h2><p>但是OSS的版权声明采用的是copyleft，一种 free software license，并不是限定他人复制改编的权力，而是赋予他人这种权力。许可证内容包括：声明源代码可用，以及改编允许的范围。</p>
<h2 id="voting"><a href="#voting" class="headerlink" title="voting"></a>voting</h2><p>有权投票的人每人最多一票；没权投票的人不能投；有权投票且选择投票的人不能被阻止投票；其须拥有充足的选择 full choice；其投票结果必须被正确统计不能被别人篡改；总票数正确相加，不能篡改；大多数时候没有人能知道任何一个投票者的选择。</p>
<p>电子投票有风险，比如数据容易被篡改，被伪造等。</p>
<h1 id="Software-Development-Tools"><a href="#Software-Development-Tools" class="headerlink" title="Software Development Tools"></a>Software Development Tools</h1><h2 id="Software-Craftsmanship-and-Clean-Code"><a href="#Software-Craftsmanship-and-Clean-Code" class="headerlink" title="Software Craftsmanship and Clean Code"></a>Software Craftsmanship and Clean Code</h2><p>注意代码整洁，比如格式、注释等。</p>
<h2 id="Saying-“No”"><a href="#Saying-“No”" class="headerlink" title="Saying “No”"></a>Saying “No”</h2><p>不要一直盲目答应老板和客户的需求，程序员更熟悉代码，而且需要帮老板规避可能发生的错误。</p>
<h2 id="Learning-from-Mistakes"><a href="#Learning-from-Mistakes" class="headerlink" title="Learning from Mistakes"></a>Learning from Mistakes</h2><h2 id="Microsoft’s-Best-Practices"><a href="#Microsoft’s-Best-Practices" class="headerlink" title="Microsoft’s Best Practices"></a>Microsoft’s Best Practices</h2><h3 id="Revision-Control-System"><a href="#Revision-Control-System" class="headerlink" title="Revision Control System"></a>Revision Control System</h3><p>版本控制。</p>
<p>roll-back：版本回滚。</p>
<p>check-out：开发者拉下来代码。</p>
<p>check-in：开发者提交自己的修订版。</p>
<p>conflict：两个人的提交出冲突了。</p>
<p>merge：合并入主分支。</p>
<h3 id="Daily-Build"><a href="#Daily-Build" class="headerlink" title="Daily Build"></a>Daily Build</h3><p>每日构建一次代码，编译链接源代码，进行一些测试，确保第二天大家能使用最新版本。</p>
<h3 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h3><p>开发人员也建议每天check-in一次。</p>
<h3 id="Build-Verification-Tests"><a href="#Build-Verification-Tests" class="headerlink" title="Build Verification Tests"></a>Build Verification Tests</h3><p>断言和单元测试。</p>
<h3 id="Bug-Database"><a href="#Bug-Database" class="headerlink" title="Bug Database"></a>Bug Database</h3><p>记录以前的bug记录，解决方法，严重程度，优先级等信息。</p>
<h3 id="War-Team-and-Bug-Triage"><a href="#War-Team-and-Bug-Triage" class="headerlink" title="War Team and Bug Triage"></a>War Team and Bug Triage</h3><p>发布前，作战小组确认系统“好到可以发布”。检查运行是否正常，剩余的bug严重程度等。</p>
<h3 id="Code-reviews-and-coding-guidelines"><a href="#Code-reviews-and-coding-guidelines" class="headerlink" title="Code reviews and coding guidelines"></a>Code reviews and coding guidelines</h3><p>团队对彼此代码进行彻底审查。</p>
<h3 id="Globalisation-and-Localisation"><a href="#Globalisation-and-Localisation" class="headerlink" title="Globalisation and Localisation"></a>Globalisation and Localisation</h3><p>针对不同语言、脚本的差异处理。</p>
<h3 id="Documentation-Generators"><a href="#Documentation-Generators" class="headerlink" title="Documentation Generators"></a>Documentation Generators</h3><p>文档生成。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Software/" rel="tag">Software</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：存算一体芯片的潜力与挑战"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/01/29/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/"
    >技术学习：存算一体芯片的潜力与挑战</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/01/29/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%AD%98%E7%AE%97%E4%B8%80%E4%BD%93%E8%8A%AF%E7%89%87%E7%9A%84%E6%BD%9C%E5%8A%9B%E4%B8%8E%E6%8C%91%E6%88%98/" class="article-date">
  <time datetime="2024-01-29T00:00:00.000Z" itemprop="datePublished">2024-01-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文学习自：存算一体芯片深度产业报告——作者：量子位</p>
<p>报告链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/557673211">存算一体是啥新趋势？值得教授学者纷纷下海造芯 | 附报告下载 - 知乎 (zhihu.com)</a>，侵删！</p>
<h2 id="存算一体技术概述"><a href="#存算一体技术概述" class="headerlink" title="存算一体技术概述"></a>存算一体技术概述</h2><p>“存算一体”技术的起因在于传统冯诺依曼架构芯片无法满足不断提升的算力与低功耗需求。随着晶体管的体积越来越小，摩尔定律逐渐失效（会引发量子隧穿等反应），导致存储器与处理器之间的数据传输成为 CPU 性能的瓶颈，相对较长时间的数据搬运导致算力受限。</p>
<p>为了解决这个问题，我们需要新的芯片架构。主要有三种解决方式：</p>
<ol>
<li>近存计算：缩短处理器芯片与存储器芯片的距离，减少数据搬运损耗。</li>
<li>内存储计算：处理器和存储器位于同一芯片的不同电路单元中。</li>
<li>内存执行计算：通过在存储器颗粒上嵌入算法，由存储器芯片内部的存储单元完成计算操作。</li>
</ol>
<h2 id="产业分析"><a href="#产业分析" class="headerlink" title="产业分析"></a>产业分析</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20240129171851417.png" alt="image-20240129171851417"></p>
<p>存算一体芯片落地的优势在于在算力提高的同时，芯片体积的减小和数据传输功耗的减少，使得芯片良率、成本、功耗等都有所改善。然而，实际应用的挑战主要在于评估市场需求和客户转换成本。重要的考量是，大规模采用新型芯片是否能够在成本和能耗方面带来足够的改进，以证明其经济效益；新架构芯片的先进生产工艺制造能力；客户对低功耗和高算力的需求；以及封装、测试、工具链、EDA 等相辅相成的产业链生态仍缺乏相应的研发公司。</p>
<p>当下大多数初创公司的思路是先聚焦特定场景，在垂直领域内站稳脚跟后技术外溢到更丰富的应用场景。主要的应用场景包括小算力低功耗场景（知存科技、九天睿芯和闪易半导体等）和大算力场景（千芯科技，后摩智能等）。</p>
<p>目前已知的商业模式主要分为三种：IP授权，定制&#x2F;联合开发以及自主SoC芯片。</p>
<p>当前国内外存算一体技术发展特征如下：</p>
<ul>
<li>成立时间不同会影响技术路线选择，国内外实现产品化的公司数量不多，离规模化还有一定距离</li>
<li>技术路线：大公司选择最容易落地的，初创公司在确保技术先进性基础上选择最容易落地的</li>
<li>国外已形成完整的自研技术链，大规模量产上国内外均未实现突破</li>
<li>不同的业务场景均已呈现出各自的优势，在商业模式上国内外都处在探索阶段</li>
<li>虽然业内尚未形成完整的生态，产业链部分环节已经出现针对存算一体进行技术研发的公司</li>
</ul>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>为了推动存算一体技术的未来发展，重点应放在解决关键技术难题上，并且寻找适合快速应用推广的场景。随着新型存储器技术，尤其是RRAM和MRAM的不断进步，预计将大幅推进存算一体架构的发展。这些技术的应用，尤其是在终端推理和物联网领域，预示着存算一体技术将在这些领域发挥重要作用。为了实现从初步商业化到大规模商业化的转变，技术创新与产业发展必须紧密协同，共同推动这一技术的成熟和应用普及。</p>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>作为一名物联网工程专业的大学生，深入了解存算一体技术让我领略了科技创新的魅力及其在未来应用的广阔前景。虽然我尚缺乏商业模式和产品上市的实践经验，但这次学习经历让我认识到理论与实践结合的重要性，以及跨学科知识对于技术创新的贡献。</p>
<p>通过研究这一技术，我明白了在物联网设备设计中，如何有效融合硬件和软件来提高性能同时降低能耗的重要性。这一认识不仅提升了我的专业技能，也激发了我对如何将技术创新转化为实际应用的深入思考。</p>
<p>此外，我也看到了自己在商业知识和市场分析方面的不足，这提示我在未来的学习中需更多关注这些领域。我期待将这次学习的感悟转化为动力，在未来的学习和工作中不断探索、学习和创新，为智能化世界贡献我的力量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Chip/" rel="tag">Chip</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：STM32 F407 霸天虎开发板"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/11/26/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9ASTM32%20F407%20%E9%9C%B8%E5%A4%A9%E8%99%8E%E5%BC%80%E5%8F%91%E6%9D%BF/"
    >技术学习：STM32 F407 霸天虎开发板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/11/26/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9ASTM32%20F407%20%E9%9C%B8%E5%A4%A9%E8%99%8E%E5%BC%80%E5%8F%91%E6%9D%BF/" class="article-date">
  <time datetime="2023-11-26T00:00:00.000Z" itemprop="datePublished">2023-11-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博主开始探索嵌入式以来，其实很早就开始玩 stm32 了。但是学了一段时间之后总是感觉还是很没有头绪，不知道在学什么。前前后后分别尝试了江协科技、正点原子、野火霸天虎三次 stm32 的课程学习。江协科技的 stm32f103c8t6 课程看了一段时间，感觉对一些外设的调用方法有一个基础的认知了，但是没有很明白到底在学什么；正点原子则是有点听不懂，半字也借给同学了就有一段时间没学，感觉自认为 stm32 学的有两把刷子了。后来听前辈说江协科技的 stm32 课程不如 51 单片机的质量好，其实课程讲的一般，我就想：是不是应该重新好好学一下 stm32 课程了。</p>
<p>这次选择的是野火的  F407 霸天虎课程，第一是听大家说，入门选野火或者正点最好。第二是野火的大师进阶篇的一些内容，涉及到一些原理等的学习讲解，我觉得对我会非常有帮助，因此正好就买了这款开发板从入门到中级到大师原理一起学习了。</p>
<p>本系列博文笔记主要基于野火相应课程，b站地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vt411X7PK/?spm_id_from=333.337.search-card.all.click&vd_source=05baa16b109824edfe68909895264c33">野火F407开发板-霸天虎视频-【入门篇】_哔哩哔哩_bilibili</a> ，仅供学习参考不做任何商业用途使用，侵删！</p>
<h3 id="调试器介绍"><a href="#调试器介绍" class="headerlink" title="调试器介绍"></a>调试器介绍</h3><p>我选择的是高速版，支持 SW 和 JTAG 两种连接方式。SW 模式则只需要连接 VREF（3V3）, TMS（数据）, TCK, RESET, GND 五个引脚。</p>
<h3 id="程序烧录配置"><a href="#程序烧录配置" class="headerlink" title="程序烧录配置"></a>程序烧录配置</h3><p>芯片型号：STM32F407ZGTX。</p>
<p><strong>DAP 仿真烧录</strong>自然非常简单。</p>
<p><strong>串口一键下载 ISP</strong> 下载速度慢，不能调试，但是成本很低。可以使用 FlyMcu 等软件。</p>
<p><strong>2023.11.2 补充。</strong></p>
<p><strong>警告，建议如果 flymcu 不能烧录，就不要尝试这种玩法了，看看课学学得了。因为我自己乱捣鼓一通后把开发板锁了。</strong></p>
<p><strong>下面的内容我不太清楚具体是哪一步出现了锁死 flash 的问题，总之不要尝试！学习一下理论得啦。</strong></p>
<p><strong>如果和我一样锁死了，请见野火大师篇程序，里面有一个解除写保护的代码，运行一下。</strong></p>
<p>ISP 下载方式：允许我们不拆下芯片来下载。对于上个世纪嵌入式学习来说这是一个很大的突破，因为当时是要把芯片拆下来烧录编程的。</p>
<p>ISP 厂商出产的时候就选定了一种串行外设对芯片内部 FLASH 进行编程，我们不能修改。常用串口下载方式，成本低，但是不能调试仿真。</p>
<p>普通 ISP 需要手动配置 boot loader，一键 ISP 不用，硬件电路和上位机配合达到一键下载的效果（手动配置：00是用户闪存启动，10是系统 SRAM&#x2F;ISP 启动，普通 ISP 要手动改跳线帽）。</p>
<p>一键下载电路的具体原理流程如下：</p>
<ol>
<li>RTS 低电平，Q1 是一个 PNP 三极管，导通，BOOT0 拉高。</li>
<li>DTS 高电平，Q2 NPN 导通，U18 是一个由 EN 控制开关的模拟开关，2 脚被导通为低电平，连接1脚拉低 NRST 复位。程序下载执行。</li>
<li>U18 模拟开关的作用是稳定电路。开发板复位的时候 DTR RTS 是不稳定的状态，如果没有这个模拟开关，DTR RTS 可能进入 ISP 状态，复位，进入 ISP 状态，复位，进入……一直运行不起来了。模拟开关右侧电容使得 VCC 需要花一点时间充电给 EN，而不是立刻激活 EN（EN 1.8V 左右）。这时候 DTR RTS 已经稳定了，可以导通 U18 12 引脚来给 NRST 复位了。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698858387784.png" alt="1698858387784"></p>
<p>不过 FlyMcu 实际配置方式是反过来的，因为他的协议是 232（+3<del>+15 是 0，-3</del>-15 是 1），和 TTL（3.3v 是1,0v 是0）正相反。</p>
<p><em>但是实际操作的时候可能遇到一种状况：部分开发板无法使用 FlyMcu 写入。我就碰到了。解决办法是使用 stm32 cube programmer 烧录程序。</em></p>
<p><em>配置如下：开发板上 boot 连接 3v3，RTS DTR&#x3D;0，选中 read unprotect，建立连接后再烧录程序。</em></p>
<p><em>但是不知道是波特率或者校验位的问题，我每次能成功烧录进去，然后过一会就显示断开找不到设备了。可能是因为波特率没有76800的选项。</em></p>
<h2 id="STM32-介绍"><a href="#STM32-介绍" class="headerlink" title="STM32 介绍"></a>STM32 介绍</h2><blockquote>
<p>正点原子网课：单片机和电脑的类比：内存是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SRAM&spm=1001.2101.3001.7020">SRAM</a>，硬盘是 FLASH，主板是外设。</p>
</blockquote>
<p>st：意法半导体公司，SoC 厂商。</p>
<p>m：微控制器。微控制器和微处理器相比性能比较拉一点，主频低，微处理器能跑一些大 os（linux）。</p>
<p>32：32位微控制器。</p>
<blockquote>
<p>正点原子网课：8051，X86 属于 CISC；ARM, MIPS, RISC-V 属于 RISC.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012212735.png" alt="image-20230401221223643"></p>
<p>冯诺依曼和哈佛结构的主要区别：程序存储器和数据存储器是否分开存储。不分开是冯诺依曼，分开是哈佛。哈佛执行效率更高，冯诺伊曼资源占据更少。</p>
<p>CORTEX-M 系列介绍<br>ARM 公司（做精简指令集计算机的）只设计内核架构和授权知识产权，不参与设计芯片，给其他合作公司授权设计芯片。半导体厂商再根据架构完善周边电路并制作芯片。现在95%手机、平板都是 ARM 架构的， ARM 公司是真的牛。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012216885.png" alt="image-20230401221658811"></p>
<p>其优点在于低功耗低成本高性能，且支持16&#x2F;32位双指令集。</p>
<p>ARM 有9个版本，从 v6 开始出现 cortex 的命名。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202304012219288.png" alt="image-20230401221918218"></p>
</blockquote>
<p>随着需求不断发展，stm32 在一众 8&#x2F;16位 MCU 中脱颖而出。</p>
<p>stm32 自带许多通信接口，如 spi i2c uart 等；扫地机，无人机，手环等都可以是 stm32 的作品。</p>
<p>如何选型？以下是几大类 stm32 的特点。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013709264.png" alt="image-20231102013709264"></p>
<p>本课程学习使用的开发板命名方式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102013830412.png" alt="image-20231102013830412"></p>
<p>选型：满足项目需求的前提下，尽可能选便宜的，比如主频低，功耗低，引脚少，flash 少。</p>
<p>引脚分配：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860405030.png" alt="1698860405030"></p>
<p>看手册的重点：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698860693691.png" alt="1698860693691"></p>
<p>外设资源，芯片功能，引脚，引脚大致分类，内存，封装……</p>
<p>哎想起前两天面试被问，如果选型 MCU 我应该看哪些因素。我只想到了外设和内存hhh。属于是只会写代码的笨比了。这也是我开始重新看野火课程的原因之一。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>虽然正式编程没有必要用寄存器编程，通常都是库函数或者 hal 库。但是还是有必要学一下原理的。</p>
<h3 id="寄存器映射"><a href="#寄存器映射" class="headerlink" title="寄存器映射"></a>寄存器映射</h3><p>芯片视图如下。</p>
<p>丝印：芯片上印的信息。型号，内核，生产批次等。</p>
<p>引脚：左上角是有小圆点的，从左上-左下-右下-右上逆时针看。或者如果没有小圆点，把丝印方向摆正，从左上角开始看。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121423731.png" alt="image-20231102121423731"></p>
<p>芯片内部组成：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102121841662.png" alt="image-20231102121841662"></p>
<p>寄存器映射：32位，2^32^&#x3D;4GB，因此所有程序都需要通过内存 4GB 去映射访问。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102122058475.png" alt="image-20231102122058475"></p>
<p>block7：M4 芯片内外设，比如一些通信总线这些都算外设。</p>
<p>block1：内存。</p>
<p>block0：代码。不过实际上由于设计工艺的问题，block0 block1 都只用了很少的一部分来存代码或者作为内存。</p>
<p>外设寄存器放在 block2 中。根据不同块速度不一样，又具体分为不同速度的外设（AHB APB）。</p>
<p>总线速度：AHB&gt;APB2&gt;APB1. APB1 是较低速的外设，包括 I2C UART SPI 看门狗等。</p>
<p>我们想要操作特定的外设，其实就是控制他的寄存器。控制寄存器就要找到寄存器相应的地址往里面写入数据，寄存器地址就是内存中的地址映射。</p>
<p>比如 GPIOF 我们想让其端口全部输出高电平。我们查找 stm32f407 手册，发现 GPIOF 的地址是 0x40021400，GPIOF 的 ODR（output data register）相对起始地址的偏移地址是14，则我们需要给 0x40021414 的地址写入数据 0xFFFF.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102123404182.png" alt="image-20231102123404148"></p>
<p>51 单片机库函数中封装的 reg51.h 中，利用 sfr 定义寄存器地址；而 stm32 库函数中使用宏定义，这些就是寄存器映射操作。<strong>对芯片里一个特殊功能的内存单元起别名的过程就是寄存器映射。</strong> 给这个地址再分配一个地址交重映射，stm32 中不咋常用。</p>
<h3 id="C语言对寄存器的封装"><a href="#C语言对寄存器的封装" class="headerlink" title="C语言对寄存器的封装"></a>C语言对寄存器的封装</h3><p>这样逐个地址，哪怕已经进行了寄存器映射，还是很复杂。</p>
<p>c 语言库函数实际进行的封装操作是使用结构体批量定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GPIO 外设基地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA_BASE (AHB1PERIPH_BASE + 0x0000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB_BASE (AHB1PERIPH_BASE + 0x0400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC_BASE (AHB1PERIPH_BASE + 0x0800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD_BASE (AHB1PERIPH_BASE + 0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE_BASE (AHB1PERIPH_BASE + 0x1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE (AHB1PERIPH_BASE + 0x1400)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG_BASE (AHB1PERIPH_BASE + 0x1800)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH_BASE (AHB1PERIPH_BASE + 0x1C00)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO 寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER; <span class="comment">/*GPIO 模式寄存器 地址偏移: 0x00 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER; <span class="comment">/*GPIO 输出类型寄存器 地址偏移: 0x04 */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR; <span class="comment">/*GPIO 输出速度寄存器 地址偏移: 0x08 */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR; <span class="comment">/*GPIO 上拉/下拉寄存器 地址偏移: 0x0C */</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR; <span class="comment">/*GPIO 输入数据寄存器 地址偏移: 0x10 */</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR; <span class="comment">/*GPIO 输出数据寄存器 地址偏移: 0x14 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL; <span class="comment">/*GPIO 置位/复位寄存器低 16 位部分 地址偏移: 0x18 */</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH; <span class="comment">/*GPIO 置位/复位寄存器高 16 位部分 地址偏移: 0x1A */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR; <span class="comment">/*GPIO 配置锁定寄存器 地址偏移: 0x1C */</span></span><br><span class="line">	<span class="type">uint32_t</span> AFR[<span class="number">2</span>]; <span class="comment">/*GPIO 复用功能配置寄存器 地址偏移: 0x20-0x24 */</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 GPIO_TypeDef 把地址强制转换成指针 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOA ((GPIO_TypeDef *) GPIOA_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOB ((GPIO_TypeDef *) GPIOB_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOC ((GPIO_TypeDef *) GPIOC_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOD ((GPIO_TypeDef *) GPIOD_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOE ((GPIO_TypeDef *) GPIOE_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF ((GPIO_TypeDef *) GPIOF_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOG ((GPIO_TypeDef *) GPIOG_BASE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOH ((GPIO_TypeDef *) GPIOH_BASE)</span></span><br></pre></td></tr></table></figure>

<p>所有外设都是如此，首先定义总线 APB AHB 地址，然后每个外设在其基础上进行偏移，每个外设的不同部分再在该外设基址上进行偏移。</p>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><h3 id="寄存器方式"><a href="#寄存器方式" class="headerlink" title="寄存器方式"></a>寄存器方式</h3><p>要命啊，一看名字我就不想试。寄存器新建不得麻烦死。</p>
<p>哎算了为了学习原理，干了。</p>
<p>我们尝试自己写一个寄存器的库函数来引用。</p>
<p>首先我们需要引用 st 官方启动文件 stmf4xx.s，具体用途后面章节再展开讲解。然后我们自己新建一个 stm32f4xx.h 文件来映射寄存器。不过只是把这个文件包含进项目，编译会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Objects\led_reg.axf: Error: L6218E: Undefined symbol SystemInit (referred from startup_stm32f40xx.o).</span><br></pre></td></tr></table></figure>

<p>进入启动文件后，可以看到这么一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK]</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line"></span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0</span><br><span class="line">                 LDR     R0, =__main</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br></pre></td></tr></table></figure>

<p>import 的作用相当于 extern，所以没有找到这个函数的定义，需要我们自己去定义。这就是为什么简单引入了启动文件会报错。</p>
<p>而 __main 是当我们定义了 main() 函数后，编译器会自动链接一些c语言库定义好的函数，用于初始化堆栈并且调用我们的 main().</p>
<p><strong>注意，如果想要生成 __main 函数，必须勾选下面这一项。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231102200243099.png" alt="image-20231102200243099"></p>
<p>野火你讲的是真好啊。我之前草草学了学 stm32 单片机用法，比赛的时候自己想移植代码，改了启动文件也不好使，就是报错。原来是这个原因。</p>
<p>那么我们只需要定义这么一个函数，哪怕内容是空都无所谓。</p>
<p>最终我们定义的初步项目框架如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698926683862.png" alt="1698926683862"></p>
<p>stm32f4xx.h：内容为空，有这么个东西就行。</p>
<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，这个程序可以烧录到板子上的。烧录成功之后没有任何反应（因为本来程序也没做什么哈哈），但是这就是一个大进步了。</p>
<h4 id="点灯——51单片机版"><a href="#点灯——51单片机版" class="headerlink" title="点灯——51单片机版"></a>点灯——51单片机版</h4><p>51单片机版就是引用 reg51.h 头文件，在其中声明了各个引脚的地址。我们只需要直接给引脚赋值即可。</p>
<p>调用代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 0 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	PA0=<span class="number">0xFE</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>接下来我们需要定义 LED 灯的寄存器位置。阅读原理图如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698939342199.png" alt="1698939342199"></p>
<p>大致可以看出，板子上的这个 RGB LED 通过三个引脚来控制 RGB 亮度。输出低电平则导通点亮。</p>
<p>具体输出方式是通过 ODR 进行输出。查找 stm32f4xx 中文参考手册可见：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940158585.png" alt="1698940158585"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940257044.png" alt="1698940257044"></p>
<p>那么我们就要给 0x4002 1400 +14 的地址赋值，让 1&lt;&lt;6 1&lt;&lt;7 1&lt;&lt;8 的位分别赋值为低电平.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	 *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这样也不亮。亮就怪了，stm32 寄存器是需要先做初始化配置的。</p>
<h4 id="点灯——stm32-版"><a href="#点灯——stm32-版" class="headerlink" title="点灯——stm32 版"></a>点灯——stm32 版</h4><p>首先我们要设置 GPIO 模式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1698940961543.png" alt="1698940961543"></p>
<p>想点灯 输出高低电平，是 01 通用输出模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">*(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br></pre></td></tr></table></figure>

<p>意思是先把 PF6 模式位置为00，然后赋值为01通用输出。</p>
<p>配置完模式之后，还需要配置时钟，stm32 每个外设都需要配置时钟。</p>
<p>前面提到过 GPIO 是在 AHB1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103516061.png" alt="1699103516061"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699103724261.png" alt="1699103724261"></p>
<p>全部代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40023800</span>+<span class="number">0x30</span>)|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0</span>)|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们把这几个地址值提取出来，宏定义映射寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx.h</span></span><br><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1_ENR    *(unsigned int *)(0x40023800+0x30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER     *(unsigned int *)(0x40021400+0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR       *(unsigned int *)(0x40021400+0x14)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点灯——流水灯闪烁"><a href="#点灯——流水灯闪烁" class="headerlink" title="点灯——流水灯闪烁"></a>点灯——流水灯闪烁</h4><p>利用软件延时实现 RGB 流水灯闪烁。很简单，前面已经看了3个 LED 通道 PF678 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    RCC_AHB1_ENR|=(<span class="number">1</span>&lt;&lt;<span class="number">5</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mode</span></span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)); </span><br><span class="line">    GPIOF_MODER&amp;=~(<span class="number">3</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>));   </span><br><span class="line">    GPIOF_MODER|=(<span class="number">1</span>&lt;&lt;(<span class="number">8</span>*<span class="number">2</span>)); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>); </span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">        GPIOF_ODR|=(<span class="number">7</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        GPIOF_ODR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">        delay_ms(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//毫秒级的延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">int</span> time)</span></span><br><span class="line">&#123;    </span><br><span class="line">   <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">   <span class="keyword">while</span>(time--)</span><br><span class="line">   &#123;</span><br><span class="line">      i=<span class="number">4000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--) ;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点灯——GPIO-具体功能框图对应"><a href="#点灯——GPIO-具体功能框图对应" class="headerlink" title="点灯——GPIO 具体功能框图对应"></a>点灯——GPIO 具体功能框图对应</h4><p>GPIO：通用输入输出引脚。我们可以通过编程来输出或者读取数据。大部分 GPIO 是已经连接、定义好了一些功能（比如上面尝试过的 PF6 LED），有的引脚有多个功能支持重新映射。</p>
<p>STM32 GPIO 除了 adc 是 3.3v，其他 GPIO 都是 5v 容忍。</p>
<p>GPIO 框图（<strong>重点</strong>）如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231104221140325.png" alt="image-20231104221140325"></p>
<p>先从输出开始看。最右侧的 IO 引脚是连接在芯片周围一圈的144个引脚之一。除了 IO 引脚，此图中其他所有部分都是封装在芯片内部我们看不到的。</p>
<p>往左有两个保护二极管。当电压大于 5V，电流会往上 VDD_FT 走。当电压为负电压，电流会由 VSS 往 IO 引脚走。</p>
<p>上下拉电阻：比武外接一个低电平工作的设备，但是我们不希望一上电外设就工作，可以设置上拉电阻，稳定一段时间。</p>
<p>GPIO 输出的数据来源：复位寄存器 BSRR，或者 ODR 设置（图中的3下路部分）。复位寄存器高16位复位（写1置0）低16位置位（写1置1），置位优先级更高。</p>
<p>配置 GPIO 模式（输入&#x2F;输出，选择哪一路）通过前面用过的 MODER 配置。</p>
<p>输出模式（图中输出控制部分）配置端口输出类型寄存器 OTYPER，比如推挽输出，开漏输出。</p>
<p>推挽输出：有直接驱动能力，输出0就是低电平，输出1就输出可以工作的高电平。原理是采用了一个放大的电路？</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699356797818.png" alt="1699356797818"></p>
<p>输入（INT）为高电平时，反向后 PMOS 导通，输出高电平。输入为低电平时，反向后 NMOS 导通，输出低电平。我们可以用一个小电流去驱动出来一个大电流。</p>
<p>开漏输出：自己本身没有输出高电平的手段。低电平可以接地，高电平没有 PMOS 管，是浮空状态。需要外接一个电阻。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357078909.png" alt="1699357078909"></p>
<p>stm32 输出 5V 电压的方法就是开漏输出外接电阻。通过接两个三极管的方式反向。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1699357296750.png" alt="1699357296750"></p>
<p>框图中的模拟部分输入输出则不用配置这些模式信息，直接由外设接到保护二极管再接到输出引脚。</p>
<p>框图中的输入部分经过保护电压后，还需要施密特触发器调整一下。比如原来电压的数值并非精确的0或 3.3V，施密特触发器将高于 1.8V 的全部视作1，低于的全部视作0后输入芯片。模拟部分则不需要经过施密特触发器。</p>
<p>因此配置 GPIO 输出的步骤如下：</p>
<ol>
<li>GPIO 功能，通用输出、复用功能、模拟输入等 MODER；</li>
<li>输出推挽 or 开漏 OTYPER；</li>
<li>输出速度 OSPEEDR；</li>
<li>上下拉电阻是否需要开启 PUPDR；</li>
<li>具体输出内容 BSRR or ODR.</li>
</ol>
<p>输入部分后面输入实验介绍~</p>
<p>按整个流程重新串一遍代码，如下：（其实和前面差不多，就是重新按照流程串了一遍）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用来存放寄存器映射相关的代码 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_BASE    (unsigned int *)    0x40023800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BASE  (unsigned int *)    0x40021400</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCC_AHB1ENR         *(RCC_BASE+0x30)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_MODER         *(GPIOF_BASE+0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_OSPEEDR       *(GPIOF_BASE+0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_PUPDR         *(GPIOF_BASE+0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR           *(GPIOF_BASE+0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_BSRR          *(GPIOF_BASE+0x18)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_AHB1ENR |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    GPIOF_MODER &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    GPIOF_MODER |= (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystemInit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>烧录前记得勾选：use MicroLib.</p>
<h3 id="构建库方式"><a href="#构建库方式" class="headerlink" title="构建库方式"></a>构建库方式</h3><h4 id="点灯——自己尝试构建库函数版"><a href="#点灯——自己尝试构建库函数版" class="headerlink" title="点灯——自己尝试构建库函数版"></a>点灯——自己尝试构建库函数版</h4><p>寄存器方法了解到这里就好，野火课程主要是库函数写代码。首先我们自己尝试构建一下库函数。</p>
<p>还是基于上次实验代码修改即可。首先对 .h 文件做一些修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个是防止多次引用头文件重复定义。</p>
<p>然后，像之前一条条定义太麻烦了。其实我们注意到每个寄存器都是4字节，我们可以用固定大小的结构体定义。比如 GPIO ABCDEF 结构都一样，我们只需要统一定义结构体和各自的基址即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span>	<span class="comment">// 包含了 uint32_t uint16_t</span></span></span><br><span class="line"><span class="comment">/* GPIO寄存器列表 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> MODER;    <span class="comment">/*GPIO模式寄存器						地址偏移: 0x00      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OTYPER;   <span class="comment">/*GPIO输出类型寄存器				地址偏移: 0x04      */</span></span><br><span class="line">    <span class="type">uint32_t</span> OSPEEDR;  <span class="comment">/*GPIO输出速度寄存器				地址偏移: 0x08      */</span></span><br><span class="line">    <span class="type">uint32_t</span> PUPDR;    <span class="comment">/*GPIO上拉/下拉寄存器			地址偏移: 0x0C      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> IDR;      <span class="comment">/*GPIO输入数据寄存器				地址偏移: 0x10      		*/</span></span><br><span class="line">    <span class="type">uint32_t</span> ODR;      <span class="comment">/*GPIO输出数据寄存器				地址偏移: 0x14      		*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRL;    <span class="comment">/*GPIO置位/复位寄存器 低16位部分	地址偏移: 0x18 	*/</span></span><br><span class="line">    <span class="type">uint16_t</span> BSRRH;    <span class="comment">/*GPIO置位/复位寄存器 高16位部分	地址偏移: 0x1A  */</span></span><br><span class="line">    <span class="type">uint32_t</span> LCKR;     <span class="comment">/*GPIO配置锁定寄存器				地址偏移: 0x1C      */</span></span><br><span class="line">    <span class="type">uint32_t</span> AFR[<span class="number">2</span>];   <span class="comment">/*GPIO复用功能配置寄存器		地址偏移: 0x20-0x24 		*/</span></span><br><span class="line">&#125; GPIO_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GPIOF ((GPIO_TypeDef *)GPIOF_BASE)</span></span><br></pre></td></tr></table></figure>

<p>main.c 中可以把对应寄存器替换为 GPIOF-&gt;寄存器名了。</p>
<p>然后我们直接对寄存器做操作，还是有点直接了，最好是我们不需要关注寄存器有哪些，直接调用一个 GPIO 设置函数即可使用，封装性可移植性都会好很多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRL=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>&#123;</span><br><span class="line">    GPIOx-&gt;BSRRH=GPIO_Pin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STM32F4XX_GPIO_H__</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_SetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ResetBits</span><span class="params">(GPIO_TypeDef * GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>比如首先我们简单写了这样一个置位函数，使用方法为 <code>GPIO_SetBits(GPIOF_Base,1&lt;&lt;6)</code> .</p>
<p>以及我们可以在 <code>stm32f4xx_gpio.h</code> 里批量定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_6          (uint16_t)(1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_7          (uint16_t)(1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_Pin_8          (uint16_t)(1&lt;&lt;8)</span></span><br></pre></td></tr></table></figure>

<p>这样 GPIO 使用用 Set Reset 函数已经非常规范了。那么初始化操作我们也可以封装成一个函数。</p>
<p>初始化需要设置 MODER PUPDR OSPEEDR OTYPER，我们可以定义一个结构体用于存储这些初始化变量，初始化的时候新建一个这样的结构体并赋值，传入初始化函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stm32f4xx_gpio.h</span></span><br><span class="line"><span class="comment">//每个模块具体的值可以定义一个枚举类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GPIO_Mode_IN=<span class="number">0x00</span>;</span><br><span class="line">    GPIO_Mode_OUT=<span class="number">0x01</span>;</span><br><span class="line">    GPIO_Mode_AF=<span class="number">0x02</span>;</span><br><span class="line">    GPIO_Mode_AN=<span class="number">0x03</span>;</span><br><span class="line">&#125;GPIOMode_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> GPIO_Pin;</span><br><span class="line">    GPIOMode_TypeDef MODER;</span><br><span class="line">    GPIOPuPd_TypeDef PUPDR;</span><br><span class="line">    GPIOOType_TypeDef OTYPER;</span><br><span class="line">    GPIOOSpeed_TypeDef OSPEEDR;</span><br><span class="line">&#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<p>具体使用的时候首先我们初始化一个 GPIO_InitTypeDef 变量，并且给其中的每一个子元素都赋值。然后传入 GPIO_Init 函数中，里面就是一系列根据手册而来的位操作，这里我感觉前面原理懂差不多就不用非跟着敲了。</p>
<h4 id="分析-stm32-固件库函数"><a href="#分析-stm32-固件库函数" class="headerlink" title="分析 stm32 固件库函数"></a>分析 stm32 固件库函数</h4><p>前面基本上都是了解固件库编程，从51过渡到 stm32. 后面所有固件编程固件库的使用方法都和前面的 GPIO 类似。</p>
<p>固件是什么？其实就是程序，固化到 EEPROM 或 FLASH 中，操作最底层的设备。<strong>不是具体的应用，而是只操作最底层的设备。比如点灯算应用，给应用工程师提供库函数的工作是固件工程师的。</strong></p>
<p>stm32 官方 stmf4 固件库下载地址：</p>
<p><a target="_blank" rel="noopener" href="https://www.st.com/zh/embedded-software/stm32-standard-peripheral-libraries/products.html?querycriteria=productId=LN1939">STM32标准外设软件库: 相关产品</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231108222206160.png" alt="image-20231108222206160"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     22:16                Libraries</span><br><span class="line">d-----         2023/11/8     22:16                Project</span><br><span class="line">d-----         2023/11/8     22:17                Utilities</span><br><span class="line">d-----         2023/11/8     22:17                _htmresc</span><br><span class="line">-ar---         2023/11/8     22:15          88007 Package_license.html</span><br><span class="line">-ar---         2023/11/8     22:15          19611 Package_license.md</span><br><span class="line">-ar---         2023/11/8     22:15         152599 Release_Notes.html</span><br><span class="line">-ar---         2023/11/8     22:15       37185187 stm32f4xx_dsp_stdperiph_lib_um.chm</span><br></pre></td></tr></table></figure>

<p>.chm：使用帮助文档。</p>
<p>.html .md：一些版本更新，包许可证相关信息。</p>
<p>Utilities：一些第三方其他软件。</p>
<p>Project：样例，模板。</p>
<p>Libraries：库，CMSIS 是一些 ARM 公司的标准，Driver 是固件。inc 是头文件，src 是c文件。</p>
<p>我们根据上节课写的项目来进行库函数文件功能分析。</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>所属类别</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>startup_stm32f40xx.s</td>
<td>片上外设</td>
<td>汇编启动文件</td>
</tr>
<tr>
<td>stm32f4xx.h</td>
<td>片上外设</td>
<td>外设寄存器映射</td>
</tr>
<tr>
<td>system_stm32f4xx.c &#x2F; system_stm32f4xx.h</td>
<td>片上外设</td>
<td>初始化系统时钟</td>
</tr>
<tr>
<td>stm32f4xx_xxxx.c &#x2F; stm32f4xx_xxxx.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cm4.h</td>
<td>内核</td>
<td>内核寄存器映射</td>
</tr>
<tr>
<td>core_cmFunc.h &#x2F; core_cmSimd.h</td>
<td>内核</td>
<td>内核外设的一些操作函数</td>
</tr>
<tr>
<td>misc.c &#x2F; misc.h</td>
<td>内核</td>
<td>中断相关函数（优先级分组，系统中断）</td>
</tr>
<tr>
<td>stm32f4xx_it.c &#x2F; stm32f4xx_it.h</td>
<td>内核</td>
<td>中断服务函数（所有中断入口）</td>
</tr>
<tr>
<td>main.c</td>
<td></td>
<td>main 函数</td>
</tr>
</tbody></table>
<ol>
<li>startupxxxx.s：启动文件。</li>
<li>stm32f4xx.h：外设寄存器映射。</li>
<li>跳到 system_Init 函数，这个函数当时我们为了执行只写了一个空函数，而 stm32 官方固件库模板里面是有的，在 system_stm32f4xx.c 里，初始化系统时钟。</li>
<li>stm32f4xx.c：具体外设驱动，比如上节课写的 gpio。</li>
<li>core_cm4.h：内核寄存器映射。</li>
<li>misc：中断。</li>
</ol>
<h4 id="构建库函数"><a href="#构建库函数" class="headerlink" title="构建库函数"></a>构建库函数</h4><p>创建一个通用的模板，后面写程序直接使用这个模板。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">d-----         2023/11/8     23:27                Libraries</span><br><span class="line">d-----         2023/11/8     23:27                Listing</span><br><span class="line">d-----         2023/11/8     23:27                Output</span><br><span class="line">d-----         2023/11/8     23:27                Project</span><br><span class="line">d-----         2023/11/8     23:27                User</span><br><span class="line">-a----         2020/2/27     13:45            401 keilkill.bat</span><br></pre></td></tr></table></figure>

<p>前面都是新建的文件夹，keilkill.bat 是从 keil 编译程序中复制出来的一个脚本，可以删掉中间文件。</p>
<p>把固件库 Lib 里的 CMSIS 和 Driver 文件拷贝到 Libraries 文件夹中。CMSIS 中只保留 Device Include 文件夹。Device 中包含外设相关（比如 stm32f4xx.h system_stm32f4xx），Include 中只包含内核相关。</p>
<p>把 main.c stm32f4xx_it.c &#x2F; stm32f4xx_it.h stm32f4xx_conf.h 拷贝到 User 文件夹中。</p>
<p>在 Project 文件夹里可以包含多给项目文件，不光只有 Keil 的。比如 IAR 的我们新建一个 IAR 文件夹，Keil 我们新建一个 RVMDK(uv5) 文件夹。RealView 是包含不止 MDK 的开发工具集合的称呼，MDK 是 MCU 开发工具集成包，uVersion 是 IDE，Keil 是公司名字。</p>
<p>uVision 里新建工程，新建在 RVMDK(uv5) 文件夹下。</p>
<p>新建组、添加文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002542997.png" alt="image-20231109002542997"></p>
<p>STM32F4xx_StdPeriph_Driver 添加 STM32F4xx_StdPeriph_Driver&#x2F;src 下的所有文件，屏蔽掉 dma2d fmc ltdc，后两个是 sd 和 lcd 屏幕组件。</p>
<p>头文件如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109002823229.png" alt="image-20231109002823229"></p>
<p>宏定义如下：</p>
<p>USE_STDPERIPH_DRIVER,STM32F40_41xxx</p>
<p>我现在好想明白为什么宏定义在这里了，这样后面换单片机型号的时候可以直接修改这个宏定义。</p>
<p><strong>PS：我下载的是 1.8.1 版本 stm32f4xx.h 库函数，里面出现了一段重复定义导致编译产生了200多个 warning。我把下面那一段删掉了就好了。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/true" alt="jingqing3948_1-1699463889291.png"></p>
<p>Output 里设置 Output 文件夹，不然都在 Proj 里太乱。</p>
<p>记得勾选 MicroLib。</p>
<h4 id="点灯——官方库函数版"><a href="#点灯——官方库函数版" class="headerlink" title="点灯——官方库函数版"></a>点灯——官方库函数版</h4><p>在 User 文件夹中新建 LED 文件夹，里面新建 bsp_led.c，代表板级支持包 LED 代码，也就是只针对我们当前这一款开发板的点灯程序。</p>
<ol>
<li><p>设置时钟：rcc 时钟，在 stm32f4xx_rcc.c 中：</p>
</li>
<li><pre><code class="c">/**
  * @brief  Enables or disables the AHB1 peripheral clock.
  * @note   After reset, the peripheral clock (used for registers read/write access)
  *         is disabled and the application software has to enable this clock before 
  *         using it.   
  * @param  RCC_AHBPeriph: specifies the AHB1 peripheral to gates its clock.
  *          This parameter can be any combination of the following values:
  *            @arg RCC_AHB1Periph_GPIOA:       GPIOA clock
  *            @arg RCC_AHB1Periph_GPIOB:       GPIOB clock 
  *            @arg RCC_AHB1Periph_GPIOC:       GPIOC clock
  *            @arg RCC_AHB1Periph_GPIOD:       GPIOD clock
  *            @arg RCC_AHB1Periph_GPIOE:       GPIOE clock
  *            @arg RCC_AHB1Periph_GPIOF:       GPIOF clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOG:       GPIOG clock
  *            @arg RCC_AHB1Periph_GPIOI:       GPIOI clock
  *            @arg RCC_AHB1Periph_GPIOJ:       GPIOJ clock (STM32F42xxx/43xxx devices) 
  *            @arg RCC_AHB1Periph_GPIOK:       GPIOK clock (STM32F42xxx/43xxx devices)  
  *            @arg RCC_AHB1Periph_CRC:         CRC clock
  *            @arg RCC_AHB1Periph_BKPSRAM:     BKPSRAM interface clock
  *            @arg RCC_AHB1Periph_CCMDATARAMEN CCM data RAM interface clock
  *            @arg RCC_AHB1Periph_DMA1:        DMA1 clock
  *            @arg RCC_AHB1Periph_DMA2:        DMA2 clock
  *            @arg RCC_AHB1Periph_DMA2D:       DMA2D clock (STM32F429xx/439xx devices)  
  *            @arg RCC_AHB1Periph_ETH_MAC:     Ethernet MAC clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Tx:  Ethernet Transmission clock
  *            @arg RCC_AHB1Periph_ETH_MAC_Rx:  Ethernet Reception clock
  *            @arg RCC_AHB1Periph_ETH_MAC_PTP: Ethernet PTP clock
  *            @arg RCC_AHB1Periph_OTG_HS:      USB OTG HS clock
  *            @arg RCC_AHB1Periph_OTG_HS_ULPI: USB OTG HS ULPI clock
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其他部分基本也是参照库函数（主要是 stm32f4xx_gpio.h）最终呈现如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &quot;bsp_led.h&quot;</span><br><span class="line"></span><br><span class="line">void LED_GPIO_Config(void)&#123;</span><br><span class="line">    //RCC set function in stm32f4xx_rcc.h</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        //Init structure</span><br><span class="line">        GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">        GPIO_InitStructure.GPIO_Mode=GPIO_Mode_OUT;</span><br><span class="line">        GPIO_InitStructure.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;</span><br><span class="line">        GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_UP;</span><br><span class="line">        GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        //init function</span><br><span class="line">        GPIO_Init(GPIOF,&amp;GPIO_InitStructure);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

置位可以使用 `GPIO_SetBits` 或 `GPIO_ResetBits`。

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span> *)(<span class="number">0x40021400</span>+<span class="number">0x14</span>)&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>); </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      GPIO_ResetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">      GPIO_SetBits(GPIOF,GPIO_Pin_6);</span><br><span class="line">      i=<span class="number">12000000</span>;</span><br><span class="line">      <span class="keyword">while</span>(i--);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

没有上下拉的时候推挽输出会直接被 ODR 值所影响，哪怕没有赋值其中本来的值也会影响。所以推挽输出无上下拉，不置位 LED 也会被点亮，因为 ODR 默认值0.
</code></pre>
</li>
</ol>
<h3 id="输入——按键点灯"><a href="#输入——按键点灯" class="headerlink" title="输入——按键点灯"></a>输入——按键点灯</h3><p>开发板按键电路如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109191525189.png" alt="image-20231109191525189"></p>
<p>按键未按下接地，按下后为高电平。电容起到消抖作用，软件处理就不需要手动延时消抖了。</p>
<p>编程没啥难度，就是改了一下输入模式。使用 <code>ReadInputDataBits</code> 读取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bsp_button.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Button_GPIO_Config</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_InitTypeDef GPIOInitStruct;</span><br><span class="line">        GPIOInitStruct.GPIO_Mode=GPIO_Mode_IN;</span><br><span class="line">        GPIOInitStruct.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">        GPIOInitStruct.GPIO_OType=GPIO_OType_PP;</span><br><span class="line">        GPIOInitStruct.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">        GPIOInitStruct.GPIO_PuPd=GPIO_PuPd_NOPULL;</span><br><span class="line">        </span><br><span class="line">        GPIO_Init(GPIOA,&amp;GPIOInitStruct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_led.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_button.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0))GPIO_SetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        <span class="keyword">else</span> GPIO_ResetBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现按键按下后翻转：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RCC</span></span><br><span class="line">    LED_GPIO_Config();</span><br><span class="line">    Button_GPIO_Config();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET)&#123;</span><br><span class="line">            <span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==Bit_SET);</span><br><span class="line">            GPIO_ToggleBits(GPIOF, GPIO_Pin_6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要等到按键松开的时候再翻转，轮询直到松开。</p>
<h3 id="位带操作"><a href="#位带操作" class="headerlink" title="位带操作"></a>位带操作</h3><p>之前51单片机常见位定义。比如 PA 引脚有8个 IO 口，我们可以定义 <code>sbit LED1=PA^0</code> 这样单独操作某一位。</p>
<p>stm32 里没有直接的位定义方式。一种解决办法是我们利用与或操作不影响其他位的同时操作特定位；另一种就是位带操作。</p>
<p>stm32 里有一部分别名区域，用于映射外设、SRAM 中特定的位带区，我们操作这一部分别名区域时就可以实现对外设、SRAM 位带区与的位操作。</p>
<p>片上外设位带区：0X4000 0000<del>0X400F 0000，别名区：0X4200 0000</del>0X43FF FFFF，包含 APB12，AHB1 外设。</p>
<p>SRAM 位带区：0X2000 0000<del>0X200F 0000，别名区：0X2200 0000</del>0X23FF FFFF</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20231109220918350.png" alt="image-20231109220918350"></p>
<p>外设地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x42000000+ (A-0x40000000)<em>8</em>4 +n*4  （n是位序号）</p>
<p>SRAM 地址 A 别名地址为：AliasAddr&#x3D; &#x3D;0x22000000+ (A-0x20000000)<em>8</em>4 +n*4</p>
<p>扩大了32倍，可以对32位寄存器中的每一位进行操作。</p>
<p>统一公式：<code>\#define BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</code></p>
<p>使用：比如我们操作一个 GPIO 的位操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000)+0x02000000+((addr &amp; 0x000FFFFF)&lt;&lt;5)+(bitnum&lt;&lt;2))</span></span><br><span class="line"><span class="comment">// 把一个地址转换成一个指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_ADDR(addr) *((volatile unsigned long *)(addr))</span></span><br><span class="line"><span class="comment">// 把位带别名区地址转换成指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO ODR 和 IDR 寄存器地址映射</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_ODR_Addr (GPIOF_BASE+20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOF_IDR_Addr (GPIOF_BASE+16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独操作 GPIO 的某一个 IO 口，n(0,1,2...15),</span></span><br><span class="line"><span class="comment">// n 表示具体是哪一个 IO 口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFout(n) BIT_ADDR(GPIOF_ODR_Addr,n) <span class="comment">//输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFin(n) BIT_ADDR(GPIOF_IDR_Addr,n) <span class="comment">//输入</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例</span></span><br><span class="line">PFout(<span class="number">6</span>)= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这个概念学学就好，好像实际应用没啥意义。我们微处理器考试也考过hh。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-效率提升：Win11磁贴配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%EF%BC%9AWin11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/"
    >效率提升：Win11磁贴配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/%E6%95%88%E7%8E%87%E6%8F%90%E5%8D%87%EF%BC%9AWin11%E7%A3%81%E8%B4%B4%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%B8%8F%E6%98%9F%E9%80%90%E8%B7%AF%EF%BC%88%E5%88%9B%E6%96%B0%E6%8E%A2%E7%B4%A2%EF%BC%89/">踏星逐路（创新探索）</a> / <a class="article-category-link" href="/categories/%E8%B8%8F%E6%98%9F%E9%80%90%E8%B7%AF%EF%BC%88%E5%88%9B%E6%96%B0%E6%8E%A2%E7%B4%A2%EF%BC%89/Efficiency/">Efficiency</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近电脑还是升级到 win11 了。我之前采用的美化方案是桌面上的图标全部移到 win10 开始菜单里的全屏菜单上，用磁贴贴一排。每次要访问文件的时候都去开始菜单里找，而不是放在桌面上，这样桌面也可以空出来欣赏壁纸。参考配置链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/45120814/answer/1007955630">如何让Windows 10系统桌面变得更好看？ - 知乎 (zhihu.com)</a></p>
<p>但是升级到 win11 对我而言影响最大的就是压根没有全屏桌面和磁贴功能了。因此我搜了很多解决方案，加上一些自己的改进，最终把桌面磁贴恢复成如上图所示。一个自己喜欢看的桌面还是会对生产力的提高有很大帮助的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712234132339.png" alt="image-20230712234132339"></p>
<h2 id="软件安装：start11"><a href="#软件安装：start11" class="headerlink" title="软件安装：start11"></a>软件安装：start11</h2><p>首先，恢复开始菜单这一操作最离不开的就是 start11 这款软件。他让 win11 的开始菜单又有了全屏菜单选项，也支持了自定义磁贴在上面。虽然调整磁贴位置的时候偶尔会花几秒重启，但大多数时候还是没问题的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235022366.png" alt="image-20230712235022366"></p>
<p>正版软件是免费试用的，欢迎付费支持原作者。或采用博主的同款方案：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru">https://pan.baidu.com/s/1HY0WuV7ynlXdBI7qfuWZzg?pwd=1fru</a><br>提取码：1fru<br>–来自百度网盘超级会员V2的分享</p>
<h2 id="xxxxxxxxxx-int-zong-int-i-纵坐标y1-double-x-i-51-double-y-12-0-sin-x-7-int-y1-int-15-y-return-y1-​int-heng-int-i-横坐标j-int-j-i-if-i-101-i202-i303-i"><a href="#xxxxxxxxxx-int-zong-int-i-纵坐标y1-double-x-i-51-double-y-12-0-sin-x-7-int-y1-int-15-y-return-y1-​int-heng-int-i-横坐标j-int-j-i-if-i-101-i202-i303-i" class="headerlink" title="xxxxxxxxxx int zong(int i)&#x2F;&#x2F;纵坐标y1{    double x&#x3D;(i-51);    double y&#x3D;12.0*sin(x&#x2F;7);    int y1&#x3D;(int)(15-y);    return y1;}​int heng(int i)&#x2F;&#x2F;横坐标j{    int j&#x3D;i;    if(i&gt;101&amp;&amp;i&lt;&#x3D;202)j&#x3D;203-i;    else if(i&gt;202&amp;&amp;i&lt;&#x3D;303)j&#x3D;i-202;    else if(i&gt;303&amp;&amp;i&lt;&#x3D;404)j&#x3D;405-i;    return j;}​void dayin(char ch,int j,int y1)&#x2F;&#x2F;在(y1,j)处输出给定字符{        gotoxy(y1,j);        if(ch&#x3D;&#x3D;’ ‘)        {            if(y1&#x3D;&#x3D;15)printf(“-“);            else if(j&#x3D;&#x3D;51)printf(“|”);            else printf(“ “);        }        else printf(“#”);        gotoxy(29-y1,102-j);        if(ch&#x3D;&#x3D;’ ‘)&#x2F;&#x2F;防止坐标点和坐标轴被空格覆盖        {            if(29-y1&#x3D;&#x3D;15)printf(“-“);            else if(102-j&#x3D;&#x3D;51)printf(“|”);            else if(29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;49)printf(“-“);            else if((29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;50)||(29-y1&#x3D;&#x3D;3&amp;&amp;102-j&#x3D;&#x3D;50))printf(“1”);            else if(29-y1&#x3D;&#x3D;16&amp;&amp;102-j&#x3D;&#x3D;100)printf(“X”);            else printf(“ “);        }        else printf(“#”);        gotoxy(1,1);}​​​​int main(){    float x,y;    int tim&#x3D;20;    system(“color F0”);    system(“mode con cols&#x3D;101 lines&#x3D;30”);    clear();        for(int i&#x3D;0;i&lt;&#x3D;100;i++)&#x2F;&#x2F;打印x轴     {        gotoxy(15,i+1);        if(i!&#x3D;50)printf(“-“);        else printf(“+”);        gotoxy(1,1);        rest(1);    }        for(int i&#x3D;29;i&gt;&#x3D;0;i–)&#x2F;&#x2F;打印y轴     {        gotoxy(i+1,51);        if(i!&#x3D;14)printf(“|”);        gotoxy(1,1);         rest(1);    }    &#x2F;&#x2F;打印轴上的点    gotoxy(16,52); printf(“O”);        gotoxy(16,100);printf(“X”);        gotoxy(1,49);printf(“Y”);        gotoxy(3,50);printf(“1”);        gotoxy(26,49);printf(“-1”);                    int i&#x3D;0,j,y1;​    for(i&#x3D;52;i&lt;&#x3D;404;i++)&#x2F;&#x2F;打印函数     {        j&#x3D;heng(i),y1&#x3D;zong(i);        dayin(‘#’,j,y1);        rest(4);                if(i-51-tim&gt;0)        {            y1&#x3D;zong(i-tim);            j&#x3D;heng(i-tim);            dayin(‘ ‘,j,y1);        }    }       for(int r&#x3D;i-tim;r&lt;&#x3D;i;r++)    {        j&#x3D;heng(r);        y1&#x3D;zong(r);        dayin(‘ ‘,j,y1);        rest(4);    }     gotoxy(1,1);    rest(1000);    return 0;}c"></a>xxxxxxxxxx int zong(int i)&#x2F;&#x2F;纵坐标y1{    double x&#x3D;(i-51);    double y&#x3D;12.0*sin(x&#x2F;7);    int y1&#x3D;(int)(15-y);    return y1;}​int heng(int i)&#x2F;&#x2F;横坐标j{    int j&#x3D;i;    if(i&gt;101&amp;&amp;i&lt;&#x3D;202)j&#x3D;203-i;    else if(i&gt;202&amp;&amp;i&lt;&#x3D;303)j&#x3D;i-202;    else if(i&gt;303&amp;&amp;i&lt;&#x3D;404)j&#x3D;405-i;    return j;}​void dayin(char ch,int j,int y1)&#x2F;&#x2F;在(y1,j)处输出给定字符{        gotoxy(y1,j);        if(ch&#x3D;&#x3D;’ ‘)        {            if(y1&#x3D;&#x3D;15)printf(“-“);            else if(j&#x3D;&#x3D;51)printf(“|”);            else printf(“ “);        }        else printf(“#”);        gotoxy(29-y1,102-j);        if(ch&#x3D;&#x3D;’ ‘)&#x2F;&#x2F;防止坐标点和坐标轴被空格覆盖        {            if(29-y1&#x3D;&#x3D;15)printf(“-“);            else if(102-j&#x3D;&#x3D;51)printf(“|”);            else if(29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;49)printf(“-“);            else if((29-y1&#x3D;&#x3D;26&amp;&amp;102-j&#x3D;&#x3D;50)||(29-y1&#x3D;&#x3D;3&amp;&amp;102-j&#x3D;&#x3D;50))printf(“1”);            else if(29-y1&#x3D;&#x3D;16&amp;&amp;102-j&#x3D;&#x3D;100)printf(“X”);            else printf(“ “);        }        else printf(“#”);        gotoxy(1,1);}​​​​int main(){    float x,y;    int tim&#x3D;20;    system(“color F0”);    system(“mode con cols&#x3D;101 lines&#x3D;30”);    clear();        for(int i&#x3D;0;i&lt;&#x3D;100;i++)&#x2F;&#x2F;打印x轴     {        gotoxy(15,i+1);        if(i!&#x3D;50)printf(“-“);        else printf(“+”);        gotoxy(1,1);        rest(1);    }        for(int i&#x3D;29;i&gt;&#x3D;0;i–)&#x2F;&#x2F;打印y轴     {        gotoxy(i+1,51);        if(i!&#x3D;14)printf(“|”);        gotoxy(1,1);         rest(1);    }    &#x2F;&#x2F;打印轴上的点    gotoxy(16,52); printf(“O”);        gotoxy(16,100);printf(“X”);        gotoxy(1,49);printf(“Y”);        gotoxy(3,50);printf(“1”);        gotoxy(26,49);printf(“-1”);                    int i&#x3D;0,j,y1;​    for(i&#x3D;52;i&lt;&#x3D;404;i++)&#x2F;&#x2F;打印函数     {        j&#x3D;heng(i),y1&#x3D;zong(i);        dayin(‘#’,j,y1);        rest(4);                if(i-51-tim&gt;0)        {            y1&#x3D;zong(i-tim);            j&#x3D;heng(i-tim);            dayin(‘ ‘,j,y1);        }    }       for(int r&#x3D;i-tim;r&lt;&#x3D;i;r++)    {        j&#x3D;heng(r);        y1&#x3D;zong(r);        dayin(‘ ‘,j,y1);        rest(4);    }     gotoxy(1,1);    rest(1000);    return 0;}c</h2><p>首先如果是按博主的磁贴方法配置，就要选“win10配置”。或者你觉得其他风格也还不错都可以选。并且 ENABLE start11.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235704628.png" alt="image-20230712235704628"></p>
<p>点击“配置菜单”，进行如下配置：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235738298.png" alt="image-20230712235738298"></p>
<p>在“自定义菜单视觉外观”里，可以设置全屏菜单的颜色、透明度等，比如我使用的是有一定透明度的毛玻璃的样式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000601091.png" alt="image-20230713000601091"></p>
<p>然后在“控制”栏里设定如何打开 start11，确保可以打开：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230712235840844.png"></p>
<p>接着，点击 win 图标就可以打开全屏菜单了。</p>
<h2 id="磁贴配置"><a href="#磁贴配置" class="headerlink" title="磁贴配置"></a>磁贴配置</h2><p>对于大部分软件，只要右键-固定到开始屏幕&#x2F;固定到 start11，就可以在全屏菜单里看到刚刚贴上的磁贴了。</p>
<p>如果贴失败，可以尝试以下的方法：</p>
<ul>
<li>右键快捷方式，点击“打开文件所在位置”，再尝试把该文件的 .exe 文件固定到开始屏幕。</li>
<li>反复尝试，因为可能有一定的延迟。可以取消固定再次固定，等待一会看开始菜单是否出现。</li>
</ul>
<p>然后可以手动分组磁贴（把他们移到临近的位置），调整磁贴背景色，调整磁贴大小（有小正方形，中正方形，长方形，大正方形四种可以选择），调整磁贴布局位置。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000428410.png" alt="image-20230713000428410"></p>
<h2 id="图片磁贴配置"><a href="#图片磁贴配置" class="headerlink" title="图片磁贴配置"></a>图片磁贴配置</h2><p>这里是最自由发挥的部分。高情商：自由发挥。低情商：都要自己做很麻烦。</p>
<p>之前 win10 是有一款快捷工具可以输入自定义图片，按自己想要的格式裁剪并自动在全屏菜单中输出的，叫 Tile Genie.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713000854968.png" alt="image-20230713000854968"></p>
<p>但是它好像并不能在 start11 中使用。我尝试了一下导出的都是不能显示的图片块，所以只能放弃这种方法。如果读者的 Tile Genie 是没有问题可以正常显示图片那再好不过了，后面的内容都可以不用看了。</p>
<p>如果导出失败……我采用的方法是手动裁剪固定图片。很笨，但是有结果。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001102790.png" alt="image-20230713001102790"></p>
<p>首先，自行裁剪图片，计算公式为：中正方形 150*150，长方形 306*150，大正方形 306*306，边界线是6（像素）.</p>
<p>我采用的图像裁剪方法是：<a target="_blank" rel="noopener" href="https://www.iloveimg.com/zh-cn/crop-image">免费在线裁剪图像文件 (iloveimg.com)</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178422454.png" alt="1689178422454"></p>
<p>然后把导出图片找一个合适的地方存储起来，注意贴上磁贴之后就不能再移动修改这些图片了。</p>
<p>在全屏菜单中右键-固定文件，选定文件路径添加。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001454756.png" alt="image-20230713001454756"></p>
<p>刚固定上是这种形式：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689178534062.png" alt="1689178534062"></p>
<p>然后右键-调整大小，调整为想要的大小。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001613170.png" alt="image-20230713001613170"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001632462.png" alt="image-20230713001632462"></p>
<p>最后一步，右键-图标-选择自定义磁贴图像，再次选择此文件，然后他就被当做图标全屏显示了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713001653804.png" alt="image-20230713001653804"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-问题解决：ubuntu 安装 emscripten 时 install latest 安装报错"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/10/09/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/"
    >问题解决：ubuntu 安装 emscripten 时 install latest 安装报错</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/10/09/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9Aubuntu%20%E5%AE%89%E8%A3%85%20emscripten%20%E6%97%B6%20install%20latest%20%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/" class="article-date">
  <time datetime="2023-10-08T23:00:00.000Z" itemprop="datePublished">2023-10-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%A0%B4%E6%B5%AA%EF%BC%88%E9%81%87%E5%88%B0%E7%9A%84bug%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89/">破浪（遇到的bug及解决方案）</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>学习官网参考：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm">Compiling a New C&#x2F;C++ Module to WebAssembly - WebAssembly | MDN (mozilla.org)</a></p>
<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>形如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: Downloading URL &#x27;https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2&#x27;: &lt;urlopen error [Errno 104] Connection reset by peer&gt;</span><br><span class="line">error: installation failed!</span><br></pre></td></tr></table></figure>

<p>OS：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux jingqing 5.19.0-35-generic #36~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 17 15:17:25 UTC 2 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<h2 id="产生错误原因分析"><a href="#产生错误原因分析" class="headerlink" title="产生错误原因分析"></a>产生错误原因分析</h2><blockquote>
<p>emsdk install latest报错（因为从谷歌中下载，cmd中命令形式访问不到google）<br>版权声明：本文为CSDN博主「小白啥时候能进阶成功」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34754747/article/details/103815349">https://blog.csdn.net/qq_34754747/article/details/103815349</a></p>
</blockquote>
<p>非常感谢博主的答疑解惑，不过我没有看得太懂原文中的解决方案，网上搜到的大多数方案也是 windows 环境下的解决方案，因此我决定自己写一个 ubuntu 系统下的补安装。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>说白了就是我自己复制链接到浏览器里，下载安装这几个包，放到 emsdk 的指定位置。</p>
<p>这里有两个要注意的点，这一部分主要是分析，不想看的同学可以直接跳到<a href="#solution">具体步骤</a>处：</p>
<ol>
<li><p>emsdk install 的默认安装规则是：不管你有没有安装过这些包，我 install latest 都是重新安装，保证最新版本。但是现在问题是 install latest 有问题，我要手动安装包放进去。<br>我们打开 emsdk.py 通过搜索关键词可以找到报错信息的位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:675</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On success, returns the filename on the disk pointing to the destination file that was produced</span></span><br><span class="line"><span class="comment"># On failure, returns None.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_file</span>(<span class="params">url, dstpath, download_even_if_exists=<span class="literal">False</span>, filename_prefix=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">  debug_print(<span class="string">&#x27;download_file(url=&#x27;</span> + url + <span class="string">&#x27;, dstpath=&#x27;</span> + dstpath + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  file_name = get_download_target(url, dstpath, filename_prefix)</span><br><span class="line">  <span class="keyword">if</span> os.path.exists(file_name) <span class="keyword">and</span> <span class="keyword">not</span> download_even_if_exists:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;File &#x27;&quot;</span> + file_name + <span class="string">&quot;&#x27; already downloaded, skipping.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> file_name</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    u = urlopen(url)</span><br><span class="line">    mkdir_p(os.path.dirname(file_name))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      file_size = get_content_length(u)</span><br><span class="line">      <span class="keyword">if</span> file_size &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s, %s Bytes&quot;</span> % (file_name, url, file_size))</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Downloading: %s from %s&quot;</span> % (file_name, url))</span><br><span class="line"></span><br><span class="line">      file_size_dl = <span class="number">0</span></span><br><span class="line">      <span class="comment"># Draw a progress bar 80 chars wide (in non-TTY mode)</span></span><br><span class="line">      progress_max = <span class="number">80</span> - <span class="number">4</span></span><br><span class="line">      progress_shown = <span class="number">0</span></span><br><span class="line">      block_sz = <span class="number">256</span> * <span class="number">1024</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27; [&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          buffer = u.read(block_sz)</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> buffer:</span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">          file_size_dl += <span class="built_in">len</span>(buffer)</span><br><span class="line">          f.write(buffer)</span><br><span class="line">          <span class="keyword">if</span> file_size:</span><br><span class="line">              percent = file_size_dl * <span class="number">100.0</span> / file_size</span><br><span class="line">              <span class="keyword">if</span> TTY_OUTPUT:</span><br><span class="line">                  status = <span class="string">r&quot; %10d  [%3.02f%%]&quot;</span> % (file_size_dl, percent)</span><br><span class="line">                  <span class="built_in">print</span>(status, end=<span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  <span class="keyword">while</span> progress_shown &lt; progress_max * percent / <span class="number">100</span>:</span><br><span class="line">                      <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">                      sys.stdout.flush()</span><br><span class="line">                      progress_shown += <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> TTY_OUTPUT:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">  <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    errlog(<span class="string">&quot;Error: Downloading URL &#x27;&quot;</span> + url + <span class="string">&quot;&#x27;: &quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;SSL: CERTIFICATE_VERIFY_FAILED&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e) <span class="keyword">or</span> <span class="string">&quot;urlopen error unknown url type: https&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(e):</span><br><span class="line">      errlog(<span class="string">&quot;Warning: Possibly SSL/TLS issue. Update or install Python SSL root certificates (2048-bit or greater) supplied in Python folder or https://pypi.org/project/certifi/ and try again.&quot;</span>)</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    rmfile(file_name)</span><br><span class="line">    exit_with_error(<span class="string">&quot;aborted by user, exiting&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> file_name</span><br></pre></td></tr></table></figure>

<p>大致一看能看明白逻辑，如果 download_even_if_exists &#x3D; True 那么无论包是否已经存在都要安装，否则为 False 就只安装不存在的包，我们需要为 False。</p>
<p>搜索函数名查看在哪里使用了这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./emsdk.py:1411</span></span><br><span class="line"></span><br><span class="line">received_download_target = download_file(url, download_dir, <span class="keyword">not</span> KEEP_DOWNLOADS, filename_prefix)</span><br></pre></td></tr></table></figure>

<p>这个 KEEP_DOWNLOADS 是一个环境变量，默认为0，我们需要他为1，传入函数的参数则为0（False），即已存在文件不再重复下载。</p>
<p>在终端输入 <code>./emsdk --help</code> 可以看到提示信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment:</span><br><span class="line">      EMSDK_KEEP_DOWNLOADS=1     - if you want to keep the downloaded archives.</span><br><span class="line">      EMSDK_NOTTY=1              - override isatty() result (mainly to log progress).</span><br><span class="line">      EMSDK_NUM_CORES=n          - limit parallelism to n cores.</span><br><span class="line">      EMSDK_VERBOSE=1            - very verbose output, useful for debugging.</span><br></pre></td></tr></table></figure>

<p>也就是说只要安装时单独指定此变量值为1即可。</p>
</li>
<li><p>第二步就是如何下载文件了。下载什么文件？放到哪个目录下？</p>
<p>这里大家可以通过 download_file 的 print debug 调试来查看他校验文件是否存在是去哪里校验的，我就不再具体展开讲调试步骤了，结论就是：他在 emsdk&#x2F;downloads&#x2F; 目录下先查找一下待下载的压缩包是否存在，那么我们复制报错信息中的 url 下载文件到这个 downloads 文件夹下即可（没有就新建）。</p>
</li>
</ol>
<h2 id="solution">具体步骤</h2>

<ol>
<li><p>首先要安装所缺的所有包，一个个安装，报错信息里提示什么安装什么。比如文章开头的报错信息中下载链接是：<a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2%EF%BC%8C%E5%B0%B1%E5%85%88%E5%AE%89%E8%A3%85%E8%BF%99%E4%B8%AA%E3%80%82">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2，就先安装这个。</a></p>
<p>node: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>wasm-binaries: <a target="_blank" rel="noopener" href="https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2">https://storage.googleapis.com/webassembly/emscripten-releases-builds/linux/b90507fcf011da61bacfca613569d882f7749552/wasm-binaries.tbz2</a></p>
<p>安装完成后要重命名 b90507fcf011da61bacfca613569d882f7749552-wasm-binaries.tbz2。</p>
</li>
<li><p>移入 emsdk&#x2F;downloads 文件夹下，不用解压。</p>
</li>
<li><p>执行 <code>EMSDK_KEEP_DOWNLOADS=1</code> 变量赋值。</p>
</li>
<li><p>执行 <code>./emsdk install latest</code>  。</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jingqing3948@jingqing:~/Webassembly/emsdk$ ./emsdk install latest</span><br><span class="line">Resolving SDK alias &#x27;latest&#x27; to &#x27;3.1.44&#x27;</span><br><span class="line">Resolving SDK version &#x27;3.1.44&#x27; to &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;</span><br><span class="line">Installing SDK &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;..</span><br><span class="line">Skipped installing node-16.20.0-64bit, already installed.</span><br><span class="line">Skipped installing releases-b90507fcf011da61bacfca613569d882f7749552-64bit, already installed.</span><br><span class="line">All SDK components already installed: &#x27;sdk-releases-b90507fcf011da61bacfca613569d882f7749552-64bit&#x27;.</span><br></pre></td></tr></table></figure>

<p>好哎，看来是自己单独安装的文件包都可以用，他会自己解压文件包后提示 All SDK components already installed。</p>
<p>接下来就是下一步：<code>./emsdk activate latest</code>.</p>
<p>最后是 <code>source ./emsdk_env.sh</code> 配置好环境变量。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：RFID"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ARFID/"
    >北邮国院笔记：RFID</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/25/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9ARFID/" class="article-date">
  <time datetime="2023-07-24T23:00:00.000Z" itemprop="datePublished">2023-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要围绕提纲里的所有问题展开，没有拓展内容，Exam oriented Study。</p>
<p>关注微信公众号：灰海宽松，回复 “RFID” 可获取本文pdf格式。</p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><h2 id="Comparison-of-different-automatic-identification-technologies"><a href="#Comparison-of-different-automatic-identification-technologies" class="headerlink" title="Comparison of different automatic identification technologies"></a>Comparison of different automatic identification technologies</h2><p>首先明确一下比较对象。human identification（cost too high）是人力识别就不用说了。</p>
<p>fingerprint identification: </p>
<ul>
<li>stability 稳定，精确度高；</li>
<li>high speed, 快速匹配；</li>
<li><strong>security issues</strong>: 容易被复制。</li>
</ul>
<p>face recognition:</p>
<ul>
<li>easy to be influenced by surroundings, hair, age…</li>
</ul>
<p>speech recognition:</p>
<ul>
<li>easy to use and accept by user;</li>
<li>not involve privacy;</li>
<li>due to international standards, is hard to promoting</li>
</ul>
<p>1d barcode:</p>
<ul>
<li>limit storage capacity, 点线组合少;</li>
<li>need to combine with database;</li>
<li>barcode size is large;</li>
<li>poor fault tolerance, 本来就需要摄像头可见，如果被污损遮挡很容易就无法识别;</li>
</ul>
<p>2d barcode recognition:</p>
<ul>
<li>larger storage capacity;</li>
<li>high information density;</li>
<li>powerful fault tolerance;</li>
<li>support for encryption 容量大了就支持更多编码解码等安全措施了。</li>
</ul>
<p>rfid：</p>
<ul>
<li>low cost;</li>
<li>low power consumption;</li>
<li>high accuracy;</li>
<li>non-contract, fast speed; 不用接触（哪怕是visual，薄纱条码）</li>
<li>certain computing and storage capabilities;</li>
</ul>
<p>主要考虑各个的缺点，人脸和声音特征点多速度慢，而且人脸容易被影响，声音由于国际标准技术难以提升；条码需要视觉可见；指纹容易被盗取。</p>
<h2 id="The-main-features-of-RFID"><a href="#The-main-features-of-RFID" class="headerlink" title="The main features of RFID"></a>The main features of RFID</h2><ul>
<li><p>Non-contact automatic and rapid identification 快速薄纱复杂的人脸和声音，无接触薄纱条码和指纹</p>
</li>
<li><p>Permanently store a certain amount of data 永久存储一定量数据</p>
</li>
<li><p>Simple logical processing 其包含的简单逻辑电路允许做一定的逻辑处理，比如安全协议、算法</p>
</li>
<li><p>Reflection signal strength is affected by the distance  and other factors significantly 信号受到距离，读写器功率，其他信号，其他标签的干扰</p>
</li>
<li><p>Low cost, can be deployed at a large scale</p>
</li>
</ul>
<h2 id="Constraints-of-RFID-technology"><a href="#Constraints-of-RFID-technology" class="headerlink" title="Constraints of RFID technology"></a>Constraints of RFID technology</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687019780697.png" alt="1687019780697"></p>
<h2 id="Core-technologies-of-RFID"><a href="#Core-technologies-of-RFID" class="headerlink" title="Core technologies of RFID"></a>Core technologies of RFID</h2><p>Anti-collision mechanism：rfid并不支持传统的cmsa&#x2F;ca无线通信协议，需要采取一些措施防碰撞（reader-reader, tag-reader, tag-tag)</p>
<p>Efficient information storage, retrieval and mining: 尽量节能的信息存储，检索，挖掘</p>
<p>Make full use of the attenuation laws of backscatter signal to assist in positioning and mobile behavior sensing: 我们知道rfid信号会随着距离衰减。反之我们也可以利用这一点来定位物体位置和移动行为感知。</p>
<p>Security certification and privacy protection: 如何利用逻辑门电路校验安全性。</p>
<h2 id="The-advantage-of-RFID-in-IoT-and-the-development-trend"><a href="#The-advantage-of-RFID-in-IoT-and-the-development-trend" class="headerlink" title="The advantage of RFID in IoT, and the development trend"></a>The advantage of RFID in IoT, and the development trend</h2><p>充电方式：Backscatter, small node and indefinitely time of endurance. but rely on reader, one to many centralized communication 利用无线电 ratio signal 充电的方式</p>
<p>ptp communication: 建立 channel awareness technologies 使得支持被动点对点通信来建立分布式系统</p>
<p>Combine with Sensors: 开发更多应用方式。</p>
<p>RFID and IoT:</p>
<ul>
<li>embed intelligence in the physical object, so that simple physical objects can also “say”. </li>
<li>allows a physical object to be uniquely identified in a way similar to the “IP address” of a computing node in the Internet. </li>
<li>provides a low-cost communication way to achieve effective communication between nodes. </li>
<li>makes the physical objects in a passive environment achieve “passive intelligence“, providing fundamental guarantee for the “thing-thing connection”</li>
</ul>
<h1 id="2-Identification"><a href="#2-Identification" class="headerlink" title="2. Identification"></a>2. Identification</h1><p>简单说RFID就是物体上贴tag，用reader上的antenna去读取，这三个是主要组成。</p>
<h2 id="Reader’s-function"><a href="#Reader’s-function" class="headerlink" title="Reader’s function"></a>Reader’s function</h2><p>Energy supply: 比如有的标签自身不带能量需要reader提供信号中蕴含的能量</p>
<p>Communication: 最基本的功能，和tag识别，通信</p>
<p>Security Assurance: 比如加密解密</p>
<p>扩展功能：比如自组网 ad-hoc, 管理天线 antenna management 中间件接口 interface of middle components 连接外设 connecting peripherals</p>
<h2 id="Reader’s-classification"><a href="#Reader’s-classification" class="headerlink" title="Reader’s classification"></a>Reader’s classification</h2><p>按频率：LF HF算低频，UHF和SHF算高频（ultra super)，高频数据传输速度快，距离远，但是衰减快 signal attenuation，收到障碍物影响大  sensitive to obstacles。</p>
<p>按外观：</p>
<ul>
<li>Fixed 固定有线的，高度集成，快速启动 set up</li>
<li>portable 可移动的像手持手机一样，small, charging battery, easy to move</li>
<li>Industrial 为工厂目的而生，比如集成其他 sensor</li>
</ul>
<h2 id="Influencing-factors-of-R-W-range"><a href="#Influencing-factors-of-R-W-range" class="headerlink" title="Influencing factors of R&amp;W range"></a>Influencing factors of R&amp;W range</h2><p>许多东西都有说明书，规范，来提醒我们怎么不把东西玩坏比如手机提示不要放水里玩。</p>
<p>RFID的R&amp;W range是其中一种。影响因素如下：</p>
<ul>
<li><p>The way that antenna is coupled 天线耦合方式，比如把两个天线绑一起太近互相干扰。</p>
</li>
<li><p>The output power of the reader’s RF signal 功率，太低可能无法激发tags</p>
</li>
<li><p>The frequency of RF carrier signal 合适的频率</p>
</li>
<li><p>Antenna direction 天线，读取器天线和标签天线极性方向 polarization 相匹配时识别范围最大</p>
</li>
<li><p>Operation environment condition</p>
</li>
<li><p>Movement speed of tags</p>
</li>
</ul>
<h2 id="Reader’s-components-and-their-functions"><a href="#Reader’s-components-and-their-functions" class="headerlink" title="Reader’s components and their functions"></a>Reader’s components and their functions</h2><p>Signal Processing and Control Module: 主要是控制功能，协调一些本地计算</p>
<ul>
<li>Communicate with upper computer,  and execute command from it</li>
<li>Control communication process with tags</li>
<li>Encode and decode signal</li>
<li>Perform anti-collision algorithm</li>
<li>Encrypt and decrypt the data  transferred between reader and tag</li>
<li>Identity certification between reader and tag</li>
</ul>
<p>Inductively Coupled RF Module: 主要是产生能量和调制发送信号功能</p>
<ul>
<li>Generate high frequency send energy, activate RF tags and  provide energy (passive RF tags) </li>
<li>Modulate signal to sent,  transferring data to RF tags</li>
<li>Receive and demodulate RF signal  from RF tags.</li>
</ul>
<h2 id="Tag’s-functions"><a href="#Tag’s-functions" class="headerlink" title="Tag’s functions"></a>Tag’s functions</h2><ul>
<li>data storage</li>
<li>energy harvesting 吸收能量，与reader的 energy supply 对应</li>
<li>contactless with R&amp;W 不用接触就能通信，与 reader 的 communication with tags 对应</li>
<li>Security Encryption 与 reader 的 Security Assurance 对应</li>
<li>Collision Concessions 碰撞让步</li>
</ul>
<h2 id="Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability"><a href="#Tag-classification-by-package-form-by-power-source-by-work-frequency-by-R-W-capability" class="headerlink" title="Tag classification: by package form, by power source, by work frequency, by R&amp;W capability"></a>Tag classification: by package form, by power source, by work frequency, by R&amp;W capability</h2><p>Package form 也就是外观上的分类：</p>
<ul>
<li>card-like</li>
<li>label-like</li>
<li>Implantable, 比如动物植物体内</li>
<li>Accessories-like 附件类标签，比如纽扣型的，这一类主要是方便携带</li>
</ul>
<p>By Power Source 按能源供应方式分类：</p>
<ul>
<li>active 自己有电池供电</li>
<li>passive 依靠 carrier signal 读取器发来的载波信号获取能量</li>
<li>semi-passive 有电池作为后备隐藏能源，平时主要是passive 方式</li>
</ul>
<p>By Work Frequency</p>
<p>LF HF UHF。UHF读写性能，距离最好，更多会使用 active 型。</p>
<p>By R&amp;W Capability</p>
<p>read-only 和 R&amp;W 两种，结构复杂度也有所不同</p>
<h2 id="Two-work-modes-of-RFID-middleware"><a href="#Two-work-modes-of-RFID-middleware" class="headerlink" title="Two work modes of RFID middleware"></a>Two work modes of RFID middleware</h2><p>interactive, independent。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618045820043.png" alt="image-20230618045820043"></p>
<p>交互模式大概就是一直接收主机的命令，你让我读我就读，读完把结果还给你。</p>
<p>独立模式是可以不接收主机命令自行按预设的程序和读取到的结果信息循环执行指令，并将结果返回给主机。</p>
<h1 id="3-Wireless-Communication-Principle-of-RFID"><a href="#3-Wireless-Communication-Principle-of-RFID" class="headerlink" title="3. Wireless Communication Principle of RFID"></a>3. Wireless Communication Principle of RFID</h1><h2 id="Different-work-principles-of-different-carrier-frequency"><a href="#Different-work-principles-of-different-carrier-frequency" class="headerlink" title="Different work principles of different carrier frequency"></a>Different work principles of different carrier frequency</h2><p>不同频率载波也适用不同的工作原则。</p>
<p>前面已经有所涉及，比如LF HF适用于近距离，UHF SHF适合远距离。</p>
<p>前者适用 Inductively Coupled RF Module 电感耦合，通过感应方式获取能量。</p>
<p>后者适用 Electromagnetic Backscatter Coupled RF Module 电磁反向散射耦合，持续不断发送射频信号来供给能量。backscatter 指的是接收机信号调制后通过发送机天线产生可被识别的信号。</p>
<p>两者的能量消耗都和距离平方成正比 squared distance</p>
<h2 id="Signal-voltage-and-energy-dB-dBm，重点：如何计算"><a href="#Signal-voltage-and-energy-dB-dBm，重点：如何计算" class="headerlink" title="Signal voltage and energy: dB, dBm，重点：如何计算"></a>Signal voltage and energy: dB, dBm，重点：如何计算</h2><p>变化的电压通常用 $V(t)&#x3D;v_0cos(\omega t)$ 表示。</p>
<p>功率P&#x3D;VI&#x3D;V^2&#x2F;R这不用多说。平均功率 $&#x3D;\frac{v_0^2}{2R}$ 很简单推因为正余弦平均就是&#x2F;根2.</p>
<p>相对变化 The relative change，这是一个比较新鲜的而且信号变化中比较重要的指标。</p>
<p>$G_{dB}&#x3D;10log_{10}\frac{P2}{P1}$ </p>
<p>参考功率 referenced power $dBm&#x3D;10log_{10}\frac{P}{10^{-3}}$</p>
<p>dBm单位是功率的W，GdB单位是dB，代表一个比值。</p>
<h2 id="Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0"><a href="#Modulation-of-reader-signal-OOK-and-its-problem-solution-PIE-Tag-encoding-FM0" class="headerlink" title="Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0"></a>Modulation of reader signal: OOK and its problem, solution: PIE; Tag encoding: FM0</h2><p>一些阅读器通过调制使得正弦电压信号携带信息的方法。</p>
<p>OOK：on off keying，高功率1低功率0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036831437.png" alt="1687036831437"></p>
<p>问题在于，低功率0的部分标签没法被激活，也无法正常工作。也就是说0信号标签压根启动不了，没法接收0信号。</p>
<p>PIE解决方法：长高功率是1，短高功率是0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687036892748.png" alt="1687036892748"></p>
<p>然后涉及到tags对reader发来的信号进行解码。空间中的信号发过来是有方向的矢量叠加，tags如何通过编码机制识别信号？</p>
<p>FM0编码方式：位窗起始处翻转信号表示1，中间翻转表示0.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687037382818.png" alt="1687037382818"></p>
<p>FM0属于 FSK frequent shift key 通过信号变化频率来识别的机制。</p>
<h2 id="Link-budget-重点"><a href="#Link-budget-重点" class="headerlink" title="Link budget (重点)"></a>Link budget (重点)</h2><p>Link budget: forward link budget  and backward link budget 发射过程中能量增减的总和</p>
<p>reader transmit energy(+) path loss(-) tag activate energy(-)</p>
<ul>
<li>pass loss: 读取器天线向360度的发送能量。其中只有一部分区域可以被tags antenna读取到，这一部分被称作 Effective  Aperture (Ae) of the tag antenna。能量&#x3D;有效面积*密度 $P_t&#x3D;\rho A_e$ 。总共发送的能量比收到的能量就等于总表面积比有效面积 $\frac{P_{TX}}{P_{RX}}&#x3D;\frac{A_e}{4\pi r^2}$</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230618174327976.png" alt="image-20230618174327976"></p>
<p>来看上例，发送方30dBm对应1W，tag接收到-10dBm对应10^-4W. 然后5dB的衰减到-15dBm。这个5dB衰减就是两个dBm做差得到的。</p>
<p>所以，dBm相当于对功率P的另一种衡量方式，为什么这么麻烦的要用log来表示？因为两个dBm的差值就是分贝（放大系数），所以由一个dBm能量转到另一个只需要加减两者间差的分贝即可，很方便。</p>
<p>从tags反射回来的信号 reflection link 和路径四次方成反比 inversely proportional. $P_{RX,back}:\frac{1}{r^4}$</p>
<h2 id="Antenna-gain-and-polarization-EIRP"><a href="#Antenna-gain-and-polarization-EIRP" class="headerlink" title="Antenna gain and polarization, EIRP"></a>Antenna gain and polarization, EIRP</h2><p>antenna gain: 输入条件相同情况下，实际情况某一点能量密度&#x2F;理想条件下的密度单元。反应了天线 concentrates the input power 的能力。就比如把阅读器放中间，标签围一圈，360度去读取周围标签对能量消耗就大，可能因此传输距离也近；但是如果把标签集中放在一块区域，周围放置的 reader 利用定向天线 Directional antenna，固定读取某一个角度范围内的tags能量利用效率就高。</p>
<p>Polarization：事物在一定条件下发生极化 polarization，使得其表现的和原有状态不一样  its properties deviate from the  original state。</p>
<p>EIRP, Equivalent Isotropic Radiated Power: 天线在所指方向上获得最大增益效果 maximum gain effect 所需要的能量。</p>
<p>For example, FCC regulations in the United States, a non-irradiated  transmitter can transmit 1W of energy signals, and can use 6dBi antenna; antenna gain increased by 1dB, transmission energy needs to  be reduced by 1dB. In fact, FCC is not more than  36dBm(30dBm+6dBi).</p>
<h2 id="Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式"><a href="#Effects-of-antenna-gain，重点：分析-link-budget，几个计算公式" class="headerlink" title="Effects of antenna gain，重点：分析 link budget，几个计算公式"></a>Effects of antenna gain，重点：分析 link budget，几个计算公式</h2><p>directional gain: radiation density of one direction d &#x2F; average value in all direction</p>
<p>power gain: radiation efficiency of that direction G</p>
<p>平面角：单位rad，比如圆周180度单位角&#x3D;2pi rad</p>
<p>立体角：单位sr，比如球面立体角&#x3D;4pi sr</p>
<p>能量增益G的计算方法是4pi&#x2F;立体角大小。比如波束宽度72°也就是2pi&#x2F;5大概是1.25rad， $G&#x3D;\frac{4\pi}{1.25^2}$</p>
<p>dipole antenna: 垂直于轴沿各个方向发送信号，比全向天线 omnidirectional antenna 小2.2dB。</p>
<p>Effective aperture $A&#x3D;G\frac{\lambda ^2}{4\pi}$</p>
<p>$P_{RX}&#x3D;P_{TX}G_{RX}G_{TX}(\frac{\lambda}{4\pi r})^2$</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619104251622.png" alt="image-20230619104251622"></p>
<p>$R_{forward}&#x3D;\frac{\lambda}{4\pi}\sqrt{\frac{P_{TX,reader}T_bG_{reader}G_{tag}}{P_{min,tag}}}$</p>
<p>$R_{reverse}&#x3D;\frac{\lambda}{4\pi}\sqrt[4]{\frac{P_{TX,reader}T_bG_{reader}^2G_{tag}^2}{P_{min,reader}}}$</p>
<h1 id="4-Tag-Identification-Protocol"><a href="#4-Tag-Identification-Protocol" class="headerlink" title="4. Tag Identification Protocol"></a>4. <strong>Tag</strong> Identification Protocol</h1><h2 id="Checksum-procedure-parity-checks-LRC-CRC"><a href="#Checksum-procedure-parity-checks-LRC-CRC" class="headerlink" title="Checksum procedure: parity checks, LRC, CRC"></a>Checksum procedure: parity checks, LRC, CRC</h2><p>奇偶校验不多说，查1的个数，poor error recognition。电路通过所有位异或是偶校验，结果为1说明有错误；再取反是奇校验。</p>
<p>LRC longitudinal redundancy check (LRC) procedure 循环冗余检测，所有字节进行异或运算，得到的结果是LRC校验码。也就是说数据发送到终点后，所有字节（数据和LRC）进行字节异或运算结果应该为0. 也有一些错误无法纠正，主要用于小的数据块校验。</p>
<p>CRC (cyclic redundancy check) procedure</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142701838.png" alt="1687142701838"></p>
<p>接收方计算原数据+CRC数据拼接起来的CRC数据值，应该为0. 不能纠错，不过检错效率很高。</p>
<h2 id="ASK-FSK-PSK"><a href="#ASK-FSK-PSK" class="headerlink" title="ASK, FSK, PSK"></a>ASK, FSK, PSK</h2><p>amplitude Shift Keying: 幅度调制，y轴上的调制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687142836442.png" alt="1687142836442"></p>
<p>计算方法2：duty factor: $m&#x3D;1-\frac{u_1}{u_0}$</p>
<p>$U_{ASK}(t) &#x3D;(m·u_{code}(t)+1−m)·u_{HF}(t)$</p>
<p>Frequency shift keying: 频率上的改变。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143205258.png" alt="1687143205258"></p>
<p>Phase shift keying: 频率相位翻转180.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143252934.png" alt="1687143252934"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687143276722.png" alt="1687143276722"></p>
<h2 id="Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags"><a href="#Difficulty-of-traditional-anti-collision-algorithms-for-solving-collision-detection-between-RFID-tags" class="headerlink" title="Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags"></a>Difficulty of traditional anti-collision algorithms for solving collision detection between RFID tags</h2><p>Compared with the reader, limited by hardware resources, tags have very limited storage capacity and computing. </p>
<p>标签受制于硬件资源，存储容量和计算能力都不高。</p>
<h2 id="TDMA-FDMA-CSMA"><a href="#TDMA-FDMA-CSMA" class="headerlink" title="TDMA, FDMA, CSMA"></a>TDMA, FDMA, CSMA</h2><p>首先主要有两种方式，一个是reader broadcast 广播到诸多 tags，一个是多个 tags Multi-access 每个tags单独访问reader。</p>
<p>TDMA FDMA是multi-access, CSMA是broadcast</p>
<p>FDMA: 多个频率通道 several frequency channels 传输数据。</p>
<p>TDMA: </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619212501183.png" alt="image-20230619212501183"></p>
<h2 id="ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程"><a href="#ALOHA-based-protocols-pure-ALOHA-S-ALOHA-FSA-DFSA-Q-算法。重点：性能分析、执行过程" class="headerlink" title="ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程"></a>ALOHA based protocols: pure ALOHA, S-ALOHA, FSA, DFSA, Q 算法。重点：性能分析、执行过程</h2><p>Pure ALOHA algorithm：收到成功确认 ack 后就不再发送。否则一直随机等待后继续发送。简单但是通道利用率 channel utilization 低，poor performance.</p>
<p>offered load G：单位时间 tau 里同时发送的应答器数量</p>
<p>s-aloha: 规定时间片 slot，一个时间片只能发一次，冲突就下一次时间片去发。channel utilization 几乎是 pure 的两倍。</p>
<p>$S &#x3D; G × e^{-G}$ G&#x3D;1最大</p>
<p>frame S-ALOHA: 规定一个周期 frame，包含若干个 slots，会更加有组织有秩序。reader 广播一个 frame length，tags 自己选择组织时间片（0~f-1），每个时间片开始 reader 轮询一下tag里sn信号是不是0，是0就发送，不是0就-1.</p>
<p>conflict slot, single slot, idle slot（空）</p>
<p>逻辑，电路设计，内存都比较简单，但是 frame length 长度不固定。tags 远远多于 frame length 冲突时间片就太多，tags 太少空时间片太多太浪费。负载 G&#x3D;1 也就是 length&#x3D;tags 利用率最好。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620001137399.png" alt="image-20230620001137399"></p>
<p>DFSA：利用以前的 frame 冲突反馈结果，和一些机器学习算法推测合适的 frame length。</p>
<p>EPC Global（第五章介绍）规范里使用了一种Q算法。简单说就是如果冲突太多了，当前 frame 就别继续了，中断，新开一个大容量 frame. 同理 空闲太多了就新开一个小 frame。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620002424045.png" alt="image-20230620002424045"></p>
<p>Qfp是指定的初始值。每次先取整，然后发起 query。</p>
<p>没有回复：Qfp-C C是一个参数，比如0.1.</p>
<p>有冲突&gt;1：+C。注意有上下限。</p>
<p>ALOHA 算法公平。<strong>但是可能发生饥饿</strong> ，比如有一个 tag 每次都是有冲突的 slot，一直没有办法被处理。</p>
<h2 id="Binary-tree-based-protocols-BT-QT-重点：执行过程"><a href="#Binary-tree-based-protocols-BT-QT-重点：执行过程" class="headerlink" title="Binary tree based protocols: BT, QT, 重点：执行过程"></a>Binary tree based protocols: BT, QT, 重点：执行过程</h2><p>第二种算法，基于二进制数。就像二叉树不断拆分冲突的结点变为两个结点，直到节点里只有一个 tag。</p>
<p>random binary tree BT：随机。</p>
<p>binary query tree QT：排序，查询。</p>
<p>每一个 tag 需要有一个计数器来记录自己的状态。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620003431357.png" alt="image-20230620003431357"></p>
<p>每一个tag都会被识别，不会饥饿，但是需要存储每个tag的状态。</p>
<p>比如看下面的例子：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620004226401.png" alt="image-20230620004226401"></p>
<p>首先 tag1234 随机选一个数，比如选了0010，SN分别加自己选的数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010150624.png" alt="image-20230620010150624"></p>
<p>找SN&#x3D;0的，发现有是有，但是他们几个都冲突了。那么继续分，比如1011，SN&#x3D;1021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010254069.png" alt="image-20230620010254069"></p>
<p>2的SN&#x3D;0而且不冲突，把2读取了之后2不再继续参与。然后当有tag读取后，所有其他SN-&#x3D;1</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010408026.png" alt="image-20230620010408026"></p>
<p>&#x3D;0的是14，但是他俩冲突。然后再重新划分一下，比如011, SN&#x3D;0021</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010452073.png" alt="image-20230620010452073"></p>
<p>然后处理1，其他-&#x3D;1，处理4，其他-&#x3D;1，处理3.</p>
<p>QT 不需要存储状态，如何实现？读取tag的序列号比较。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620010802734.png" alt="image-20230620010802734"></p>
<p>不会饿死，也不需要一个可以读写的cnt，识别的时间和 tag id 有关。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011058481.png" alt="image-20230620011058481"></p>
<h2 id="Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程"><a href="#Binary-search-Manchester-code-instead-of-NRZ-code-重点：执行过程" class="headerlink" title="Binary search: Manchester code instead of NRZ code, 重点：执行过程"></a>Binary search: Manchester code instead of NRZ code, 重点：执行过程</h2><p>具体分辨哪一位有冲突。1代表冲突。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011804411.png" alt="image-20230620011804411"></p>
<p>NRZ混合没法检测错误。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011902936.png" alt="image-20230620011902936"></p>
<p>曼彻斯特可以，一个上升一个下降，合起来是0或者1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620011942870.png" alt="image-20230620011942870"></p>
<p>查询的流程：</p>
<ul>
<li>request：发送一个序列号给tags的transponder，如果tags的序列号小于给定序列号返回。</li>
<li>select：给定一个特定序列号，返回等序列号的tag。</li>
<li>read_data：返回所选tag的信息。</li>
<li>unselect：读取完data了，这个tag退出选择流程。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620012706251.png" alt="image-20230620012706251"></p>
<p>第一次迭代：返回uplink是所有transponder的id的共同信息（通过曼彻斯特编码找出没有冲突的位）。046位冲突了（从右往左），8个可能。</p>
<p>第二次迭代：限定 bit6 为0的request。发现有3个还是冲突04位（最高位冲突位&#x3D;0，其他冲突位&#x3D;1，如果range是大于等于，则正好相反）。</p>
<p>第三次迭代：限定bit4为0的request……</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230620013603192.png" alt="image-20230620013603192"></p>
<p>长度 L(N)&#x3D;log2(N)+1</p>
<h2 id="Dynamic-binary-search-重点：执行过程"><a href="#Dynamic-binary-search-重点：执行过程" class="headerlink" title="Dynamic binary search, 重点：执行过程"></a>Dynamic binary search, 重点：执行过程</h2><p>Binary Search 是每次都传输完整二进制字符串. 其实我们只需要动态改变的部分.</p>
<p>比如我们查询1010 1111 1111, 那返回值前面一定是1010呀, 就不用传输了. 前缀叫 NVB, Number of Valid Bits</p>
<p>每次请求发送的信息: Request+NVB&#x3D;4+1010</p>
<h2 id="Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-ALOHA-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of ALOHA based anti-collision algorithm"></a>Advantages and disadvantages of ALOHA based anti-collision algorithm</h2><p>simple</p>
<p>good identification performance</p>
<p>results can be statistically analyzed 结果可以被统计化分析</p>
<p>缺点就是可能 starvation 饥饿，delay trend to ∞</p>
<h2 id="Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm"><a href="#Advantages-and-disadvantages-of-binary-tree-based-anti-collision-algorithm" class="headerlink" title="Advantages and disadvantages of binary tree based anti-collision algorithm"></a>Advantages and disadvantages of binary tree based anti-collision algorithm</h2><p>simple</p>
<p>intermediate state variables 不需要存储中间状态变量（QT）</p>
<p>缺点：查询时间受到 tags id 和 长度限制，比如二叉树沿着一个方向一直偏。</p>
<h1 id="5-EPCglobal-Standard-protocol"><a href="#5-EPCglobal-Standard-protocol" class="headerlink" title="5. EPCglobal Standard &amp; protocol"></a>5. EPCglobal Standard &amp; protocol</h1><h2 id="Concept-of-EPC-global-network"><a href="#Concept-of-EPC-global-network" class="headerlink" title="Concept of EPC global network"></a>Concept of EPC global network</h2><p>EPCglobal Network: a technology that </p>
<ul>
<li>allows trading partners to document and determine the location of individual goods </li>
<li>if possible in real time</li>
<li>additional information: such as 生产使用日期，能否被贸易伙伴交换</li>
</ul>
<h2 id="Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network"><a href="#Five-basic-services-of-EPC-global-network-interaction-of-different-components-of-EPCglobal-network" class="headerlink" title="Five basic services of EPC global network, interaction of different components of EPCglobal network"></a>Five basic services of EPC global network, interaction of different components of EPCglobal network</h2><p>Electronic product code (EPC)</p>
<p>The identification system</p>
<p>EPCglobal Middleware</p>
<p>Discovery Service (DS)</p>
<p>EPC Information Services (EPCIS)</p>
<p>EPC码是唯一标识对象的代码。识别系统包括对象上的可被读取的包含EPC码的transponder和读取器reader可以识别EPC，然后通过EPCglobal Middleware传到网上，通过DS在 EPCglobal network 查找EPC码的相关信息（包括object naming service）。可以通过EPCIS和其他贸易伙伴交换EPC相关信息。</p>
<p>这其中的交互：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230619112053963.png" alt="image-20230619112053963"></p>
<p>transponder and reader : data acquisition</p>
<p>Middleware</p>
<p>Discovery services</p>
<p>EPC Information Services : access to EPC-related data</p>
<h2 id="EPC-code-组成"><a href="#EPC-code-组成" class="headerlink" title="EPC code 组成"></a>EPC code 组成</h2><p>Domain Manager Number + Object Class Number + Serial Number</p>
<h2 id="Basic-procedures-of-the-EPC-Network"><a href="#Basic-procedures-of-the-EPC-Network" class="headerlink" title="Basic procedures of the EPC Network"></a>Basic procedures of the EPC Network</h2><p>EPC码用于标识对应对象</p>
<p>all information about the object 在EPCGlobal Network里注册 administer</p>
<p>each company in the EPCglobal Network: 各个公司管理数据集和数据对象</p>
<p>access rights to object data: 包含在EPCIS里，指明了trading partners 之间访问权限</p>
<ol>
<li><p>the manufacturer：把transponder和product绑定</p>
</li>
<li><p>all data assigned to the product：在EPCIS里</p>
</li>
<li><p>EPCIS registers the entries with EPC Discovery Services：注册了DS之后方能找得到EPCIS</p>
</li>
<li><p>product：卖给零售商 retailer</p>
</li>
<li><p>At the retailer’s goods-in point 数据存储在零售商EPCIS中</p>
</li>
<li><p>registered by EPCIS with EPC Discovery Services </p>
</li>
<li><p>The company prefix send to root EPCIS</p>
</li>
<li><p>root -&gt; local -&gt; the EPCIS</p>
</li>
</ol>
<h2 id="Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0"><a href="#Binary-tree-based-variant-algorithm-for-EPCglobal-Class-0" class="headerlink" title="Binary tree based variant algorithm for EPCglobal Class 0"></a>Binary tree based variant algorithm for EPCglobal Class 0</h2><p>这种tag是只读的，制造商赋值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687148304873.png" alt="1687148304873"></p>
<h2 id="EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs"><a href="#EPCglobal-C1-G1-PingID-C1G2-four-commands-是什么，分别干什么用的-two-types-of-performance-trade-offs" class="headerlink" title="EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs"></a>EPCglobal C1 G1: PingID; C1G2: four commands (是什么，分别干什么用的), two types of performance  trade-offs</h2><p>EPC C1G1：查询tags EPC的一种标准。</p>
<p>被动标签，支持kill和lock两种操作。</p>
<p>pingID：掩码，用于查询tag EPC</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197150310.png" alt="1687197150310"></p>
<p>EPC C1G2 有 OSI 的七层模型，两条数据链路（R-T）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687197271532.png" alt="1687197271532"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687198440696.png" alt="1687198440696"></p>
<p>上电 ready</p>
<p>发 query 命令，aribtrate 仲裁。选择随机数生成时间片。</p>
<p>slot&#x3D;0 的开始 reply </p>
<p>tag 发 ack 给 reader，acknowledged 状态。</p>
<p>tag 收到 reader 的命令后进入 open，校验后进入 secured，完成 killed。</p>
<p>4个识别 tags 的命令：Select command, Query command, QueryRep command, QueryAdjust command</p>
<p>select 指明要查哪些 tags 的集合。</p>
<p>query 启动新的识别过程。</p>
<p>Rep 开启下一轮 slot 查询，标签 SN–，到0时读取。</p>
<p>Adjust 调整时隙数，选择新的时隙计数器等。</p>
<p>两大性能问题：</p>
<ul>
<li>Build a set of tags involved in the recognition process，如何建立正确的tags集合来查询（select 和 query 负责）</li>
<li>Select the way of data encoding, for the readerto-tag, the tag-to-reader, the reader itself and the  tag itself 根据环境调整编码方式</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RFID/" rel="tag">RFID</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-北邮国院笔记：Microprocessor 微处理器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/14/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMicroprocessor%20%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/"
    >北邮国院笔记：Microprocessor 微处理器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/14/%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E7%AC%94%E8%AE%B0%EF%BC%9AMicroprocessor%20%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="article-date">
  <time datetime="2023-07-13T23:00:00.000Z" itemprop="datePublished">2023-07-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/">邮途（北邮国院课内学习）</a> / <a class="article-category-link" href="/categories/%E9%82%AE%E9%80%94%EF%BC%88%E5%8C%97%E9%82%AE%E5%9B%BD%E9%99%A2%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>主要围绕提纲里的所有问题展开，没有拓展内容，Exam oriented Study。</p>
<p>关注微信公众号：灰海宽松，回复 “微处理器” 可获取本文pdf格式。</p>
<h1 id="Introduction-随便聊"><a href="#Introduction-随便聊" class="headerlink" title="Introduction-随便聊"></a>Introduction-随便聊</h1><p>嵌入式系统是什么？专用的计算机系统。为专门功能可能对计算机架构，外设等做出一些取舍。</p>
<p>通常的限制：Cost（比如大量部署传感器节点），Size and weight limits（特定应用场景，比如下水道流量检测系统，需要体积小的节点），Power and energy limits（比如部署在极端环境下，喜马拉雅山顶采集节点，不方便去充电），Environment（防水，防高温等）</p>
<p>MCU MPU两种嵌入式系统区别：focus on 控制 还是 处理。控制比如点灯，机械臂，电机这些都是。处理比如摄像头采集到的数据进行图像处理。</p>
<p>编程语言：靠近计算机底层，主要使用汇编和c。</p>
<p>OS：嵌入式系统里不一定有操作系统结构。操作系统这个东西说白了就是更好地帮助管理计算机资源调度用的。现在我们来分析一下我们lab2的代码主函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//background</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IRQ_Handler</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//interrupt handler function, frontground</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台部分：一个循环，重复去执行要做的任务。</p>
<p>这种方法乍一看也没啥问题。但是想想这样的计算机能做什么，只能按顺序执行一遍又一遍所有任务，甚至没法变顺序。</p>
<p>前台部分：中断处理，我们lab2里的uart_rx_isr函数，一般也用IRQ_Handler（实际上如果对lab2里的uart_rx_isr溯源一下，就会发现其实他也是被IRQ_Handler调用的，这个方法在启动对应中断时，触发中断就会自动调用）。</p>
<p>前后台合起来的系统还是一个裸机无os系统，只不过加了中断之后允许我们用中断的任务去打断后台轮询，改变一下执行顺序。比如串口中断发个数过来，CPU把手头后台的事情放下，去处理一下前台中断，处理完了再回来。</p>
<p>我们课程仅限于裸机开发的内容。</p>
<h1 id="计算机系统简要介绍"><a href="#计算机系统简要介绍" class="headerlink" title="计算机系统简要介绍"></a>计算机系统简要介绍</h1><h2 id="Von-Neumann-Architecture"><a href="#Von-Neumann-Architecture" class="headerlink" title="Von Neumann Architecture"></a>Von Neumann Architecture</h2><p>运算器控制器 (合在CPU中) 存储器 main memory 输入设备输出设备 IO，以及三条传输总线：数据，控制，地址 data bus &#x2F; control bus &#x2F; address bus.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686650488954.png" alt="1686650488954"></p>
<p>前面介绍过MPU重点在于数据计算处理，MCU则是控制，因此MPU不需要一些外设去控制外接的组件。</p>
<h2 id="Harvard-Architecture"><a href="#Harvard-Architecture" class="headerlink" title="Harvard Architecture"></a>Harvard Architecture</h2><p>和冯诺依曼区别就是在于指令和数据分开存储。这样寻指取指取数效率高。</p>
<h2 id="Stored-Program-Concept"><a href="#Stored-Program-Concept" class="headerlink" title="Stored Program Concept"></a>Stored Program Concept</h2><p>主要两个部分：RAM存储程序和数据，ROM存储不变只读的程序和数据。</p>
<p>cpu执行指令就是三个步骤的重复执行：fetch decode execute 取指解码执行</p>
<h2 id="assembly"><a href="#assembly" class="headerlink" title="assembly"></a>assembly</h2><p>如果高级语言相当于人话翻译给计算机，汇编语言相当于计算机语言翻译给我们。更贴近底层，因此运行效率也更高，而且可以直接操作硬件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD r3, r1, r2 	;r3 = r1 + r2</span><br><span class="line">SUB r3, r0, r3 </span><br><span class="line">MOV r2, r1 		;r2 = r1</span><br></pre></td></tr></table></figure>

<p>; 是注释。变量r123是寄存器register，是可以操纵硬件的部分，我们可以通过对其赋值来操作硬件。</p>
<p>高级语言通过 compiler 翻译为汇编语言，汇编语言通过 assembler翻译为二进制机器语言。</p>
<h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h1><p>ARM是一个指令集，前面讲的几个汇编指令这些都算做指令。</p>
<p>ARM公司有意思的地方是，他们不做ARM设备，他们只设计指令集架构，然后授权（知识产权核，IP核）给其他半导体厂商做。</p>
<p>A：application，主打高性能，手机电脑有许多就是ARM架构的。</p>
<p>R：realtime，主打实时，比如车联网对实时性要求很高。</p>
<p>M：microcontroller，应用于小型嵌入式系统，我们使用的板子。</p>
<p>m系列有m0到m7（简单说就是性能逐渐增加？），而且向下兼容即m7兼容m0~m6.</p>
<h2 id="SoC"><a href="#SoC" class="headerlink" title="SoC"></a>SoC</h2><p>我们的板子上有一个黑色的小芯片，上面写着stm32blabla一串字符。这个就是整个板子的核心，相当于囊括了上文提到的计算机架构的芯片结构，system on chips。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686658267695.png" alt="1686658267695"></p>
<p>设计soc规则：首先选用IP核，设计ARM处理器，外加一系列存储、IO外设结构，全部集成在黑芯片上。</p>
<p>ARM处理器 processor 是 architecture 的具体涵盖，多了很多新内容比如定时器。</p>
<p>我们主要学习m4架构。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686658682835.png" alt="1686658682835"></p>
<p>只看非optional大概了解即可，处理器核访问代码，数据接口。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>前面我们已经简单介绍了register。事实上如果想对内存中数据做处理，也要先拿到处理器核中的寄存器里做运算，然后返回回去。</p>
<p>arm register 如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686659016141.png" alt="1686659016141"></p>
<p>通用寄存器：临时变量，可以存储计算数据之类的。</p>
<p>SP：栈顶指针寄存器，指向栈顶。</p>
<p>LR：函数返回用，保存返回地址。比如要调用函数了，把PC的值存入LR，然后PC跳转到函数起始位置；函数返回的时候LR的值还给PC。</p>
<p>PC：指向程序当前执行到的位置（下一个要执行的指令的地址）程序计数器。每条指令取了之后PC自动加一条指令，比如32位指令集PC+&#x3D;4B。</p>
<p>PSR系列是状态寄存器，指明当前程序状态。比如当前是用户模式还是内核模式？IPSR指明当前是否允许中断？等。</p>
<p>xPSR包括：</p>
<ul>
<li>APSR：计算用，如标志是否进位，结果是否为0，是否为负，是否溢出等。</li>
<li>IPSR：中断处理相关。</li>
<li>EPSR：执行相关，指明指令集，中断是否继续等信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686659814546.png" alt="1686659814546"></p>
<h2 id="Memory-Map"><a href="#Memory-Map" class="headerlink" title="Memory Map"></a>Memory Map</h2><p>m4有4g的内存空间默认映射到一片空间中，用户也可以根据自己喜好修改。有存储代码的code region，存储数据的sram region，存储外设的peripheral region，external ram region，external device region，Internal Private Peripheral Bus (PPB)。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686669411390.png" alt="1686669411390"></p>
<h2 id="Bit-band-Operations"><a href="#Bit-band-Operations" class="headerlink" title="Bit-band Operations"></a>Bit-band Operations</h2><p>位带操作。</p>
<p>如果我们要读写32位数据中的某一位，比如第三位（从左往右是31:0，第三位是右边第4个），有的寄存器允许我们直接获取r[3]，但是大多数是不允许直接获取的。</p>
<p>如何处理？如果写入1，那么r|0000 0000 0000 0000 0000 0000 0000 1000.</p>
<p>如果写入0，那么 r &amp; 1111 1111 1111 1111 1111 1111 1111 0111.</p>
<p>读取：看 r &amp; 0000 0000 0000 0000 0000 0000 0000 1000 结果是否为0.</p>
<p>这样很麻烦，比如我们要给0x2000 0000处的数据第3位写1，详细汇编代码：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232342659.png" alt="image-20230613232342659"></p>
<p>LDR是把后面的数据加载到前面的寄存器中，[R1]是把R1的值当做一个地址，取得其中存储的数据。</p>
<p>这样挺麻烦的，但是因为有内存映射我们可以直接写入和获取“位带别名地址”中的数据。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232721037.png" alt="image-20230613232721037"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230613232713587.png" alt="image-20230613232713587"></p>
<p>0x2000 0000处的第0位到第31位分别是：</p>
<p>0x2200 0000</p>
<p>0x2200 0004</p>
<p>0x2200 0008</p>
<p>0x2200 000c……</p>
<p>0x2200 007c</p>
<p>所以直接获取，修改0x2200 000c的数据即可。</p>
<p>0x2000 0000映射到0x2200 0000是 sram 区域映射，0x4000 0000映射到0x4200 0000是外设 peripheral 区域映射。</p>
<p>操作更快，指令更少，而且只访问一位更安全，比如刚取出0x2000 0000的32位数据，这时候中断修改了0x2000 0000的数据，这时我们取得的数据就是旧的错误数据了，修改完第3位再写回去，相当于中断白改了。</p>
<h2 id="Program-Image"><a href="#Program-Image" class="headerlink" title="Program Image"></a>Program Image</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686670722574.png" alt="1686670722574"></p>
<p>vector：向量表，存储比如main堆栈的地址（MSP），异常的地址等信息。</p>
<p>start-up：板子上电或rst时的启动代码。</p>
<p>program code：我们烧进去的程序代码。</p>
<p>c lib code：库函数代码。</p>
<p>复位时，先读取 msp 地址找到 main 在哪。然后读取 reset vector 执行 BIOS 初始化代码，再开始读取第一条，第二条指令……</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686670972039.png" alt="1686670972039"></p>
<h2 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h2><p>两种存储规范。</p>
<p>比如十进制数字，1234，一千二百三十四。然后我们记录到数据库中，地址从低到高存储为4321，权值大的位1存在地址最高处，这就是大端存储 Big endian。否则，权值大的位存在地址低处，1234地址从低到高，就是小端存储 Little endian。m4两种方法都支持。</p>
<blockquote>
<p>术语“little endian(小端)”和“big endian(大端)”出自Jonathan Swift的《格列佛游记》（Gulliver’s Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。</p>
<p>一下是Jonathan Swift在1726年关于大小端之争历史的描述：</p>
<p><em>“……下面要告诉你的是，Lilliput和Blefuscu这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由Blefuscu的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”（此段译文摘自网上蒋剑锋译的 《格列佛游记》第一卷第4章。）</em></p>
<p>在他那个时代，Swift是在讽刺英国（Lilliput）和法国（Blefuscu）之间的持续的冲突。Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了.</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/316347205">大端、小端基础知识 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="Instruction-Set"><a href="#Instruction-Set" class="headerlink" title="Instruction Set"></a>Instruction Set</h2><p>指令集。早期arm指令集32位，性能好能实现的功能强大。但是太长了处理效率低。</p>
<p>thumb-1 指令集16位，处理效率高了，性能也降了。早期arm架构如果是支持两种指令集的，就要频繁切换模式，效率低。</p>
<p>后来thumb-2指令集包含早期16位和新的32位，和arm指令集的混合指令集性能没减太多，代码量和处理效率还高了。</p>
<h1 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h1><p>汇编语法。</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">label							; 可省略，用于跳转到此位置</span><br><span class="line">	助记符 operand1, operand2, … ; Comments</span><br><span class="line">	</span><br><span class="line">MOV r1, #0x01					; 数据0x01放入r1</span><br><span class="line">MOV r1, #&#x27;A&#x27;					; 数据A的ascii码放入r1</span><br><span class="line">MOV R0, R1 						; move R1 into R0</span><br><span class="line">MOVS R0, R1 					; move R1 into R0, 并且更新APSR的状态</span><br><span class="line"></span><br><span class="line">LDR R1, [R0]					; R0存的是一个地址值如0x2000 0000, 这个指令是取出R0代表的地址中的数据存入R1</span><br><span class="line">STR R1, [R0]					; 写回去</span><br><span class="line">LDR R0, =0x12345678 			; Set R0 to 0x12345678</span><br><span class="line">; 等效于：</span><br><span class="line">; LDR R0, [PC, #offset] </span><br><span class="line">; ...</span><br><span class="line">; DCD 0x12345678</span><br><span class="line">; 也就是先在文档末尾的一条指令里写入数据0x12345678，然后编译器自动计算PC+多少offset到达DCD的位置，把其值返给R0</span><br><span class="line">; DCD是声明一个字 32bit，DCB是声明一个Byte</span><br><span class="line">; 如果多个数值的声明可以用标签声明</span><br><span class="line">LDR R3, =MY_NUMBER</span><br><span class="line"></span><br><span class="line">ALIGN 4 ; 字要先用这个声明，代表停止长度</span><br><span class="line">MY_NUMBER DCD 0x2000ABCC</span><br><span class="line">HELLO_TEXT DCB “Hello\n”, 0 ; Null terminated string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDRB R1, [R0]					; B: 只写8位，就是说R0地址处的数据写入R1后，R1高24位清零</span><br><span class="line">SDRH R1, [R0]					; H: 只写16位</span><br><span class="line"></span><br><span class="line">LDRSH R1, [R0]					; 视作signed有符号数，写16位</span><br><span class="line"></span><br><span class="line">LDRB R0, [R1, #0x3]				; 从R1+3读取一个字节给R0</span><br><span class="line">LDR R3, [R0, R2, LSL #2]		; 从R0+（R2&lt;&lt;2)读取一个字节给R3</span><br><span class="line">LDR R0, [R1], #4				; 赋完值后，令R1=R1+4</span><br><span class="line"></span><br><span class="line">ADD R0, R0, R1</span><br><span class="line">ADDS R0, R0, R1					; 加完更新APSR状态，比如有溢出或者进位则更新</span><br><span class="line">ADC R0, R1, R2					; R1+R2还要+APSR的carry位</span><br><span class="line"></span><br><span class="line">; SUB SBC类似</span><br><span class="line"></span><br><span class="line">MUL R0, R1, R2</span><br><span class="line">UDIV R0, R1, R2</span><br><span class="line">SDIV R0, R1, R2					; signed</span><br></pre></td></tr></table></figure>

<p>例题：应该是因为有可能减成负的所以signed</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686672985123.png" alt="1686672985123" style="zoom:50%;" />

<p>指令有1字长，半字长的。hw1是指明功能用的，hw2是一些拓展比如立即数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686713591015.png" alt="1686713591015"></p>
<p>地址从低到高分别是：4F F0 0A 00 0A 68 10 44……</p>
<p>PC每次取到半个字 hw，就+2B跳转到下一个hw。</p>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	CMP R0, R1						; 相当于if，比较后更新APSR。EQ= LT&lt; GT&gt; LE&lt;= GE &gt;=</span><br><span class="line">	BEQ BRANCH_1					; B是跳转，BL是跳转到函数执行完后返回，BX是根据地址最低位判断目标地址是arm还是thumb在决定跳转到整字还是半字。bx操作数不能是立即数，必须是寄存器</span><br><span class="line">	B BRANCH_2</span><br><span class="line">	</span><br><span class="line">BRANCH_1</span><br><span class="line">	...</span><br><span class="line">	B IFEND							; 不写这个就继续执行BRANCH_2了，像switch的break</span><br><span class="line">BRANCH_2</span><br><span class="line">	...</span><br><span class="line">B IFEND</span><br></pre></td></tr></table></figure>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WHILE_BEGIN </span><br><span class="line">	UDIV R2, R0, R1 ; R2 = n / x</span><br><span class="line">	MUL R3, R2, R1 ; R3 = R2 * x</span><br><span class="line">	CMP R0, R3 ; n == (n / x) * x</span><br><span class="line">	BEQ WHILE_END</span><br><span class="line">	SUBS R1, R1, #1 ; x--</span><br><span class="line">	B WHILE_BEGIN ; loop back</span><br><span class="line">WHILE_END</span><br></pre></td></tr></table></figure>

<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>内存中有一片内存空间类似栈的数据结构。SP指针指向栈顶。</p>
<p>这个栈地址是从高到低的，也就是存入数据 SP–，取出数据 SP++，类似一个翻转过来的，倒着的书堆。</p>
<p>满堆栈：sp指针指向最后一个栈顶数据。</p>
<p>空堆栈：指向最后一个数据的下一个要放入数据的空位置。</p>
<p>我们的课程中使用空堆栈，指向下一个空位置，存数据就先存入再SP-4，取数据就先SP+4再出栈。不过这两条指令都不需要我们手动执行，有专门的指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0, R4-R7&#125; 	; Push r0, r4, r5, r6, r7</span><br><span class="line">POP &#123;R2-R3, R5&#125; 	; Pop to r2, r3, r5。入栈出栈顺序不是按照书写顺序而是自动根据寄存器地址，高地址值给高地址寄存器</span><br></pre></td></tr></table></figure>

<p>存入5个数据和取出3个数据。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>BL先保存当前PC值到LR，然后PC跳转到函数地址，</p>
<p>BX LR跳转到LR中的地址用于函数返回。</p>
<p>Architecture Procedure Call Standard (AAPCS) ：规范定义哪些寄存器主函数和函数通用，哪些是独有的。</p>
<p>arm AAPCS规定：r0-r3是通用寄存器（类似全局变量），但main和函数的R4 – R8, R10-R11不通用（类似临时变量，到了函数里这些值就变了，不是原函数的），要压入栈保存。函数调用和返回的时候要保存和恢复通用寄存器值。这些由调用原函数的子函数 callee-procedure 执行。</p>
<p>简单的参数的函数调用：传参给R0-R3作为函数参数，R4-R11压入栈，然后跳转到函数处。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686733381292.png" alt="1686733381292"></p>
<h2 id="Program-Memory-Use"><a href="#Program-Memory-Use" class="headerlink" title="Program Memory Use"></a>Program Memory Use</h2><p>ROM里都是只读数据，比如常量常数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686733480351.png" alt="1686733480351"></p>
<h2 id="const-static-volatile"><a href="#const-static-volatile" class="headerlink" title="const, static, volatile"></a>const, static, volatile</h2><p>貌似是不会过多涉及具体代码实现的部分，就先简单介绍一下了。</p>
<p>const 就是定义常量变量，定义后无法再次修改。</p>
<p>static 通常定义静态函数，静态函数里的值是通用的，也就是每次调用该函数其值都是接着上次调用该函数的值继续。</p>
<p>volatile：一个在嵌入式里挺重要的东西，软考题里出现过几次。大概就是禁止编译器优化该变量来防止不必要的错误。</p>
<p>比如编译器优化num变量，这样每次修改num变量的值的时候都不会立刻写入内存中，可能会先把修改时的值写入寄存器，函数返回时写回内存。</p>
<p>现在比如我们在main中num+&#x3D;5, 修改值后的num暂时存在寄存器里。然后我们调用中断，从内存中读取当前num的值并+1.但是内存中值还没改，还是原值。返回后，main再把自己手中的num值写回内存，最后内存中num值只+5，而不是我们期望的+6.</p>
<p>volatile 声明后的变量不会做这样的优化，值改变了就立刻写回内存，虽然可能效率低但是安全。</p>
<h1 id="Interrupts"><a href="#Interrupts" class="headerlink" title="Interrupts"></a>Interrupts</h1><p>比如我们程序的逻辑是按键按下的时候点亮小灯。第一种做法是 Polling 轮询，一直看：按键按下了吗？没有。按下了吗？没。按下了吗？……</p>
<p>这样主要是效率低浪费CPU资源，如果为了节约资源轮询间隔大了，又不能及时响应。</p>
<p>中断允许CPU专心处理background的事情，触发中断的时候先放下后台处理前台。对于无os的裸机也能实现简单的多线程切换。</p>
<h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><ol>
<li><p>结束当前正在执行的指令。</p>
</li>
<li><p>当前模式寄存器值压栈保存。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230614171134845.png" alt="image-20230614171134845"></p>
</li>
<li><p>切换模式。</p>
</li>
<li><p>PC LR更新（根据异常处理器提供的值）。PC去查中断向量表，看要跳到哪里，EXC_RETURN Code赋值给LR。</p>
</li>
<li><p>更新IPSR状态。</p>
</li>
<li><p>开始执行异常代码。</p>
</li>
<li><p>退出，BX LR把 EXC_RETURN Code 值返回给PC。</p>
</li>
<li><p>出栈。</p>
</li>
</ol>
<h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h2><p>中断执行也是耗时的，需要一定的时间保存源程序状态，执行中断，恢复。</p>
<p>FMax_Int：最大中断执行频率，即：单位时间内最多执行几次中断。</p>
<p>F_CPU：CPU频率，即：单位时间内CPU有多少次指令周期。</p>
<p>C_ISR：执行中断内容需要多少周期。</p>
<p>C_Overhd：中断保存、恢复数据等准备工作用多少周期。</p>
<p>中断一次执行所需周期：C_Overhd+C_ISR</p>
<p>因此， $F_{Max_Int&#x3D;}F_{CPU}&#x2F;(C_{ISR}+C_{Overhd})$</p>
<p>U_int：中断处理实际消耗的利用率，上面那个毕竟是最大值。</p>
<p>$U_{int}&#x3D;F_{Int}&#x2F;F_{Max_Int}$</p>
<p>中断执行速度（和频率一样）：F_Int</p>
<p>非中断执行速度：(1-U_Int)*F_Int</p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><p>General Purpose Input Output, </p>
<h2 id="Memory-Mapped-IO"><a href="#Memory-Mapped-IO" class="headerlink" title="Memory-Mapped IO"></a>Memory-Mapped IO</h2><p>把设备，控制等寄存器映射到内存里。好处就是访问设备方式和内存一样，也不用设计复杂的IO电路，便捷；缺点在于占用了内存空间。</p>
<h2 id="Peripheral-Mapped-IO"><a href="#Peripheral-Mapped-IO" class="headerlink" title="Peripheral-Mapped IO"></a>Peripheral-Mapped IO</h2><p>IO有一块专门的存储区域，和内存不一样，也有专门的不同的电路指令去访问IO。好处就是节省内存空间，也能清晰的知道什么时候发生IO了；缺点在于开发、设计上的造价增加。</p>
<h2 id="GPIO-1"><a href="#GPIO-1" class="headerlink" title="GPIO"></a>GPIO</h2><p>通用IO可以判断引脚高低电平，可以给引脚赋值高低电平进行控制。</p>
<p>stm32有几组GPIO，每个有16个Pin，可以配置为input output pullin pullup等模式，以及定时器、串口、中断等功能。</p>
<p>什么是上下拉模式？如果不设置为上下拉，引脚浮空的时候（没有设置输入为高或低电平的时候）浮空引脚可能收到电磁波干扰等等问题导致输入状态不确定，有0有1的，容易造成错误。</p>
<p>下拉：三极管控制默认接地，无输入的时候默认低电平。</p>
<p>上拉：三极管控制默认接Vdd 芯片工作电压。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686742220470.png" alt="1686742220470"></p>
<p>大多数引脚是这两个功能都有的，我们初始化GPIO的时候选用一个，寄存器根据值控制接通相应电路。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230614193552367.png" alt="image-20230614193552367"></p>
<p>输入输出信号真的可以被称为“信号”。输入规定为0-0.5视作低电平，0.5-Vdd视作高电平，范围以外的值无效。输出电流也只有5mA左右是没有能力直接驱动一些设备的，我们可以通过一些电路比如三极管，放大器等，电路接收到信号得知”需要输出驱动电流了“然后输出大电流。</p>
<h2 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h2><p>每个GPIO口有：</p>
<p>4 * 32bit configuration registers: 配置相关信息，比如in&#x2F;out，上啦下拉，开漏输出或推挽输出，输出频率等。</p>
<ul>
<li>推挽输出 push-pull：能输出高低电平。</li>
<li>开漏输出 open-drain：没有能力输出高电平，想输出高电平需要设置上拉电路来输出。</li>
</ul>
<p>2 * 32bit data registers: 输入输出数据寄存器。</p>
<p>1 * 32bit set&#x2F;reset registers: 设置或复位寄存器。</p>
<p>1 * 32bit locking registers: 锁定寄存器。</p>
<p>2 * 32bit alternate function selection register.</p>
<h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>如图，32个Pin，每个两位来设置4种模式（in out 可选 模拟）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743308300.png" alt="1686743308300"></p>
<h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>只有3种模式（无pull，上拉，下拉）。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743360055.png" alt="1686743360055"></p>
<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>输入输出数据寄存器分开的。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686743538223.png" alt="1686743538223"></p>
<h2 id="CMSIS"><a href="#CMSIS" class="headerlink" title="CMSIS"></a>CMSIS</h2><p>先说一下考试定义：</p>
<p>CMSIS transforms memory mapped registers  into C structs </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT0 ((struct PORT*)0x2000030)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686747214412.png" alt="1686747214412"></p>
<p>再说一下和一些嵌入式前辈讨论的理解，以下内容不许考试写：</p>
<blockquote>
<p>李肯老师：arm-M推出的一系列API和软件组件，包括核心功能、DSP库、RTOS支持和调试接口等。</p>
<p>李肯老师：如果芯片厂不想再多一层，CMSIS就够用；但有的厂商会再在上面封一层，可能叫driver层。</p>
<p>李肯老师：另外CMSIS有个限定，就是ARM的ARM Cortex-M处理器；虽然它很常见，但并不是所有的处理器都是这个内核；这个需要注意。</p>
<p>榊：这种与内核相关的文件，比如启动文件，内核文件是CMSIS规定。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/a6953d9ebb72f2ecd6cc4dbf569d406.png" alt="a6953d9ebb72f2ecd6cc4dbf569d406"></p>
<p>榊：对比STM32F103和GD32E23的启动文件，我们会发现是一样的：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/711dd8daa73cb3dd198e50f32f6f86a.png" alt="711dd8daa73cb3dd198e50f32f6f86a"></p>
<p>榊：而芯片厂商要做的是根据这个arm规定的接口二次开发库函数。</p>
</blockquote>
<p>李肯老师c站账号：<a target="_blank" rel="noopener" href="https://blog.csdn.net/szullc">架构师李肯的博客_CSDN博客-程序人生,粉丝福利领域博主</a></p>
<p>榊老师c站账号：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63922192">风正豪的博客_CSDN博客-C语言,MSP430F5529,Linux领域博主</a></p>
<p>平时李肯老师的交流群会讨论很多嵌入式相关问题，欢迎有兴趣的同学来学习[Doge]</p>
<p>以上内容感兴趣的看个乐呵。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">Reset, <span class="comment">//!&lt; Resets the pin-mode to the default value.</span></span><br><span class="line">Input, <span class="comment">//!&lt; Sets the pin as an input with no pull-up or pull-down.</span></span><br><span class="line">Output, <span class="comment">//!&lt; Sets the pin as a low impedance output.</span></span><br><span class="line">PullUp, <span class="comment">//!&lt; Enables the internal pull-up resistor and sets as input.</span></span><br><span class="line">PullDown <span class="comment">//!&lt; Enables the internal pull-down resistor and sets as input.</span></span><br><span class="line">&#125; PinMode;</span><br><span class="line"></span><br><span class="line">gpio_set_mode(P1_10, Input);</span><br><span class="line">gpio_set_mode(P2_8, Output);</span><br><span class="line"><span class="type">int</span> PBstatus=gpio_get(P1_10); </span><br><span class="line">gpio_set(P2_8, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码是老师提供的driver，大意就是选定pin，传入特定参数，即可设置模式，设置输出。</p>
<p>感兴趣可以看看我的这篇文章，如果使用arm定义的cmsis直接去开发也是可以的：</p>
<p><a target="_blank" rel="noopener" href="https://jingqing3948.blog.csdn.net/article/details/130299783">STM32 学习笔记_4 GPIO：LED，蜂鸣器，按键，传感器的使用_灰海宽松的博客-CSDN博客</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 控制gpio需要三个步骤：开启rcc时钟，初始化，输入输出函数控制 */</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">    </span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_0);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>drivers二次开发，可以帮助简化。</p>
<p>当然这一段都是题外话了。考试就理解为“cmsis是变量宏定义直接映射到寄存器上；drivers是对其添加进一步行为”即可。</p>
<h1 id="Serial-Communication"><a href="#Serial-Communication" class="headerlink" title="Serial Communication"></a>Serial Communication</h1><p>串口通信，一种发送消息的通信方式。</p>
<p>串，指的是发数据的方式：一位一位串行发，并行是可能有多路通道，每路同时发一个数据，多路同时到达。</p>
<p>串口通信有单工 Simplex，半双工 Half Duplex，全双工 Full Duplex。</p>
<p>两种传输方式：同步 Synchronous，共用一个时钟；异步 Asynchronous，有各自的时钟。</p>
<p>同步很简单，发送方接收方比如都规定时钟信号下降沿收发。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686749582568.png" alt="1686749582568"></p>
<p>异步：需要通过异步通讯协议 Asynchronous Comm. Protocol 来协调。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686749956698.png" alt="1686749956698"></p>
<p>1位起始位标志开始传输，7&#x2F;8&#x2F;9位数据位，1位可选奇偶校验位，1位停止位。</p>
<p>RT两方需要有相同的波特率。</p>
<p>当然这只是最简单的串口通信因为只有双方。如果更多方通信我们需要校验地址来判断是哪个发给哪个；数据需要更复杂的校验方式。</p>
<p>异步通信不需要同步时钟之类电路，开销小，但是开发起来难度大一些因为需要起始结束位啥的。</p>
<h2 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h2><p>异步通信，Reversed Polarity 标准电压（-3<del>-15是1,3</del>15是0.还有一些其他标准比如TTL是+5为1，-5为0.）</p>
<p>发送数据有两种类型，ascii码和二进制，都得转化为二进制传输。</p>
<h2 id="uart"><a href="#uart" class="headerlink" title="uart"></a>uart</h2><p>针对stm32f401.</p>
<p>全双工异步串口。</p>
<p>为了处理RT缓冲数据（因为发收数据需要时间）我们可以通过缓冲区数组，头指针表示已经发到的位置，尾指针表示要发的数据的结尾。增加新数据，尾指针++；发一个数据，头指针++直到碰到尾。</p>
<p>原来发送方一直是发高电平，start frame 起始帧是1帧低电平来表示开始发数据了。</p>
<p>如何判断是1帧低电平？通过在这一帧里多次采样判断是不是真的是一帧低电平。</p>
<p>为什么多次采样？因为异步两个信号有一定的偏移，多次采样准，能确定是不是真的一整帧都低电平。</p>
<p>采样是有一定采样率的，不是说真的能像模拟信号一样一直采。</p>
<p>采样率 oversampling&#x3D;16: 这个是最大可以达到的采样频率而不是真的一帧采了16次。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686756691253.png" alt="1686756691253"></p>
<p>接收方首先第一次检测到0位，开始怀疑：有可能是串口有消息。这是start frame的第一次采样。</p>
<p>然后每隔一帧检测一次，3 5 7检测3次，如果2个都是0，说明确实有可能。</p>
<p>然后连着检测8910，如果还是2个0，说明确实是start frame。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686756881390.png" alt="1686756881390"></p>
<p>8采样率因为采样间隔长了，更容易碰到左右边界的高电平，所以容错率低。但是速度更快。</p>
<h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>波特率计算：</p>
<p>$T_x&#x2F;R_x(baud)&#x3D;\frac{f_{PCLK}}{8*(2-OVER8)*USARTDIV}$</p>
<p>OVER8是过采样率，fPCLK是时钟频率。</p>
<p>USARTDIV是一个浮点数</p>
<p>USARTDIV浮点数怎么存储？通过算法转化为十六进制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686759124660.png" alt="1686759124660"></p>
<p>小数部分用一个16进制位表示，比如例1是C也就是12，转换后即为12&#x2F;16也就是0.75.</p>
<p>例2转换为一位16进制，就是0.62*16约等于10也就是A。</p>
<p>整数部分直接转换十六进制即可，例2的25转为19，例1的27转为1B。</p>
<p>然后整数小数部分拼接起来（最多3个整数位，1个小数位，32位寄存器）。</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>想让程序定时运行，比如led 1s闪烁一次。如何做到？</p>
<p>第一种方法是愚蠢的delay延时，我自己估算一下：嗯，delay(2000)差不多1s。然后在程序中delay，点亮，delay，熄灭……</p>
<p>太浪费资源了。</p>
<p>第二种方法，32是有定时器中断的。</p>
<p>定时器中断大概原理是，32上有时钟晶振按固定频率周期输出0101010……定时器里有一个cnt，收到一个时钟晶振就++。</p>
<p>我们可以设置定时器溢出值，比如溢出值是1000，cnt加到1000会自动触发定时器中断。然后归0，继续++。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230615014136641.png" alt="image-20230615014136641"></p>
<p>执行周期数量：1+1+1+1+(0xFFFFFFFF一直-1-1-1直到变为0x00FFFFFF的循环次数)+(r0+1的执行次数，1次)</p>
<p>定时器也有一些扩展方法，比如我们可以设定++还是–；可以设定信号源是时钟或者外部输入的方波信号；可以读取计数值……</p>
<p><strong>我们课件常用方法好像是–到0触发中断，然后恢复初值。</strong></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686764952191.png" alt="1686764952191"></p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>PWM这个东西是什么？</p>
<p>PWM（Pulse Width Modulation）脉冲宽度调制，在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域。</p>
<p>就好比说，你骑自行车速度只能是100和0，模拟电信号只能输出高低。</p>
<p>但是呢，你骑自行车是有惯性的，以100速度蹬一脚，以0速度蹬1脚，100速度蹬一脚……</p>
<p>整体来看你的自行车平均速度是50（我们假设加速度不需要时间哈）</p>
<p>这个应用场景有很多，比如设定led闪烁频率：高低高低高低……，因为频率极高，我们肉眼看不出来在闪，给我们呈现的视觉效果就是以一半的亮度在亮。高低低高低低就是1&#x2F;3亮度。</p>
<p>比如电机通过这个方式调速度。</p>
<p>那么他有什么应用场景。第一，输入捕获 Input capture。</p>
<p>对于一个这种有惯性的系统，我们也可以反过来读取其波形来判断其速度。比如电机放一个转速检测传感器，把输入波形作为定时器的时钟源信号，定时器一直++：检测上升下降沿时记录cnt值，通过差值比较计算时间间隔。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230615020829378.png" alt="image-20230615020829378"></p>
<p>第二，输出比较 output compare。</p>
<p>定时器一直++，与预先设定好的阈值比较，如果相等触发中断输出。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1686767856060.png" alt="1686767856060"></p>
<p>这就是PWM。占空比相当好算。</p>
<h2 id="Low-Power-Timer"><a href="#Low-Power-Timer" class="headerlink" title="Low Power Timer"></a>Low Power Timer</h2><p>我们目前假设的是CPU一直运作的，只是在后台和前台之间切换。有一种低功耗定时器使得没有发生定时器中断的时候CPU被置为低功耗状态，只有发生定时器中断的时候才启动。（使用 __WFI() wait for instruction 指令）</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235021294.png" alt="image-20230621235021294"></p>
<h2 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h2><p>M系列自带的一个系统时钟，使用处理器时钟或者参考时钟作为时钟源。</p>
<p>有四位寄存器：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235527699.png" alt="image-20230621235527699"></p>
<p>每次赋值是load，一直–到0时重新load赋值。ctrl是控制启用系统时钟。这个是CMSIS有提供的数据结构和相关操作函数的时钟处理部分。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230621235805628.png" alt="image-20230621235805628"></p>
<p>init 参数是中断间隔的毫秒数。timer_set_callback() 里跟一个可以是自己定义的函数，使得触发定时器中断时该函数被执行。以上代码意思是每隔100ms LED灯翻转一次，且 CPU 常态下处于低功耗状态。</p>
<h1 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h1><p>连接多个模块的传输方案：I2C，使用两根总线。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622000302459.png" alt="image-20230622000302459"></p>
<p>两根总线分别是时钟总线 SCL 和数据总线 SDA。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>现在我们串一遍I2C上一个模块（master）要给另一个模块（slave）发消息的过程。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1687363434463.png" alt="1687363434463"></p>
<ol>
<li>MCU 使用一定的方法标识自己开始传输了。</li>
<li>MCU 发送 LCD slave 的地址+一位读写位，其他模块接收到发现地址不是自己的，就不做处理。</li>
<li>LCD 接收到后知道目标是自己，于是返回 ack。</li>
<li>MCU 收到 ACK 后发送一帧数据。</li>
<li>发送完 MCU 等着 ACK，收到 ACK 后继续发送下一帧数据。</li>
<li>一直发送到发送停止位 stop 结束。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622000920336.png" alt="image-20230622000920336"></p>
<p>数据长度可以设置，比如789.</p>
<p>总线上的器件是开漏输出的半双工通信。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713135505107.png" alt="image-20230713135505107"></p>
<p>默认总线是上拉电阻拉成高电平。</p>
<p>当器件输出 out 为低电平时，总线导通到接地，总线被拉低（整条总线都被拉低）。江协科技老师举的例子很好，就像公交车上的一根横杆，有人拉住横杆拽下来，整条横杆都被拉低了，其他人都知道“横杆被一个人拉低了，说明有人正在使用总线”。</p>
<p>然后是总线传输数据的方式，SCL SDA 两根总线在何种情况下表示 start stop 0 1 bit? </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713140225426.png" alt="image-20230713140225426"></p>
<p>首先都是 SCL 为高电平时 SDA 的数值才有意义。</p>
<p>SDA 从高到低，表示 start 位。从低到高，表示 stop 位。</p>
<p>start 位后，SDA 高电平表示1，低电平表示0.</p>
<p>发送完 1byte 数据后，总线保持拉高状态。如果接收方把总线拉低了，发送方发现总线1→0了（不是发送方自己拉的，是接收方给他拉下来的，但是发送方能察觉到），说明接收方成功接收了并且拉了拉总线以示“收到”。如果 SDA 还是保持在高电平，说明接收方没有成功收到或者成功发送 ACK。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713140822834.png" alt="image-20230713140822834"></p>
<h2 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h2><p>I2C 是一种很简单的主从通信协议了，但是局限性也很多，比如7 bit 的地址线只允许 2^7 个设备；一次顶多两个设备主从通信；一个设备的快慢会影响到整条总线的通信等。</p>
<p>问题1：从设备处理速度太慢了，赶不及在下一个时钟周期接收新数据帧怎么办？</p>
<p>方法：clock stretching, 拉低一段时间 SCL 假装下一个时钟周期还没到。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713141906054.png" alt="image-20230713141906054"></p>
<p>问题2：多个设备同时发数据冲突了怎么办？</p>
<p>方法：Bus Aribitation，前面我们知道总线被一个设备拉低了，所有设备都能接收到总线拉低的信号。因此如果两个设备同时开始发信息，前面数据一致都无所谓，等到第一次数据不一致的时候，一个设备发送数据0，一个发送数据1，这时 SDA 总线被 DATA2 的0拉低了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713142029471.png" alt="image-20230713142029471"></p>
<p>发送 DATA1 数据的设备就明白了：有人同时在和我一起发数据，因此总线不是我预期的1而是被他拉低为0了。那我 quit，你发吧。然后就只有 DATA2 发送的数据了。</p>
<p>问题3：以上发送的数据每次都是 1byte 8bits 很正好。那如果要发送的地址不是 8bits 呢？</p>
<p>方法：少于 8bits 用一些固定的额外的 start 位填充，多于 8bits 的地址用两个 bytes，不够的也是用额外的 start 位填充。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143052018.png" alt="image-20230713143052018"></p>
<p>问题3：如果我 master 发完数据，想紧接着再收数据，变成 slave，可行吗？</p>
<p>方法：通过一个 sr 信号，也就是 repeat start 重发 start 位，来标识自己是 read 而不再是 write 了重新开始通信。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143601570.png" alt="image-20230713143601570"></p>
<h2 id="编址格式"><a href="#编址格式" class="headerlink" title="编址格式"></a>编址格式</h2><p>slave 地址编址有一些固定格式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713143744619.png" alt="image-20230713143744619"></p>
<p>0000 000 0：广播，对所有 slave 结点讲话。如果 slave 无视（NACK），就不会参与广播。如果返回 ACK 就参与进来了。不过多个 slave 都返回 ACK 的话 master 是不知道都有谁回应了的。</p>
<p>第二个 byte 发送一些行为相关，比如：start，clear，reset software</p>
<h2 id="编程应用"><a href="#编程应用" class="headerlink" title="编程应用"></a>编程应用</h2><p>slave mode: </p>
<ul>
<li>I2C 设备默认工作在 slave mode。</li>
<li>外设时钟在 I2C_CR2 寄存器中编程。频率介于 2kHz~100kHz。</li>
<li>硬件自动等待发过来的 start 和 addr 信息。</li>
<li>如果 addr 信息和  OAR1 中存储的地址相同，说明目标是自己。如果 ACK 位为1，则发送 ack pulse。</li>
<li>设置 ADDR 位，1表示匹配。</li>
<li>如果 ITEVFEN 就是中断事件 flag 为1，则生成中断。</li>
<li>TRA 位标明 slave 是 R 还是 T 模式（收 or 发）。</li>
<li>BTF 位标识收没收完。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689255491311.png" alt="1689255491311"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230713214410998.png" alt="image-20230713214410998"></p>
<p>这么说起来还是有点混乱 I2C 到底经历了哪些才顺利发送了数据？</p>
<p>首先，从主模式的概念。master 主模式驱动时钟信号，发起传输；slave 从模式响应传输。</p>
<h2 id="主模式"><a href="#主模式" class="headerlink" title="主模式"></a>主模式</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/Figure-1-4.png" alt="用于主发送数据的 I2C 传输序列图"></p>
<p>发送：</p>
<p>所有 EV 事件都会拉低 SCL，直到相应软件序列执行完成。</p>
<p>S：start 事件。比如CR2 寄存器中设置外设时钟，配置时钟寄存器，上升时钟寄存器，使能 CR1 来启用时钟，CR1 中设置 start 位，等待总线被拉低表示就绪，发送启动信号，并切换为主模式。</p>
<p>EV5：启动事件成功进行，设置 SB 寄存器&#x3D;1. SB 寄存器&#x3D;1后才可以进行地址阶段，执行完地址阶段会自动清除 SB 和 EV5 事件。</p>
<p>Address：地址阶段。传输7位地址+1位读写位，然后等待从机的 ack。收到 ack 进入 EV6.</p>
<p>EV6：设置 addr 位&#x3D;1代表地址阶段顺利执行， master 收到 ack了。清除 EV6 后自动进入 EV8.</p>
<p>EV8：设置 TxE ，准备写入主机要传入的数据。TxE 表示数据寄存器为空可以写入。每次数据写入 DR 都会清空 TxE 和 EV8 事件。写完数据数据传过去了，主机收到 ack 后继续传输。以 BTF&#x3D;1 表示数据传输的结尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_write</span><span class="params">(<span class="type">uint8_t</span> address, <span class="type">uint8_t</span> *buffer, <span class="type">int</span> buff_len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Send in sequence: Start bit, Contents of buffer 0..buff_len, Stop</span></span><br><span class="line">    <span class="keyword">while</span> (((I2C1-&gt;SR2&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>)); <span class="comment">// wait until I2C1 is not busy anymore</span></span><br><span class="line">    I2C_GenerateSTART(I2C1, ENABLE); <span class="comment">// Send I2C1 START condition</span></span><br><span class="line">    <span class="comment">// wait for I2C1 EV5 --&gt; Slave has acknowledged start condition</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));</span><br><span class="line">    <span class="comment">// Send slave Address for write then wait for EV6</span></span><br><span class="line">    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Transmitter);</span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));</span><br><span class="line">    <span class="keyword">while</span> (i &lt; buff_len)&#123;</span><br><span class="line">        I2C_SendData(I2C1, buffer[i]); <span class="comment">// send data then wait for EV8_2</span></span><br><span class="line">        <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_GenerateSTOP(I2C1, ENABLE); <span class="comment">// send stop bit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230714110003657.png" alt="image-20230714110003657"></p>
<p>接收：</p>
<p>前面和 master transmit 都一样。</p>
<p>TxE 改为 RxE 了，&#x3D;1标识接收到了数据。</p>
<p>master 自己设置 stop 事件后（发送 NACK）停止接收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_read</span><span class="params">(<span class="type">uint8_t</span> address, <span class="type">uint8_t</span> *buffer, <span class="type">int</span> buff_len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Start bit, Contents of buffer from 0..buff_len, sending a NACK</span></span><br><span class="line">    <span class="comment">// for the last item and an ACK otherwise, Stop bit</span></span><br><span class="line">    I2C_GenerateSTART(I2C1, ENABLE);</span><br><span class="line">    <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); <span class="comment">//EV5</span></span><br><span class="line">    <span class="comment">// Send slave Address for write then wait for EV6</span></span><br><span class="line">    I2C_Send7bitAddress(I2C1, address, I2C_Direction_Receiver);</span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));</span><br><span class="line">    I2C_AcknowledgeConfig(I2C1, ENABLE); <span class="comment">// going to send ACK</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; buff_len - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); <span class="comment">//EV7</span></span><br><span class="line">        buffer[i] = I2C_ReceiveData(I2C1); <span class="comment">// get data byte</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    I2C_AcknowledgeConfig(I2C1, DISABLE); <span class="comment">// going to send NACK</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); <span class="comment">//EV7</span></span><br><span class="line">    buffer[i] = I2C_ReceiveData(I2C1); <span class="comment">// get the last byte</span></span><br><span class="line">    I2C_GenerateSTOP(I2C1, ENABLE); <span class="comment">// send stop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从模式"><a href="#从模式" class="headerlink" title="从模式"></a>从模式</h3><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689259086166.png" alt="1689259086166"></p>
<p>发送：</p>
<p>start 启动事件由 master 发起。从机校验地址并决定是否发送 ack 位。</p>
<p>EV1：设置 addr 位表示地址匹配。</p>
<p>EV3-1：设置 TxE 位，开始传入数据。一直到主机返回 NACK 表示不想再要数据了，或者 AF&#x3D;1 说明 ack 失败了为止。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1689259113895.png" alt="1689259113895"></p>
<p>接收：</p>
<p>前面到 EV1 和 slave transmit 都一样。</p>
<ol>
<li>数据从 DR 寄存器中读。</li>
<li>读入一个 byte 后，如果 ack 位已经设置，则返回 ack 信息。</li>
<li>RxE 位是接收数据的状态寄存器。</li>
<li>主机生成停止条件时停止。</li>
</ol>
<p>异常情况：</p>
<p>总线错误，NACK，仲裁失败，时钟异常超时。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230714110916968.png" alt="image-20230714110916968"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Miprocessor/" rel="tag">Miprocessor</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：瑞萨开发板"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/06/24/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%91%9E%E8%90%A8%E5%BC%80%E5%8F%91%E6%9D%BF/"
    >技术学习：瑞萨开发板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/06/24/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%91%9E%E8%90%A8%E5%BC%80%E5%8F%91%E6%9D%BF/" class="article-date">
  <time datetime="2023-06-23T23:00:00.000Z" itemprop="datePublished">2023-06-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这回参加的是csdn李肯老师的攻城狮计划，简单说就是我白嫖板子，输出学习笔记。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/a3cc9258486e875c183b4fbbb1ce5fbe.jpeg" alt="552ca9fa46d8c1c7f192cdad4d207d4"></p>
<p>板子是瑞萨的CPK_RA2E1，还有触摸元件，看起来很有意思hh。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>一开始决定采取vscode搭建的方式。后期进行到最后一步——cmake build的时候一直显示语法错误，肯哥表示是环境配置不全，但是我反反复复根据官网和其他博主的文章检查了不下10遍都不知道问题何在。最终决定还是老老实实用keil。</p>
<ol>
<li><p>keil导入瑞萨包。官网下载地址：<a target="_blank" rel="noopener" href="https://www.keil.arm.com/vendors/renesas/packs/">Arm Keil | Renesas</a></p>
</li>
<li><p>下载rasc软件。对于这个东西我的理解是类似stm32cubemx，可以快速初始化项目的软件。该软件可以在瑞萨官网下载：<a target="_blank" rel="noopener" href="https://www2.renesas.cn/kr/en/software-tool/ra-smart-configurator">https://www2.renesas.cn/kr/en/software-tool/ra-smart-configurator</a></p>
</li>
<li><p>接下来我们尝试新建编译一个项目。这是我第一次没有跟着一块有完整开发流程的板子的视频课，而几乎完全是自己检索资料探索尝试的项目构建，因此碰到了很多弯路。首先rasc软件我们新建一个项目。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/1d1872b93bd272401e7d2a90a943d622.png" alt="项目起名"></p>
<p>板子型号这里是根据我的学习板设置的。IDE一定记得改为keil。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/091c255e2177162e613b3635d9e8128b.png" alt="image-20230601022545320"></p>
</li>
</ol>
<p>后两页选择 no rtos 和 minimal 即可，因为我们现在的目的只是尝试编译通过一个项目。</p>
<ol start="4">
<li><p>添加完成后，点击generate code 生成相关的项目代码。然后用keil打开，尝试编译。</p>
</li>
<li><p>我第一次遇到的问题是报了19个错。我还以为是pack导入的不对，但是后来搜了一下发现不是那么回事，是编译方式选错了。参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20017379/article/details/119523286">keil出现大量未知语法错误（系统移植）_portforce_inline_IT小生lkc的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/73a1e19aee6d2d2b7837c180d17939dc.png" alt="image-20230601022913830"></p>
</li>
<li><p>于是我把编译器改为version5，编译到一半，再次报错：error: A3903U: Argument ‘Cortex-M7.fp.sp’ not permitted for option  cpu’.。这个问题原因是因为编译器版本太低，于是我又去下载了新的keil5.</p>
</li>
<li><p>再次编译的时候提示我，不能用version5，新版本已经不支持了。于是我又改为version6进行编译。这次非常顺利！</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/d34a7cfbf5f7e0bdbb55a0063df5887f.png" alt="image-20230601023151749"></p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>终于考完试了，然而攻城狮的截止期限也快到了QAQ，得尽快水（划掉）写几篇文章了！</p>
<p>先争取可以成功下载一个空的程序。</p>
<p>先对上一篇文章下载 DFP 也就是 keil MDK Software Packs 做一个补充。我们要下载的是 RA_DFP，下载地址为：<a target="_blank" rel="noopener" href="https://www.keil.arm.com/packs/ra_dfp-renesas/versions/">Arm Keil | Renesas RA_DFP</a></p>
<p>至于版本我看到有前辈使用 3.5.0 的版本可以成功运行，而我下载的是4+的版本也可以。只不过在选择 device 的时候会有一点不同：<br><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622160103209.png" alt="image-20230622160103209"></p>
<p>可以看到 4.1.0 的版本无法细化选择到 R7FA2E1A92DFM，只能选择大类 A9. 不过经过下面的烧录尝试，是没有问题的。</p>
<p>流程：基于上次的空项目，用keil打开，编译，下载成功。</p>
<p>一直到编译的步骤前面都做完了。下载主要需要以下几个步骤：</p>
<ol>
<li>引入项目的 src 文件夹。在 options for target - c&#x2F;c++ 里引入即可很简单。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622154546545.png" alt="image-20230622154546545"></li>
<li>debug 模式设置为 jlink 模式。设置完之后插上板子设置配置，这里因为我的jlink版本太低出现了一个报错：unkown to this version of the jlink software。解决办法就是在官网上下载了一个新版本的jlink（官网链接：<a target="_blank" rel="noopener" href="https://www.segger.com/downloads/jlink%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E7%9A%84%E6%98%AF">https://www.segger.com/downloads/jlink，我选择的是</a> windows 版本），下载好后直接会提示“检测到你电脑里的 keil 环境，请问是否更新其 jlink 调试器”，更新后重新启动就没有问题了。</li>
<li>上一步参考文章: <a target="_blank" rel="noopener" href="https://blog.csdn.net/wsq_666/article/details/124367141">keil识别不到芯片，提示unkown to this version of the jlink software_keil识别不到单片机_王小琪0712的博客-CSDN博客</a> 里面也有如果没有提示自动更新 jlink 调试器的选项如何手动进行更新的步骤，建议多多支持原作者。</li>
<li>只是选择了 jlink 调试器也并不算设置完成。如果这个时候点击下载，会提示“找不到 flash”，也就是还没有配置完成，需要设置闪存。首先确保插上了板子，然后打开 jlink 的setting：<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155204869.png" alt="image-20230622155204869"></li>
<li>如果显示下图说明板子被正常识别。如果没有显示这些数据，可能是 jlink 的版本还是过低，或者线坏了，或者还未下载对应 rcsa 包。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155322848.png" alt="image-20230622155322848"></li>
<li>接下来我们配置 flash download. 打开这个页面后点击 add，添加图中所示的这款型号芯片，然后 start 和 size 应该就会自动配置成和图中一样的情形，这样就算成功了。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155451715.png" alt="image-20230622155451715"></li>
<li>点击 load，如果显示如下信息说明成功下载程序。<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230622155546525.png" alt="image-20230622155546525"></li>
</ol>
<p>刚插上板子的时候板子上是有白色的 power 指示灯和一个红蓝交替闪烁灯。下载空程序之后，应该只有电源指示灯还在亮。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/de933bcec619535b3e8b7fe60f61238.jpg" alt="de933bcec619535b3e8b7fe60f61238"></p>
<h1 id="点亮LED"><a href="#点亮LED" class="headerlink" title="点亮LED"></a>点亮LED</h1><p>本文主要参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/oxygen23333/article/details/130306105">【致敬未来的攻城狮计划】— 连续打卡第十一天：FSP固件库开发点亮第一个灯。_嵌入式up的博客-CSDN博客</a></p>
<p>在32阶段我们已经接触过类似做法了。初始化引脚模式（可以手动库函数，或者在工具包图形化界面里配置），设置引脚输出值。</p>
<h2 id="设置-FSP-Smart-Configurator"><a href="#设置-FSP-Smart-Configurator" class="headerlink" title="设置 FSP Smart Configurator"></a>设置 FSP Smart Configurator</h2><p>像上次一样创建一个项目。</p>
<p>首先我们翻一下RA2E1的数据手册看看led在哪。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624005444720.png" alt="image-20230624005444720"></p>
<p>如图所示，一红一蓝，502 501，输出高电平亮。</p>
<p>因此 configurator 里的pin如图所示设置501 502为output initial high</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624005611958.png" alt="image-20230624005611958"></p>
<p>配置完成后点击右上角 generate project content，输出更新配置到该项目中。</p>
<h2 id="Keil代码编写"><a href="#Keil代码编写" class="headerlink" title="Keil代码编写"></a>Keil代码编写</h2><p>接下来就是编写keil里，驱动两个led灯输出高电平的部分了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624011259206.png" alt="image-20230624011259206"></p>
<p>hal_entry.c 是相当于 main.c 的入口函数。其他都是 configurator 提供的配置函数。</p>
<p>引脚设置已经设置好了。我们打开 pin_data.c 可以看到：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624011748710.png" alt="image-20230624011748710"></p>
<p>这就代表确实初始化配置加进代码里了。</p>
<p>然后在 hal_entry.c 里是通过这个 open 函数在 warm_start 里初始化了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624012345948.png" alt="image-20230624012345948"></p>
<p>接下来我们需要一个写入位函数。在 r_ioport.c 里。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624012543274.png" alt="image-20230624012543274"></p>
<p>参数1：固定参数，传入 &amp;p_ctrl。</p>
<p>参数2：引脚，老方法 goto the definition</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013133790.png" alt="image-20230624013133790"></p>
<p>参数3：电平。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013206720.png" alt="image-20230624013206720"></p>
<p>然后就简单了，只需要在主函数里调用write函数写亮led。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hal_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> add your own code here */</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">				 R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);</span><br><span class="line">				 R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BSP_TZ_SECURE_BUILD</span></span><br><span class="line">    <span class="comment">/* Enter non-secure code */</span></span><br><span class="line">    R_BSP_NonSecureEnter();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624013456059.png" alt="image-20230624013456059"></p>
<h1 id="按键模块"><a href="#按键模块" class="headerlink" title="按键模块"></a>按键模块</h1><h2 id="后台轮询"><a href="#后台轮询" class="headerlink" title="后台轮询"></a>后台轮询</h2><p>按键也是一个比较简单的模块，主要是为了学习IO输入模式。</p>
<p>查看RA2E1电路图可见：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624133704709.png" alt="image-20230624133704709"></p>
<p>按键相关引脚是004引脚，默认上拉高电平，按下接地为低电平。</p>
<p>首先第一步还是设置对应引脚。类似上一期设置LED的方式，只不过Mode改为Input mode。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624133750237.png" alt="image-20230624133750237"></p>
<p>设置好之后仍然是记得generate。</p>
<p>然后就是程序编写。首先还是明确一下开发流程。首先我们尝试后台轮询的按键检测。在while里不断检测按键电平，如果为高点亮蓝灯，如果为低点亮红灯。</p>
<p>点亮好写，上一次已经尝试过write函数。那么我们接下来再去看类似的read函数。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624135423601.png" alt="image-20230624135423601"></p>
<p>第一个参数还是传入固定的&amp;g_ioport_ctrl。第二个是引脚。第三个是存放我们要存储的读取按键的值。比如传入变量state的地址 &amp;state，函数执行结束后state的值就是读取的按键电平。</p>
<p>主函数编写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hal_entry</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bsp_io_level_t</span> state;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> add your own code here */</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">			R_IOPORT_PinRead(&amp;g_ioport_ctrl, BSP_IO_PORT_00_PIN_04,&amp;state);</span><br><span class="line">			<span class="keyword">if</span>(state==BSP_IO_LEVEL_HIGH)&#123;</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_HIGH);</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_LOW);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_01, BSP_IO_LEVEL_LOW);</span><br><span class="line">				R_IOPORT_PinWrite(&amp;g_ioport_ctrl, BSP_IO_PORT_05_PIN_02, BSP_IO_LEVEL_HIGH);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BSP_TZ_SECURE_BUILD</span></span><br><span class="line">    <span class="comment">/* Enter non-secure code */</span></span><br><span class="line">    R_BSP_NonSecureEnter();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/8d99e5ae0be2c97e2e2bb44a1ed92f6.jpg" alt="8d99e5ae0be2c97e2e2bb44a1ed92f6"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/59b0f842762bb1349190932bdcb4e74.jpg" alt="59b0f842762bb1349190932bdcb4e74"></p>
<h1 id="活动总结"><a href="#活动总结" class="headerlink" title="活动总结"></a>活动总结</h1><p>一转眼攻城狮计划就已经到了最后一天了。<br>5月我还处在一个迷茫期，那时候刚刚入坑嵌入式，只学了几款电子积木，对整个体系也不是很清楚，也不知道应该学些什么。因为刚刚转到硬件领域，也缺少相关经历和能力证明，科研实习面试都失败了。</p>
<p>一开始得到的少许鼓励来源于C站推荐的一系列交流会活动。我去参加了RTThread的学习营，第一次尝试在单片机开发中加入RTOS系统，也算是跳脱出自己当时缓慢的按部就班学习路线，如井底之蛙般弹出脑袋窥探了一眼外面的风景。</p>
<p>后来偶然收到李肯老师的攻城狮活动邀请。虽然因为选在了期末周，自己又比较懒，基本没更几篇文章hh。但是借助李肯老师的交流活动认识了很多嵌入式领域的前辈，同伴，从每天的交流话题中也能学到很多。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20230624180328147.png" alt="image-20230624180328147"></p>
<p>现如今，虽然学到的知识相比之前可能没有太多，但是整个系统的框架，从硬件到ISA，操作系统解释器等系统软件，汇编语言和机器语言的转化等……确实见识到了很多。</p>
<p>再聊到本次活动。虽然自己没有做过多的尝试，但是因为之前我也只尝试过51和32的库函数开发，rcsa的configurator配置本身对我来说就是一种新奇的开发模式。与32的hal库对比更能让我体会到这些driver的便捷之处，也开始适应这种开发方式。</p>
<p>非常感谢给予这次机会的李肯老大！也期望自己能保持这股热情继续学下去~</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
    <article
  id="post-技术学习：51单片机"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/03/31/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A51%E5%8D%95%E7%89%87%E6%9C%BA/"
    >技术学习：51单片机</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/03/31/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%EF%BC%9A51%E5%8D%95%E7%89%87%E6%9C%BA/" class="article-date">
  <time datetime="2023-03-30T23:00:00.000Z" itemprop="datePublished">2023-03-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/">算道求索（课外IT技能学习）</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E9%81%93%E6%B1%82%E7%B4%A2%EF%BC%88%E8%AF%BE%E5%A4%96IT%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%EF%BC%89/Lecture/">Lecture</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h1><p>开发：Keil。如果想要没乱码的中文注释，那么设置编码方式为 UTF8 或 GB2312。</p>
<p>程序文件下载到单片机：STC&#x2F;普中（STC需要冷启动，先点击下载再开启单片机电源）</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Micro Controller Unit, MCU 单片机，其中包含了CPU RAM ROM 输入输出设备 等一系列电脑硬件常用功能。</p>
<p>功能：通过传感器采集数据，通过CPU处理数据，控制硬件。</p>
<p>可以说是一个性能低的小电脑，是了解计算机原理的很好的学习方法。</p>
<p><em>右上角的跳线帽使用数码管时跳到VCC，使用点阵时跳到GND。</em></p>
<h2 id="STC89C52RC-命名规则"><a href="#STC89C52RC-命名规则" class="headerlink" title="STC89C52RC 命名规则"></a>STC89C52RC 命名规则</h2><p>STC：芯片为 STC 公司生产的产品。 </p>
<p>8：该芯片为 8051 内核芯片。 </p>
<p>9：表示内部含有 Flash EEPROM 存储器，还有如 80C51 中 0 表内部含有 MaskROM（掩模 ROM）存储器；如 87C51 中 7 表示内部含有 EPROM（紫外线可擦除 ROM）存储器。 </p>
<p>C–表示该器件为 CMOS 产品。还有如 89LV52 和 89LE58 中的 LV 和 LE 都表示 该芯片为低电压产品（通常为 3.3V 电压供电）；而 89S52 中 S 表示该芯片含有 可串行下载功能的 Flash 存储器，即具有 ISP 可在线编程功能。 </p>
<p>5–固定不变。 </p>
<p>2：表示该芯片内部程序存储（FLASH）空间大小，1 为 4KB，2 为 8KB，3 为  12KB，即该数乘以 4KB 就是芯片内部的程序存储空间大小。程序空间大小决定了 一个芯片所能装入执行代码的多少。一般来说，程序存储空间越大，芯片价格也 越高，所以我们再选择芯片的时候要根据自己需求选择合适芯片。 RC–STC 单片机内部 RAM（随机读写存储器）为 512B。还有如 RD+表示内部 RAM 为 1280B。还有芯片会省略此部分</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540672.png" alt="image-20220828144814559"></p>
<h2 id="芯片介绍"><a href="#芯片介绍" class="headerlink" title="芯片介绍"></a>芯片介绍</h2><p>芯片在 PDIP 里。黑色的部分 PDIP 是一种封装方式，可能还有 LQFP 等（一个正方形的形状）封装方式。</p>
<p>8051 内核基本上都是中间绿色块的样子，只是外设、封装等方式不同。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540673.png" alt="image-20220828145334929"></p>
<p>管脚图：</p>
<p>Vcc 是电源，XTAL 管时钟，RST 是复位，等等。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540674.png" alt="image-20220828145345268"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252144730.png" alt="image-20230125214429628"></p>
<p>整个是一个总线结构，所有外设都挂在上面。如最下面一行左边是晶振，右边是外部引脚。</p>
<p>只有这一个单片机是不能运行的，看我们的开发板上面还外接了好多好多外设呢。能让单片机运行的最小应用系统如下：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252147253.png" alt="image-20230125214745143"></p>
<p>三角是正极，三线符号是负极。</p>
<p>首先需要 Vcc 接正，GND 接负。</p>
<p>然后需要接晶振。没有晶振单片机程序无法一条条往下执行，有了晶振按照固定的周期才能一条条往下执行。晶振就是板子上银色的椭圆形的一个东西，频率写在上面，一般是有12MHz和11.多MHz的两种（有的芯片自带晶振。不过很明显我们的芯片并不自带）。</p>
<p>然后还有复位电路，让程序回到第一条的位置。</p>
<h2 id="开发板介绍"><a href="#开发板介绍" class="headerlink" title="开发板介绍"></a>开发板介绍</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540671.png" alt="image-20220903113237968" style="zoom: 67%;" />

<p>中间黑色的是刚刚介绍的单片机。拉起拉杆，可以取下单片机，但放回时<strong>一定不能放反</strong>。单片机有缺口的一端左侧从01开始，逆时针逐渐增大到40。</p>
<p>右侧中间有8个 LED 灯，我是点灯大师！</p>
<p>下面是一个矩阵按键，用户可以通过按按键输入。</p>
<p>最下面一行右侧有个红外接收传感器，接收红外线的。</p>
<p>左边无线模块，8个插孔的，做无线模块（如2.4G）用的。</p>
<p>再左边四个独立按键。</p>
<p>最左下是 USB 自动下载模块，插上 USB 线后按开关就会自动下载程序，不用了解。</p>
<p>DS1302 时钟芯片，可以做一个小时钟，读取时间。</p>
<p>红色按钮是 RST 按钮。</p>
<p>AD&#x2F;DA 模数转换器，使单片机在数字与模拟领域之间转化。</p>
<p>74H595 可以扩展出更多的 IO 口。</p>
<p>步进电机可以精确控制脚步（转一圈、转半圈）。比如空调会用。</p>
<p>超声波模块可以测距。</p>
<p>蜂鸣器模块可以放歌。但我（）（）（）（）。</p>
<p>138译码器控制数码管，也可以扩展 IO 口。</p>
<p>24c02 也是一种 ROM，还是 EEP ROM（掉电不丢失）。其实单片机自带的 Flash ROM 更先进，但是只能用来存储程序。</p>
<p>温度传感器可以用来检测温度。</p>
<p>74HC245 可以驱动数码管（我的单片机是 HC138）。</p>
<p>左上角的电位器和排座用于接显示屏。电位器可以调整显示屏的亮度。</p>
<p>最大的黑色方阵是一个 LED 点阵。可以点亮8*8的方阵，甚至用来做动画。</p>
<p>之后的课程中还会详细介绍每一个模块，以及对应的电路图。</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>&amp;与，|或，!非，⊙同或（相同结果才&#x3D;1），异或⊕（不同结果才为1）</p>
<h1 id="C语言语法"><a href="#C语言语法" class="headerlink" title="C语言语法"></a>C语言语法</h1><p>int 16位，char 8位。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540675.png" alt="image-20220904115124141"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540676.png" alt="image-20220904115224027"></p>
<p>基本语法其他的都好说，再复习一下位运算。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540677.png" alt="image-20220904145323095"></p>
<p>左右移补0.</p>
<p>位运算符也可以参与成为复合赋值运算符，如^&#x3D;, &lt;&lt;&#x3D;</p>
<p>逗号运算符&#x3D;最后一个表达式的值</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540678.png" alt="image-20220904145638619"></p>
<h3 id="函数在C语言基础上做的拓展"><a href="#函数在C语言基础上做的拓展" class="headerlink" title="函数在C语言基础上做的拓展"></a>函数在C语言基础上做的拓展</h3><h4 id="重入函数"><a href="#重入函数" class="headerlink" title="重入函数"></a>重入函数</h4><p>在函数形参括号后加修饰符 reentrant，代表这个函数是重入函数，可以被递归调用，但这样就不能有bit变量，也不能进行位运算。</p>
<h4 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h4><p>在函数形参括号后加修饰符 interrupt m，系统编译时把对应函数转化为中断函数，自动加上程序头段和尾段，并按 51 系 统中断的处理方式自动把它安排在程序存储器中的相应位置。 </p>
<p>在该修饰符中，m 的取值为 0~31，对应的中断情况如下： </p>
<p>0——外部中断 0 </p>
<p>1——定时&#x2F;计数器 T0</p>
<p>2——外部中断 1 </p>
<p>3——定时&#x2F;计数器 T1 </p>
<p>4——串行口中断 </p>
<p>5——定时&#x2F;计数器 T2 </p>
<p>其它值预留。</p>
<h4 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h4><p>如果要调用的函数不在本文件内，在其他文件内，定义函数时函数开头要加 extern 修饰符。</p>
<h3 id="sfr-sbit"><a href="#sfr-sbit" class="headerlink" title="sfr sbit"></a>sfr sbit</h3><p>用于定义特殊功能寄存器或特殊位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sfr P0=<span class="number">0x80</span>;<span class="comment">//把地址 0x80 处的寄存器定义为 P0</span></span><br><span class="line">sbit P0_1=P0^<span class="number">1</span>;<span class="comment">//取第一位定义为 P0_1</span></span><br></pre></td></tr></table></figure>

<p>其实头文件 regx52.h 中都有。</p>
<p>能不能给位单独赋值要看是不是可位寻址。因为物理地址有限，每8个寄存器只能有一个可位寻址。</p>
<h2 id="51单片机最小系统组成"><a href="#51单片机最小系统组成" class="headerlink" title="51单片机最小系统组成"></a>51单片机最小系统组成</h2><ul>
<li>晶振电路，提供时钟，相当于心脏</li>
<li>复位电路，系统运行不正常时可以重启</li>
<li>电源电路，注意单片机的供电电压要求</li>
<li>下载电路，烧入程序</li>
</ul>
<p>另外注意，单片机的P0口是漏级开路，输出高电平会导致高阻态，因此输出高电平时要接上拉电阻，通常选择 4.7K~10K 阻值。</p>
<h1 id="程序编写前言"><a href="#程序编写前言" class="headerlink" title="程序编写前言"></a>程序编写前言</h1><p>新建项目 new μversion project</p>
<p><strong>选择 CPU 型号：Keil 中没有完全对应的 STC89C52 版本，用Atmel 中的 AT89C52 即可，不用把8051启动文件添加到工程中。</strong></p>
<blockquote>
<p>AT 和 STC 是两种型号的单片机。有的 STC 单片机上面还有 AT 接口，AT 使用那个接口烧录程序。STC 就用 USB 下载。</p>
</blockquote>
<p>新建好后有一个文件夹：source group，代码文件都在其中。</p>
<p>选中该文件夹，右键新建new item，新建c语言文件。可以选c&#x2F;cpp&#x2F;asm</p>
<p>在魔术棒 Output 选项中添加 “ create HEX file”.</p>
<h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：translate按钮</p>
<p>建立：build按钮，也有编译的作用，只编译发生变动的文件。</p>
<p>重新建立：rebuild，编译所有文件（速度慢不建议）。</p>
<p>报错如果显示：缺少root segment根段，即没有找到主函数。</p>
<h2 id="头文件作用"><a href="#头文件作用" class="headerlink" title="头文件作用"></a>头文件作用</h2><p><code>#include&lt;reg52.h&gt;</code>和&#96;#include “reg52.h”都可以。区别在于&lt;&gt;直接去软件安装处搜索头文件，而””先在该项目下查找头文件，找不到再去软件安装处，再找不到就报错。</p>
<p>查看头文件可以在左侧的结构树对应的c文件目录下打开，或者右键“reg52.h” open 打开。</p>
<p>该头文件中定义了52单片机内部所有功能寄存器，把地址值如0x80赋值给P0等端口。</p>
<h2 id="程序烧录"><a href="#程序烧录" class="headerlink" title="程序烧录"></a>程序烧录</h2><p>程序编译建立没有错误，也开启了魔术棒创建 HEX 文件选项，那么 build 后就会在对应路径中找到生成的 HEX 文件。</p>
<p>在 STC-ISP 中选定单片机型号、串口、晶振频率（可以直接看开发板上的晶振上面有写），选择对应的 HEX 文件，先断电开发板，再点击下载，再开机，就可以查看呈现在开发板上的效果。</p>
<h1 id="HELLO-WORLD——LED部分"><a href="#HELLO-WORLD——LED部分" class="headerlink" title="HELLO WORLD——LED部分"></a>HELLO WORLD——LED部分</h1><p>LED 发光二极管。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252222021.png" alt="image-20230125222255962" style="zoom:50%;" />

<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252223906.png" alt="image-20230125222332854"></p>
<p>下面两个黑色的方块就是8个电阻。电阻是限流作用，防止电流过大烧毁 LED。</p>
<p>电阻上面写着小小的“102”，代表10*10^2，即1kΩ。</p>
<p>每个 LED 正极是一定通电流的，如果负极接地，那么这个 LED 被点亮。否则两头都是高电平点不亮（这里的电平是 TTL 电平，高5低0）。</p>
<p>单片机如何驱动高低电平？在 MCU 内，CPU 接到指令（如P2^0口赋1，即高电平）CPU 把数据写入寄存器，寄存器数据通过驱动器放大后变为5V&#x2F;0V 电平输出。</p>
<h2 id="点亮-LED"><a href="#点亮-LED" class="headerlink" title="点亮 LED"></a>点亮 LED</h2><p>GPIO（general purpose input output) 即通用输入输出端口，可以通过软件控制其输入和输出.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540679.png" alt="image-20220905111036720"></p>
<ul>
<li>电源引脚： Vcc， GND</li>
<li>晶振引脚：XTAL1 2</li>
<li>复位引脚：RST VPD，不做其他功能。</li>
<li>下载引脚：TXD RXD</li>
<li>GPIO引脚：Px.x的都是 GPIO 引脚，大致分为P0 P1 P2 P3，每组8个IO，P3还有附加功能，比如串口、外部中 断、计数器等。每个引脚每次只能使用一个功能。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>; <span class="comment">//将 P2.0 管脚定义为 LED1</span></span><br><span class="line"><span class="comment">//我们也可以直接给P2整个赋值。比如P2=0xFE，即1111 1110，就只会点亮最后一个 LED 灯，和 P2^0=0 效果是一样的。</span></span><br><span class="line"><span class="comment">//另，我们的这种做法只是寻找特殊寄存器P2的第几位。而头文件 REGX52.H 中是真正包含所有引脚信息的，如P2_0 就是2.0引脚，也能起到一样的效果。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LED1=<span class="number">0</span>; <span class="comment">//LED1 端口设置为低电平，就会被点亮</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">//单片机默认不断执行主程序。如果没有这个死循环，单片机就会不断点亮点亮点亮点亮……不如点亮一次之后无限延时。</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译结果里面的几个数据的意义： </p>
<p>code：表示程序所占用 FLASH 的大小。 </p>
<p>data：数据储存器内部 RAM 占用大小。 </p>
<p>xdata：数据储存器外部 RAM 占用大小。 </p>
<h2 id="LED-闪烁"><a href="#LED-闪烁" class="headerlink" title="LED 闪烁"></a>LED 闪烁</h2><p>只需要点亮——延时——熄灭——延时循环即可。</p>
<p>单片机频率单位是 MHz 兆赫兹，所以只是单纯的亮灭亮灭肉眼看不出亮灭的效果。所以需要延时。</p>
<p>延时可以写一个这样的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 ten_us)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>u16 代表16位的无符号整型数据。这是一个比较常用的定义，unsigned char 定义为 u8, unsigned int 定义为 u16。当 ten_us 超出 u16 的范围后，跳出 while 循环。</p>
<p>然后就<code>LED1=0;delay(50000);LED1=1;delay(50000);</code>循环即可.</p>
<p>但是，STC-ISP 可以根据晶振频率和要延时的时间生成延时函数，真的牛！不过注意软件上标明的适用系列版本。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252241257.png" alt="image-20230125224132185"></p>
<p>其中 _nop_() 函数包括在 INTRINS.H 头文件中，是一个空语句，就只会产生延时的效果。</p>
<p>不过 STC-ISP 只能生成固定时长的延时函数。如果想要像自己写的那个 delay() 函数一样传入参数，延时对应长度的毫秒&#x2F;微秒呢？</p>
<p>很简单，我们先生成延时1毫秒&#x2F;微秒的函数，然后把函数中的内容重复执行传入参数遍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay1ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"> 	<span class="keyword">while</span>(xms--)&#123;<span class="comment">//这里是修改过的</span></span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        _nop_();</span><br><span class="line">        i = <span class="number">11</span>;</span><br><span class="line">        j = <span class="number">190</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (--j);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Keil-软件仿真"><a href="#Keil-软件仿真" class="headerlink" title="Keil 软件仿真"></a>Keil 软件仿真</h2><p>使用仿真功能查看 LED 闪烁案例中的实际延时时间。</p>
<ol>
<li>点击魔术棒，选择 Target 选项卡，设置 Xtal 为12M或11.0592M，根据开发板晶振修改对应值。</li>
<li>点击黑色放大镜中有红色d的仿真按钮，进入仿真页面</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540680.png" alt="image-20220905153847511"></p>
<p>我们要关注的参数是sec。</p>
<ol start="3">
<li>点击RST按钮重新复位系统参数，sec 变为0。然后在要调试的行前双击，就会出现红色块的断点，点击8运行时就会直接运行到断点处。再次点击就会运行到下一处断点处。</li>
<li>点击红色标记8运行，运行到36行时显示用时：0.00039s，再次点击运行到37行，用时：0.45s</li>
<li>可见delay花费时间约为0.45s</li>
</ol>
<h2 id="LED-流水灯"><a href="#LED-流水灯" class="headerlink" title="LED 流水灯"></a>LED 流水灯</h2><p>学会了点亮和延时，流水灯的原理就很好懂了。就是给P2的所有端口赋值为：1111 1110，每次只有一个为0即点亮，这个点亮的0从最高位逐渐降到最低位。</p>
<p>取反后即为：</p>
<p>1000 0000</p>
<p>0100 0000</p>
<p>0010 0000</p>
<p>0001 0000</p>
<p>0000 1000</p>
<p>0000 0100</p>
<p>0000 0010</p>
<p>0000 0001</p>
<p>也就是一个移位运算，0x01&lt;&lt;i的循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LED P2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i--)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">			<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">				LED=~(<span class="number">0x01</span>&lt;&lt;i);</span><br><span class="line">				delay(<span class="number">50000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移位函数"><a href="#移位函数" class="headerlink" title="移位函数"></a>移位函数</h2><p>位运算的移位操作只能补0，但是 Keil C51 软件内有对应的移位库函数，左移_crol_()，右移_cror_()，<strong>包含在 intrins.h 库中</strong>。</p>
<p>移位函数会把移出去的位补到空位，一个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LED P2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> i)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i--)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LED=~(<span class="number">0x01</span>);</span><br><span class="line">	delay(<span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">			LED=_crol_(LED,<span class="number">1</span>);</span><br><span class="line">			delay(<span class="number">50000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="蜂鸣器实验"><a href="#蜂鸣器实验" class="headerlink" title="蜂鸣器实验"></a>蜂鸣器实验</h1><p>蜂鸣器简单地说，就是电磁线圈和磁铁对振动膜的作用。</p>
<p>单片机的是无源蜂鸣器，不能一直充电，需要外部控制器发送震荡信号，可以改变频率产生不同的音色、音调。</p>
<p>大多数有源蜂鸣器则没有这个效果，有源蜂鸣器外观与之相同，内部自带震荡源，接上电就能响，但不能改变频率。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302071544133.png" alt="image-20230207154444964" style="zoom: 50%;" />

<p>我们知道三极管的作用是不用单片机自己直接驱动单片机。</p>
<p>另一种方法是步进电机。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302071559700.png" alt="image-20230207155956609" style="zoom: 80%;" />

<p>ULN 2003，高电压 高电流驱动器，给信号就被驱动。IN 取反输出 OUT。</p>
<h2 id="简谱"><a href="#简谱" class="headerlink" title="简谱"></a>简谱</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302071631942.png" alt="image-20230207163112788"></p>
<p>首先整个谱大概分为几个区。大字组、小字组、小字1组、小字2组。每个组之间差8度，每相邻的两个键（如黑白）差半音，相邻的两个同色键差一个全音。</p>
<p>几个白键的表示方法就是下面的简谱，差半音的黑键用左上角的#表示升半音，b表示降半音。</p>
<p>演奏两大要素：音高和时值。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/image-20240301121053848.png" alt="image-20240301121053848"></p>
<p>谱上一个数字是1&#x2F;4 音符，二分是其两倍，数字加个横线 - 。全音符就是（2 - - -）。这个线叫增时线。</p>
<p>八分是其1&#x2F;2，数字下加一条线（<u>2</u>）.再&#x2F;2就再加一条，叫减时线。</p>
<p>试着识一个完整的谱：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302072331332.png" alt="image-20230207233115087"></p>
<p>4&#x2F;4：以四分音符为一拍，每小节有四拍。</p>
<p>第二节 $\dot{1}$ · 上面的点我们知道代表高音，后面的点代表：前一位音符延长1&#x2F;2长度，即四分音符+1&#x2F;2的四分音符。也就是3&#x2F;8哈哈哈。</p>
<p>看第一节，一般连着两个八分音符就把 underline 连起来。但是这种哪怕是一个音，中间也要先断开再重响。比如右上角的<u>3 3</u>。</p>
<p>升音和降音在本小节中有效。如第三行的 7 #4 4 7 ，两个4都是升音。</p>
<p>不过如果顶端画了延音线，就是连起来的不用断开。如中间的 $\widehat{7 7}$，拆开写是为了好读谱。</p>
<p>接下来就是如何把谱转化为单片机代码。左上角 1&#x3D;c 说明是c调的。d大调会出现黑键，c调只有白键。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080007323.png" alt="image-20230208000727170" style="zoom:67%;" />

<p>音具体是怎么定义的？首先以中音a为基准，高音a是其2倍，低音a是其1&#x2F;2。</p>
<p>中间每次升音都是等比数列递增的，即*2的1&#x2F;12次方</p>
<h2 id="使用蜂鸣器"><a href="#使用蜂鸣器" class="headerlink" title="使用蜂鸣器"></a>使用蜂鸣器</h2><p>响起来很简单：不断反转 P1^5 口（是不是这个口得看自己的板子型号）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u16 i=<span class="number">2000</span>;<span class="comment">//决定时值</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(i--)</span><br><span class="line">		&#123;</span><br><span class="line">			BEEP=!BEEP;</span><br><span class="line">			delay10Us(<span class="number">100</span>);<span class="comment">//决定音高</span></span><br><span class="line">		&#125;</span><br><span class="line">        i=<span class="number">2000</span>;</span><br><span class="line">        BEEP=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时值还好确认，音高怎么说？</p>
<p>首先我们有上图的音符与频率对照表。我们把频率转化为周期，即1&#x2F;频率。这里周期单位是us。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080935317.png" alt="image-20230208093509168"></p>
<p>然后周期时长转化为机器周期，即记一个数需要的时间。我们看看需要多少机器周期。</p>
<p>1机器周期&#x3D;12时钟周期，时钟周期&#x3D;1&#x2F;单片机晶振。比如对于我的11.0592MHZ 晶振，机器周期&#x3D;12&#x2F;11.0592MHZ （单位：us）。</p>
<p>据此把“需要切换的周期时长”转化为“需要切换的周期需要执行几次指令”。即周期&#x2F;机器周期。如果是12MHZ 晶振这一步相当于没有。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080945402.png" alt="image-20230208094537336"></p>
<p>然后电平从低到高，从高到低才是一个周期。所以实际电平反转一次的周期是周期的一半。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302080951297.png" alt="image-20230208095158230"></p>
<p>我们知道定时器原理是 TH TL 加至65536触发中断。因此重装载值（定时器初值）&#x3D;65536-取整值。</p>
<table>
<thead>
<tr>
<th>音符</th>
<th>频率</th>
<th>周期</th>
<th>需要的机器周期数</th>
<th>需要的机器周期数&#x2F;2</th>
<th>取整</th>
<th>重装载值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>262</td>
<td>3816.794</td>
<td>3517.557252</td>
<td>1758.778626</td>
<td>1759</td>
<td>63777</td>
</tr>
<tr>
<td>1#</td>
<td>277</td>
<td>3610.108</td>
<td>3327.075812</td>
<td>1663.537906</td>
<td>1664</td>
<td>63872</td>
</tr>
<tr>
<td>2</td>
<td>294</td>
<td>3401.361</td>
<td>3134.693878</td>
<td>1567.346939</td>
<td>1567</td>
<td>63969</td>
</tr>
<tr>
<td>2#</td>
<td>311</td>
<td>3215.434</td>
<td>2963.344051</td>
<td>1481.672026</td>
<td>1482</td>
<td>64054</td>
</tr>
<tr>
<td>3</td>
<td>330</td>
<td>3030.303</td>
<td>2792.727273</td>
<td>1396.363636</td>
<td>1396</td>
<td>64140</td>
</tr>
<tr>
<td>4</td>
<td>349</td>
<td>2865.33</td>
<td>2640.687679</td>
<td>1320.34384</td>
<td>1320</td>
<td>64216</td>
</tr>
<tr>
<td>4#</td>
<td>370</td>
<td>2702.703</td>
<td>2490.810811</td>
<td>1245.405405</td>
<td>1245</td>
<td>64291</td>
</tr>
<tr>
<td>5</td>
<td>392</td>
<td>2551.02</td>
<td>2351.020408</td>
<td>1175.510204</td>
<td>1176</td>
<td>64360</td>
</tr>
<tr>
<td>5#</td>
<td>415</td>
<td>2409.639</td>
<td>2220.722892</td>
<td>1110.361446</td>
<td>1110</td>
<td>64426</td>
</tr>
<tr>
<td>6</td>
<td>440</td>
<td>2272.727</td>
<td>2094.545455</td>
<td>1047.272727</td>
<td>1047</td>
<td>64489</td>
</tr>
<tr>
<td>6#</td>
<td>466</td>
<td>2145.923</td>
<td>1977.682403</td>
<td>988.8412017</td>
<td>989</td>
<td>64547</td>
</tr>
<tr>
<td>7</td>
<td>494</td>
<td>2024.291</td>
<td>1865.587045</td>
<td>932.7935223</td>
<td>933</td>
<td>64603</td>
</tr>
<tr>
<td>1</td>
<td>523</td>
<td>1912.046</td>
<td>1762.141491</td>
<td>881.0707457</td>
<td>881</td>
<td>64655</td>
</tr>
<tr>
<td>1#</td>
<td>554</td>
<td>1805.054</td>
<td>1663.537906</td>
<td>831.7689531</td>
<td>832</td>
<td>64704</td>
</tr>
<tr>
<td>2</td>
<td>587</td>
<td>1703.578</td>
<td>1570.017036</td>
<td>785.0085179</td>
<td>785</td>
<td>64751</td>
</tr>
<tr>
<td>2#</td>
<td>622</td>
<td>1607.717</td>
<td>1481.672026</td>
<td>740.8360129</td>
<td>741</td>
<td>64795</td>
</tr>
<tr>
<td>3</td>
<td>659</td>
<td>1517.451</td>
<td>1398.482549</td>
<td>699.2412747</td>
<td>699</td>
<td>64837</td>
</tr>
<tr>
<td>4</td>
<td>698</td>
<td>1432.665</td>
<td>1320.34384</td>
<td>660.1719198</td>
<td>660</td>
<td>64876</td>
</tr>
<tr>
<td>4#</td>
<td>740</td>
<td>1351.351</td>
<td>1245.405405</td>
<td>622.7027027</td>
<td>623</td>
<td>64913</td>
</tr>
<tr>
<td>5</td>
<td>784</td>
<td>1275.51</td>
<td>1175.510204</td>
<td>587.755102</td>
<td>588</td>
<td>64948</td>
</tr>
<tr>
<td>5#</td>
<td>831</td>
<td>1203.369</td>
<td>1109.025271</td>
<td>554.5126354</td>
<td>555</td>
<td>64981</td>
</tr>
<tr>
<td>6</td>
<td>880</td>
<td>1136.364</td>
<td>1047.272727</td>
<td>523.6363636</td>
<td>524</td>
<td>65012</td>
</tr>
<tr>
<td>6#</td>
<td>932</td>
<td>1072.961</td>
<td>988.8412017</td>
<td>494.4206009</td>
<td>494</td>
<td>65042</td>
</tr>
<tr>
<td>7</td>
<td>988</td>
<td>1012.146</td>
<td>932.7935223</td>
<td>466.3967611</td>
<td>466</td>
<td>65070</td>
</tr>
<tr>
<td>1</td>
<td>1046</td>
<td>956.0229</td>
<td>881.0707457</td>
<td>440.5353728</td>
<td>441</td>
<td>65095</td>
</tr>
<tr>
<td>1#</td>
<td>1109</td>
<td>901.7133</td>
<td>831.018936</td>
<td>415.509468</td>
<td>416</td>
<td>65120</td>
</tr>
<tr>
<td>2</td>
<td>1175</td>
<td>851.0638</td>
<td>784.3404255</td>
<td>392.1702128</td>
<td>392</td>
<td>65144</td>
</tr>
<tr>
<td>2#</td>
<td>1245</td>
<td>803.2129</td>
<td>740.2409639</td>
<td>370.1204819</td>
<td>370</td>
<td>65166</td>
</tr>
<tr>
<td>3</td>
<td>1318</td>
<td>758.7253</td>
<td>699.2412747</td>
<td>349.6206373</td>
<td>350</td>
<td>65186</td>
</tr>
<tr>
<td>4</td>
<td>1397</td>
<td>715.8196</td>
<td>659.6993558</td>
<td>329.8496779</td>
<td>330</td>
<td>65206</td>
</tr>
<tr>
<td>4#</td>
<td>1480</td>
<td>675.6757</td>
<td>622.7027027</td>
<td>311.3513514</td>
<td>311</td>
<td>65225</td>
</tr>
<tr>
<td>5</td>
<td>1568</td>
<td>637.7551</td>
<td>587.755102</td>
<td>293.877551</td>
<td>294</td>
<td>65242</td>
</tr>
<tr>
<td>5#</td>
<td>1661</td>
<td>602.047</td>
<td>554.846478</td>
<td>277.423239</td>
<td>277</td>
<td>65259</td>
</tr>
<tr>
<td>6</td>
<td>1760</td>
<td>568.1818</td>
<td>523.6363636</td>
<td>261.8181818</td>
<td>262</td>
<td>65274</td>
</tr>
<tr>
<td>6#</td>
<td>1865</td>
<td>536.193</td>
<td>494.155496</td>
<td>247.077748</td>
<td>247</td>
<td>65289</td>
</tr>
<tr>
<td>7</td>
<td>1976</td>
<td>506.0729</td>
<td>466.3967611</td>
<td>233.1983806</td>
<td>233</td>
<td>65303</td>
</tr>
</tbody></table>
<p>使用方法：TH&#x3D;重装载值&#x2F;256，TL&#x3D;重装载值%256.</p>
<p>音高从低到高逐位响起代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Timer0.h&quot;</span></span></span><br><span class="line">sbit beep=P1^<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> beep_table[]=&#123;<span class="comment">//可以加个0代表不响的0</span></span><br><span class="line">	<span class="number">63777</span>,<span class="number">63872</span>,<span class="number">63969</span>,<span class="number">64054</span>,<span class="number">64140</span>,<span class="number">64216</span>,<span class="number">64291</span>,<span class="number">64360</span>,<span class="number">64426</span>,<span class="number">64489</span>,<span class="number">64547</span>,<span class="number">64603</span>,</span><br><span class="line">	<span class="number">64655</span>,<span class="number">64704</span>,<span class="number">64751</span>,<span class="number">64795</span>,<span class="number">64837</span>,<span class="number">64876</span>,<span class="number">64913</span>,<span class="number">64948</span>,<span class="number">64981</span>,<span class="number">65012</span>,<span class="number">65042</span>,<span class="number">65070</span>,</span><br><span class="line">	<span class="number">65095</span>,<span class="number">65120</span>,<span class="number">65144</span>,<span class="number">65166</span>,<span class="number">65186</span>,<span class="number">65206</span>,<span class="number">65225</span>,<span class="number">65242</span>,<span class="number">65259</span>,<span class="number">65274</span>,<span class="number">65289</span>,<span class="number">65303</span>	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> beep_select=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;																	 </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	timer0Init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		beep_select++;</span><br><span class="line">		delayMs(<span class="number">50</span>);<span class="comment">//时值		</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0Interrupt</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">    TH0 = beep_table[beep_select]/<span class="number">256</span>; <span class="comment">// 因为触发中断时，TH TL 归零，所以记得赋初值！</span></span><br><span class="line">    TL0 = beep_table[beep_select]%<span class="number">256</span>;</span><br><span class="line">	beep=!beep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编曲：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302081250459.png" alt="image-20230208125043337"></p>
<p>根据乐谱写一个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> little_star[]=&#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">19</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">21</span>, <span class="number">19</span>,    <span class="comment">//增时线</span></span><br><span class="line">                            <span class="number">17</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">16</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">14</span>, <span class="number">12</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">17</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">16</span>, <span class="number">14</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">17</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">16</span>, <span class="number">14</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">19</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">21</span>, <span class="number">19</span>, </span><br><span class="line">                            <span class="number">17</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">16</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">14</span>, <span class="number">12</span></span><br><span class="line">                           &#125;;</span><br></pre></td></tr></table></figure>

<p>遍历数组，得到的音高再去 beep_table 中获取重装载值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TH0 = beep_table[little_star[beep_select]]/<span class="number">256</span>; <span class="comment">// 因为触发中断时，TH TL 归零，所以记得赋初值！</span></span><br><span class="line">TL0 = beep_table[little_star[beep_select]]%<span class="number">256</span>;</span><br></pre></td></tr></table></figure>

<p>但是播放起来都是连着的，听起来效果并不好。可以每次播完一个音先关闭中断并延时一段时间，再继续播放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		beep_select++;</span><br><span class="line">		delayMs(<span class="number">50</span>);</span><br><span class="line">		TR0=<span class="number">0</span>;</span><br><span class="line">		delayUs(<span class="number">1</span>);</span><br><span class="line">		TR0=<span class="number">1</span>;		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>増时线如何处理？中间是不断开一直想的，因此需要几个特定的音符delay时间更长一些。怎么区分哪些音符加长哪些不加呢？</p>
<p>最好还是存储乐谱时搞一个二维数组（逻辑上物理上都可以），既能存储音高，也能存储时值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> little_star[]=&#123;<span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">8</span>,  <span class="comment">//增时线</span></span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">21</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">19</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">17</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">16</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">14</span>, <span class="number">4</span>,</span><br><span class="line">                            <span class="number">12</span>, <span class="number">8</span>,</span><br><span class="line">                            <span class="number">0xFF</span>,<span class="number">4</span><span class="comment">//终止标志防越界</span></span><br><span class="line">                           &#125;;</span><br></pre></td></tr></table></figure>

<p>如果数组大小超限，在魔术棒-Target-Memory Model 中选择第三个。不过这只是治标不治本，因为 RAM 只有512字节所以存不下太长。可以在定义数组时加上关键词 code 来存在 ROM 8K 的闪存中。不过这样的数组是只读的。</p>
<p>当然这样找索引比较麻烦。最好是索引全部重新宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//音符与索引对应表，P：休止符，L：低音，M：中音，H：高音，下划线：升半音符号#</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L1	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L1_	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L2	3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L2_	4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L3	5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L4	6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L4_	7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L5	8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L5_	9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L6	10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L6_	11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L7	12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M1	13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M1_	14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M2	15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M2_	16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M3	17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M4	18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M4_	19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M5	20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M5_	21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M6	22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M6_	23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M7	24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H1	25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H1_	26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H2	27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H2_	28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H3	29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H4	30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H4_	31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H5	32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H5_	33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H6	34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H6_	35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> H7	36</span></span><br></pre></td></tr></table></figure>



<h1 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h1><p>动态数码管原理是什么？首先我们知道每个数码管都有 abcdefg 七个段。</p>
<p>8个数码管那我们按理来说是需要8*7个引脚，很浪费。</p>
<p>于是设计了动态数码管。首先所有数码管是共阴极的。然后我们选中哪一个数码管阴极赋0，就会启动哪一个数码管，传入的 abcdefg 就会点亮该数码管的对应段。</p>
<p>然后8个数码管像流水灯一样，以极高频率依次点亮，肉眼看到的就是8个数码管都被点亮且呈现出不同的图案。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301261308342.png" alt="image-20230126130808285"></p>
<p>开发板上的数码管是共阴极数码管，所有位共接一个阴极，给对应ABCDEF输入高电平点亮。</p>
<p>直接引脚：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301260119755.png" alt="直接引脚"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301261252056.png" alt="image-20230126125258985"></p>
<p>74译码器使用3位 bit 输入表示8种状态，调整 LED1~8 哪一个输出低电平，代表要启动8个数码管的哪一个的公共端。</p>
<p>输入的三位从最低位到最高位分别是P2^2, P2^3, P2^4，代表数码管从左到右的第几位是输入取反。</p>
<p>比如P2^4&#x3D;1, P2^3&#x3D;1, P2^2&#x3D;0, 输入就是110，取反后就是001，就是从左到右第1位数码管（从第0位开始）。</p>
<p>VCC 和 GND 是使能，接到译码器上一上电就工作。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301260059586.png" alt="image-20230126005938488"></p>
<p>P00<del>P07 代表控制当前数码管的 a</del>g 显示形式，接到 74HC245 缓冲器上而不是直接接到数码管上，使得单片机不用直接驱动数码管，Ai 连到 Bi 上。</p>
<p>OE 是使能，接地工作不接地不工作的原理。</p>
<p>DIR 是规定方向，高电平从左边读取数据传输到右边。低电平从右边读数据到左边。开发板上有个 J21 跳线帽，可以调整是 GND 与 LE 相连还是 VCC 与 LE 相连，也就是高电平输入 DIR 还是低电平输入 DIR。</p>
<p>数码管上面的 COM 是公共端，选中哪一个公共端（使得其&#x3D;0，因为是共阴极）就是调整哪一个数码管的点亮方式。</p>
<p>点亮一位数码管代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Display P0 </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> display_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="comment">/*具体显示什么图案是怎么推算出来的呢？首先 abcdefg 和 dp 小数点段一共有8个要控制的段。</span></span><br><span class="line"><span class="comment">比如我们要呈现数字6，就是 acdefg 亮，b和小数点不亮。</span></span><br><span class="line"><span class="comment">因为数码管是共阴极，所以我们想让哪个段亮哪个段就输入高电平，和 LED 相反。</span></span><br><span class="line"><span class="comment">所以P00~P07 的输入应该是 1011 1110</span></span><br><span class="line"><span class="comment">然后我们直接给 P0 赋值的话，是 P0_7 在最高位，P0_0 在最低位，所以输入应该正好反过来，0111 1101，即0x7d。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Display=display_code[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//这个程序是从左到右显示12345678.当然完全也可以把确定哪一位数码管和确定要显示的数字封装成一个函数，点亮会更方便。</span></span><br><span class="line">		<span class="keyword">switch</span>(i)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;<span class="comment">//从左往右第0个数码管</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SMG_A_DP_PORT=gsmg_code[i];</span><br><span class="line">		delay_10us(<span class="number">100</span>);</span><br><span class="line">		SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消影</span></span><br><span class="line">    <span class="comment">//为什么要消影？ 不延时的话动态数码管会反复重复 位选 段选 位选 段选……位选之后不一定及时段选，可能前一位的位选就会赋给后一位。因此需要消影。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这种动态数码管扫描方式是单片机直接扫描，硬件会简单很多，但是会占据大量的 CPU 时间。有的动态数码管自带显存和扫描电路，只要告诉他要显示什么他会自动扫描显示。</p>
<h1 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h1><p>内部有一个金属片，按下后电路接通。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252340383.png" alt="image-20230125234043319" style="zoom: 50%;" />

<p>和学习 LED 时类似，所有 IO 口一开始都是高电平，我们给其接地就变成低电平了。</p>
<p>按下按键后一段时间内电平会高低抖动。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301252359619.png" alt="image-20230125235945530" style="zoom:67%;" />

<p>1，先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻，所以默认 IO 为高 电平）。 </p>
<p>2，读取 IO 口电平确认是否有按键按下。 </p>
<p>3，如有 IO 电平为低电平后，延时几个毫秒。 </p>
<p>4，再读取该 IO 电平，如果仍然为低电平，说明按键按下。 </p>
<p>5，执行按键控制程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义独立按键控制脚</span></span><br><span class="line">sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//定义 LED1 控制脚</span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line">sbit LED2=P2^<span class="number">1</span>;</span><br><span class="line">sbit LED3=P2^<span class="number">2</span>;</span><br><span class="line">sbit LED4=P2^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">	<span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		delay_10us(<span class="number">1000</span>);<span class="comment">//10ms 消抖</span></span><br><span class="line">        <span class="comment">/*另一种消抖的方法：</span></span><br><span class="line"><span class="comment">        if(KEY==0)&#123;</span></span><br><span class="line"><span class="comment">        	delay_ms(20);</span></span><br><span class="line"><span class="comment">        	while(KEY==0);</span></span><br><span class="line"><span class="comment">        	delay(20ms);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        这个是针对按下按钮又抬起按钮之后的执行。*/</span></span><br><span class="line">		key=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">		key=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		key=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY1_PRESS)<span class="comment">//检测按键 K1 是否按下</span></span><br><span class="line">		LED1=!LED1;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">		<span class="keyword">if</span>(key==KEY2_PRESS)<span class="comment">//检测按键 K2 是否按下</span></span><br><span class="line">		LED2=!LED2;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">		<span class="keyword">if</span>(key==KEY3_PRESS)<span class="comment">//检测按键 K3 是否按下</span></span><br><span class="line">		LED3=!LED3;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">		<span class="keyword">if</span>(key==KEY4_PRESS)<span class="comment">//检测按键 K4 是否按下</span></span><br><span class="line">		LED4=!LED4;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="矩阵按键"><a href="#矩阵按键" class="headerlink" title="矩阵按键"></a>矩阵按键</h1><p>为了减少 IO 口的占用，用4个 IO 口代表行，4个 IO 口代表列。</p>
<p>类似动态数码管快速扫描实现几乎同时点亮的效果，矩阵键盘也是快速扫描。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301262213298.png" alt="image-20230126221349232" style="zoom:67%;" />



<p>主要有两种扫描方法</p>
<p>行列式扫描法：每次给某一列赋值为0，然后检测这一列有无按钮按下。</p>
<p>​	按行扫描：通过设置 P17 16 15 14 中的一个为低电平来选择扫描哪一行。根据 P10 P11 P12 P13 的输入判断是哪一列。但是 	P15 口是蜂鸣器，不断反转会响。所以最好还是用按列扫描。</p>
<p>线翻转扫描方法：给所有列赋1，给所有行赋0，先判断在哪一行；然后用同样的方法判断在哪一列。</p>
<p>这里有一点问题就是：本单片机是准双向口输出，每个口既能做输入也能做输出而不用重新配置口线输出状态。其实这样相当于单片机一个引脚输出高电平，直接与另一个为低电平的引脚相连接。不会短路吗？</p>
<p>单片机的处理方法是这样的：内部 VCC 电源还附带一个下拉电阻。低电平的驱动力比高电平强，高电平直接接低电平就会被变为低电平，而不会短路。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_MATRIX_PORT P1 <span class="comment">//使用宏定义矩阵按键控制口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,<span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_matrix_ranks_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xf7</span>;<span class="comment">//1111 0111 给第一列也就是 P1_3 赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>)<span class="comment">//判断第一列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖。因为这里用了类似动态数码管的循环扫描的方法。</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第一列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x77</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;<span class="comment">//0111 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xb7</span>: key_value=<span class="number">5</span>;<span class="keyword">break</span>;<span class="comment">//1011 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xd7</span>: key_value=<span class="number">9</span>;<span class="keyword">break</span>;<span class="comment">//1101 0111</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xe7</span>: key_value=<span class="number">13</span>;<span class="keyword">break</span>;<span class="comment">//1110 0111</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfb</span>;<span class="comment">//给第二列赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>)<span class="comment">//判断第二列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第二列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbb</span>: key_value=<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdb</span>: key_value=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xeb</span>: key_value=<span class="number">14</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfd</span>;<span class="comment">//给第三列赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>)<span class="comment">//判断第三列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第三列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbd</span>: key_value=<span class="number">7</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdd</span>: key_value=<span class="number">11</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xed</span>: key_value=<span class="number">15</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfe</span>;<span class="comment">//给第四列赋值 0，其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>)<span class="comment">//判断第四列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第四列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbe</span>: key_value=<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xde</span>: key_value=<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xee</span>: key_value=<span class="number">16</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    <span class="keyword">return</span> key_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_matrix_flip_scan</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//另一种扫描方式，这个函数暂时没有投入使用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0x0f</span>;<span class="comment">//给所有行赋值 0，列全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)<span class="comment">//判断按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//测试列</span></span><br><span class="line">            KEY_MATRIX_PORT=<span class="number">0x0f</span>;</span><br><span class="line">            <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存行为 0，按键按下后的列值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x07</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x0b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x0d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x0e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//测试行</span></span><br><span class="line">            KEY_MATRIX_PORT=<span class="number">0xf0</span>;</span><br><span class="line">            <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存列为 0，按键按下后的键值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x70</span>: key_value=key_value;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xb0</span>: key_value=key_value+<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xd0</span>: key_value=key_value+<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0xe0</span>: key_value=key_value+<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf0</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    key_value=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> key_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key=key_matrix_ranks_scan();</span><br><span class="line">        <span class="keyword">if</span>(key!=<span class="number">0</span>)</span><br><span class="line">        SMG_A_DP_PORT=gsmg_code[key<span class="number">-1</span>];<span class="comment">//得到的按键值减 1 换算成数组下标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO-扩展-串转并-74HC595"><a href="#IO-扩展-串转并-74HC595" class="headerlink" title="IO 扩展(串转并)-74HC595"></a>IO 扩展(串转并)-74HC595</h1><p>前面接的一些输入输出设备都是直接连接的单片机 IO 口，单片机仅有的 IO 口非常有限。而使用 IO 扩展可以大量增加可使用的端口。比如后面要使用的 LED 点阵，8*8个格子，使用扩展 IO 输入就更为合适。如果多级联一个，就又有了8位输出，能实现16*16的点阵。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301300101058.png"></p>
<p>由图可知，OE 低电平有效，因此 <strong>LED 点阵旁的跳线帽一定要接到 OE-GND 一端。</strong></p>
<p>74HC595 是一个位移缓存器，有8位串行输入、并行输出，并行输出是三态输出（高电平、低电平、高阻抗）。比如一次输入一个比特，输入八次，并行输出可以输出一个8位的字 1010 1010.</p>
<p>输出是由 VCC 驱动的，原理有那么一点像三极管。因为单片机内部是弱上拉，输出不足以点亮 LED 点阵，所以抛开 IO 口不够的问题，也不能直接接到 LED 点阵上，至少要有三极管。</p>
<h2 id="点亮-LED-点阵"><a href="#点亮-LED-点阵" class="headerlink" title="点亮 LED 点阵"></a>点亮 LED 点阵</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301300048214.png" alt="image-20230130004758073"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301300048730.png" alt="image-20230130004829583"></p>
<p>传入数据如列是0100 0000，行是0000 0001，则代表最后一行第二列的点会被点亮。</p>
<p>SRCLK：移位寄存器，数据先传输到移位寄存器中。移位寄存器<strong>上升沿</strong>时移位，再接收下一次数据。</p>
<p>RCLK：存储寄存器。存储寄存器<strong>上升沿</strong>时把寄存器中所有数据都通过端口输出。</p>
<p>相当于手枪，每次 SRCLK 上升时我们填入一枚子弹，RCLK 上升时把弹夹塞入。</p>
<p>QH 是级联用的。</p>
<p>列数据直接输入引脚，行数据输入 IO 拓展。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="comment">//编写程序先定义管脚和端口。管脚用sbit，端口宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MATRIX P0</span></span><br><span class="line">sbit SRCLK=P3^<span class="number">6</span>;</span><br><span class="line"><span class="comment">//因为 RCLK 是关键字不能被复用了</span></span><br><span class="line">sbit rCLK=P3^<span class="number">5</span>;</span><br><span class="line">sbit SER=P3^<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hc_led_arr[<span class="number">8</span>]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="keyword">while</span>(i--);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc_write_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span>&#123;</span><br><span class="line">	<span class="comment">//要传入8个输入，需要循环</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//注意 芯片传数据先传高位 再传低位，所以要反着写。这个问题在write函数内部解决，传入的数据和想要的形式一样就好。</span></span><br><span class="line">		<span class="comment">//通过移位获取</span></span><br><span class="line">		SER=c&gt;&gt;<span class="number">7</span>;</span><br><span class="line">		<span class="comment">//想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿</span></span><br><span class="line">		SRCLK=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//芯片一般给定一个延时时间，经过这个时间之后才能处理完毕</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		SRCLK=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//让传入数据的次高位变为下次循环的高位</span></span><br><span class="line">		c&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后通过存储寄存器的上升沿，传输全部数据</span></span><br><span class="line">	rCLK=<span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">	rCLK=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	LED_MATRIX=<span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		 <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		 	hc_write_data(<span class="number">0x00</span>);<span class="comment">//消隐</span></span><br><span class="line">		 	hc_write_data(hc_led_arr[i]);</span><br><span class="line">			delay(<span class="number">500000</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如0000 0001，传入LED阵列的数据是：每轮循环传入最高位的值，并且所有数据向左移动一位。因此前7轮 SER 传入都是0，最后一轮 SER 传入1，最下面一行全亮。</p>
<h2 id="LED-点阵实验"><a href="#LED-点阵实验" class="headerlink" title="LED 点阵实验"></a>LED 点阵实验</h2><p>上面的方法只能确定某一具体的行被点亮。可不可以具体确定哪些点点亮的方法？</p>
<p>我们让想被点亮的点列为低电平，行为高电平，就会被点亮。如果我们只想点亮第一行第一列的点，只需行脚只有第一行接高电平，列脚只有第一列接低电平即可。</p>
<p>所以只要先让第一列为低电平，其他列为高天平来只读取第一列，遍历所有行检查第一列哪些点应该被点亮；然后第二列，第三列……一次类推，每轮循环不用消除上次的结果即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="comment">//编写程序先定义管脚和端口。管脚用sbit，端口宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_MATRIX P0</span></span><br><span class="line">sbit SRCLK=P3^<span class="number">6</span>;</span><br><span class="line">sbit rCLK=P3^<span class="number">5</span>;</span><br><span class="line">sbit SER=P3^<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> hc_led_arr[<span class="number">8</span>]=&#123;<span class="number">0x38</span>,<span class="number">0x7C</span>,<span class="number">0x7E</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x7E</span>,<span class="number">0x7C</span>,<span class="number">0x38</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> col[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> i)</span>&#123;<span class="keyword">while</span>(i--);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc_write_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span>&#123;</span><br><span class="line">	<span class="comment">//要传入8个输入，需要循环</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//注意 芯片传数据先传高位 再传低位，所以要反着写</span></span><br><span class="line">		<span class="comment">//通过移位获取</span></span><br><span class="line">		SER=c&gt;&gt;<span class="number">7</span>;</span><br><span class="line">		<span class="comment">//想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿</span></span><br><span class="line">		SRCLK=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//芯片一般给定一个延时时间，经过这个时间之后才能处理完毕</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		SRCLK=<span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//让传入数据的次高位变为下次循环的高位</span></span><br><span class="line">		c&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后通过存储寄存器的上升沿，传输全部数据</span></span><br><span class="line">	rCLK=<span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">	rCLK=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	LED_MATRIX=<span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		 <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		 	LED_MATRIX=col[i];</span><br><span class="line">		 	hc_write_data(hc_led_arr[i]);</span><br><span class="line">             <span class="comment">//不知道为什么，下面两部分不写图形会偏移。不知道会不会有大佬解答一下</span></span><br><span class="line">			delay(<span class="number">100</span>);</span><br><span class="line">			hc_write_data(<span class="number">0x00</span>);</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点阵的具体图案生成方法：字模提取软件。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202212301540684.png" alt="image-20220908234813283"></p>
<h1 id="步进电机"><a href="#步进电机" class="headerlink" title="步进电机"></a>步进电机</h1><p>电脉冲信号转化为角位移。</p>
<p><strong>注意步进电机红色线接到5V的地方。</strong>以下程序意为：启动步进电机后，按按钮1旋转方向改变，按按钮2加速，按按钮3减速。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">sbit IN1_A=P1^<span class="number">0</span>;</span><br><span class="line">sbit IN2_B=P1^<span class="number">1</span>;</span><br><span class="line">sbit IN3_C=P1^<span class="number">2</span>;</span><br><span class="line">sbit IN4_D=P1^<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义独立按键控制脚</span></span><br><span class="line">sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MINSPEED 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MAXSPEED 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">step_motor_28BYJ48_send_pulse</span><span class="params">(u8 step,u8 dir)</span>&#123;</span><br><span class="line">	u8 temp=step;</span><br><span class="line">	<span class="keyword">if</span>(dir==<span class="number">0</span>)temp=<span class="number">7</span>-step;<span class="comment">//逆时针旋转</span></span><br><span class="line">	<span class="keyword">switch</span>(temp)<span class="comment">//8 个节拍控制：A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">	<span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">	delay(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">	key=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">	&#123;</span><br><span class="line">	key=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 key=<span class="number">0</span>;</span><br><span class="line">	u8 dir=<span class="number">0</span>;</span><br><span class="line">	u8 speed=STEPMOTOR_MAXSPEED;</span><br><span class="line">	u8 step=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		key=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">switch</span>(key)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRESS:dir=!dir;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY2_PRESS:<span class="keyword">if</span>(speed&gt;STEPMOTOR_MINSPEED)speed-=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY3_PRESS:<span class="keyword">if</span>(speed&lt;STEPMOTOR_MAXSPEED)speed+=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		step_motor_28BYJ48_send_pulse(step++,dir);</span><br><span class="line">		step%=<span class="number">8</span>;</span><br><span class="line">		delay(speed*<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>使单片机能对外部或者内部随机发生的事件实时处理。</p>
<p>分时操作，实时响应，可靠性高。</p>
<p>中断相应条件：首先我们要确保相关配置都准备好了，CPU 允许中断，中断源允许中断，然后发生中断事件时才会正确触发中断。</p>
<p>中断可能还会被优先级更高的中断打断，支持这种操作的系统叫多级中断系统。</p>
<p>STC89C52 有8个中断，4外部，3定时器，1串口。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301270023159.png" alt="image-20230127002315074"></p>
<p>这是传统51单片机定时器中断结构，原理与 STC89C52 相近。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301270024434.png" alt="image-20230127002418325"></p>
<p>通过配置寄存器控制线路连接。比如上图中的开关就是由寄存器控制。</p>
<p>EA ENABLE ALL：即使能所有中断。</p>
<p>ET：中断允许位。</p>
<p>PT：中断优先级。只有一个 PT 只能决定是高或低两种优先级。更多的中断优先级寄存器可以决定更多中断优先级。</p>
<p>TCON 部分： time controller，不属于 CPU 部分，等到定时器部分展开叙述。</p>
<p>代码编写：主程序中需要包含：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">EA=<span class="number">1</span>;<span class="comment">//总中断开关：打开</span></span><br><span class="line">EX0=<span class="number">1</span>;<span class="comment">//外部中断0开关：打开。</span></span><br><span class="line">IT0=<span class="number">0</span>/<span class="number">1</span>;<span class="comment">//外部中断触发方式的选择。如下降沿触发，或低电平触发。</span></span><br><span class="line"><span class="comment">//如果要配置外部中断1，则改为EX1和IT1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">()</span> interrupt 0 using 1<span class="comment">//using 1 可省略</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时器中断实验"><a href="#定时器中断实验" class="headerlink" title="定时器中断实验"></a>定时器中断实验</h2><p>本章利用单片机自带的定时器来实现之前做过的操作：LED灯间歇闪烁。一直以来实现的方法都是借助while循环来拖延时间。定时器不仅更加准确，还可以节省下 CPU 的资源。</p>
<p>STC89C52 有3个定时器。</p>
<p><strong>CPU时序的相关知识</strong></p>
<p>振荡周期：为单片机提供信号的振荡源的周期（晶振周期）。12MHZ 的晶振振荡周期就是1&#x2F;12us, 求倒数。</p>
<p>状态周期：两个振荡周期&#x3D;1状态周期s（时钟周期）。</p>
<p>机器周期：6状态周期&#x3D;1机器周期。</p>
<p>指令周期：完成一条指令所用的全部时间，以机器周期为单位。</p>
<p><strong>定时器的相关知识</strong></p>
<p>定时器又可以计数，也叫计数器。不需要CPU参与自己就能完成任务，根据脉冲信号对寄存器中数据+1。来一个脉冲定时器+1，加到全为1后输出一个脉冲并归0.同时，向CPU发出计时器中断信息。</p>
<p>一般有四种工作模式：</p>
<p>13位定时器，16位定时器，8位自动重装模式，双8位计数器。</p>
<p>我们的工作模式用的是16位。</p>
<blockquote>
<p> 串口通信中为了精度考虑要使用自动重装模式。因为我们要自己设置每次溢出产生中断后 TH TL 的初值，这样吧比较容易出错且有点慢。8位自动重装模式就是舍弃了16位存储数据（到65535），只采用后八位 TL 计数（到255），初始值TH TL 赋一样的初值。TL 每次溢出，TH 把自己的值赋给 TL，这样就不用我们自己手动重新赋初值了，初值一直保存在 TH 中。</p>
<p>而且，在本例中我们使用定时器中断就是为了产生中断时给定时器赋初值并让灯切换状态。使用8位自动重装模式后，不用手动给定时器赋初值了；如果没有其他的需要定时器溢出时必须做的操作，定时器可以不用设置中断，起到一个可以看时间但是不会响的闹钟的功能，即 ET&#x3D;0。</p>
</blockquote>
<p>  <img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301262352827.png" alt="image-20230126235200709"></p>
<p>左上角支路是时钟功能，左下角支路是计数功能，最终实现中断功能。</p>
<p>TH TL 寄存器最大能存储到65535.每来一次脉冲+1，加到最大值时 flag 申请中断。</p>
<p>SYSCLK 是晶振周期。另一个时钟是 T0 引脚，如果启用 T0 引脚定时器就变成计数器了，每来一个脉冲+1。</p>
<p>默认使用12T 的分频，把 12MHZ 分成12份，每一份就是1us。这个单片机上是没有对应调整的寄存器的，如果想使用 6T 的分频需要在 STC-ISP 中选择使能 6T 模式。</p>
<p>CT 是一位寄存器，赋1为C，即计数器；赋0为T，即时钟（T上面的横线就代表0时）。</p>
<p>每个定时器主要有两种寄存器：TCON TMOD。</p>
<p>TCON 包括：TF, TR, IE, IT。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301271148775.png" alt="image-20230127114845707"></p>
<p>​	TF 可见上图主路，TH TL 被允许计数后周期性+1计数，加到最大值时 TF&#x3D;1，并发起中断。处理完中断后恢复为0.</p>
<p>​	TR 可见上图支路，是开启中断的条件之一。</p>
<p>​	IE 是外部中断。</p>
<p>​	IT 是设置中断触发模式，比如设置为0是低电平触发，设置为1是下降沿触发。</p>
<p>TMOD 是不可寻址的寄存器，也就是只能整体赋值，不能像 P2 一样分开给每个变量赋值。包含：GATE, CT, M0, M1.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301271149238.png" alt="image-20230127114908062"></p>
<p>​	GATE 用于开启定时器。当 GATE 打开, TR&#x3D;1（timer reset）且$\overline{INT1&#x2F;INT0}$ 为高（即打开中断引脚）时定时器开始工作。这一部分内容对应上图电路中的左下角。</p>
<p>​	M0M1 用于选定时钟的4个模式。比如16 位就是01. 两者包含一个叫做 TMOD 的不可位寻址的变量里，</p>
<p>​	CT就是打开定时器的计时还是时钟功能。</p>
<p>开启定时器计数功能及总中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD&amp;=<span class="number">0xF0</span>;<span class="comment">//设置定时器模式</span></span><br><span class="line">    TMOD|=<span class="number">0X01</span>;<span class="comment">//我们知道 TMOD 是不可位寻址，也就是里面虽然既包含了定时器1和0的寄存器，但是我们赋值只能一整个赋值。</span></span><br><span class="line">    <span class="comment">//如果直接给 TMOD=0x01，就会影响定时器1的值。因此我们用这两部先清空后四位，再单独给后四位赋值为0x01。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//TCON 中的 IE IT 对应就是支路图中的 INT0，因为我们开启了 GATE，或电路，因此 IE IT 不用设置也行。</span></span><br><span class="line">    <span class="comment">//我们知道 TH TL 合起来达到65535，也就是过了 65535个机器周期 后会触发中断。</span></span><br><span class="line">    <span class="comment">//比如我们现在想1ms触发一次中断，怎么处理呢？</span></span><br><span class="line">    <span class="comment">//12MHZ 下1us一个周期，1ms 1000个周期，因此我们每次设置初始值为64535，变为65535正好需要1ms。</span></span><br><span class="line">    <span class="comment">//11.0592MHz除12为921600Hz，就是1us 0.9216 个机器周期，因此初值为65535-922=64613.</span></span><br><span class="line">    <span class="comment">//我们可以给 TH TL 赋初始值，64535，这样只要过 1000us 就会触发中断。</span></span><br><span class="line">    <span class="comment">//然后因为 TH 和 TL 拼接变为一整个16位的寄存器，所以 TH 是高8位，TL 是低8位，分别用计算出的初值/256 %256得到最终结果。</span></span><br><span class="line">    TH0=<span class="number">0XFC</span>; <span class="comment">//64613/256=252=0xFC，我的单片机是 11.0592 MHZ</span></span><br><span class="line">    TL0=<span class="number">0X65</span>;<span class="comment">//64613%256=0x65</span></span><br><span class="line">    </span><br><span class="line">    TF0=<span class="number">0</span>;<span class="comment">//归零，防止刚配置好就产生中断。可有可无</span></span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器，开启中断条件之一</span></span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    PT0=<span class="number">0</span>;<span class="comment">//设置中断优先级为低。默认也是低，不写也没关系。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STC-ISP 上也有生成定时器函数。不过 AUXR 设置定时器时钟那一步是针对最新版本可以调整单片机定时器使能而添加的，我们的单片机加上会报错，需要删掉。</p>
<p>另外需要手动添加 ET EA PT。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301271643006.png" alt="image-20230127164307914"></p>
<p>LED灯间隔1s闪烁代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED=P2^<span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//不再重写了~</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  <span class="title function_">time0</span><span class="params">()</span> interrupt 1&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line">	TH0=<span class="number">0XFC</span>; <span class="comment">//因为触发中断时，TH TL 归零，所以记得赋初值！</span></span><br><span class="line">	TL0=<span class="number">0X65</span>;</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		i=<span class="number">0</span>;</span><br><span class="line">		LED=!LED;<span class="comment">//闪烁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	time0_init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="外部中断实验"><a href="#外部中断实验" class="headerlink" title="外部中断实验"></a>外部中断实验</h2><p><strong>运行程序前，请摘下红外接收传感器。因为共用P3^2引脚，会干扰实验结果。</strong></p>
<p>51单片机都有2个外部中断。STC89C5X系列有INT0~INT3四个。</p>
<p>对于三个参数的初始化，一般用一个init函数执行，在main的最开头。</p>
<p>本例中，我们用按键3作为外部中断源。按下按键3就会产生中断。中断执行的指令就是点亮或熄灭LED灯。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED=P2^<span class="number">0</span>;</span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">int</span> ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span>&#123;</span><br><span class="line">	EA=<span class="number">1</span>;<span class="comment">//总中断开关：打开</span></span><br><span class="line">	EX0=<span class="number">1</span>;<span class="comment">//外部中断0开关：打开。</span></span><br><span class="line">	IT0=<span class="number">1</span>;<span class="comment">//外部中断触发方式的选择。如下降沿触发，或低电平触发。	</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">int0</span><span class="params">()</span> interrupt 0&#123;</span><br><span class="line">	delay(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">if</span>(KEY3==<span class="number">0</span>)&#123;</span><br><span class="line">		LED=!LED;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	interrupt_init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><h2 id="通信基础知识"><a href="#通信基础知识" class="headerlink" title="通信基础知识"></a>通信基础知识</h2><p>单片机还可以通过IO口实现多种通信。</p>
<p><strong>串行通信</strong>：一条数据线，一次发1bit，发很久。</p>
<p><strong>并行通信</strong>：多条数据线，同时发送，发的速度快多了但是费用高、接收困难、抗干扰性差。</p>
<p><strong>异步通信</strong>：发送和接收方时钟可以不用完全一致。</p>
<p><strong>同步通信</strong> ：发送和接收方时钟要完全一致。</p>
<p><strong>单工、半双工、全双工通信</strong>：数据的传输方式，略。</p>
<p>比特率：位&#x2F;s。</p>
<p>波特率：码元&#x2F;s。</p>
<p>溢出率：比如13us溢出一次。溢出率就是1&#x2F;13us。</p>
<p>校验位：如奇偶校验位。</p>
<p>停止位：分隔数据帧。</p>
<p>（有那么一点点感谢通原了~）</p>
<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p>串口通信，指外设和计算机之间通过数据线等传输数据的一种通信方式。比如RS-系列，大多数计算机应该都有对应的梯形接口。51单片机内自带<strong>UART</strong>（Universal Asynchronous Receiver Transmitter，通用异步收发器），可实现与计算机之间的串口通信！</p>
<p>单片机串口通信的管脚：VCC TXD（发送数据，串行输出）RXD（接收数据，串行输入）SGND（信号接地）。</p>
<p><em>电脑的串口还有很多管脚，如 RTS CTS，单片机的相对简单很多。</em></p>
<p>TXD和RXD用正负电压表示逻辑1和0，51单片机采用TTL 晶体管-晶体管逻辑集成电路，用高低电平表示逻辑状态（+5V：1；0V：0），所以需要转换型时候才能与计算机串口通信。</p>
<p><em>还有两种电平状态：RS232，3<del>15V 表示低（注意），-15</del>-3V 表示高。RS485，两线压差（差分信号）2<del>6V 表示高，-6</del>-2V 表示低。</em></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301282311596.png" alt="image-20230128231105461"></p>
<p>STC89C52系列有一个通用异步收发器（UART P30 P31端口），有四种工作模式。</p>
<ul>
<li>模式0：同步移位寄存器；</li>
<li>模式1：8位UART，波特率可变（<strong>常用</strong>）；</li>
<li>模式2：9位UART，波特率固定；</li>
<li>模式3：9位UART，波特率可变.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301290130378.png" alt="image-20230129013008311"></p>
<p>TXD RXD 直接接到单片机 P30 P31 上. 另一端是单片机上自带的，我们把数据线连到电脑上就接上了。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301290143413.png" alt="image-20230129014312317"></p>
<p>溢出率到波特率的计算见图。</p>
<p>串口助手和单片机要规定好发送数据的形式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301291933058.png" alt="image-20230129193307966"></p>
<p>串口数据缓存寄存器：SBUF。物理上是接收和发送两个寄存器，实际上共用相同的地址，只是使用时有不同的意义。我们只需要把数据放入其中就行，发送原理暂不用弄明白。</p>
<p>SCON：串口控制寄存器。控制电路。包含：</p>
<p>​	SM0，SM1：设置工作方式。比如我们采用8位 UART，就赋值01.</p>
<p>​	SM2：与工作方式1无关。</p>
<p>​	REN：是否允许串行接收状态。1允许接收。</p>
<p>​	TB8 RB8：接收到的第9位数据，与工作方式1无关。</p>
<p>​	TI RI：发送接收中断请求标志位。代表发送完了。硬件赋1，需要用软件复位。</p>
<p>赋值的话只有 SM0 SM1&#x3D;01，和 REN 需要注意，其他的初始值都&#x3D;0。</p>
<p>PCON：电源管理。包含：</p>
<p>​	SMOD：可见支路图，用于设置波特率是否加倍。</p>
<p>​	SMOD1：纠错或协助 SM0 设置工作方式。</p>
<p>IE：打开中断。</p>
<p>移位寄存器会触发对应中断。在中断图中的 TI RI，触发的是同一个中断。</p>
<p><strong>实施串口通信</strong></p>
<p>STC-ISP自带一个串口调试助手。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301030207020.png" alt="image-20230103020705868"></p>
<p>串口选择左侧和串口号一致的选项。</p>
<p>STC89C52串口初始化函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">    SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1。40是 REN 关闭，50是打开，代表单片机是否可以接收数据</span></span><br><span class="line">    PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍，0就是不加倍</span></span><br><span class="line">    TH1=<span class="number">0XFA</span>; <span class="comment">//计数器初始值设置，根据波特率为9600</span></span><br><span class="line">    TL1=<span class="number">0XFA</span>;</span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//打开计数器1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化函数也可以在 STC-ISP 中生成。这里会发现 12MHZ 的晶振相较 11.0592 MHZ 的晶振误差较大，要通过波特率加倍才能减少一些。这就是 11.0592 MHZ 晶振的设计原因。</p>
<p><strong>单片机向电脑发送数据</strong>：给SBUF赋值即可。</p>
<p>在程序中发送可以直接<code>SBUF=0X11;</code>单片机就会收到11的信息，点击复位按钮后可以在串口助手的接收缓冲区中看到。</p>
<p>赋值后需要一段时间才能发送完成，发送完成后TI不再是0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    uart_init();</span><br><span class="line">    SBUF=<span class="number">0x11</span>;</span><br><span class="line">    <span class="keyword">while</span>(TI==<span class="number">0</span>);TI=<span class="number">0</span>;<span class="comment">//=1说明发送完成，然后手动复位</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就在程序中发送了11信息。</p>
<p><strong>电脑给单片机发送数据</strong>：通过串口助手发信息可以通过串口中断<code>interrupt 4</code>实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart</span><span class="params">()</span> interrupt 4 <span class="comment">//串口通信中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    u8 rec_data;</span><br><span class="line">    P2=<span class="number">0x00</span>;<span class="comment">//这一句使得函数成功触发时LED灯全亮，便于调试</span></span><br><span class="line">    <span class="keyword">if</span>(RI==<span class="number">1</span>)&#123;P2=~SBUF;RI=<span class="number">0</span>;&#125;<span class="comment">//因为发送和接收中断共用4中断，这句用于区分具体是发送还是接收中断</span></span><br><span class="line">    <span class="comment">//如果是接收中断，RI=1，那么只简单执行这两句即可。</span></span><br><span class="line">    SBUF=rec_data; <span class="comment">//将接收到的数据放入到发送寄存器</span></span><br><span class="line">    <span class="keyword">while</span>(!TI); <span class="comment">//等待发送数据完成</span></span><br><span class="line">    TI=<span class="number">0</span>; <span class="comment">//清除发送完成标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序可以将发送缓冲区中输入的数据发给单片机，单片机再在接收缓冲区中原封不动地呈现出来。</p>
<p>文本模式和 HEX 模式就是文本和 ASCII 码的转换。</p>
<h1 id="封装头文件；绘制LED动画"><a href="#封装头文件；绘制LED动画" class="headerlink" title="封装头文件；绘制LED动画"></a>封装头文件；绘制LED动画</h1><p>类似C语言的语法，部分函数等内容可以封装到头文件里，需要的时候引入到source file 中，再在 include 中指明即可正常使用。</p>
<p>编写.h文件：如：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301031627395.png" alt="image-20230103162731330"></p>
<p>引入.h文件：右键左侧的.c文件→options for file→C51→include path→找到.h文件所在的文件夹并选中，注意<strong>一定不能有中文路径</strong>。然后就可以使用.h文件中定义的变量和函数了，注意<strong>不能重复定义</strong>。</p>
<p>什么内容封装到函数里呢？静态的方法待调用的封装进去。逻辑判断后决定使用哪个方法这类的就不用放进函数里了，因为逻辑判断很可能经常改。</p>
<p>接下来就自己试着先把delay函数和矩阵LED绘制函数写入头文件，然后制作矩阵动画，这样动起来也会更方便一些。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;</span><br><span class="line"></span><br><span class="line">	sbit SRCLK = P3 ^ <span class="number">6</span>;</span><br><span class="line">	sbit rCLK = P3 ^ <span class="number">5</span>;</span><br><span class="line">	sbit SER = P3 ^ <span class="number">4</span>;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function name: time0_init</span></span><br><span class="line"><span class="comment"> * Function paremeter: void</span></span><br><span class="line"><span class="comment"> * Function performance: 初始化定时器。只有执行此函数后才能使用单片机的定时器功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD |= <span class="number">0X01</span>; <span class="comment">// 选择为定时器 0 模式，工作方式 1</span></span><br><span class="line">	TH0 = <span class="number">0XFC</span>;	  <span class="comment">// 给定时器赋初值，定时 1ms</span></span><br><span class="line">	TL0 = <span class="number">0X18</span>;</span><br><span class="line">	ET0 = <span class="number">1</span>; <span class="comment">// 打开定时器 0 中断允许</span></span><br><span class="line">	EA = <span class="number">1</span>;	 <span class="comment">// 打开总中断</span></span><br><span class="line">	TR0 = <span class="number">1</span>; <span class="comment">// 打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function name:time0</span></span><br><span class="line"><span class="comment"> * Function paremeter: void</span></span><br><span class="line"><span class="comment"> * Function performance: 启动定时器。定时器计数器time_counter在0~10000之间循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void time0() interrupt 1&#123;</span></span><br><span class="line"><span class="comment">	TH0=0XFC; //给定时器赋初值，定时 1ms</span></span><br><span class="line"><span class="comment">	TL0=0X18;</span></span><br><span class="line"><span class="comment">	time_counter++;</span></span><br><span class="line"><span class="comment">	bit pass_1s=0;</span></span><br><span class="line"><span class="comment">	if(time_counter==1000)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		time_counter=0;</span></span><br><span class="line"><span class="comment">		pass_1s=~pass_1s;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(u16 delay_10us)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(delay_10us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc_write_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 要传入8个输入，需要循环</span></span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 注意 芯片传数据先传高位 再传低位，所以要反着写</span></span><br><span class="line">		<span class="comment">// 通过移位获取</span></span><br><span class="line">		SER = c &gt;&gt; <span class="number">7</span>;</span><br><span class="line">		<span class="comment">// 想获取下一位寄存器，需要移位寄存器移位。需要创造上升沿</span></span><br><span class="line">		SRCLK = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 芯片一般给定一个延时时间，经过这个时间之后才能处理完毕</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		SRCLK = <span class="number">1</span>;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 让传入数据的次高位变为下次循环的高位</span></span><br><span class="line">		c &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后通过存储寄存器的上升沿，传输全部数据</span></span><br><span class="line">	rCLK = <span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">1</span>);</span><br><span class="line">	rCLK = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">matrix_led_animation</span><span class="params">(u8 hc_led_arr[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> col[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	P0=<span class="number">0x00</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		P0=col[i];</span><br><span class="line">		hc_write_data(hc_led_arr[i]);</span><br><span class="line">        <span class="comment">//不知道为什么，下面两部分不写图形会偏移。不知道会不会有大佬解答一下</span></span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">		hc_write_data(<span class="number">0x00</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是利用取模软件得到要绘制的图案的字模。这里我选定的图案是之前圣诞节临摹过的像素画中”Merry Christmas“的字体。参照来源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ZK41167sF/?spm_id_from=333.337.search-card.all.click">圣诞节 像素画 圣诞树🎄_哔哩哔哩_bilibili</a></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301041233469.png" alt="image-20230104123321341"></p>
<p>绘制部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;MyHFile.H&gt;</span></span></span><br><span class="line">u8 anime_row[]=&#123;</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>,</span><br><span class="line"> <span class="number">0x40</span>, <span class="number">0x7C</span>, <span class="number">0x40</span>, <span class="number">0x7C</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x14</span>, <span class="number">0x18</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x1D</span>,</span><br><span class="line"> <span class="number">0x05</span>, <span class="number">0x1F</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>, <span class="number">0x44</span>, <span class="number">0x44</span>, <span class="number">0x44</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x7C</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>, <span class="number">0x00</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x5C</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x7C</span>, <span class="number">0x14</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x1C</span>, <span class="number">0x00</span>, <span class="number">0x0C</span>, <span class="number">0x14</span>,</span><br><span class="line"> <span class="number">0x1C</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"> <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">for</span>(cnt;cnt&lt;<span class="number">62</span>;cnt++)&#123;</span><br><span class="line">		u8 row[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		row[<span class="number">0</span>]=anime_row[cnt];</span><br><span class="line">		row[<span class="number">1</span>]=anime_row[cnt+<span class="number">1</span>];</span><br><span class="line">		row[<span class="number">2</span>]=anime_row[cnt+<span class="number">2</span>];</span><br><span class="line">		row[<span class="number">3</span>]=anime_row[cnt+<span class="number">3</span>];</span><br><span class="line">		row[<span class="number">4</span>]=anime_row[cnt+<span class="number">4</span>];</span><br><span class="line">		row[<span class="number">5</span>]=anime_row[cnt+<span class="number">5</span>];</span><br><span class="line">		row[<span class="number">6</span>]=anime_row[cnt+<span class="number">6</span>];</span><br><span class="line">		row[<span class="number">7</span>]=anime_row[cnt+<span class="number">7</span>];</span><br><span class="line">		matrix_led_animation(row);</span><br><span class="line">		delay(<span class="number">5000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然因为每次绘制完成必须擦除再重新绘制，导致看起来一闪一闪的。</p>
<p>不过最终的动画效果还是不错的~</p>
<h1 id="IIC-AT24C02"><a href="#IIC-AT24C02" class="headerlink" title="IIC, AT24C02"></a>IIC, AT24C02</h1><p>掉电不丢失的存储器。存储结构是 E2PROM，通讯方式是 I2C。</p>
<h2 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h2><p>存储器主要分为 RAM 易失性存储器和 ROM 非易失性存储器，RAM 存取快但掉电丢失，ROM 正相反。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170018818.png" alt="image-20230217001811596" style="zoom:80%;" />

<p>SRAM：锁存器，速度最快。</p>
<p>DRAM：电容，充电1放电0. 但是电容漏电比较严重，需要扫描器每隔一段时间检查一下是否漏电，漏电再充。</p>
<p>ROM 名字来源于 read-only，但是后期的非易失性存储器都可以写入，只是沿用了名字。</p>
<p>MASK ROM：不可写入。</p>
<p>PROM：只能写入一次。</p>
<p>EPROM：可擦除，但是形式比较麻烦，要用紫外线照射很久。</p>
<p>E2PROM：电擦除更加方便，我们现在的单片机所用。但是容量小。</p>
<p>FLASH：应用广泛。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170605706.png" alt="image-20230217060513510" style="zoom: 50%;" />

<p>这只是一个有助理解的简化模型~</p>
<p>选定一些结点导通，比如我们读取第一行地址1处的数据，发现第1&#x2F;2&#x2F;3个结点导通，其他节点都未导通，则从最下端读到的该处地址的数据为：1110 0000。</p>
<p>MASK ROM 中，两条线中没有二极管，则两条线都通电流就会导通。有二极管后，数据总线无法流下来，为低电平。</p>
<p>PROM 中如何实现可编程写入一次？蓝色的二极管容易被击穿。被击穿后二极管的通路变为断路，导通；否则和 MASK ROM 低电平原理一样。</p>
<p>EPROM 是二极管可以恢复。</p>
<p>选中哪条总线可以通过三位138译码器的输入决定。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170627913.png" alt="image-20230217062720840"></p>
<p>VCC 范围：1.8~5.5v</p>
<p>WE&#x2F;WR：写保护，WR 高电平保护，不能写入。可以看到 WE 标明低电平启用，而且单片机上的 EEPROM 直接 WE 接地了。</p>
<p>SCL SDA：I2C 接口。</p>
<p>E1 E2：I2C 地址。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170634937.png" alt="image-20230217063431839"></p>
<p>大概是能看懂的。SCL SDA 传入数据后，看是 R&#x2F;W 哪个地址里的数据，通过 DEC 译码器找到地址 R&#x2F;W，通过串行多路复用器 serial MUX 把并行数据转化为串行并输出。</p>
<h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><p>I2C（Inter－Integrated Circuit BUS）总线是由 PHILIPS 公司开发的两线式 串行总线，用于连接微控制器及其外围设备。因为各家自己开发的数据总线可能不通用，PHILIPS 公司开发了这款统一通信标准。这样不仅方便了芯片开发，也便于大家学习。</p>
<h3 id="I2C-结构"><a href="#I2C-结构" class="headerlink" title="I2C 结构"></a>I2C 结构</h3><p>I2C 只有两根双向信号线，一根是 SDA 数据线，一根是 SCL 时钟线。是同步、半双工的通信线，带数据应答。</p>
<p>所有设备的 SCL 和 SDA 都连在总线上。设备的 SCL SDA 是开漏输出的（高电平直接接地），SCL 和 SDA 又要添加弱上拉电阻。这两共同作用实现了“线与”的功能，避免各个设备通信相互干扰。</p>
<p>如下图所示，设备上的 SCLK SDA 是开漏输出。如果给高电平导通开关， IN 也是接地，该设备就无法读取输入数据不会被干扰。否则如果是低电平关闭开关，数据会流出 DATA IN。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302170723919.png" alt="image-20230217072355835"></p>
<p>主机：启动数据传送并产生时钟信号的设备； </p>
<p>从机：被主机寻址的器件； </p>
<p>多主机：同时有多于一个主机尝试控制总线但不破坏传输； </p>
<p>主模式：用 I2CNDAT 支持自动字节计数的模式； 位 I2CRM,I2CSTT,I2CSTP 控制数据的接收和发送； </p>
<p>从模式：发送和接收操作都是由 I2C 模块自动控制的； </p>
<p>仲裁：是一个在有多个主机同时尝试控制总线但只允许其中一个控制总线并 使传输不被破坏的过程； </p>
<p>同步：两个或多个器件同步时钟信号的过程； </p>
<p>发送器：发送数据到总线的器件；</p>
<p>接收器：从总线接收数据的器件。</p>
<h3 id="I2C-协议"><a href="#I2C-协议" class="headerlink" title="I2C 协议"></a>I2C 协议</h3><p>①时钟信号周期性的高电平低电平。只有时钟信号为低电平时，数据信号才能变化。</p>
<p>②起始和停止信号：SCLK 高电平时，SDA 由高→低为开始，低→高为结束。</p>
<p>④发送数据：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171111865.png" alt="image-20230217111133747" style="zoom:67%;" />

<p>先发 start 标识，后跟一个字节，第一个字节是地址+读写位。前四位固定，比如 24C02 是1010. 后三位是地址。收到接收应答后就开始发送数据。读写位 $R&#x2F;\overline{W}$ .</p>
<p>SCLK 低电平时，SDA 先设置好要传的数据。然后 SCLK 变为高电平后 SDA 不允许再数据变化，SCLK 先读取数据。这样发送一位，SCLK 再变为低电平，如此循环。</p>
<p>发送器件传输完一个字节8位数据后，后面必须紧跟一个ACK&#x2F;NACK校验位，判断接受是否完成，数据传送是否可以继续。接收方会让主机在发完的下一个时钟信号收到接收应答。 </p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301042045379.png" alt="image-20230104204527296"></p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171118952.png" alt="image-20230217111807804" style="zoom: 80%;" />

<p>复合数据帧格式：先发再收。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171135305.png" alt="image-20230217113542179" style="zoom:80%;" />

<p>字节写：规定一个字节数据地址，写入和读取都去那里。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171137046.png" alt="image-20230217113728972" style="zoom:80%;" />

<p>随机读：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302171927490.png" alt="image-20230217192714230" style="zoom:80%;" />

<p>③总线寻址方式</p>
<p>从机有自己的地址，总线寻址采用7或10位的寻址位数。如7位：位定义D0表示数据传送方向位（是主机从从机读取数据？还是主机向从机写数据？代表这个从机是接收器还是发送器），D7~D1是从机地址位。</p>
<p>主机发送一个地址后，所有从机前7位地址和主机比较，如果相同再判断从机是接收还是发送器。</p>
<p>从机地址包含固定位和可编程位，可编程位决定了这个部件可以最多有多少个接入总线。如4位固定位，3位可编程位，说明2^3&#x3D;8个最多可以接入总线。</p>
<p>④数据传输</p>
<p>起始信号 S+7位从机地址+数据方向位+ACK+数据+NACK+终止信号。如果主机还想要新的数据传送，可以不终止，继续发出起始信号向另一从机寻址。</p>
<p>数据方向位&#x3D;0：主机向从机发送数据。主机一直发到从机返回 NACK 为止。</p>
<p>数据方向位&#x3D;1：从机向主机发送数据，发送到主机返回 NACK 为止。</p>
<h2 id="AT24C02"><a href="#AT24C02" class="headerlink" title="AT24C02"></a>AT24C02</h2><p>是一个2k位串行CMOS，主板上的主板上的一块可读写的并行或串行FLASH芯片。该芯片有 I2C 接口，是个从机。而且有写保护功能，其中写入的数据断电不丢失。</p>
<p>我们可以通过单片机的模拟 IIO 功能，将数据写入该芯片永久存储，下次断电时也能访问。</p>
<h2 id="创建多文件工程"><a href="#创建多文件工程" class="headerlink" title="创建多文件工程"></a>创建多文件工程</h2><p>下面编写的程序要求：</p>
<p>设计一个系统，可以写入、读取 AT24C02 中的数据，并将其中的数据用数码管显示出来。</p>
<p>这个系统涉及之前学过的按键、数码管信息，还涉及新的 AT24C02 的使用，三部分代码。由于内容太多，所以这次我们创建一个多文件系统，以后也会用这个系统模板更好的管理文件。</p>
<p>本项目主要包含：</p>
<p>App 文件夹：存储各类函数</p>
<p>Obj 文件夹：存放编译产生的 hex 文件、列表清单等。</p>
<p>Public 文件：存放公共文件，如延时、变量重定义。</p>
<p>User：存放 main.c 等主函数文件。</p>
<p><strong>创建步骤：</strong></p>
<p>①新建一个项目文件夹，在该项目文件夹中新建以上四个文件夹。</p>
<p>②在 Keil 中新建项目，选中这个项目文件夹。选择不复制 StartUp 代码。</p>
<p>③点击魔术棒右边的三色方块，创建三个分组 Group。这里创建的分组是一个逻辑上的分组，并不是指选中这三个具体的文件夹。与三个文件夹起名相同是为了方便管理.</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301051154952.png" alt="image-20230105115404825"></p>
<p>④编写程序.</p>
<p>清楚了我们的需求，我们想一下要写那些代码，放在什么地方。</p>
<p>公共内容：public 中。</p>
<p>使用按钮代码：App中。</p>
<p>使用数码管代码：App中。</p>
<p>使用 AT24C02 代码：App 中。</p>
<p>调用以上几部分内容代码：main 中。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301051344402.png" alt="image-20230105134459205"></p>
<p>把普中部分代码复制到单片机中，大意：按键1将当前数据写入芯片，按键2读取芯片中存储的数据，按键3将当前数据+1，按键4将当前数据清零。</p>
<p>iic：定义i2c总线的一些方法。如开始等待接收数据、结束关闭、ack、nack、wait ack、读取写入数据等方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////iic.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _iic_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _iic_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义EEPROM控制脚</span></span><br><span class="line">sbit IIC_SCL=P2^<span class="number">1</span>;<span class="comment">//SCL时钟线</span></span><br><span class="line">sbit IIC_SDA=P2^<span class="number">0</span>;<span class="comment">//SDA数据线</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//IIC所有操作函数				 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_start</span><span class="params">(<span class="type">void</span>)</span>;			<span class="comment">//发送IIC开始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_stop</span><span class="params">(<span class="type">void</span>)</span>;	  		<span class="comment">//发送IIC停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_write_byte</span><span class="params">(u8 txd)</span>;	<span class="comment">//IIC发送一个字节</span></span><br><span class="line">u8 <span class="title function_">iic_read_byte</span><span class="params">(u8 ack)</span>;		<span class="comment">//IIC读取一个字节</span></span><br><span class="line">u8 <span class="title function_">iic_wait_ack</span><span class="params">(<span class="type">void</span>)</span>; 			<span class="comment">//IIC等待ACK信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_ack</span><span class="params">(<span class="type">void</span>)</span>;				<span class="comment">//IIC发送ACK信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_nack</span><span class="params">(<span class="type">void</span>)</span>;			<span class="comment">//IIC不发送ACK信号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///////////iic.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>; <span class="comment">// SCL为高电平时，SDA的数据才有效</span></span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SDA = <span class="number">0</span>; <span class="comment">// SCL SDA 都由高变低，是起始标志</span></span><br><span class="line">    </span><br><span class="line">	delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_stop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_ack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_SDA = <span class="number">0</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_nack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    IIC_SDA = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    delay(<span class="number">10</span>);</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">iic_wait_ack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 time_temp = <span class="number">0</span>;</span><br><span class="line">    IIC_SCL = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (IIC_SDA)</span><br><span class="line">    &#123; <span class="comment">// 等待数据变成0</span></span><br><span class="line">        <span class="keyword">if</span> (++time_temp &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            iic_stop();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">iic_read_byte</span><span class="params">(u8 ack)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>, receive = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        IIC_SCL = <span class="number">0</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL = <span class="number">1</span>;</span><br><span class="line">        receive &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (IIC_SDA)</span><br><span class="line">            receive += <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        iic_nack();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iic_ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_write_byte</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i = <span class="number">0</span>;</span><br><span class="line">    IIC_SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dat &amp; <span class="number">0x80</span>) &gt; <span class="number">0</span>)</span><br><span class="line">            IIC_SDA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            IIC_SDA = <span class="number">0</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL = <span class="number">1</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL = <span class="number">0</span>;</span><br><span class="line">        delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>24c02：主要就是芯片调用iic来写入或取出数据的函数。看上去倒没有多少自己的东西。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////24c02.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _24c02_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _24c02_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_write_one_byte</span><span class="params">(u8 addr, u8 dat)</span>;</span><br><span class="line">u8 <span class="title function_">at24c02_read_one_byte</span><span class="params">(u8 addr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////24c02.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;24c02.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_write_one_byte</span><span class="params">(u8 addr, u8 dat)</span>&#123;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0xA0</span>);<span class="comment">//写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr);<span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(dat);</span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_stop();<span class="comment">//停止条件</span></span><br><span class="line">    delay(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">at24c02_read_one_byte</span><span class="params">(u8 addr)</span>&#123;</span><br><span class="line">	u8 temp;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0xA0</span>);<span class="comment">//写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr);<span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(<span class="number">0xA1</span>);<span class="comment">//进入接收模式</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    temp=iic_read_byte(<span class="number">0</span>);<span class="comment">//读取条件</span></span><br><span class="line">    iic_stop();<span class="comment">//停止条件</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>public.h和.c里面就是装了u8 u16 和 delay 函数的定义。不用多说。</p>
<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;public.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;key.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;display.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;24c02.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_ADDRESS 0<span class="comment">//数据存入EEPROM 的起始地址</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    u8 key_temp=<span class="number">0</span>;</span><br><span class="line">    u8 save_value=<span class="number">0</span>;<span class="comment">//每次刚打开单片机时，起始值都=0</span></span><br><span class="line">    u8 save_buf[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        key_temp=key_scan(<span class="number">0</span>);<span class="comment">//单词扫描按键获取当前按键</span></span><br><span class="line">        <span class="keyword">switch</span>(key_temp)&#123;<span class="comment">//按键1：写入</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">case</span> KEY1_PRESS:</span><br><span class="line">                at24c02_write_one_byte(EEPROM_ADDRESS,save_value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KEY2_PRESS:</span><br><span class="line">                save_value=at24c02_read_one_byte(EEPROM_ADDRESS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KEY3_PRESS:</span><br><span class="line">                <span class="keyword">if</span>(save_value&lt;<span class="number">255</span>)save_value++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> KEY4_PRESS:</span><br><span class="line">                save_value=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        save_buf[<span class="number">0</span>]=save_value/<span class="number">100</span>;</span><br><span class="line">        save_buf[<span class="number">1</span>]=save_value/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">        save_buf[<span class="number">2</span>]=save_value%<span class="number">10</span>;</span><br><span class="line">        smg_display(save_buf,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> dat=<span class="number">0</span>,KeyNum;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	<span class="comment">//LCD_ShowString(1,1,&quot;Hello!&quot;);</span></span><br><span class="line">	<span class="comment">//AT24C02_WriteByte(1,66);//256 位字节，存入数据不 &gt;256</span></span><br><span class="line">	<span class="comment">//delayMs(50);//两次写之间需要的时间间隔</span></span><br><span class="line">	<span class="comment">//AT24C02_WriteByte(2,34);//256 位字节</span></span><br><span class="line">	<span class="comment">//delayMs(50);</span></span><br><span class="line">	<span class="comment">//dat=AT24C02_ReadByte(1);</span></span><br><span class="line">	<span class="comment">//delayMs(50);</span></span><br><span class="line">	<span class="comment">//dat1=AT24C02_ReadByte(2);</span></span><br><span class="line">	LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		KeyNum=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">switch</span>(KeyNum)&#123;</span><br><span class="line">			<span class="keyword">case</span> KEY1_PRESS:</span><br><span class="line">				<span class="keyword">if</span>(dat&lt;<span class="number">255</span>)dat+=<span class="number">1</span>;</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;++&quot;</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY2_PRESS:</span><br><span class="line">				<span class="keyword">if</span>(dat&gt;<span class="number">0</span>)dat-=<span class="number">1</span>;</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;--&quot;</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY3_PRESS:</span><br><span class="line">				AT24C02_WriteByte(<span class="number">1</span>,dat);</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Write Complete!&quot;</span>);</span><br><span class="line">				delayMs(<span class="number">50</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> KEY4_PRESS:</span><br><span class="line">				dat=AT24C02_ReadByte(<span class="number">1</span>);</span><br><span class="line">				LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Read Complete!&quot;</span>);</span><br><span class="line">				LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,dat,<span class="number">3</span>);	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p>一开始运行，显示当前数字000.</p>
<p>按下按钮1，数字++。</p>
<p>按下按钮2，数字–。</p>
<p>按下按钮3，当前数字会写入。</p>
<p>按下按钮4，会读取 AT24C02 中存储的数字显示出来。断电也能保存。</p>
<p>一个字节确实只能存到 255. 我们可以拿 12 两个存储地址合起来存储一个数据，一个存储高八位 &#x2F;256，一个存储低八位 %256. 取数据的时候 <code>datl|=dath&lt;&lt;8;</code></p>
<p>写入多位时，延时间隔应该&gt;5ms！因为 at24c02 的写入还是很慢的。</p>
<h1 id="温度传感器-DS18B20"><a href="#温度传感器-DS18B20" class="headerlink" title="温度传感器 DS18B20"></a>温度传感器 DS18B20</h1><p>单片机上自带的温度传感器模块：DS18B20。是一种常见的数字温度传感器。不用 ADC，自己处理好数据后放到 RAM 中，我们取出来就能用。</p>
<p>总线结构，可以把很多设备挂到总线上，省 IO 口；有温度报警装置；寄生供电（总线高电平可以供电）.</p>
<p>寄生供电需要添加强上拉电阻。</p>
<p>传感器很简单，只有三个引脚：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303222226823.png" alt="image-20230322222620666"></p>
<p>DQ 是 P37。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303222324058.png" alt="image-20230322232422937"></p>
<p>具体结构如上图。寄生供电使得 DQ 也可以供电。</p>
<p>ROM 是寻址用，可以跳过。</p>
<p>SCRATCHPAD：暂存器，读取的数据在其中。</p>
<p>EEPROM：存储一些配置信息，比如报警阈值，精度。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303222358570.png" alt="image-20230322235814438"></p>
<p>DS18B20 采用异步半双工的单总线，加上寄生供电，使得只要两根线就能驱动。不过这种结构并不常见。</p>
<p>我们将检测到的温度通过数码管显示出来。数码管的传入函数和IIC的一样，将外部dat数组传给数码管。</p>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>主机输出低电平拉低总线 480<del>960 us，释放总线；外部上拉电阻把总线拉高，延时 15</del>60 us 进入接收模式。接着 DS18B20 拉低总线 60~240 us。</p>
<p>我们要在主机释放总线后，检测一下一定时间内总线是否被拉低了，拉低了说明有从机。然后再检测一定时间内从机是否把总线又释放了。</p>
<h2 id="发送一位数据"><a href="#发送一位数据" class="headerlink" title="发送一位数据"></a>发送一位数据</h2><p>主机拉低总线 60~120 us 后释放：0.</p>
<p>主机拉低总线 1~15 us ：1.</p>
<p>一般发送间隔 1ms。</p>
<p>从机拉低 30us 读取数据。</p>
<h2 id="读取一位数据"><a href="#读取一位数据" class="headerlink" title="读取一位数据"></a>读取一位数据</h2><p>主机拉低总线 15us，接近结束时释放，看一下总线是否释放。</p>
<p>如果释放了，说明从机在发送数据1，在 15us 内就释放了。</p>
<p>如果没释放，说明从机还在拉着总线，是打算拉 60us 以上的0.</p>
<p>至于发送读取是否会混淆，无需担心，因为总线发送给主机指令来决定其作用。</p>
<h2 id="发送-接收字节"><a href="#发送-接收字节" class="headerlink" title="发送 接收字节"></a>发送 接收字节</h2><p>连续读或发1个字节 8次。低位在前。</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>从机复位，主机检测从机是否响应；</p>
<p>ROM 指令+本指令是 R&#x2F;W；</p>
<p>功能指令+本指令是 R&#x2F;W。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303241521091.png" alt="image-20230324152054926"></p>
<p>因为只有一个从机，所以这里用 skip rom 指令 跳过地址校验。</p>
<p>功能指令：</p>
<ul>
<li>转换温度：该指令一发出，立刻转换温度后放在暂存器中。</li>
<li>写入寄存器：只写3个字节。TH TL configuration register。</li>
<li>读寄存器：读出寄存器数据。我们知道温度值只是前2个字节，所以简单处理只读2个字节即可。</li>
<li>copy：寄存器指令写入 EEPROM。RECALL 相反。</li>
<li>read power supply：检测是否寄生供电，这里我们也不需要。</li>
</ul>
<p>温度变换：init-跳过 ROM-转换温度。</p>
<p>温度读取：init-跳过 ROM-读取温度-持续读取。</p>
<p>温度&gt;0：*0.625</p>
<p>温度&lt;0：取反+1，再*0.625</p>
<p>具体代码解释在下文的注释中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line">sbit DS18B20_PORT=P3^<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化序列：首先拉低总线至少480us，以产生复位脉冲。接着主机释放总线，延时至少15us，进入接收模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_reset</span><span class="params">()</span>&#123;</span><br><span class="line">	DS18B20_PORT=<span class="number">0</span>;<span class="comment">//拉低DQ</span></span><br><span class="line">	delay(<span class="number">75</span>);<span class="comment">//拉低750us</span></span><br><span class="line">	DS18B20_PORT=<span class="number">1</span>;<span class="comment">//DQ=1</span></span><br><span class="line">	delay(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds18b20_check</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 time_temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(DS18B20_PORT&amp;&amp;time_temp&lt;<span class="number">20</span>)&#123;</span><br><span class="line">		time_temp++;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//超时跳出，而不是因为DQ变低跳出</span></span><br><span class="line">	<span class="keyword">else</span> time_temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((!DS18B20_PORT)&amp;&amp;time_temp&lt;<span class="number">20</span>)&#123;</span><br><span class="line">		time_temp++;</span><br><span class="line">		delay(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds18b20_init</span><span class="params">()</span>&#123;</span><br><span class="line">	ds18b20_reset();</span><br><span class="line">	<span class="keyword">return</span> ds18b20_check();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写时序：写1时序：拉低后延时2us，释放后延时60us.</span></span><br><span class="line"><span class="comment">写0时序：拉低后延时60us，释放后延时2us。*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_write_byte</span><span class="params">(u8 dat)</span>&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u8 temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		temp=dat&amp;<span class="number">0x01</span>;dat&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp)&#123;</span><br><span class="line">			DS18B20_PORT=<span class="number">0</span>;</span><br><span class="line">			_nop_();_nop_();</span><br><span class="line">			DS18B20_PORT=<span class="number">1</span>;	</span><br><span class="line">			delay(<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			DS18B20_PORT=<span class="number">0</span>;</span><br><span class="line">			delay(<span class="number">6</span>);</span><br><span class="line">			DS18B20_PORT=<span class="number">1</span>;</span><br><span class="line">			_nop_();_nop_();	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读时序：至少需要60us。时序起始后15us内读数据（采样总线）。</span></span><br><span class="line"><span class="comment">//典型的读时序过程为：主机输出低电平延时 2us，然后主机转入输入模式延时12us，然后读取单总线当前的电平，然后延时 50us。</span></span><br><span class="line">u8 <span class="title function_">ds18b20_read_bit</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 dat=<span class="number">0</span>;</span><br><span class="line">	DS18B20_PORT=<span class="number">0</span>;</span><br><span class="line">	_nop_();_nop_();</span><br><span class="line">	DS18B20_PORT=<span class="number">1</span>;	</span><br><span class="line">	_nop_();_nop_(); <span class="comment">//该段时间不能过长，必须在15us内读取数据</span></span><br><span class="line">	<span class="keyword">if</span>(DS18B20_PORT)dat=<span class="number">1</span>;	<span class="comment">//如果总线上为1则数据dat为1，否则为0</span></span><br><span class="line">	<span class="keyword">else</span> dat=<span class="number">0</span>;</span><br><span class="line">	delay(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> dat;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds18b20_read_byte</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	u8 dat=<span class="number">0</span>;</span><br><span class="line">	u8 temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//先低位后高位</span></span><br><span class="line">		temp=ds18b20_read_bit();</span><br><span class="line">		dat=(temp&lt;&lt;<span class="number">7</span>)|(dat&gt;&gt;<span class="number">1</span>);<span class="comment">//读取到的先放到最高位，然后逐渐向低位移动</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_start</span><span class="params">()</span>&#123;</span><br><span class="line">	ds18b20_init();</span><br><span class="line">	ds18b20_write_byte(<span class="number">0xcc</span>);<span class="comment">//跳过ROM命令，此命令通过允许总线主机不提供64位ROM编码而访问存储器操作来节省时间。</span></span><br><span class="line">	ds18b20_write_byte(<span class="number">0x44</span>);<span class="comment">//转换命令</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read_temperature</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 datl=<span class="number">0</span>,dath=<span class="number">0</span>;</span><br><span class="line">	u16 val=<span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> temp;</span><br><span class="line">	ds18b20_start();</span><br><span class="line">	ds18b20_init();</span><br><span class="line">	ds18b20_write_byte(<span class="number">0xcc</span>);</span><br><span class="line">	ds18b20_write_byte(<span class="number">0xbe</span>);<span class="comment">//读存储器命令，读出温度</span></span><br><span class="line">	datl=ds18b20_read_byte();<span class="comment">//低字节</span></span><br><span class="line">	dath=ds18b20_read_byte();<span class="comment">//高字节</span></span><br><span class="line">	val=(dath&lt;&lt;<span class="number">8</span>)+datl;</span><br><span class="line">	<span class="keyword">if</span>((val&amp;<span class="number">0xf800</span>)==<span class="number">0xf800</span>)<span class="comment">//负温度</span></span><br><span class="line">	&#123;</span><br><span class="line">		val=(~val)+<span class="number">1</span>;<span class="comment">//取反+1</span></span><br><span class="line">		temp=val*(<span class="number">-0.0625</span>);<span class="comment">//计算方法如此。*0.0625，如果是负数要先取反+1。</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> temp=(<span class="number">0.0625</span>*val);</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;<span class="comment">//每50次循环读取一次温度</span></span><br><span class="line">	<span class="type">int</span> temp_value;</span><br><span class="line">	u8 temp_buf[<span class="number">5</span>];</span><br><span class="line">	ds18b20_init();</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span>(cnt%<span class="number">50</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			cnt%=<span class="number">50</span>;</span><br><span class="line">			temp_value=ds18b20_read_temperature()*<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span>(temp_value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				temp_value=-temp_value;</span><br><span class="line">				temp_buf[<span class="number">0</span>]=<span class="number">0x40</span>;<span class="comment">//负号</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> temp_buf[<span class="number">0</span>]=<span class="number">0x00</span>;<span class="comment">//不显示负号</span></span><br><span class="line">			temp_buf[<span class="number">1</span>]=gsmg_code[temp_value/<span class="number">1000</span>];</span><br><span class="line">			temp_buf[<span class="number">2</span>]=gsmg_code[temp_value%<span class="number">1000</span>/<span class="number">100</span>];</span><br><span class="line">			temp_buf[<span class="number">3</span>]=gsmg_code[temp_value%<span class="number">100</span>/<span class="number">10</span>]|<span class="number">0x80</span>; <span class="comment">//加小数点</span></span><br><span class="line">			temp_buf[<span class="number">4</span>]=gsmg_code[temp_value%<span class="number">10</span>];</span><br><span class="line">			smg_display(temp_buf,<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h1><p>DS1302 时钟芯片。开发板上已经集成的芯片，本次实验目的是用数码管显示出当前时间，以hh-mm-ss的格式。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301301306004.png" alt="image-20230130130648915"></p>
<p>VCC2：电源</p>
<p>VCC1：备用电源，即单片机断电后维持时钟继续运行的。STC89C52 是没有的，即断电就停止运行。</p>
<p>X1X2：晶振。</p>
<p>CE：使能。</p>
<p>IO：输入输出。</p>
<p>SCLK：时钟。</p>
<p>操作流程就是将数据写入 DS1302 的寄存器来设置当前时间格式，然后 DS1302 时钟运作后我们再将寄存器中数据读出。</p>
<p>DS1302 中存储顺序是秒分时日月周年，存储格式是 BCD 码。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202301101426338.png" alt="image-20230110142624173"></p>
<p>首先，CE&#x2F;RST在整个读写过程中要保持是高电平，一次字节读写完毕后要返回低电平。</p>
<p>然后，控制指令字输入后的下一个 SCLK 上升沿数据写入，下降沿数据读出，在图中可以看得出来，都是从低位0先读，最后出高位7. 第一位代表读或写，后四位代表地址（年、月、日、时、分、秒有着不同的地址），R&#x2F;C 代表存取 RAM 数据还是读取时钟数据。最高位只有&#x3D;1才能启用时钟。后面八位是读或写的数据。</p>
<p>读时序注意：<strong>因此写命令的第八个上升沿结束后，紧接着第八个下降沿就开始读数据了。</strong></p>
<p>写时序注意：先关闭写保护 WP，1是只读，0才可以写。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302062342494.png" alt="image-20230206234252279"></p>
<p>我们先试着写入一个秒初值，然后读取时钟里的秒数值，应该是1s一加。</p>
<p>记得 BCD 码和十进制的转换。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302060152783.png" alt="image-20230206015234658"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;REG52.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;LCD1602.h&quot;</span></span></span><br><span class="line">sbit DS1302_CLK=P3^<span class="number">6</span>;<span class="comment">//时钟管脚</span></span><br><span class="line">sbit DS1302_CE=P3^<span class="number">5</span>;<span class="comment">//复位管脚</span></span><br><span class="line">sbit DS1302_IO=P3^<span class="number">4</span>;<span class="comment">//数据管脚</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302Init</span><span class="params">()</span>&#123;</span><br><span class="line">    DS1302_CE=<span class="number">0</span>;</span><br><span class="line">    DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302WriteByte</span><span class="params">(u8 command,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i;</span><br><span class="line">    DS1302_CE=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO=command&amp;(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO=dat&amp;(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CE=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">ds1302ReadByte</span><span class="params">(u8 command)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	u8 dat=<span class="number">0x00</span>;<span class="comment">//全局变量会有初值0，局部变量不会。data 是要写入的数据</span></span><br><span class="line">    DS1302_CE=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DS1302_IO=command&amp;(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;<span class="comment">//这里为什么和 write 是相反的？因为我们注意到 read 是先上升沿读入8位，再切换为下降沿读入8位。、</span></span><br><span class="line">        <span class="comment">//如果还是先1后0，读入第8位时不仅会把上升沿读掉，下降沿也会读掉，导致错过第九位。</span></span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">        DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//需要查询最小执行时间。不过这里执行时间都大于最小时间了。</span></span><br><span class="line">		<span class="keyword">if</span>(DS1302_IO)dat|=(<span class="number">0x01</span>&lt;&lt;i);<span class="comment">//从低到高写入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    DS1302_CE=<span class="number">0</span>;</span><br><span class="line">	DS1302_IO=<span class="number">0</span>;<span class="comment">//读取前要归0，因为内部是以 BCD 码格式存储。</span></span><br><span class="line">	<span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    u8 second;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	ds1302Init();</span><br><span class="line">	<span class="comment">//ds1302WriteByte(0x8E,0x00);//如果读出数据&gt;59，可能是处于 wp 写保护，需要通过这句关闭</span></span><br><span class="line">	ds1302WriteByte(<span class="number">0x80</span>,<span class="number">0x01</span>);<span class="comment">//写入55s，就是0x55，与内部BCD码对应</span></span><br><span class="line">	LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;DS1302&quot;</span>);</span><br><span class="line">	second=ds1302ReadByte(<span class="number">0x81</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,second/<span class="number">16</span>*<span class="number">10</span>+second%<span class="number">16</span>,<span class="number">3</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入其他变量时分秒都一样。就是更换不同的地址。</p>
<p>不过全部定义变量明显太麻烦。可以先 define 定义了所有地址，再定义一个数组存所有值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">u8 ds1302_address[<span class="number">7</span>]=&#123;<span class="number">0x80</span>, <span class="number">0x82</span>, <span class="number">0x84</span>, <span class="number">0x86</span>, <span class="number">0x88</span>, <span class="number">0x8c</span>&#125;;<span class="comment">// second, minute, hour, date, month, year</span></span><br><span class="line">u8 ds1302_time[<span class="number">7</span>]=&#123;<span class="number">0x55</span>, <span class="number">0x59</span>, <span class="number">0x11</span>, <span class="number">0x07</span>, <span class="number">0x02</span>, <span class="number">0x23</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	u8 i;</span><br><span class="line">    u8 time_temp[<span class="number">6</span>];</span><br><span class="line">	u8 temp;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	ds1302Init();</span><br><span class="line">	<span class="comment">//ds1302WriteByte(0x8E,0x00);//如果读出数据&gt;59，可能是处于 wp 写保护，需要通过这句关闭</span></span><br><span class="line">	ds1302WriteByte(<span class="number">0x80</span>,<span class="number">0x01</span>);</span><br><span class="line">	ds1302WriteByte(<span class="number">0x82</span>,<span class="number">0x37</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">		ds1302WriteByte(ds1302_address[i], ds1302_time[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;  -  -  &quot;</span>);</span><br><span class="line">	LCD_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;  :  :  &quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			temp=ds1302ReadByte(ds1302_address[i]+<span class="number">1</span>);</span><br><span class="line">			time_temp[i]=temp/<span class="number">16</span>*<span class="number">10</span>+temp%<span class="number">16</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">			LCD_ShowNum(<span class="number">1</span>+i/<span class="number">3</span>,<span class="number">1</span>+<span class="number">3</span>*(i%<span class="number">3</span>), time_temp[<span class="number">5</span>-i],<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//LCD_ShowNum(2,1,minute/16*10+minute%16,2);</span></span><br><span class="line">		<span class="comment">//LCD_ShowNum(2,3,second/16*10+second%16,2);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们让按键可以修改时钟值，这样用户可以手动更改时钟。</p>
<p>按键1切换切换要调整的位，按键2切换回第0位，按键3+1，按键4-1.</p>
<p>难点主要在于+ -的溢出情况。这里我们不考虑秒+1进位对分钟或小时等影响，大多数闹钟也是这样设计的。59+1就归零，0-1就变59.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(key)&#123;</span><br><span class="line">			<span class="keyword">switch</span>(key)&#123;</span><br><span class="line">				<span class="keyword">case</span> KEY1_PRESS: time_set_select=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY2_PRESS: time_set_select=(time_set_select+<span class="number">1</span>)%<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY3_PRESS:</span><br><span class="line">					<span class="keyword">if</span>(time_set_select&lt;=<span class="number">1</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">59</span>)&#123;<span class="comment">//second, minute 59-00</span></span><br><span class="line">						ds1302_time[time_set_select]=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">2</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">23</span>)ds1302_time[time_set_select]=<span class="number">0</span>;<span class="comment">//hour 23-00</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">3</span>&amp;&amp;ds1302_time[time_set_select]==maxDate(ds1302_time[<span class="number">3</span>],ds1302_time[<span class="number">4</span>],ds1302_time[<span class="number">5</span>]))ds1302_time[time_set_select]=<span class="number">1</span>;<span class="comment">//date 超过最大日期 -01</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">4</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">12</span>)ds1302_time[time_set_select]=<span class="number">1</span>;<span class="comment">//month 12-00</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">5</span>&amp;&amp;ds1302_time[time_set_select]==<span class="number">99</span>)ds1302_time[time_set_select]=<span class="number">0</span>;<span class="comment">//year 99-00</span></span><br><span class="line">					<span class="keyword">else</span> ds1302_time[time_set_select]++;<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> KEY4_PRESS: </span><br><span class="line">					<span class="keyword">if</span>((ds1302_time[time_set_select]&amp;&amp;time_set_select!=<span class="number">3</span>&amp;&amp;time_set_select!=<span class="number">4</span>)</span><br><span class="line">					||ds1302_time[time_set_select]&gt;<span class="number">1</span>)ds1302_time[time_set_select]--;<span class="comment">//date month!=0</span></span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select&lt;=<span class="number">1</span>)ds1302_time[time_set_select]=<span class="number">59</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">2</span>)ds1302_time[time_set_select]=<span class="number">23</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">3</span>)ds1302_time[time_set_select]=maxDate(ds1302_time[<span class="number">3</span>],ds1302_time[<span class="number">4</span>],ds1302_time[<span class="number">5</span>]);</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">4</span>)ds1302_time[time_set_select]=<span class="number">12</span>;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span>(time_set_select==<span class="number">5</span>)ds1302_time[time_set_select]=<span class="number">99</span>;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(key&gt;=<span class="number">3</span>)timeSet();</span><br></pre></td></tr></table></figure>

<p>计算日期最大值函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">maxDate</span><span class="params">(u8 date, u8 month,u8 year)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(month==<span class="number">1</span>||month==<span class="number">3</span>||month==<span class="number">5</span>||month==<span class="number">7</span>||month==<span class="number">8</span>||month==<span class="number">10</span>||month==<span class="number">12</span>)<span class="keyword">return</span> <span class="number">31</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>((month==<span class="number">4</span>||month==<span class="number">6</span>||month==<span class="number">9</span>||month==<span class="number">11</span>)&amp;&amp;date==<span class="number">31</span>)<span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(year%<span class="number">4</span>)<span class="keyword">return</span> <span class="number">28</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>)<span class="keyword">return</span> <span class="number">28</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">29</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个弊端就是不知道现在在操作哪一位（只能自己记住）。可以利用定时器的定时闪烁，让在被操作的位不停闪烁。（重复写入空格或数值。）</p>
<p>还有就是按下按键，时钟会停走，不松开就一直停着。可以改按键触发条件为按下或弹起的上升沿或下降沿，避免按键处理函数死循环。</p>
<h1 id="红外传感器"><a href="#红外传感器" class="headerlink" title="红外传感器"></a>红外传感器</h1><p>遥控器通过红外 LED 发送调制后的信号，开发板上的红外接收模块接收遥控器的红外线。</p>
<p>单工异步，940nm 波长（还有一种 250nm 的N，可见光），EC 通信标准。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280003691.png" alt="image-20230328000312504"></p>
<p>38KHz：红外线频率。</p>
<p>IN：发送的方波。</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280019264.png" alt="image-20230328001955152" style="zoom:50%;" />

<p>红外接收模块中会自动帮我们滤出 In 部分。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280027670.png" alt="image-20230328002724563"></p>
<p>空闲状态：OUT 输出高电平。</p>
<p>发送高电平：OUT 输出高电平。</p>
<p>发送低电平：OUT输出低电平，代表有数据。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303280049094.png" alt="image-20230328004940943"></p>
<p>38kHz 属于是底层信息，所以协议层不给予展示，类似类的封装。</p>
<p>9ms 低+4.5ms 高：start。</p>
<p>后面跟四个字节数据。反码用于数据验证。</p>
<p>560us 低+560us 高表示0，560us 低+1690us 高表示1. 结束的最后一个高电平后面要跟一个下降沿表示终止。</p>
<p>一直扫描是效率很低的做法，所以 out 是接在外部中断上的。</p>
<h2 id="外部中断"><a href="#外部中断" class="headerlink" title="外部中断"></a>外部中断</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303281153651.png" alt="image-20230328115258479"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    LCD_Init();</span><br><span class="line">    LCD_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    IT0=<span class="number">1</span>;</span><br><span class="line">    IE0=<span class="number">0</span>;</span><br><span class="line">    EX0=<span class="number">1</span>;</span><br><span class="line">    EA=<span class="number">1</span>;</span><br><span class="line">    PX0=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        LCD_ShowNum(<span class="number">2</span>,<span class="number">1</span>,num,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Int0_Routine</span><span class="params">()</span> interrupt 0 &#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断和第三个按键 P3^2 接在一起，因此按下按键3时就会下降沿触发中断。</p>
<p>如果改为低电平触发，即 IT0&#x3D;0，按下按键就一直触发。</p>
<p>接收到的数据会以2位的二进制位展现在数码管上，这里遥控器上的按钮并不是按几数码管就会显示几的注意一下。重点只是在于看遥控器不同的信号单片机能否区分和识别。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303281457220.png" alt="image-20230328145734093"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ired.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ired_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ired_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管脚定义</span></span><br><span class="line">sbit IRED=P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="keyword">extern</span> u8 gired_data[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ired.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ired.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">u8 gired_data[<span class="number">4</span>];<span class="comment">//存储4个字节接收码（地址码+地址反码+控制码+控制反码）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名         : ired_init</span></span><br><span class="line"><span class="comment">* 函数功能		   : 红外端口初始化函数，外部中断0配置 </span></span><br><span class="line"><span class="comment">* 输    入         : 无</span></span><br><span class="line"><span class="comment">* 输    出         : 无</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	IT0=<span class="number">1</span>;	<span class="comment">//下降沿触发</span></span><br><span class="line">	EX0=<span class="number">1</span>;	<span class="comment">//打开中断0允许</span></span><br><span class="line">	EA=<span class="number">1</span>;	<span class="comment">//打开总中断</span></span><br><span class="line">	IRED=<span class="number">1</span>;	<span class="comment">//初始化端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired</span><span class="params">()</span> interrupt 0	<span class="comment">//外部中断0服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 ired_high_time=<span class="number">0</span>;</span><br><span class="line">	u16 time_cnt=<span class="number">0</span>;</span><br><span class="line">	u8 i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//引导信号有9ms的低电平和4.5ms的高电平，先把这两部分读掉，并且如果太长时间引导信号没有发生相应的变化就先跳出，省的系统死机。我们给引导信号10ms和5ms的机会。</span></span><br><span class="line">	<span class="keyword">if</span>(IRED==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		time_cnt=<span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">while</span>((!IRED)&amp;&amp;(time_cnt))<span class="comment">//等待引导信号9ms低电平结束，若超过10ms强制退出</span></span><br><span class="line">		&#123;</span><br><span class="line">			delay_10us(<span class="number">1</span>);<span class="comment">//延时约10us</span></span><br><span class="line">			time_cnt--;</span><br><span class="line">			<span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(IRED)<span class="comment">//引导信号9ms低电平已过，进入4.5ms高电平</span></span><br><span class="line">		&#123;</span><br><span class="line">			time_cnt=<span class="number">500</span>;</span><br><span class="line">			<span class="keyword">while</span>(IRED&amp;&amp;time_cnt)<span class="comment">//等待引导信号4.5ms高电平结束，若超过5ms强制退出</span></span><br><span class="line">			&#123;</span><br><span class="line">				delay_10us(<span class="number">1</span>);</span><br><span class="line">				time_cnt--;</span><br><span class="line">				<span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//接下来是读取地址、地址反码、控制、控制反码。</span></span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//循环4次，读取4个字节数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)<span class="comment">//循环8次读取每位数据即一个字节</span></span><br><span class="line">				&#123;</span><br><span class="line">					time_cnt=<span class="number">600</span>;</span><br><span class="line">					<span class="keyword">while</span>((IRED==<span class="number">0</span>)&amp;&amp;time_cnt)<span class="comment">//等待数据1或0前面的0.56ms结束，若超过6ms强制退出</span></span><br><span class="line">					&#123;</span><br><span class="line">						delay_10us(<span class="number">1</span>);</span><br><span class="line">						time_cnt--;</span><br><span class="line">						<span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;	</span><br><span class="line">					&#125;</span><br><span class="line">					time_cnt=<span class="number">20</span>;</span><br><span class="line">					<span class="keyword">while</span>(IRED)<span class="comment">//等待数据1或0后面的高电平结束，若超过2ms强制退出</span></span><br><span class="line">					&#123;</span><br><span class="line">						delay_10us(<span class="number">10</span>);<span class="comment">//约0.1ms</span></span><br><span class="line">						ired_high_time++;</span><br><span class="line">						<span class="keyword">if</span>(ired_high_time&gt;<span class="number">20</span>)<span class="keyword">return</span>;	</span><br><span class="line">					&#125;</span><br><span class="line">					gired_data[i]&gt;&gt;=<span class="number">1</span>;<span class="comment">//先读取的为低位，然后是高位</span></span><br><span class="line">					<span class="keyword">if</span>(ired_high_time&gt;=<span class="number">8</span>)<span class="comment">//如果高电平时间大于0.8ms，数据则为1，否则为0</span></span><br><span class="line">						gired_data[i]|=<span class="number">0x80</span>;<span class="comment">//最高位赋1</span></span><br><span class="line">					ired_high_time=<span class="number">0</span>;<span class="comment">//重新清零，等待下一次计算时间</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(gired_data[<span class="number">2</span>]!=~gired_data[<span class="number">3</span>])<span class="comment">//校验控制码与反码，错误则清空后返回</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">				gired_data[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;	</span><br><span class="line">	u8 ired_buf[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">	ired_init();<span class="comment">//红外初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;				</span><br><span class="line">		ired_buf[<span class="number">0</span>]=gsmg_code[gired_data[<span class="number">2</span>]/<span class="number">16</span>];<span class="comment">//将控制码高4位转换为数码管段码</span></span><br><span class="line">		ired_buf[<span class="number">1</span>]=gsmg_code[gired_data[<span class="number">2</span>]%<span class="number">16</span>];<span class="comment">//将控制码低4位转换为数码管段码</span></span><br><span class="line">		ired_buf[<span class="number">2</span>]=<span class="number">0X76</span>;<span class="comment">//显示H的段码</span></span><br><span class="line">		smg_display(ired_buf,<span class="number">6</span>);	</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LCD1602"><a href="#LCD1602" class="headerlink" title="LCD1602"></a>LCD1602</h1><p>liquid crystal display 液晶显示屏，一种字符型液晶显示模块，可以显示 16*2 个字符，每个字符是 5*7 点阵。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302030040324.png" alt="image-20230203004049189"></p>
<p>P0 P2 会和数码管、LED 一定程度上冲突。</p>
<ol>
<li><p>地。</p>
</li>
<li><p>Vcc。</p>
</li>
<li><p>调对比度的。</p>
</li>
<li><p>RS：数据指令端。1代表 DB 是数据，0代表是指令。</p>
</li>
<li><p>RW：1读0写。</p>
</li>
<li><p>E：类似时钟的使能。高电平有效，下降沿执行。</p>
</li>
<li><p>DB：并行输入。一个字节长。</p>
</li>
<li><p>BG：背光灯电源。</p>
</li>
</ol>
<h2 id="内部结构图"><a href="#内部结构图" class="headerlink" title="内部结构图"></a>内部结构图</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302210241581.png" alt="image-20230221024102411"></p>
<p>类似 SMG，想显示1并不是直接输入1，而是操纵数码管右侧一竖被点亮。字模库起的就是这个作用，里面有固定的 ROM 和用户课自定义的 RAM。</p>
<p>DDRAM 长于屏幕，可以通过移平实现滚动效果。 </p>
<p>AC address controller，可以自动移位写入数据。</p>
<p>字模库中的数据大多数和 ASCII 码是一样的。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302211954113.png" alt="image-20230221195404983"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302211954631.png" alt="image-20230221195434495"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302211954194.png" alt="image-20230221195450094"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212006550.png" alt="image-20230221200656434"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212008132.png" alt="image-20230221200839017"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212010707.png" alt="image-20230221201026593"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212012009.png" alt="image-20230221201247867"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212013859.png" alt="image-20230221201355749"></p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302221623821.png" alt="image-20230222162315672"></p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212056483.png" alt="image-20230221205604331" style="zoom:67%;" />

<h2 id="初始化指令"><a href="#初始化指令" class="headerlink" title="初始化指令"></a>初始化指令</h2><p>初始化要做哪些操作？</p>
<p>规定显示区域（如8位数据接口，2行显示，5*7点阵，即为0011 10xx，如果取0即为 0x38.）。</p>
<p>显示的模式设置（如开启显示，关闭光标，关闭光标闪烁：0000 1101，即 0x0D）。</p>
<p>进入模式设置（如读写后光标++，屏幕不动：0000 0110,0x06。如果是滚动屏幕则为）。</p>
<p>清屏（0x01）。</p>
<h2 id="显示指令"><a href="#显示指令" class="headerlink" title="显示指令"></a>显示指令</h2><p>先设置 DDRAM 初始地址，0x80|AC（开头的8是 DDRAM 固定指令信息不能改。后面的全是0，与 AC 光标位置做与，AC 不同位置的值见 DDRAM 地址表）.</p>
<p>然后发送数据。</p>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212100898.png" alt="image-20230221210035721" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212101594.png" alt="image-20230221210102393" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302212106325.png" alt="image-20230221210614193" style="zoom: 80%;" />

<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>第一阶段我们先编写 LCD1602 模块化编程代码，这一部分主要显示静态内容，用于程序编写过程中显示变量进行调试。</p>
<p>目标模块化函数：</p>
<img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202302030044040.png" alt="image-20230203004415880" style="zoom: 80%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LCD1602.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LCD1602_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LCD1602_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line">sbit LCD_RS=P2^<span class="number">6</span>;</span><br><span class="line">sbit LCD_RW=P2^<span class="number">5</span>;</span><br><span class="line">sbit LCD_E=P2^<span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_DATAPORT P0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Delay1ms</span><span class="params">()</span>;		<span class="comment">//@11.0592MHz</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">LCD_Pow</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> str[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LCD1602.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LCD1602.H&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Delay1ms</span><span class="params">()</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line"></span><br><span class="line">	_nop_();</span><br><span class="line">	_nop_();</span><br><span class="line">	_nop_();</span><br><span class="line">	i = <span class="number">11</span>;</span><br><span class="line">	j = <span class="number">190</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (--j);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteCommand</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Command)</span>&#123;</span><br><span class="line">	LCD_RS=<span class="number">0</span>;</span><br><span class="line">	LCD_RW=<span class="number">0</span>;</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">	LCD_DATAPORT=Command;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">1</span>;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_WriteData</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Data)</span>&#123;</span><br><span class="line">	LCD_RS=<span class="number">1</span>;</span><br><span class="line">	LCD_RW=<span class="number">0</span>;</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">	LCD_DATAPORT=Data;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">1</span>;</span><br><span class="line">	LCD_Delay1ms();</span><br><span class="line">	LCD_E=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x38</span>);</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x0C</span>);</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x06</span>);</span><br><span class="line">	LCD_WriteCommand(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_SetCursor</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(line==<span class="number">1</span>)&#123;</span><br><span class="line">		LCD_WriteCommand(<span class="number">0x80</span>|(column<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		LCD_WriteCommand(<span class="number">0x80</span>|(column<span class="number">-1</span>)+<span class="number">0x40</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">LCD_Pow</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i=y;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i--)res*=x;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowChar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> c)</span>&#123;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	LCD_WriteData(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowString</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">char</span> str[])</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">		LCD_WriteData(str[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> base;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">10</span>, i<span class="number">-1</span>);</span><br><span class="line">		LCD_WriteData(num/base%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowBinNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> base;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> single_num;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">2</span>, i<span class="number">-1</span>);</span><br><span class="line">		single_num=num/base%<span class="number">2</span>+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		LCD_WriteData(single_num);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowHexNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">unsigned</span> <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> base;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> single_num;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">16</span>, i<span class="number">-1</span>);</span><br><span class="line">		single_num=num/base%<span class="number">16</span>;</span><br><span class="line">		<span class="keyword">if</span>(single_num&lt;=<span class="number">9</span>)single_num+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> single_num+=<span class="string">&#x27;A&#x27;</span><span class="number">-10</span>;</span><br><span class="line">		LCD_WriteData(single_num);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LCD_ShowSignedNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> line, <span class="type">unsigned</span> <span class="type">char</span> column, <span class="type">int</span> num, <span class="type">unsigned</span> <span class="type">char</span> length)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="type">unsigned</span> base;</span><br><span class="line">	LCD_SetCursor(line, column);</span><br><span class="line">	<span class="keyword">if</span>(num&gt;<span class="number">0</span>)LCD_WriteData(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;LCD_WriteData(<span class="string">&#x27;-&#x27;</span>);num=-num;&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=length;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		base=LCD_Pow(<span class="number">10</span>, i<span class="number">-1</span>);</span><br><span class="line">		LCD_WriteData(num/base%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望屏幕滚动，一定时间执行一次<code>LCD_WriteCommand(0x18);</code> 屏幕左移指令。</p>
<h1 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h1><p>电能转机械能。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303270017098.png" alt="image-20230327001703813"></p>
<p>第二种驱动方式可以双向，电机可以双向驱动，转向不同。</p>
<p>直接驱动电机还起到电感的作用，断开电源后电机产生电压，可以形成一个回路慢慢消耗掉。</p>
<p>PWM：脉冲信号调制。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303270035159.png" alt="image-20230327003516983"></p>
<p>比如调 LED 灯，我们可以加一个有电位器的电阻（滑动变阻器）。</p>
<p>电机可能这种方式有局限性，比如电阻太大直接不转，驱动不起来，太小烧毁。</p>
<p>脉冲调制比如：“转2s”“停1s”“转2s”“停1s”……因为电机有惯性，所以可行。</p>
<p>示例：LED 流水灯：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sbit LED=P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> i)</span>		<span class="comment">//@11.0592MHz</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">char</span> period=<span class="number">100</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ti;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(ti=<span class="number">0</span>;ti&lt;<span class="number">100</span>;ti++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">				LED=<span class="number">0</span>;</span><br><span class="line">				delay(ti);</span><br><span class="line">				LED=<span class="number">1</span>;</span><br><span class="line">				delay(period-ti);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(ti=<span class="number">100</span>;ti&gt;<span class="number">0</span>;ti--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">				LED=<span class="number">0</span>;</span><br><span class="line">				delay(ti);</span><br><span class="line">				LED=<span class="number">1</span>;</span><br><span class="line">				delay(period-ti);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用 timer 来计数，我们知道 timer 是一直增加的，我们可以设置一个比较值，当 timer 大于比较值时输出1，小于时输出0类似这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;regx52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;nixie.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">sbit LED=P1^<span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> compare;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> T0Count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> level=<span class="number">1</span>;</span><br><span class="line">	time0Init();</span><br><span class="line">	compare=<span class="number">5</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		key=key_scan(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(key==KEY1_PRESS)level++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(key==KEY2_PRESS)<span class="keyword">if</span>(level&gt;<span class="number">1</span>)level--;</span><br><span class="line">		level%=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span>(level==<span class="number">0</span>)level++;</span><br><span class="line">		<span class="keyword">if</span>(level==<span class="number">1</span>)compare=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">2</span>)compare=<span class="number">50</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">3</span>)compare=<span class="number">75</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(level==<span class="number">4</span>)compare=<span class="number">100</span>;</span><br><span class="line">		Nixie_Scan(<span class="number">1</span>,level);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line">  TL0 = <span class="number">0xAE</span>;</span><br><span class="line">  TH0 = <span class="number">0xFB</span>;</span><br><span class="line">  T0Count++;</span><br><span class="line">  <span class="keyword">if</span>(T0Count&gt;=<span class="number">100</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    T0Count=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(T0Count&lt;compare)&#123;</span><br><span class="line">  	 LED=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(T0Count&gt;compare)LED=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><p>使得调节开发板上的电位器时，数码管上能够显示 AD 模块 采集电位器的电压值且随之变化。</p>
<p>开发板上有三个应用：光敏电阻，热敏电阻，电位器。</p>
<p>一般 AD 转换有多个输入，提高使用效率。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271700414.png" alt="image-20230327170005984"></p>
<p>ADC 通过地址锁存与译码判断采用哪个输入。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271722801.png" alt="image-20230327172256586"></p>
<p>运算放大器，可以作为电压比较器、同相反相放大器、电压跟随器</p>
<p>T 型电阻网络 DA 转换器：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271951179.png" alt="image-20230327195138979"></p>
<p>低通滤波器：输入是有直交流两个分量的，可以通过低通滤波器提取出直流。电压跟随器让驱动能力增加。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303271951641.png" alt="image-20230327195154405"></p>
<p>da 简单些，因为d值是固定的，根据d调整a即可。</p>
<p>ad 怎么判断电压大小？我们用一个电压值和给定电压作比较，看大于还是小于，逐渐逼近来找近似值。</p>
<p>分辨率：精细程度。比如8位的 ad 可以把 5v 转换到 0~255 范围。</p>
<p>转换速度：最大采样&#x2F;建立频率。</p>
<p>XPT2046 采用 SPI，的时序在上升沿输入，下降沿输出，可实现输入再输出。</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303272139709.png" alt="image-20230327213950578"></p>
<p>采用单端模式（触摸屏查分会更好一些）。</p>
<p>PD1&#x3D;1 采用内部参考电压，内部电压为 2.5v，我们知道adc 映射范围是 0~5v，所以1采用内部电压不如0采用5v的外部电压。</p>
<p>A 地址配置：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303272207617.png" alt="image-20230327220710512"></p>
<p>VBAT：电池电压。</p>
<p>AUX：辅助电压。</p>
<p>XP YP：XY 正极。</p>
<p>读取指令并 ad 转化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_XP_8 0x9C    <span class="comment">// 1001 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_YP_8 0xDC    <span class="comment">// 1101 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_VBAT_8 0xAC  <span class="comment">// 1010 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_AUX_8 0xEC   <span class="comment">// 1110 1100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_XP_12 0x94   <span class="comment">// 1001 0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_YP_12 0xD4   <span class="comment">// 1101 0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_VBAT_12 0xA4 <span class="comment">// 1010 0100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XPT2046_AUX_12 0xE4  <span class="comment">// 1110 0100</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">XPT2046_ReadAD</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> command)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp=command;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ADValue = <span class="number">0</span>;</span><br><span class="line">    XPT2046_DCLK = <span class="number">0</span>;</span><br><span class="line">    XPT2046_CS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        XPT2046_DIN = temp &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        XPT2046_DCLK = <span class="number">1</span>;</span><br><span class="line">        XPT2046_DCLK = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        XPT2046_DCLK = <span class="number">1</span>;</span><br><span class="line">        XPT2046_DCLK = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (XPT2046_DOUT)</span><br><span class="line">            ADValue |= (<span class="number">0x0800</span> &gt;&gt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    XPT2046_CS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//for 12 bit:</span></span><br><span class="line">    <span class="keyword">if</span>(command&amp;<span class="number">0x08</span>)<span class="keyword">return</span> ADValue&gt;&gt;<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ADValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ADValue = <span class="number">0</span>;</span><br><span class="line">	LCD_Init();</span><br><span class="line">	LCD_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;ADC NTC RG&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ADValue = XPT2046_ReadAD(XPT2046_XP_8);<span class="comment">//电位器</span></span><br><span class="line">		LCD_ShowNum(<span class="number">2</span>, <span class="number">1</span>, ADValue, <span class="number">3</span>);</span><br><span class="line">		ADValue = XPT2046_ReadAD(XPT2046_YP_8);<span class="comment">//热敏电阻</span></span><br><span class="line">		LCD_ShowNum(<span class="number">2</span>, <span class="number">5</span>, ADValue, <span class="number">3</span>);</span><br><span class="line">		ADValue = XPT2046_ReadAD(XPT2046_VBAT_8);<span class="comment">//光敏电阻</span></span><br><span class="line">		LCD_ShowNum(<span class="number">2</span>, <span class="number">9</span>, ADValue, <span class="number">3</span>);</span><br><span class="line">		delayMs(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dac 也是采用 pwm 的原理，改变01 叫错频率来模拟灯的亮度（输出口：P2^1）。所以 dac 用处不广泛，因为可以被代替。</p>
<h1 id="完结：库函数封装说明"><a href="#完结：库函数封装说明" class="headerlink" title="完结：库函数封装说明"></a>完结：库函数封装说明</h1><p>从12月开始决定入嵌入式开始，经历了5个月的学习，终于把入门模块基本弄懂并且跟着代码敲了一遍。</p>
<p>在这期间跟随普中课程老师学习到的封装习惯让我主键开始留意每做完一个模块后就进行调试并把该模块封装起来，供下次使用该模块时可以快捷导入。</p>
<p>后来浅了解了一些 git 的项目管理后，我又把封装好的函数发布到 github repository 上。</p>
<p>单片机版本：STC89C52RC</p>
<p>github 仓库地址：<a target="_blank" rel="noopener" href="https://github.com/Jingqing3948/MySTC89C52RCFunction">Jingqing3948&#x2F;MySTC89C52RCFunction: 学习 STC89C52RC 单片机时的一些封装好的库函数。 (github.com)</a></p>
<p>函数包含：</p>
<p><img src="https://raw.githubusercontent.com/Jingqing3948/FigureBed/main/mdImages/202303281845268.png" alt="image-20230328184524152"></p>
<p>AT24C02：掉电不丢失存储器。</p>
<p>DS18B20：温度传感器。</p>
<p>delay：stc-isp 生成的基于 11.0592MHz 晶振的延时函数。</p>
<p>IIC：IIC 总线的使用，配合 AT24C02 模块使用。</p>
<p>IR：红外遥控模块，包括外部中断、定时器等内容。</p>
<p>Key：四个独立按键。</p>
<p>LCD1602：LCD1602 显示屏。</p>
<p>NiXie：数码管。</p>
<p>Timer：定时器中断函数。</p>
<p>public.h：无用，定义了 u8 u16 两个变量。</p>
<p>有问题欢迎随时与博主沟通。如侵犯他人权益会尽快删除！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul>

    </footer>
  </div>

   
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: 'Ov23li1TkQEYXFu51qLu',
    clientSecret: '0c4ca8b5adfcc2aedd741ba78ca96fcbf2c4f5b5',
    repo: 'Jingqing3948.github.io',
    owner: 'Jingqing3948',
    admin: 'Jingqing3948',
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: true,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

  
  
</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022-2025
        <i class="ri-heart-fill heart_icon"></i> Jingqing3948
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="灰海宽松的博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://jingqing3948.lofter.com/">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://blog.csdn.net/jtwqwq?spm=1000.2115.3001.5343">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://jingqing3948.github.io/Tianweijiang.github.io/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>星光不问，梦终有回</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/LinkedIn.jpg">
      <span class="reward-type">LinkedIn</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/WXOfficalAccount.jpg">
      <span class="reward-type">公众号</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=1357960253&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>